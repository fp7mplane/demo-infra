/**
 * @author Be?ta Pletscher
 * @docauthor Be?ta Pletscher
 */

/*
 * This file is the Entry Point for the implementation of this ExtJS package.
 * 
 * NOTE: Please DO NOT edit this file unless you know what you are exactly
 * doing.
 */

// BEGIN: Package definition
(function(){
	{
		var pkg =
		{
		  name : 'chart-library',
		  namespace : 'NV.chart.library',
		  path : 'chart-library',
		  date : new Date('2015','01','21','11','25','07'), // 2015/01/21 11:25:07
		  version : new Ext.Version('1.0.0.85'),
		  description : 'Chart Library'
		};
	
		// Register Package
	
		Ext.namespace( 'NV' );
		var packages = NV.$Packages || (NV.$Packages = {});
		packages[pkg.name] = pkg;
	
		Ext.Loader.setPath( pkg.namespace, 'lib/' + pkg.path );
	}
})();
// END: Package definition
// @tag chart-library
/**
*	Chart interface
**/

Ext.define('NV.chart.library.Chart', {
	
	config:{
		
		dataUrl : undefined,				//the url of the datas
		
		legend : undefined, 
		gradients: undefined,
		threeD : undefined,
		
		label: undefined,
		colors:undefined,
		title: undefined,
		background: undefined,				//TODO: bg color minden charthoz
	
		standAlone: true,					//standalon chart content handle the refresh, the zoom. when is in portlet, the portlet handle the refresh functions
		refreshIntervall: undefined,		
		actions: undefined,	
		currentIntervall : {},				//used on zoom
		
		chartContent : undefined,			//az az objektum, amit ki lehet rajzolni pl a portletekre
		header: false,
		portletContentObject : undefined,
		jsonStore : undefined,
		store:undefined,

		decimals:2,
		autoRound:true
	},

	constructor : function(config){
		this.store = [];
		this.initConfig(config);
		
		if(this.legend){
			this.legend = Ext.create('NV.chart.library.utils.Legend', config.legend);
		}
		
		
		//set the gradients
		this.gradientArray = [];

		for ( var i in this.gradients) {
			this.gradientArray[this.gradients[i].id] = {
				colors : []
			};
			this.gradientArray[this.gradients[i].id].orientation = this.gradients[i].angle != 90 ? "vertical" : "horizontal";
			this.gradientArray[this.gradients[i].id].colors = this.gradients[i].colors;

		}
		
		var me = this;
		
		this.titlePanel = {
				xtype: 'panel',
				header: false,
				border: false,
				margin: '0 0 0 0',
				bodyBorder: false,
				hidden: this.title == undefined,
				html: "<center><h3>" + this.title + "</h3></center>"
		};
		
		this.chartContentPanel = Ext.create('Ext.container.Container',{
			flex:1,
			layout:'fit'
		});
		
		this.chartContent = Ext.create('Ext.panel.Panel', {
			header : false,
			frame : false,
			flex : 1,
			bodyCls : me.bodyCls,
			layout : {
				type : 'vbox',
				align: 'stretch'
			},
			items : [
			         this.titlePanel,
			         this.chartContentPanel
			],
			border : false,
			bodyBorder:false,
			listeners : {
				afterrender : function() {
				},
				afterlayout : function() {
					if(!me.chartRendered){
						me.drawChart();
					}
				},
				beforedestroy : function() {

				},
				show: function(){
				},
				resize: function(){
					if(me.chart && me.chart.invalidateSize){
						me.chart.invalidateSize();
					}
					
				}
			}
		});
		

		this.initChart();

		if(this.standAlone){//nem portletben vagyunk
			if(this.dataUrl){	
				this.getDataFromServerStandalone();
			}else{
				this.createStoreFromJson(this.jsonStore);
				this.refreshChartStore();
			}
		}else{				//portletben vagyunk
			if(this.jsonStore){	
				this.createStoreFromJson(this.jsonStore);
				this.refreshChartStore();
			}else{
				//a portlet refresher felel a frissítésekért és az első betöltésért is
			
			}
		}
		
		return this;
	},

	
	validate: function(){		
		for(var i in this.actions){
			if(!i.match("plot")){
				Ext.Msg.show({
				    title: 'Warning',
				    msg: "Actions is defined, but no plot in action. ",
				    width: 300,
				    buttons: Ext.Msg.OK,
				    icon: Ext.Msg.WARNING
				});
			}
			for(var j=0; j<this.actions[i].length; j++){
				if(!Ext.Array.contains(['link','set','menu','tooltip'],this.actions[i][j].command)){
					Ext.Msg.show({
					    title: 'Action config error',
					    msg: "Undefined command: "+this.actions[i][j].command,
					    width: 300,
					    buttons: Ext.Msg.OK,
					    icon: Ext.Msg.ERROR
					});
					return false;
				}
				if(this.actions[i][j].command=="link"){
					if(!this.actions[i][j].url){
						Ext.Msg.show({
						    title: 'Link action error',
						    msg: "url is required",
						    width: 300,
						    buttons: Ext.Msg.OK,
						    icon: Ext.Msg.ERROR
						});
						return false;
					}
				}
				if(this.actions[i][j].command=="tooltip"){
					if(!this.actions[i][j].html && !this.actions[i][j].url){
						Ext.Msg.show({
						    title: 'Tooltip action error',
						    msg: "url or html required",
						    width: 300,
						    buttons: Ext.Msg.OK,
						    icon: Ext.Msg.ERROR
						});
						return false;
					}
				}
				if(this.actions[i][j].command=="set"){
					if(!this.portletContentObject){
						Ext.Msg.show({
						    title: 'Set action error',
						    msg: "Set is usable when portletContentObject is defined.",
						    width: 300,
						    buttons: Ext.Msg.OK,
						    icon: Ext.Msg.ERROR
						});
						return false;
					}
					if(!this.actions[i][j].set && (!this.actions[i][j].target || !this.actions[i][j].value)){
						Ext.Msg.show({
						    title: 'Set action error',
						    msg: "The set array or the target and value are required!",
						    width: 300,
						    buttons: Ext.Msg.OK,
						    icon: Ext.Msg.ERROR
						});
						return false;
					}
				}
			}
		}
		return true;
	},
	
	refreshData: function(json){		
		if(!json.measurementData){
		//	Ext.Msg.alert("Error", "No measurementData received, dataurl:"+this.dataUrl);
			return;
		}
		this.createStoreFromJson(json.measurementData);
		this.refreshChartStore();

		//iframe-es chart esetén érdemes megadni, vagy ha nem a dashboard-ban használjuk
		
	},
	
	getPlotSize: function(){
		return {x:undefined, y:undefined};
	},
	
	getDataFromServerStandalone: function (args){
		
		if(!args){
			args = {};
		}
		
		var params = {
				command:this.dataUrl,
				arguments: args
		};
		this.getPlotSize();
		if(this.job){
			this.job.stop();
		}
		this.job = Ext.create('NV.ajax.scheduler.RefreshJob', {
			fixParams:params, 
			url:NV.chart.library.ChartDrawer.serverUrls.base, 
			batchedAjaxEnabled:window.globalAjaxClient!=undefined, 
			callback: this.refreshData, 
			scope:this,
			doOnFirstTime: true,
			refreshIntervall: this.refreshIntervall,
			justOne:this.refreshIntervall==undefined
		});
		this.job.start();
		
	},
		
	refreshChartStore: function(){},
	createStoreFromJson: function(json){},
	initChart: function(){},
	
	createStore : function(values) {
		var retList = new Array();
		var numOfColumns = values[0].length;
		for ( var i = 0; i < values.length; i++) {
			var obj = {};
			
			for(var j =0; j<numOfColumns; j++){
				if(values[i][j]==null){
					continue;
				}
				if(j==0){
					obj.key = values[i][0];
					obj.value0 = values[i][j];
				}else{
					if(this.autoRound){
						var round = this.decimals==0?1:this.decimals*10;
						obj["value"+j] = Math.round(values[i][j]*round)/round;
					}else{
						obj["value"+j] = values[i][j];
					}
					
				}
			}
			retList.push(obj);
		}
		return retList;
	},

	createTimeStore : function(values) {
		var retList = new Array();
		var numOfColumns = values[0].length;
		
		for ( var i = 0; i < values.length; i++) {
			
			var obj = {};
			for(var j =0; j<numOfColumns; j++){
				if(values[i][j]==null){
					continue;
				}
				if(j==0){
					obj.key = new Date(values[i][j]);
					obj.value0 = values[i][j];
				}else{
					if(this.autoRound){
						var round = this.decimals==0?1:this.decimals*10;
						obj["value"+j] = Math.round(values[i][j]*round)/round;
					}else{
						obj["value"+j] = values[i][j];
					}
				}
				
			}
			retList.push(obj);
		}
		return retList;
	}
	
});

// @tag chart-library
Ext.define('NV.chart.library.ChartDrawer',{

	singleton: true,
	serverUrls : {},
	
	drawChartFromJson: function(measurement, portletContentObject){
		index = Math.floor((Math.random()*1000))+""+(Ext.Date.format(new Date(),'U'));
		
		
		var chart = undefined;
		var chartDef = Ext.apply(measurement,{
			seriesConfigs:measurement.series,
			jsonStore:measurement.measurementData,
			axisConfigs:measurement.axes,
			portletContentObject:portletContentObject
		});
		
		if (measurement.chartType == "pie") {
			
			chart = Ext.create('NV.chart.library.amchart.AmPieChart',chartDef);

		}else if (measurement.chartType == "combo" || measurement.chartType == "bar" || measurement.chartType == "dynamic") {

			if(measurement.chartType == "bar"){
				chart = Ext.create('NV.chart.library.amchart.AmBarChart', chartDef);
			}else if(measurement.chartType == "dynamic"){
				chart = Ext.create('NV.chart.library.amchart.AmRefreshSeriesChart', chartDef);
			}else{
				chart = Ext.create('NV.chart.library.amchart.AmComboChart', chartDef);
			}

		}else if(measurement.chartType == "meter") {
		
			chart = Ext.create('NV.chart.library.amchart.AmMeterChart', chartDef);

		} 
		else if(measurement.chartType == "status"){
			chartDef.seriesArray = []; 
			chart = Ext.create('NV.chart.library.otherchart.StatusChart',chartDef);
			
		}
		
		return chart;
	}
});

// @tag chart-library

lastWidth = undefined;
lastHeight = undefined;
contentDivs = [];
contentDivsCount = 0;
contentRowsCount = 0;


refreshSize = function(width, height, count){
	
/*
	lastWidth = width;
	lastHeight = height;

	height = height/contentRowsCount;
	
	width = parseInt(width);
	
	if(contentDivs.length == 1){
		Ext.getBody().el.setHeight(Ext.getBody().getViewSize().height);
		contentDivs[0].setHeight(Ext.getBody().getViewSize().height);
		
	}
	
	if(Ext.getBody().getViewSize().height<document.height){
		width -=18;
	}
	if(Ext.query('table').length<=2){
		contentDivs[0].setWidth(width);
		contentDivs[0].setHeight(height);
	}
*/
};
Ext.require('Ext.Ajax') ;
Ext.require('NV.chart.library.ChartDrawer') ;
Ext.define('NV.chart.library.ReportChartDrawer',{
	singleton: true,
	initChartDrawer : function(){
	
		NV.chart.library.ChartDrawer.serverUrls = this.fillUrls();
			
		var chartElements = Ext.select('div.chart_url').elements;
		try{
//			if(chartElements.length==1 && Ext.query('table').length<=2){chartElements[0].style.setProperty("height", (Ext.getBody().getViewSize().height-10)+"px");}
		}catch(e){}
		if(chartElements.length>0){
			
			this.drawCharts(chartElements,0, chartElements[0].attributes.id.value);
		}
	},
	fillUrls : function(){
		var serverUrls = {};
		var serverUrl = "";
		var metas = document.getElementsByTagName('meta');;
		
		for (var x=0,y=metas.length; x<y; x++) {
			 if (metas[x].name.toLowerCase() == "nv_url") {
			     serverURL = metas[x].content;
			 }
		}
		for (var x=0, y=metas.length; x<y; x++) {

			if (metas[x].name.toLowerCase() == "nv_image_folder_url") {
				 serverUrls['imageFolderUrl'] = serverURL + metas[x].content;
			}
		}
		
		if(window.frameElement){
			var metas = window.frameElement.ownerDocument.getElementsByTagName("meta");
				
			for (var x=0,y=metas.length; x<y; x++) {
				 if (!serverURL && metas[x].name.toLowerCase() == "nv_url") {
				     serverURL = metas[x].content;
				 }
			}
			for (var x=0, y=metas.length; x<y; x++) {
				if (!serverUrls['imageFolderUrl'] && metas[x].name.toLowerCase() == "nv_image_folder_url") {
					 serverUrls['imageFolderUrl'] = serverURL + metas[x].content;
				}
				
			}
		}
		return serverUrls;
	},
	drawCharts : function(chartElements, ind, divId){
		contentRowsCount ++;
		var me = this;
		Ext.Ajax.request({
			url : chartElements[ind].attributes.nv_chart_url.value,
			success : function(response) {
				var json = Ext.decode(response.responseText);
				
				if(json.collapsible==null || json.collapsible==undefined){
					json.collapsible = true;
				}
		
				var currentWidth = Ext.query('#'+divId)[0].clientWidth;
				if(currentWidth=='0px'){
					currentWidth = Ext.getBody().getViewSize().width;
				}
		//		var currentWidth = json.width==undefined?500:json.width;
				var currentHeight = json.height==undefined?300:json.height;
				if(Ext.select('div.chart_url').elements.length==1 && Ext.query('table').length<=2){
					currentHeight = Ext.getBody().getViewSize().height-10;
				}
				var title = json.title==undefined?"":json.title;
				var header;
				if(json.header){
					header = {
						/*style : {
							background : "#8db9e0"
						}*/
					};
				}else{
					header = false;
				}
				
				var divWidth = Ext.query("#"+divId);
				currentDiv = Ext.create('Ext.panel.Panel', {
					bodyCls : 'chartDivBody',
					componentCls : 'chartDiv',
					width : currentWidth,
					height: currentHeight,
					title: title,
					hidden : false,
					maximizable : true,
					divId: divId,
					renderTo : divId,
					border:header?true:false,
					frame:header?true:false,
					layout : {
						type : 'vbox',
						align : 'stretch'
					},
					flex:1,
					animCollapse : true,
					collapsible : json.collapsible,
					header:header
				});
				
				if(lastWidth==null || lastWidth==undefined)lastWidth = currentWidth;
				if(lastHeight==null || lastHeight==undefined)lastHeight = currentHeight;
				
				contentDivs[ind] = currentDiv;
				
				currentWidth = currentWidth/json.measurements.length;
				for ( var i = 0; i < json.measurements.length; i++) {
					json.measurements[i].header = json.header;
					var chart = NV.chart.library.ChartDrawer.drawChartFromJson(json.measurements[i]);						
					currentDiv.add(chart.chartContent);

				}
				
				ind ++;
				refreshSize(lastWidth, lastHeight, json.measurements.length);
				if(chartElements.length>ind){
					me.drawCharts(chartElements,ind, chartElements[ind].attributes.id.value);
					
				}		
			}
		});
		
	}
	
});

// @tag chart-library
Ext.define('NV.chart.library.amchart.AmComboChart', {
	extend : 'NV.chart.library.Chart',

	config : {

		//from json
		axes : undefined ,					
		series : undefined, 
		rotated: false,
		
		zoom:false,
		zoomScrollbarVisible:false,
		refreshOnZoom:false,
		
		chart : undefined,
		seriesConfig : undefined,
		valueAxisArray : undefined,
		seriesMap : undefined,
		technicalseries : undefined,
		resolutionBySize:true,
		cursor:false,
		enableSave:false
		
	},

	constructor : function(config) {
		this.valueAxisArray = [];
		this.globalFieldMap = {};
		this.technicalseries = {};	//used on statistic graph
		this.callParent([ config ]);
		this.validate();
	},

	validate:function(){
		
		return this.callParent();
	},
	
	
	initPlus : function() {
		this.createSeriesConfig();
	},

	createSeriesObjects: function(){
		//create the series objects
		this.seriesMap = {};
		for(var i=0; i<this.series.length; i++){
			var s =  Ext.create('NV.chart.library.utils.Series', Ext.apply(this.series[i],{chart:this, id:this.series[i].seriesId}));
			this.seriesMap[this.series[i].seriesId] = s;
		}
	},
	
	initChart : function() {

		//create the axis objects
		this.axisMap = {};
		for(var i=0; i<this.axes.length; i++){
			var ax = Ext.create('NV.chart.library.utils.Axis', Ext.apply(this.axes[i],{chart:this}));
			this.axisMap[ax.id?ax.id:ax.position] = ax;
		}
		
		//create the series objects
		this.createSeriesObjects();
		
		this.chartConfig = {
				type:"serial"
				};
		
		this.chartConfig.dataProvider = []; 
		this.chartConfig.categoryField = "key"; 
		this.chartConfig.usePrefixes = true;	//a tengelyeken rövidíti a számokat pl az 1000-et K-ra

		this.chartConfig.marginTop = 10; // nincsenek ilyen paraméterek
		this.chartConfig.marginLeft = 10;
		this.chartConfig.marginRight = 20;
		this.chartConfig.marginBottom = 10;

		this.chartConfig.startDuration = 0;
		if(this.colors){
			this.chartConfig.colors = this.colors;
		}
		if(this.background){
			this.chartConfig.backgroundColor = this.background;
			this.chartConfig.backgroundAlpha = 1;
		}
		
		
		//this.chartConfig.balloon.textShadowColor = "#000000"; 
		this.chartConfig.pathToImages = "resource/amchart/image/";
		this.chartConfig.panEventsEnabled = true; 
		this.chartConfig.zoomOutButton = {
			backgroundColor : "#0B00F0",
			backgroundAlpha : 0.15
		};
		
		this.chartConfig.rotate = this.rotated;
		
		this.chartConfig.columnSpacing = 0.5;
		this.chartConfig.columnWidth = 0.2;
		
		//create the amchart axis objects
		this.chartConfig.valueAxes = [];
		for(var i in this.axisMap){
			if(this.axisMap[i].type == 'Category' || this.axisMap[i].type == 'Time'){
				this.chartConfig.categoryAxis = this.axisMap[i].createAmchartObject();
			}else{
				this.chartConfig.valueAxes.push(this.axisMap[i].createAmchartObject());
			}
			
		}
		//create the amchart series objects
		this.createSeriesConfig();

		// LEGEND
		if (this.legend) {
			var legend = {};

			if (this.legend.position) {
				legend.position = this.legend.position;
			}else{
				legend.position = "right";
			}
			
			if(this.legend.color){
				legend.color = this.legend.color;
			}
			
			if(this.legend.fontSize){
				try{
					legend.fontSize = this.legend.fontSize; 
				}catch(e){
					
				}
			}
			
			legend.borderAlpha = 0.2;
			
			
			//color, visible, width, bg
			if(this.legend.line){
				if(this.legend.line.color){
					legend.borderColor = this.legend.line.color;
				}
				if(this.legend.line.visible==false){
					legend.borderAlpha = 0;
				}
				if(this.legend.line.width){
					legend.markerBorderThickness = this.legend.line.width;
				}
			}
			
			if(this.legend.background){
				legend.backgroundColor = this.legend.background;
				legend.backgroundAlpha = 0.5;
			}
			
			if(this.legend.margin){
				legend.autoMargin = false;
				legend.marginLeft = this.legend.margin.left;
				legend.marginRight = this.legend.margin.right;
				legend.marginTop = this.legend.margin.top;
				legend.marginBottom = this.legend.margin.bottom;
			}
			legend.horizontalGap = 0;
			legend.equalWidths = true;
			legend.valueText = '[[description]]'; 
			this.chartConfig.legend = legend;
		}

		if (this.threeD) {
			this.chartConfig.depth3D = 20;
			this.chartConfig.angle = 30;
		}
		
	
		
	
		if(this.cursor){
			this.hasCursor = this.cursor;
		}
		if(this.zoom && this.zoomScrollbarVisible){
			this.addScrollBar();
			this.hasCursor = true;
		}
		this.defaultPeriod = 'ss';

		//create the chart cursor object, if is neccesary
		if (this.hasCursor) {
		//	var newPeriod = this.getPreferedPeriod();
			this.chartConfig.chartCursor = {};
			
			
			this.chartConfig.chartCursor.cursorPosition = "middle";
			this.chartConfig.chartCursor.bulletsEnable = false;
			this.chartConfig.chartCursor.bulletSize = 2;
			if (this.zoom) {
				this.chartConfig.chartCursor.zoomable = true;
			} else {
				this.chartConfig.chartCursor.zoomable = false;
			}
			this.chartConfig.chartCursor.categoryBalloonDateFormat = 'MM DD JJ:NN';

			if (this.defaultPeriod.match('hh')) {
				this.chartConfig.chartCursor.categoryBalloonDateFormat = 'MM DD JJ:NN';
			} else if (this.defaultPeriod.match('DD')) {
				this.chartConfig.chartCursor.categoryBalloonDateFormat = 'MM DD';
			} else if (this.defaultPeriod.match('ss')) {
				this.chartConfig.chartCursor.categoryBalloonDateFormat = 'MM DD JJ:NN:SS';
			}
		
		}

		//export
		if(this.enableSave){
			this.chartConfig.exportConfig = {
					"menuTop":"0px",
				      "menuRight":"0px",
				      "menuItems": [{
				      "icon": 'resource/amchart/image/export.png',
				      "format": 'png'	  
				      }]  
					
			    };
		}
		 
		

	},
	
	afterChartRendered: function(){
		
		if(this.refreshOnZoom){
			this.chart.addListener('zoomed', function(obj){
				if(this.portletContentObject){
					this.portletContentObject.addExtraParamsToRefresh({from:obj.startDate.getTime(), to:obj.endDate.getTime()});
					this.portletContentObject.propagateParams({from:obj.startDate.getTime(), to:obj.endDate.getTime()});
				}else{
					this.getDataFromServerStandalone({from:obj.startDate.getTime(), to:obj.endDate.getTime()});
				}
			}, this);
		}
		
	/*	if(this.chartCursor){
			this.chart.addChartCursor(this.chartCursor);
		}*/
		
	/*	if(this.zoom && this.zoomScrollbarVisible){
			this.addScrollBar();
			this.hasCursor = true;
		}
*/
		this.addActionsToChart();
		
	},
	
	addActionsToChart: function(){
		if (this.actions) {
			for ( var i=0; i< Ext.Object.getKeys(this.actions).length; i++) {
				if (Ext.Object.getKeys(this.actions)[i].match("plot")) {
					var seriesId = Ext.Object.getKeys(this.actions)[i].substr(0, Ext.Object.getKeys(this.actions)[i].indexOf("plot") - 1);

					var clickFunction = function(evt) {
						if (evt.graph.title == this.graph.title) {
							for(var a=0; a<this.action.length; a++){
								if(this.type==this.action[a].eventType || (this.type=='click' && this.action[a].eventType==undefined)){
									var action = Ext.create('NV.dashboard.actionhandler.ActionHandler',{
										portletContentObject: this.portletContentObject,
										action: this.action[a],
										doubleClose: true,
										context: "this.scope.dataContext[this.scope.globalFieldMap",
										scope: {
											dataContext : evt.item.dataContext,
											globalFieldMap : this.globalFieldMap
										},
										event:evt.evt
									});
									action.doAction();
								}
							}
						}
					};
					
					
					
					try{
						this.chart.addListener('clickGraphItem', clickFunction, {
							graph : this.seriesMap[seriesId].amchartObject,
							action : this.actions[Ext.Object.getKeys(this.actions)[i]],
							globalFieldMap : this.globalFieldMap,
							portletContentObject: this.portletContentObject,
							type:"click"
						});
						this.chart.addListener('doubleClickGraphItem', clickFunction, {
							graph : this.seriesMap[seriesId].amchartObject,
							action : this.actions[Ext.Object.getKeys(this.actions)[i]],
							globalFieldMap : this.globalFieldMap,
							portletContentObject: this.portletContentObject,
							type:"dblclick"
						});
						this.chart.addListener('rightClickGraphItem', clickFunction, {
							graph : this.seriesMap[seriesId].amchartObject,
							action : this.actions[Ext.Object.getKeys(this.actions)[i]],
							globalFieldMap : this.globalFieldMap,
							portletContentObject: this.portletContentObject,
							type:"rightclick"
						});
						
						if(this.technicalseries[seriesId]){
						try{
							this.chart.addListener('clickGraphItem', clickFunction, {
								graph : this.technicalseries[seriesId].amchartObject,
								action : this.actions[Ext.Object.getKeys(this.actions)[i]],
								globalFieldMap : this.globalFieldMap,
								portletContentObject: this.portletContentObject
							});
						}catch(e){
						}
					}
						
					}catch(e){
					}					
				}
			}
		}
	},
	
	createSeriesConfig : function() {
		
		if(this.chart){
			try {
				var size = this.chart.graphs.length;
				for ( var i = 0; i < size; i++) {
					this.chart.removeGraph(this.chart.graphs[0]);
				}
			} catch (e) {

			}
		}
		

		this.chartConfig.graphs = [];
		for(var i in this.seriesMap){	
			/**
			 * ha nem oszlop típusú, akkor kell cursor hogy működjön a kattintás
			 */
			if(this.actions && this.seriesMap[i].type!='column'){
				this.hasCursor = true;
			}
			this.chartConfig.graphs.push(this.seriesMap[i].createAmchartObject());
		}
	},

	findAxis: function(id){
		return this.axisMap[id];
	},
	
	refreshChartStore : function() {
		if(this.chart){
			this.chart.destroy();
			this.chart.dataProvider = this.store;
		}
		this.chartConfig.dataProvider = this.store;
		
		
		var newPeriod = this.getPreferedPeriod();
		this.defaultPeriod = newPeriod;
		this.chartConfig.categoryAxis.minPeriod = this.defaultPeriod;
		if(this.chart){
			this.chart.categoryAxis.minPeriod = this.defaultPeriod;
		}
			
		
		if (this.hasCursor) {
		
			if (this.defaultPeriod.match('hh')) {
				this.chartConfig.chartCursor.categoryBalloonDateFormat = 'MM DD JJ:NN';
			} else if (this.defaultPeriod.match('DD')) {
				this.chartConfig.chartCursor.categoryBalloonDateFormat = 'MM DD';
			} else if (this.defaultPeriod.match('ss')) {
				this.chartConfig.chartCursor.categoryBalloonDateFormat = 'MM DD JJ:NN:SS';
			}
			if(this.chart){
				this.chart.chartCursor, categoryBalloonDateFormat = this.chartConfig.chartCursor.categoryBalloonDateFormat;
			}
		
		}

		try {
			if(this.chart){
				this.chart.validateData();
			}
			
		} catch (e) {

		}

	},

	createStoreFromJson : function(json) {
		if(json.length>=1){
			if (json.length >= 1 && typeof json[0][0] == "number") {
				this.store = this.createTimeStore(json);
			} else {
				this.store = this.createStore(json);
			}
		}
		
	},

	getPreferedPeriod : function() {
		var defaultPeriod = 'ss';

		try {
			if (this.store.length >= 2) {

				var diff = (this.store[1].key.getTime() - this.store[0].key.getTime()) / 1000;
				if (diff >= 60 && diff < (60 * 60)) { // 1 perc és 60 perc között van
					var count = Math.round(diff/60);
					defaultPeriod = count+'mm';
				} else if (diff >= 60 * 60 && diff < (60 * 60 * 24)) { // 1 óra és 1 nap között van
					var count = Math.round(diff/(60*60));
					defaultPeriod = count+'hh';
				} else if (diff >= 60 * 60 * 24 && diff < 60 * 60 * 24 * 30) { // 1 nap és 1hónap között van
					var count = Math.round(diff/(60*60*24));
					defaultPeriod = count+'DD';
				} else if(diff > 60 * 60 * 24 * 30){
					var count = Math.round(diff/(60*60*24*30));//több mint 1 hónap
					defaultPeriod = count+'MM';
				}
			}
		} catch (e) {

		}
		return defaultPeriod;
	},

	seriesAddScrollBar : function(graph) {
		if(this.zoom){
			this.addScrollBar();
		}
	},

	addScrollBar : function() {
		if(this.zoom || this.zoomScrollbarVisible){
			this.chartScrollbar = new AmCharts.ChartScrollbar(); 
			try {
				this.chart.removeChartScrollbar(this.chartScrollbar);
			} catch (e) {
	
			}
			this.chart.addChartScrollbar(this.chartScrollbar);
		}
	},

	drawChart : function() {
		try{
			this.chartContentPanel.removeAll();
		}
		catch(e){
			
		}
		try{
			
			this.chart = AmCharts.makeChart(this.chartContentPanel.id, this.chartConfig);
			this.afterChartRendered();
			this.chartRendered = true;
		}
		catch(e){
			
		}
	},

	getPlotSize: function(){
		try{
			var width = parseInt(Ext.query("div#" + this.id + "-body > div:nth(1) > div:nth(1)")[0].style.width);
			width-=(this.valueAxisArray*48);
			return width/5;
		}catch(e){
			return ;
		}
		
	}
	
});

// @tag chart-library

Ext.define('NV.chart.library.amchart.AmBarChart', {
	extend: 'NV.chart.library.amchart.AmComboChart',

	/**
	 * Csak 1 db series van. Ahhoz hogy minden jó legyen minden egyes elemre létre kell hozni egy külön series-t.
	 * Majd csak az annyiadik eleme legyen nem 0, ahányadik ő maga :)
	 * stacked legyen a grafikon fixen
	 */
	
	constructor: function(config){
		this.isStacked = true;
		
		this.callParent([config]);
	},
	
	createStoreFromJson: function(values) {

		var retList = new Array();
		var numOfColumns = values.length;
		for ( var i = 0; i < values.length; i++) {
			var obj = {};
			obj.key = values[i][0];
			for(var j =1; j<=numOfColumns; j++){
				obj["value"+j] = 0;
			}
			obj["value"+(i+1)] = values[i][1];	
			retList.push(obj);
		}
		this.store = retList;

	},
	
	refreshChartStore: function(){
       	this.initChart();
    	this.createSeriesConfig();
    	this.chart.dataProvider = this.store;

    	this.chart.validateData();
    	this.drawChart();
    },
    
    initPlus : function(){
    	
    },
    
	createSeriesConfig : function(){

		try{
			var size = this.chart.graphs.length;
    		for(var i =0; i<size; i++){
    			this.chart.removeGraph(this.chart.graphs[0]);
    		}
    	}catch(e){
    		
    	}
    	this.seriesMap = {};
		for(var i =0; i<this.store.length; i++){
			var color = this.chartColors&&this.chartColors[i%this.chartColors.length]?this.chartColors[i%this.chartColors.length]:undefined;
			this.series[0].field = {
					value:  i+1
			};
			this.series[0].title = this.store[i].key;
			this.series[0].color = color;
			this.series[0].gutter = "80%";
			
			var s =  Ext.create('NV.chart.library.utils.Series', Ext.apply(this.series[0],{chart:this, id:i}));
			this.seriesMap[ i ] = s;
		}
   }	
});

// @tag chart-library
Ext.define('NV.chart.library.amchart.AmMeterChart', {
	extend : 'NV.chart.library.Chart',
	
	config:{
		label:undefined,
		ranges:undefined,
		field:undefined,
		arrows: undefined
	},
	
	constructor : function(config) {
		this.globalFieldMap = {};
		this.callParent([config]);
		if(this.label){
			this.label = Ext.create('NV.chart.library.utils.Label', config.label);
		}
		
		var rangesTmp = Ext.clone(this.ranges);
		this.ranges = [];
		for(var i=0; i < rangesTmp.length; i++){
			this.ranges.push(Ext.create('NV.chart.library.utils.Range', rangesTmp[i]));
		}
		
		this.validate();
	},
	
	validate: function(){
		if(this.field){
			if(!this.field.value){
				Ext.Msg.alert("Meter chart configuration error", "field.value required (or don't use field)");
			}
		}
	},
	
	createChart : function() {
	/*
	 * init gradients
	 */
		this.arrows = [];
		
		if(!this.field){
			 this.globalFieldMap["value"] = 1;
		     this.globalFieldMap["key"] = 0;
		}else{
			this.globalFieldMap = this.field;
			this.globalFieldMap["key"] = 0;
			
		}
		
		this.chart = new AmCharts.AmAngularGauge(); 
		
		 // create axis
	    this.axis = new AmCharts.GaugeAxis();
	    
	    this.bands = [];
	    var minValue = undefined;
	    var maxValue = undefined;
	    for(var i=0; i<this.ranges.length; i++){
	    	if(!this.ranges[i].color.toUpperCase().match("#[0-9A-F]{6}")){
	    		this.ranges[i].color =  this.gradientArray[this.ranges[i].color].colors.reverse()[0];
	    	}
	    	
	    	this.bands.push({
	    		startValue:this.ranges[i].from,
	    		endValue:this.ranges[i].to,
	    		color: this.ranges[i].color,
	    	    innerRadius : "50%"

	    		
	    	});
	    	if(minValue==undefined || minValue>this.ranges[i].from){
	    		minValue = this.ranges[i].from;
	    	}
	    	if(maxValue==undefined || maxValue<this.ranges[i].to){
	    		maxValue = this.ranges[i].to;
	    	}
	    }
	    
	    this.axis.startValue = minValue;
	    this.axis.endValue = maxValue;
	    this.axis.bands = this.bands;
	    this.axis.inside = false;
	    this.axis.axisThickness = 0;
	    this.axis.gridInside = false;
	    this.axis.valueInterval = (maxValue-minValue)%20==0?(maxValue-minValue)/20:(maxValue-minValue)/10;
	    this.axis.minorTickInterval = (maxValue-minValue)%20==0?(maxValue-minValue)/20:(maxValue-minValue)/10;
	    // bottom text
	    this.axis.bottomTextYOffset = -20;

	    if(this.label){
	    	if(this.label.fontSize){
	    		this.axis.bottomTextFontSize = this.label.fontSize;
			}
			if(this.label.unit){
				this.axis.unit = this.label.unit;
				
				
			}
			if(this.label.color){
				this.axis.bottomTextColor = this.label.color;
			}
		}
	    this.chart.addAxis(this.axis);

		return this;
	},

	refreshChartStore: function(){
		if(!this.chart){
			this.createChart();
		}
		this.chart.titles=[];

		for(var i=0; i<this.store.length; i++){
    		 // gauge arrow
    		
			if(!this.arrows[i]){
				this.arrows[i] = new AmCharts.GaugeArrow();
				this.arrows[i].color = this.colors[i];
				this.chart.addArrow(this.arrows[i]);
			}
			
    	}
		
		for(var i=0; i<this.store.length; i++){
			this.chart.titles.push({
				text:this.store[i][this.globalFieldMap["key"]],
				color:this.colors[i]
			});
			this.arrows[i].setValue(this.store[i][this.globalFieldMap["value"]]);
    	}
		this.chart.validateData();
		if(this.store.length==1){
			 var labelText = this.store[0][this.globalFieldMap["value"]];
	    	    if(this.label && this.label.format){
	    	    	labelText += this.label.unit;
	    	    }
	    	    this.axis.setBottomText(labelText);
		}
    },
    

    createStoreFromJson: function(json){
	    this.store = json; 
    },
    
    drawChart : function() {
    	if(this.dataUrl){
    		this.createChart();
    	}
    	this.chart.write(this.chartContentPanel.id);
		this.chartRendered = true;
	}
});

// @tag chart-library
Ext.define('NV.chart.library.amchart.AmPieChart', {
	extend: 'NV.chart.library.Chart',
		
	config:{
		showKeyOnBalloon: false,
		showTitleOnBalloon: false,
		showKeyOnLabel: false,
		field: undefined
	},
	
	constructor : function(config){
		this.globalFieldMap = {};
		if(!config.field){
			 this.globalFieldMap["value"] = "value1";
			 this.globalFieldMap["link"] = "value2";
		     this.globalFieldMap["key"] = "key";
		}else{
			this.globalFieldMap["key"] = "key";
			for(var i in config.field){
				this.globalFieldMap[i] = "value"+config.field[i];
			}
		}
		this.callParent([config]);
		
		if(this.label){
			this.label = Ext.create('NV.chart.library.utils.Label', config.label);
		}
		if(this.legend){
			this.legend = Ext.create('NV.chart.library.utils.Legend', config.legend);
		}
		
    },

    initChart : function (){

    	this.chart = new AmCharts.AmPieChart();	//combo-nál mindíg ezt kell használni
        this.chart.dataProvider = this.generateChartData();				
        
        this.chart.titleField = this.globalFieldMap["key"];				
        this.chart.valueField = this.globalFieldMap["value"];	
        this.chart.pulledField = "pulled";
        this.chart. usePrefixes = true;
        
        if(this.background){
			this.chart.backgroundColor = this.background;
			this.chart.backgroundAlpha = 1;
		}
		
		
		this.chart.balloon.textShadowColor = "#000000"; 
		
		this.chart.theme = "chalk";
		
		this.chart.balloonText = "[[value]]";
		
		if(this.showKeyOnBalloon){
			this.chart.balloonText = "[[key]]<br><b>[[value]]</b>";
		}
		
        if(this.label){
        	
        	this.chart.labelsEnabled=true;
        	
        	if(this.showKeyOnLabel){
        		this.chart.labelText = "[[key]]<br>[[value]]";
        	}else{
        		this.chart.labelText = "[[value]]";
        	}
        	
        	
        	if (this.label.unit) {
        		this.chart.labelText = this.chart.labelText+" "+this.label.unit;
				this.chart.balloonText += this.label.unit;
    		}
        	if(this.label.precision){
        		this.chart.percentPrecision = this.label.precision;
				this.chart.precision = this.label.precision;
        	}
        }else{
        	this.chart.labelsEnabled=false;
        }

      
        
        
        if(this.colors){
        	for(var i in this.colors){
        		if(!this.colors[i].toUpperCase().match("#[0-9A-F]{6}")){
        			this.colors[i] = this.gradientArray[this.colors[i]].colors.reverse()[0];
        			this.chart.gradientRatio = [-0.2,0.2];
        		}
        	}
        	this.chart.colors = this.colors;
        }
        
        
        if(this.actions){
        	var clickFunction = function(evt){
				for(var a=0; a<this.action.length; a++){
					if(this.type==this.action[a].eventType || (this.type=='click' && this.action[a].eventType==undefined)){
						var action = Ext.create('NV.dashboard.actionhandler.ActionHandler',{
							portletContentObject: this.portletContentObject,
							action: this.action[a],
							doubleClose: true,
							context: "this.scope.dataContext[this.scope.globalFieldMap",
							scope: {
								dataContext : evt.dataItem.dataContext,
								globalFieldMap : this.globalFieldMap
							},
							event:evt.evt
						});
						action.doAction();
					}
				}
        	};
        	
        	this.chart.addListener('clickSlice', clickFunction,{
					action : this.actions.plot,
					globalFieldMap : this.globalFieldMap,
					portletContentObject: this.portletContentObject,
					type:"click"
			});
        	this.chart.addListener('rightClickSlice', clickFunction,{
					action : this.actions.plot,
					globalFieldMap : this.globalFieldMap,
					portletContentObject: this.portletContentObject,
					type:"rightclick"
			});  	
        	 
        }

     // LEGEND
		if (this.legend) {
			var legend = new AmCharts.AmLegend();

			if (this.legend.position) {
				legend.position = this.legend.position;
			}else{
				legend.position = "right";
			}
			
			if(this.legend.color){
				legend.color = this.legend.color;
			}
			
			if(this.legend.font){
				try{
					legend.fontSize = this.legend.fontSize; 
				}catch(e){
					
				}
			}
			
			legend.borderAlpha = 0.2;
			
			
			//color, visible, width, bg
			if(this.legend.line){
				if(this.legend.line.color){
					legend.borderColor = this.legend.line.color;
				}
				if(this.legend.line.visible==false){
					legend.borderAlpha = 0;
				}
				if(this.legend.line.width){
					legend.markerBorderThickness = this.legend.line.width;
				}
			}
			
			if(this.legend.background){
				legend.backgroundColor = this.legend.background;
				legend.backgroundAlpha = 0.5;
			}
			
			if(this.legend.margin){
				legend.autoMargin = false;
				legend.marginLeft = this.legend.margin.left;
				legend.marginRight = this.legend.margin.right;
				legend.marginTop = this.legend.margin.top;
				legend.marginBottom = this.legend.margin.bottom;
			}
			legend.horizontalGap = 3;
			legend.valueText = '[[description]]'; 
			this.chart.addLegend(legend);
		}

        
        if(this.threeD){
        	 this.chart.depth3D = 10;
        	 this.chart.angle = 30;
        }
        
      //export
	/*	 this.chart.exportConfig = {
		        menuTop: "21px",
		        menuBottom: "auto",
		        menuRight: "21px",
		        backgroundColor: "#efefef",

		        menuItemStyle: {
		            backgroundColor: '#FFFFFF',
		            rollOverBackgroundColor: '#DDDDDD'
		        },

		        menuItems: [{
		            textAlign: 'center',
		            icon: 'resource/amchart/image/export.png',
		            items: [{
		                title: 'JPG',
		                format: 'jpg'
		            }, {
		                title: 'PNG',
		                format: 'png'
		            }, {
		                title: 'SVG',
		                format: 'svg'
		            }, {
		                title: 'PDF',
		                format: 'pdf'
		            }]
		        }]
		    };*/
        
    	return this;
    },
    
    generateChartData: function () {
        var chartData = [];
       
        if( this.store.length<=6){
        	
        	for (var i = 0; i < this.store.length; i++) {
                chartData.push(this.store[i]);
            }
        }else{	//első 5 kiszűrése
        	var firstFive = [];
        	for(var i =0; i<5; i++){
        		firstFive.push(this.store[i]);
        	}        	
        	
        	for(var i=5; i<this.store.length; i++){
        		var newItem = undefined;
        		for(var j=0; j<firstFive.length; j++){
        			//van az első 5-ben olyan elem, aminél ez az új nagyobb
        			//keressük meg a legkissebb elemet az első 5-ben és azt cseréljük ki
        			if(firstFive[j].value1<this.store[i].value1){
        				newItem = this.store[i];
        				break;
        			}
        		}
        		if(newItem){
        			var minInFirstFive = firstFive[0];
            		var minIndex = 0;
            		for(var j=0; j<firstFive.length; j++){
            			if(minInFirstFive.value1>firstFive[j].value1){
            				minInFirstFive = firstFive[j];
            				minIndex = j;
            			}
            		}
            		firstFive[minIndex] = newItem;
        		}
        		
        	}
        	var otherSum = 100;
        	for(var j=0; j<firstFive.length; j++){
    			otherSum -= firstFive[j].value1;
    		}
        	
        	chartData = firstFive;
        	chartData.push({
        		key: "others",
        		value1: otherSum
        	});
        }

        return chartData;
    },
    
    refreshChartStore: function(){
    	
    	this.chart.dataProvider = this.generateChartData();
    	
    	this.chart.validateData();
    	this.drawChart();
    },
    
    createStoreFromJson: function(json){
    	if(json.length>=1){
	    	this.store = this.createStore(json);
	    }
	    
    },
          
    drawChart : function() {
    	try{
			this.chartContentPanel.removeAll();
		}
		catch(e){
			
		}
		try{
			this.chart.write(this.chartContentPanel.id);
			this.chartRendered = true;
		}
		catch(e){
			
		}
	}
});

// @tag chart-library
Ext.define('NV.chart.library.amchart.AmRefreshSeriesChart', {
	extend: 'NV.chart.library.amchart.AmComboChart',

	/**
	 * Csak 1 db series van. Ahhoz hogy minden jó legyen minden egyes elemre létre kell hozni egy külön series-t.
	 * Majd csak az annyiadik eleme legyen nem 0, ahányadik ő maga :)
	 * stacked legyen a grafikon fixen
	 */
	
	constructor: function(config){
		this.callParent([config]);
	},
	
	initPlus : function(){
    	
    },   
    
   createSeriesObjects: function(){

	},
   
	createSeriesConfig : function(titles, colors){
		try{
			this.chart.removeChartScrollbar(this.chartScrollbar);
		}catch(e){
			
		}
		try{
			var size = this.chart.graphs.length;
    		for(var i =0; i<size; i++){
    			this.chart.removeGraph(this.chart.graphs[0]);
    		}
    	}catch(e){
    		
    	}
    	if(titles || colors){
    		this.seriesMap = {};
    		var usedcolors = this.colors;
    		if(colors){
    			usedcolors = colors;
        	}
    		for(var i =0; i<titles.length; i++){
    			var color = this.colors[i%usedcolors.length];
    			this.series[0].color=color;
    			this.series[0].title=titles[i];
    			this.series[0].field = {
        				value:i+1	
        			};
    			this.series[0].chart=this;
    			var s =  Ext.create('NV.chart.library.utils.DynamicSeries', this.series[0]);
    			this.seriesMap[i] = s;

    		}
    		
        	this.callParent();

    	}

   },
	
   seriesAddScrollBar: function(graph){
	   
   },
   
   refreshData: function(json){		
		if(!json.measurementData){
			Ext.Msg.alert("Error", "No measurementData received");
			return;
		}
		this.createStoreFromJson(json.measurementData);
		this.refreshChartStore(json.title, json.color);
		
	},
   
	refreshChartStore: function(titles, colors){
		
		this.createSeriesConfig(titles, colors);
		this.callParent();
		this.drawChart();
    	
    }
});

// @tag chart-library

Ext.define('NV.chart.library.extchart.BaseComboChart',{
	extend: 'NV.chart.library.Chart',
	
	constructor : function(config, index) {
		this.index = index;
		this.callParent([config]);
		return this;
	},
	
	initChart : function (){
		links2 = [];
		if(this.links){
			for(var i in this.store.data.items){
				links2[this.store.data.items[i].data.key] = this.links[i];
			}

		}
		
		var axis = new Array();
		for(var i=0; i<this.axisConfigs.length; i++){
			axis.push(this.addAxis(this.axisConfigs[i]));
		}
		
		var seriesArr = new Array();
		for(var i=0; i<this.seriesConfigs.length; i++){
			this.seriesConfigs[i].index = i+1;
			
			currentSeries = this.addSeries(this.seriesConfigs[i], links2);
			
			seriesArr.push(currentSeries);
		}
		
		if(this.legendConfig == undefined){
			this.legendConfig=false;
		}
		
		var me = this;
		
		this.chart = Ext.create('Ext.chart.Chart', {
			width: "100px",
			height: "100px",
			id : 'chartCol'+me.index,
			xtype : 'chart',
			legend: me.legendConfig,
			// style: 'background:#fff',
			animate : true,
			shadow : false,
			store : me.store,
			gradients: me.gradients,
			background : {
				gradient : config.chartBG
			},
			axes:axis,
			series:seriesArr,
			flex:1
		});		
		this.chartContent = this.chart;
	},
	
	 refreshChartStore: function(store){
		 if(!store){
	    		store = this.store;
	    	}
	    	this.chart.store = store;
	    },
	    
    createStoreFromJson: function(json){
    	var me = this;
    	if(json.length>=1 && typeof json[0][0]=="number"){
    		this.store = Ext.create(
				'Ext.data.Store',
				{
					model : 'ChartTimeStore',
					data : me.createTimeStore(json)
				}
    		);
    	}else{
    		this.store = Ext.create(
				'Ext.data.Store',
				{
					model : 'ChartStore',
					data : me.createStore(json)
				}
    		);
    	}
    },
	
	addAxis : function(options){
		currentAxis = options;
		currentAxis.dashSize = 2;
		
		
		if(options.type=='Numeric'){
			
	/*		currentAxis.label = {
				renderer : Ext.util.Format.numberRenderer('0,0')
			};
		*/	

		}else if(options.type=='Category'){
			currentAxis.fields = "key";
		}else if(options.type=='Time'){
			currentAxis.fields = "key";
            currentAxis.dateFormat = 'Y.m.d';
         //   currentAxis.step = [Ext.Date.DAY, 7]; 
         //   currentAxis.grid = false;
            currentAxis.label = {
            		renderer: function(v) { 
            			return v; 
            		}
            };
		}
		
		
		
		if((options.showlabel != true && options.type == 'Category') || (options.showlabel == false && (options.type != 'Category'))){
			currentAxis.label = {
				renderer : function(v) {
					return '';
				}
			};
			currentAxis.dateFormat = undefined;
		}
		
		return currentAxis;
	},
	
	addSeries : function(options, links){
		series = options;
		if(series.gutter==0){
			series.xPadding = 0;
			series.yPadding = 0;
		}
		series.highlight = true;
		
		if(series.color){
			if(series.color instanceof Array){
				for(var i in series.color){
					if(!series.color[i].match("#[0-9A-F]{6}")){
						series.color[i] = "url(#"+series.color[i]+")";
					}	
				}
			}else{
				if(!series.color.match("#[0-9A-F]{6}")){
					series.color = "url(#"+series.color+")";
				}
			}
			
		}
		
		series.tips = {
				trackMouse : true,
				
				border: 2,
				style: {
				    borderColor: 'white',
				    borderStyle: 'solid',
				    backgroundColor: series.color,
				    borderRadius: '10px'
				},
				renderer : function(storeItem,item) {
				
					title = Math.round(item.value[1]*10000)/10000+"";
					
	                this.setWidth(title.length*8);
	                this.setHeight(28);
					this.setTitle(title);
					
				}
		};
		
		if(links!=null){
			series.listeners = {
	            itemmousedown : function(obj, obj2, obj3, obj4) {
	            	if(links[obj.storeItem.data['key']]){
		            	window.open(links[obj.storeItem.data['key']], obj.storeItem.data['key'] + " popup",'height=500, width=500');	            		
	            	}
	            }
	        };
		}
		
		
		
		series.renderer = function(sprite, record, attributes, index, store){
			if(series.randomcolumnwidth){
				if(options.field=="value1"){
					attributes.width = attributes.width * record.data.value4;
					attributes.width = attributes.width+(record.data.value4/2);
				}
				
				if(record.data.value1>record.data.value3 && options.field!="value2"){
					attributes.fill = "#FF9933";
				}
				if(options.field=="value2"){
					attributes.fill = "#FF0000";
					attributes.width = "5px";
				}
			}
			if(series.gutter==0){
				attributes.width = attributes.width+1;
			}
			if(series.color){
				if(series.color instanceof Array){
					attributes.fill = series.color[parseInt(index%options.field.length)];
				} else{
					attributes.fill = series.color;
				}
				
			}
			return attributes;
		};
		
		
		if (series.color){
			series.getLegendColor= function(index) {
				if(series.color instanceof Array){
					return series.color[index];
				} else{
					return series.color;
				}
	        };
		}
		
		
		if(!series.style){
			series.style = {
					opacity : 1
			};
		}
		
		
		if(options.field instanceof Array){
			var fields = new Array();
			for(var i=0; i<options.field.length; i++){
				fields.push("value"+options.field[i]);
			}
		}else{
			fields= "value"+options.field;
		}
		
		if(series.rotated && series.type!="bar"){
			series.xField = "value1";
			series.yField = "key";
		}else{
			series.xField = "key";
			series.yField = fields;
		}
		
		series.field = fields;
		
		if(series.label){
			series.label.field = series.field;
			series.label.orientation = 'horizontal';
	//		series.label.color = '#FFFFFF';
		}
		
		return series;
	}

});


Ext.define('ChartStore', {
	extend : 'Ext.data.Model',
	fields : [ {
		name : 'key',
		type : 'string'
	}, {
		name : 'value1',
		type : 'double'
	}, {
		name : 'value2',
		type : 'double'
	}, {
		name : 'value3',
		type : 'double'
	}, {
		name : 'value4',
		type : 'double'
	} ]
});

Ext.define('ChartTimeStore', {
	extend : 'Ext.data.Model',
	// name: Ext.Date.add(date, Ext.Date.DAY, i+1),
	fields : [ {
		name : 'key',
		type : 'date'
	}, {
		name : 'value1',
		type : 'double'
	}, {
		name : 'value2',
		type : 'double'
	}, {
		name : 'value3',
		type : 'double'
	}, {
		name : 'value4',
		type : 'double'
	} ]
});

// @tag chart-library
Ext.define('NV.chart.library.extchart.BaseMeterChart',{
	extend: 'NV.chart.library.Chart',
	require:['NV.ext.ux.chart.series.KPIGauge'],
	
	
	initChart : function(){
		var me = this;
		var max = 0;
		for(var i=0; i<this.config.ranges.length; i++){
			if(this.config.ranges[i].to>max){
				max = this.config.ranges[i].to;
			}
		}
		
		me.axisConfig={minimum:0, maximum:max};
		me.axisConfig.type = "gauge";
		me.axisConfig.field = "value"+me.valueField;
		me.axisConfig.position = "gauge";
		me.axisConfig.title = "";
		me.axisConfig.margin = 10;
		
		if(this.labelConfig){
			var labelConf = {};
			if(this.labelConfig.font){
				labelConf.font = this.labelConfig.font;
			}
			if(this.labelConfig.unit){
				window["basemeterchartunit"] = this.labelConfig.unit;
				labelConf.scope = this.labelConfig.unit;
				labelConf.renderer = function(value, label, storeItem, item, i, display, animate, index) {
			         
					value = value + basemeterchartunit;
			        return value;
			      };
			}
			
			me.axisConfig.label = labelConf;
		}
		var axis = new Array();
		axis.push(me.axisConfig);
		
		var itemmouseDownListener = {};
		if(this.actions){
			itemmouseDownListener = {
        	        itemclick : function(obj, obj2, obj3, obj4) {
        	           	
        	        	if(this.portletContentObject){
 							this.portletContentObject.model.beginEdit();
 						}
 						
 						for(var a=0; a<this.action.length; a++){
 							var action = Ext.create('NV.dashboard.actionhandler.ActionHandler',{
								portletContentObject: this.portletContentObject,
								action: this.action[a],
								doubleClose: true,
								context: "this.scope.storeItem[this.scope.globalFieldMap",
								scope: {
									storeItem : obj.storeItem.data,
									globalFieldMap : this.globalFieldMap
								}
							});
							action.doAction();
 						}
 						if(this.portletContentObject){
 							this.portletContentObject.model.endEdit();
 						}
        	        	
        	        	
        	        },
        	        scope:{
    					action : this.actions.plot,
    					globalFieldMap : this.globalFieldMap,
    					portletContentObject: this.portletContentObject
}
                };
		}
		
		this.chart = Ext.create('Ext.chart.Chart', {
			title:"KPI",
			gradients:me.config.gradients,
			insetPadding: 40,
            flex: 1,
			id : 'chartGauge'+this.index,
			xtype : 'chart',
			store : [],
			axes: axis,
			series: [{
                type: 'kpigauge',
                field: this.globalFieldMap.value,
                listeners : itemmouseDownListener,
                needle: {
                    width: 2,
                    pivotFill: '#222',
                    pivotRadius: 5
                   },
                renderer: function(value){
                	if(window.basemeterchartunit){
                		return value+basemeterchartunit;
                	}else{
                		return value;
                	}
                	
                },
                donut: 50,
                ranges: me.config.ranges
            }]
			
		});
		
		this.titleHTML = me.config.title?me.config.title:"_";
		var items = [ 
			            me.chart
			    ];
		if(this.legendConfig){
			this.chartTitle = {
				    xtype: 'label',
				    forId: 'myFieldId',
				    html: "<center><b>" + me.titleHTML + "</b></center>",
				    margins: '0 0 0 0',
				    align: 'center',
				    flex:0, 
				    height:'50'
				};
			items = [ 
			          me.chartTitle,
			          me.chart
			        ];
		}
		
		
		this.chartPanel = Ext.create('Ext.Panel', {
		
			header:false,
	//	    title: "meter",
		    flex:1,
		    minwidth:200,
		    minHeight:150,
		    border:false,
		    layout: {
		        type: 'vbox',
		        align: 'stretch'
		    },
		    items: items
		});
		this.chartContent = this.chartPanel;
	},
	
	constructor : function(config) {
		this.index = index;

		this.globalFieldMap = [];
		if(!config.fields){
			 this.globalFieldMap["value"] = "value1";
			 this.globalFieldMap["link"] = "value2";
	//		 this.globalFieldMap["tooltip"] = "value2";
		     this.globalFieldMap["key"] = "key";
		}else{
			this.globalFieldMap["key"] = "key";
			for(var i in config.fields){
				this.globalFieldMap[i] = "value"+config.fields[i];
			}
		}
		
		this.callParent([config]);
		return this;
	},
	
	refreshChartStore: function(){
    	this.chart.bindStore(this.store);
    	this.titleHTML = this.store.data.items[0].raw[this.globalFieldMap.key];
    	if(this.legendConfig){
    		try{
        		this.chartPanel.items.items[0].el.dom.innerHTML = "<center><b>" + this.titleHTML + "</b></center>";
        	}catch(e){
        		this.chartPanel.items.items[0].html = "<center><b>" + this.titleHTML + "</b></center>";
        	}
    	}
    	
    	
    },
	
    createStoreFromJson: function(json){
    	var me = this;
		    	
    	store = Ext.create(
				'Ext.data.Store',
				{
					model : 'ChartStore',
					data : me.createStore(json)
				});
	   this.store = store; 
    }

});
Ext.define('ChartStore', {
	extend : 'Ext.data.Model',
	fields : [ {
		name : 'key',
		type : 'string'
	}, {
		name : 'value1',
		type : 'double'
	}, {
		name : 'value2',
		type : 'double'
	}, {
		name : 'value3',
		type : 'double'
	}, {
		name : 'value4',
		type : 'double'
	} ]
});

// @tag chart-library
Ext.define('NV.chart.library.extchart.BasePieChart', {
	extend: 'NV.chart.library.Chart',
	field :"value1",
	initChart : function(){
		var me = this;
		this.chart = Ext.create('Ext.chart.Chart', {
			width: "200px",
			height: "200px",
			id : 'chartPie'+this.index,
			xtype : 'chart',
			legend: this.config.legend,
			animate : true,
			shadow : true,
			store : [],
			gradients: this.config.gradients,
			background : {
				gradient : config.chartBG
			},
			series:[{
				type : 'pie',
				showInLegend: true,
				colorSet: this.config.colors,
		        tips: {
		        	trackMouse : true,
					//	width : 50,
					//	height : 28,
						border: 2,
						style: {
						    borderColor: 'white',
						    borderStyle: 'solid',
						    backgroundColor:'#FFD1A8',
						    borderRadius: '10px'
						},
		            renderer: function(storeItem, item) {
		               
		                var total = 0;
		                me.store.each(function(rec) {
		                    total += parseInt(rec.get(me.field));
		                });
		                var aktField = storeItem.get(me.field);
		                if(!isNaN(Number(aktField))){
		                	aktField = Math.round(Number(aktField)*10000)/10000;
		                }
		                var title = storeItem.get('key') + ':'+aktField+ "(" + Math.round(parseInt(storeItem.get(me.field)) / total * 100) + '%)';
		                	 title = storeItem.get('key') + ':<br>'+aktField+ "(" + Math.round(storeItem.get(me.field) / total * 100) + '%)';
		                	 this.setWidth((aktField+ "(" + Math.round(storeItem.get(me.field) / total * 100) + '%)').length*8);
		                	 this.setHeight(40);

		                this.setTitle(title);
		            }
		        },
		        highlight: {
		            segment: {
		                margin: 15
		            }
		        },
		        listeners:{
		            itemmousedown : function(obj) {
		            	window.open(obj.storeItem.data['value2'],obj.storeItem.data['key']+" popup",'height=500,width=500');
		            }
		        },
		        label: {
		            field: 'key',
		          //  display: 'rotate',
		            contrast: true,
		            font: '16px Arial'
		        },				
				field: me.field
			}],
		flex:1
		});
		this.chartContent = this.chart;
	},
	constructor : function(config, index) {
		this.index = index;
		this.callParent([config]);
		return this;
	},
	
	refreshChartStore: function(store){
    	if(!store){
    		store = this.store;
    	}
    	this.chart.store = store;
    	
    },
    
    createStoreFromJson: function(json){
    	var me = this;
    	store = Ext.create(
				'Ext.data.Store',
				{
					model : 'ChartPieStore',
					data : me.createStore(json)
				});
	   this.store = store;   
    }

})


Ext.define('ChartPieStore', {
	extend : 'Ext.data.Model',
	// name: Ext.Date.add(date, Ext.Date.DAY, i+1),
	fields : [ {
		name : 'key',
		type : 'string'
	}, {
		name : 'value1',
		type : 'int'
	}, {
		name : 'value2',
		type : 'string'
	} ]
})

// @tag chart-library
Ext.define('NV.ext.ux.chart.axis.KPIGauge', {
    extend: 'Ext.chart.axis.Gauge',
    alias: 'axis.kpigauge',
    drawTitle: function() {
        
    }
});

// @tag chart-library
Ext.define('NV.ext.ux.chart.series.KPIGauge', {
	extend: 'Ext.chart.series.Gauge',
	alias: 'series.kpigauge',
	
	drawSeries: function () {
		var me = this,
            chart = me.chart,
            store = chart.getChartStore(),
            group = me.group,
            animate = me.chart.animate,
            axis = me.chart.axes.get(0),
            minimum = axis && axis.minimum || me.minimum || 0,
            maximum = axis && axis.maximum || me.maximum || 0,
			ranges = me.ranges,
            field = me.angleField || me.field || me.xField,
            surface = chart.surface,
            chartBBox = chart.chartBBox,
            rad = me.rad,
            donut = +me.donut,
            values = {},
            items = [],
            seriesStyle = me.seriesStyle,
            seriesLabelStyle = me.seriesLabelStyle,
            colorArrayStyle = me.colorArrayStyle,
            colorArrayLength = colorArrayStyle && colorArrayStyle.length || 0,
            gutterX = chart.maxGutters[0],
            gutterY = chart.maxGutters[1],
            cos = Math.cos,
            sin = Math.sin,
            rendererAttributes, centerX, centerY, slice, slices, sprite, value,
            item, ln, record, i, j, r, slice, splitAngle, rl, startAngle, endAngle, middleAngle, sliceLength, path,
            p, spriteOptions, bbox, valueAngle;
        
        Ext.apply(seriesStyle, me.style || {});

        me.setBBox();
        bbox = me.bbox;

        //override theme colors
        if (me.colorSet) {
            colorArrayStyle = me.colorSet;
            colorArrayLength = colorArrayStyle.length;
        }
        
        //if not store or store is empty then there's nothing to draw
        if (!store || !store.getCount()) {
            return;
        }
        
        centerX = me.centerX = chartBBox.x + (chartBBox.width / 2);
        centerY = me.centerY = chartBBox.y + chartBBox.height;
        me.radius = Math.min(centerX - chartBBox.x, centerY - chartBBox.y);
        me.slices = slices = [];
        me.items = items = [];
        
        if (!me.value) {
            record = store.getAt(0);
            me.value = record.get(field);
        }
        
        value = me.value;
		valueAngle = -180 * (1 - (value - minimum) / (maximum - minimum));
		
		for (r = 0, rl = ranges.length; r < rl; r++) {
			splitFromAngle = -180 * (1 - (ranges[r].from - minimum) / (maximum - minimum));
			splitToAngle = -180 * (1 - (ranges[r].to - minimum) / (maximum - minimum));
			slices.push ({
				//series: me,
				startAngle: splitFromAngle,
				endAngle: splitToAngle,
				rho: me.radius,
				color: ranges[r].color
			});
		}
		
        //do pie slices after.
        for (i = 0, ln = slices.length; i < ln; i++) {
            slice = slices[i];
            sprite = group.getAt(i);
            //set pie slice properties
            rendererAttributes = Ext.apply({
                segment: {
                    startAngle: slice.startAngle,
                    endAngle: slice.endAngle,
                    margin: 0,
                    rho: slice.rho,
                    startRho: slice.rho * +donut / 100,
                    endRho: slice.rho
                } 
            }, Ext.apply(seriesStyle, colorArrayStyle && { fill: slice.color } || {}));

            item = Ext.apply({},
            rendererAttributes.segment, {
                slice: slice,
                series: me,
                storeItem: record,
                index: i
            });
            items[i] = item;
            // Create a new sprite if needed (no height)
            if (!sprite) {
                spriteOptions = Ext.apply({
                    type: "path",
                    group: group
                }, Ext.apply(seriesStyle, colorArrayStyle && { fill: slice.color } || {}));
                sprite = surface.add(Ext.apply(spriteOptions, rendererAttributes));
            }
            slice.sprite = slice.sprite || [];
            item.sprite = sprite;
            slice.sprite.push(sprite);
            if (animate) {
                rendererAttributes = me.renderer(sprite, record, rendererAttributes, i, store);
                sprite._to = rendererAttributes;
                me.onAnimate(sprite, {
                    to: rendererAttributes
                });
            } else {
                rendererAttributes = me.renderer(sprite, record, Ext.apply(rendererAttributes, {
                    hidden: false
                }), i, store);
                sprite.setAttributes(rendererAttributes, true);
            }
        }
        
		valueAngle = valueAngle * Math.PI / 180;
		
		if (!me.needleSprite) {
			me.needlePivotSprite = me.chart.surface.add({
				type: 'circle',
				fill: me.needle.pivotFill || '#222',
				radius: me.needle.pivotRadius || 7,
				x: centerX,
				y: centerY
			});
			me.needleSprite = me.chart.surface.add({
				type: 'path',
				path: [
					'M', centerX + (me.radius * 0 / 100) * cos(valueAngle),
						centerY + -Math.abs((me.radius * 0 / 100) * sin(valueAngle)),
					'L', centerX + me.radius * cos(valueAngle),
						centerY + -Math.abs(me.radius * sin(valueAngle))
				],
				'stroke-width': me.needle.width || 2,
				'stroke': '#222'
			});
			me.valueSprite = me.chart.surface.add({
				type: 'text',
				text: value,
				font: '18px Arial',
				x: centerX-10,
				y: centerY + 15
			});
		} else {
			if (animate) {
				me.onAnimate(me.needleSprite, {
					to: {
					path: ['M', centerX + (me.radius * 0 / 100) * cos(valueAngle),
								centerY + -Math.abs((me.radius * 0 / 100) * sin(valueAngle)),
						   'L', centerX + me.radius * cos(valueAngle),
								centerY + -Math.abs(me.radius * sin(valueAngle))]
					}
				});
			} else {
				me.needlePivotSprite.setAttributes({
					type: 'circle',
					fill: me.needle.pivotFill || '#222',
					radius: me.needle.pivotRadius || 7,
					x: centerX,
					y: centerY
				});
				me.needleSprite.setAttributes({
					type: 'path',
					path: ['M', centerX + (me.radius * 0 / 100) * cos(valueAngle),
								centerY + -Math.abs((me.radius * 0 / 100) * sin(valueAngle)),
						   'L', centerX + me.radius * cos(valueAngle),
								centerY + -Math.abs(me.radius * sin(valueAngle))]
				});
				me.valueSprite.setAttributes({
					type: 'text',
					text: value,
					x: centerX-10,
					y: centerY + 15
				});
			}
		}
		me.needlePivotSprite.setAttributes({
			hidden: false
		}, true);
		me.needleSprite.setAttributes({
			hidden: false    
		}, true);
		me.valueSprite.setAttributes({
			hidden: false
		}, true);
        
        delete me.value;
	}
});

// @tag chart-library
Ext.define('NV.chart.library.otherchart.StatusChart', {
	extend : 'NV.chart.library.Chart',

	config:{
		config :undefined,
		imageSize : 100,
		padding : 15,
		field:undefined,
		type:undefined
	},
	
	constructor : function(config, index) {
		this.index = index;

		this.globalFieldMap = {};
		if (!config.field) {
			this.globalFieldMap["value"] = "value1";
			this.globalFieldMap["tooltip"] = "value2";
			this.globalFieldMap["key"] = "key";
		} else {
			this.globalFieldMap["key"] = "key";
			for ( var i in config.field) {
				this.globalFieldMap[i] = "value" + config.field[i];
			}
		}

		this.iconType = config.config.type;
		if (config.config.padding)
			this.padding = config.config.padding;

		this.callParent([ config ]);
		return this;
	},

	initChart : function() {
		this.chartContentInner = Ext.create('Ext.panel.Panel', {
			header : false,
			border : false,
			title : "chartContentInner",
			bodyBorder : false,
			layout : {
				type : 'table',
				columns : this.config.columns
			},
			flex : 1
		});

		this.chartContentPanel.removeAll();
		this.chartContentPanel.layout = {
				type:"vbox",
				align:"center"
		};
		this.chartContentPanel.add(this.chartContentInner);
		
		if (this.iconType == undefined || this.iconType == null) {
			this.iconType = 'default';
		}
		if (this.config.imageSize) {
			this.imageSize = this.config.imageSize;
		}
		if(!this.label){
			this.label = {
					position:"top"
			};
		}
		
		this.label = Ext.create('NV.chart.library.utils.Label',this.label);
		
	},

	drawChart: function(){
		this.refreshChartStore;
	},
	
	refreshChartStore : function() {
		var store = this.store;

		var maxLabelWidth = [];	//egy tömb, ami tartalmazza minden oszlopra hogy hány pixel a maximuma

		if ( !this.label.fontSize) {
			this.label.fontSize=10;
		}
		for ( var i = 0; i < store.length; i++) {
			if(maxLabelWidth[i % this.config.columns]==undefined){
				maxLabelWidth[i % this.config.columns] = (this.label.fontSize * store[i][this.globalFieldMap.key].length) * 0.5;
			}else if ((this.label.fontSize * store[i][this.globalFieldMap.key].length) * 0.5 > maxLabelWidth[i % this.config.columns]) {
				maxLabelWidth[i % this.config.columns] = (this.label.fontSize * store[i][this.globalFieldMap.key].length) * 0.5;
			}
		}

		this.chartContentInner.removeAll();

		var fullWidth = 0;
		
		for(var i=0; i<maxLabelWidth.length; i++){
			if (this.label.position == "left" || this.label.position == "right") {
				 maxLabelWidth[i] = maxLabelWidth[i] + this.imageSize + this.padding;
			} else {
				 maxLabelWidth[i] = (maxLabelWidth[i] > this.imageSize) ? maxLabelWidth[i] : this.imageSize;
				 maxLabelWidth[i] += this.padding;
			}
			fullWidth += maxLabelWidth[i];
		}
		
		this.chartContentInner.setWidth(fullWidth);
		
		for ( var i = 0; i < store.length; i++) {
			var elemWidth = maxLabelWidth[i%this.config.config.columns];

			var labelFlex = 1;
			
			
			var path = "";
			if (this.portletContentObject) {
				path = this.portletContentObject.portlet.dashboard.model.get('urls').imageFolderUrl;
			} else {
				path = NV.chart.library.ChartDrawer.serverUrls.imageFolderUrl;
			}

			var src = path + "status/" + this.iconType + "/null.png";
			if (store[i][this.globalFieldMap.value] != null) {
				src = path + "status/" + this.iconType + "/" + store[i][this.globalFieldMap.value] + ".png";
			}

			if (this.globalFieldMap.icon != undefined && store[i][this.globalFieldMap.icon] != undefined) {
				src = path + "status/" + store[i][this.globalFieldMap.icon] + "/null.png";
				if (store[i][this.globalFieldMap.value] != null) {
					src = path + "status/" + store[i][this.globalFieldMap.icon] + "/" + store[i][this.globalFieldMap.value] + ".png";
				}
			}
			
			var plusPadding = 0;
			if(this.label.fontSize){
				plusPadding = (parseInt(this.label.fontSize / 10)-1)*20;
			}
			
			var image = {};
			if ((this.globalFieldMap.icon != undefined && store[i][this.globalFieldMap.icon] == "text") || ((this.globalFieldMap.icon == undefined || store[i][this.globalFieldMap.icon]==undefined) && this.iconType=='text' )) {
				image = Ext.create('Ext.container.Container', {
					html : store[i][this.globalFieldMap.value],
					cls : store[i][this.globalFieldMap.css],
					width : this.imageSize,
					height : this.imageSize,
					margin : ((this.padding+plusPadding) / 2)
				});
			} else {
				image = Ext.create('Ext.Img', {
					src : src,
					width : this.imageSize,
					height : this.imageSize,
					margin : ((this.padding+plusPadding) / 2)
				});
			}

			if (this.actions) {
				image.addListener("mousedown", function(evt, b, c, d) {

					for ( var a = 0; a < this.action.length; a++) {
						if (((!this.action[a].eventType || this.action[a].eventType == 'click') && evt.button == 0) || (this.action[a].eventType == 'rightclick' && evt.button == 2)) {
							var action = Ext.create('NV.dashboard.actionhandler.ActionHandler', {
								portletContentObject : this.portletContentObject,
								action : this.action[a],
								doubleClose : true,
								context : "this.scope.row[this.scope.globalFieldMap",
								scope : {
									row : this.row,
									globalFieldMap : this.globalFieldMap
								},
								event : evt
							});
							action.doAction();
						}
					}

				}, {
					action : this.actions.plot,
					globalFieldMap : this.globalFieldMap,
					portletContentObject : this.portletContentObject,
					row : this.store[i]
				}, {
					element : 'el'
				});

				image.addListener("dblclick", function(a, b, c, d) {

					for ( var a = 0; a < this.action.length; a++) {
						if (this.action[a].eventType == 'dblclick') {
							var action = Ext.create('NV.dashboard.actionhandler.ActionHandler', {
								portletContentObject : this.portletContentObject,
								action : this.action[a],
								doubleClose : true,
								context : "this.scope.row[this.scope.globalFieldMap",
								scope : {
									row : this.row,
									globalFieldMap : this.globalFieldMap
								}
							});
							action.doAction();
						}
					}

				}, {
					action : this.actions.plot,
					globalFieldMap : this.globalFieldMap,
					portletContentObject : this.portletContentObject,
					row : this.store[i]
				}, {
					element : 'el'
				});

			}

			if (this.label) {
				if (this.label.position == "top" || this.label.position == "bottom") {
					this.label.textAlign = "center";
				} else {
					this.label.textAlign = "left";
				}

				var label = Ext.create('Ext.form.Label', {
					text : store[i][this.globalFieldMap.key],
					height : 20,
					flex : labelFlex,
					style :{
						fontSize : this.label.fontSize+"px",
						textAlign : this.label.textAlign,
						color: this.label.color
					}
				});
			}
			var panelConfig = {};
			var items = [];
			if (this.label.position == "left") {
				panelConfig = {
					width : elemWidth,
					layout : {
						type : 'hbox',
						align : 'middle'
					}
				};
				items = [ label, image ];

			}
			if (this.label.position == "right") {
				panelConfig = {
					width : elemWidth,
					layout : {
						type : 'hbox',
						align : 'middle'
					}
				};

				items = [ image, label ];

			}
			if (this.label.position == "top") {

				panelConfig = {
					width : elemWidth,
					layout : {
						type : 'vbox',
						align : 'center'
					}
				};
				items = [ label, image ];

			}

			if (this.label.position == "bottom") {

				panelConfig = {
					width : elemWidth,
					layout : {
						type : 'vbox',
						align : 'center'
					}
				};
				items = [ image, label ];
			}

			if (!this.label) {
				items = [ image ];
			}

			var panel = Ext.create('Ext.panel.Panel', {
				title : store[i][this.globalFieldMap.tooltip],
				header : false,
				bodyBorder : false,
				border : false,
				width : panelConfig.width,
				layout : panelConfig.layout,
				bodyStyle : {
					background : 'none'
				},
				items : items,
				listeners : {
					render : function(a, b, c) {
						Ext.create('Ext.tip.ToolTip', {
							target : a.body.dom,
							html : a.title
						});

					}
				}
			});
			try {
				this.chartContentInner.add(panel);
			} catch (e) {

			}
		}
	},

	createStoreFromJson : function(json) {
		this.store = this.createStore(json);
	}
});

// @tag chart-library
Ext.require('NV.ext.ux.layout.Center') ;
Ext.define('NV.chart.library.otherchart.StatusChartDynamicSize',{
	extend: 'NV.chart.library.Chart',
	
	config:undefined,
	imageSize :100,
	nameField: undefined,
	linkField: undefined,
	valueField: undefined,
	padding: 20,
	
	constructor : function(config, index) {
		this.index = index;
		this.nameField = config.config.nameField;
		this.valueField = config.config.valueField;
		this.linkField = config.config.linkField;
		this.toolTipField = config.config.toolTipField;
		this.iconType = config.config.type;
		
		
		this.callParent([config]);
		return this;
	},
	
	initChart : function (){

		
		var me = this;

		var bodyCls = this.config.header?"blueGradientPanel":"";
		
		this.columns = [];
		for(var i =0; i<this.config.config.columns; i++){
			this.columns[i] = Ext.create('Ext.panel.Panel', {
				header:false,
				bodyBorder: false,
			    border: false,
				flex: 1,
				layout: {
			        type: 'vbox',
			        align: 'stretch'
			    }
			});
		}
		
		this.chartContent = Ext.create('Ext.panel.Panel', {
			header:false,
		   border:false,
		    bodyBorder:false,
		    width: 100,
		    height: 100,
		    layout: {
		        type: 'hbox',
		        align: 'stretch'
		    },
		    flex: 1, 
		    items: me.columns,
		    bodyCls: bodyCls
		});
		
		this.chartContentInner = this.chartContent;
		
		if(this.iconType == undefined || this.iconType == null){
			this.iconType='default';
		}
		if(this.config.config.imageSize){
			this.imageSize = this.config.config.imageSize;
		}
		
		this.legendConfig.style = {
				fontSize: 14
		};
		if(this.config.legendConfig.labelFont){
			me.legendConfig.style.font = this.config.legendConfig.labelFont;
			me.legendConfig.style.fontSize = this.config.legendConfig.labelFont.substring(0, this.config.legendConfig.labelFont.search("px"));
		};
		me.legendConfig.style.color = this.config.legendConfig.labelColor;

	},
	
	 refreshChartStore: function(){
		 
		var me = this;		
	    var store = this.store;

	    var maxLabelWidth = 0; 
	    	elemWidth = 0;
	    	
	    
	    	if(me.legendConfig && me.legendConfig.style!=null && me.legendConfig.style.fontSize!=null){
			
	    		for(var i=0; i<store.length; i++){
					if((me.legendConfig.style.fontSize * store[i]["value"+this.config.config.nameField].length)*0.7>maxLabelWidth){
						
						maxLabelWidth = (me.legendConfig.style.fontSize * store[i]["value"+this.config.config.nameField].length)*0.7;
					}
				}
			}

		if(this.legendConfig.position=="left" || this.legendConfig.position=="right"){

			elemWidth = maxLabelWidth + me.imageSize + me.padding;
		}else{
			elemWidth = (maxLabelWidth>me.imageSize)?maxLabelWidth:me.imageSize;
			elemWidth += me.padding;
		}
	    
	
	//	this.chartContentInner.removeAll();
	//	this.chartContentInner.setWidth(elemWidth * this.config.config.columns);
		
		for(var i=0; i<store.length; i++){
			var src = NV.chart.library.ChartDrawer.serverUrls['imageFolderUrl']+"status/"+this.iconType+"/null.png";
			if(store[i]["value"+this.valueField]!=null){
				 src =NV.chart.library.ChartDrawer.serverUrls['imageFolderUrl']+"status/"+this.iconType+"/"+store[i]["value"+this.valueField]+".png";
			}

			var image = Ext.create('Ext.Img', {
			    src: src,
			    width: me.imageSize,
			    height: me.imageSize,
			    margin: me.padding/2,
			    link: store[i]["value"+me.linkField],
			    title: store[i]["value"+me.toolTipField]
			   
			});			

			image.addListener("click", function(a,b,c,d){ 
            	if(c.scope.link){
            		window.open(c.scope.link);
            	}
            }, image, {element: 'el'});
			
			
			if(me.legendConfig){
				var label = Ext.create('Ext.form.Label',{
					text: store[i]["value"+this.nameField],
					height:20,
					flex:1,
					style:me.legendConfig.style,
					width:maxLabelWidth
					
				});
			}
			var panelConfig = {};
			var items = [];
			if(this.legendConfig.position=="left"){
				panelConfig = {
						width: elemWidth ,
					    layout:{
					    	 type: 'hbox',
					         align: 'middle'
					    }
				};
				items = [label, image];
				
			}
			if(this.legendConfig.position=="right"){
				panelConfig = {
						 width: elemWidth,
						    layout:{
						    	 type: 'hbox',
						         align: 'middle'
						    }
				};

				items= [image, label];
				    
			}
			if(this.legendConfig.position=="top"){
				label.style.textAlign="center";
				
				panelConfig = {
						width: elemWidth,
						layout:{
					    	 type: 'vbox',
					         align: 'center'
					    }
				};
				items = [label, image];
				
				
			}
			if(this.legendConfig.position=="bottom"){
				label.style.textAlign="center";
				
				panelConfig = {
						width: elemWidth,
						layout:{
					    	 type: 'vbox',
					         align: 'center'
					    }
				};
				items = [image,label];
			}

			if(!me.legendConfig){
				items= [image];
			}
			
			var panel = Ext.create('Ext.panel.Panel', {
			    title: store[i]["value"+me.toolTipField],
			    header: false,
			    bodyBorder: false,
			    border: false,
			    width: panelConfig.width,
			    layout: panelConfig.layout,
			    bodyStyle:{
			    	background:'none'
			    },
			    items: items,
			    listeners:{
			    	render: function(a,b,c){
			    		Ext.create('Ext.tip.ToolTip', {
						    target: a.body.dom,
						    html: a.title
						});
						
			    	}
			    }, 
			    flex:1
			});
			this.columns[i%me.config.config.columns].add(panel);
		}

		if(this.columns[2].items.items.length<this.columns[0].items.items.length){
			this.columns[2].add(Ext.create('Ext.panel.Panel', {
				header:false,
				bodyBorder: false,
			    border: false,
				flex: 1
			}));
			if(this.columns[1].items.items.length<this.columns[0].items.items.length){
				this.columns[1].add(Ext.create('Ext.panel.Panel',{
					header:false,
					bodyBorder: false,
				    border: false,
					flex: 1
				}));
			}
		}
		
	 },
	    
    createStoreFromJson: function(json){
		this.store = this.createStore(json);
    }
});
	



// @tag chart-library
/**
 * Axis config object. Used by XY (combo) charts
 **/

Ext.define('NV.chart.library.utils.Axis',{
	config:{
		id:undefined,
		title:undefined,
		position:undefined,
		grid:undefined,
		gridPosition:undefined,
		minimum:undefined,
		maximum:undefined,
		type:undefined,
		label:undefined,
		id:undefined,
		offset:undefined,
		line:undefined,
		format:undefined,
		autoGridCount:true,
		
		chart:undefined
	},

	constructor: function(config){
		this.initConfig(config);
		if(!this.id){
			this.id=this.position;
		}
		if(this.line){
			this.line = Ext.create('NV.chart.library.utils.Line', this.line);
		}
		if(this.label){
			this.label = Ext.create('NV.chart.library.utils.Label', this.label);
		}
		this.validate();
	
	},
	
	validate: function(){
		if(this.position==undefined && this.id==undefined){
			Ext.Msg.alert("Configuration error", "Position or Id required!");
			return false;
		}

/*		if(!(this.minimum==undefined && this.maximum==undefined) && (this.minimum==undefined || this.maximum==undefined)){
			Ext.Msg.alert("Configuration error", "Minimum and Maximum required together!");
			return false;
		}
*/		
		//TODO: IE-ben nem megy
		
		if(!Ext.Array.contains(['top','left','bottom','right'],this.position)){
			Ext.Msg.alert("Configuration error", "Axis Position incorrect (" + this.position + ")\n correct positions are: top, bottom, left, right");
			return false;
		}		
		
		if(this.label && this.label.fontSize && parseInt(this.label.fontSize)!=this.label.fontSize){
			Ext.Msg.alert("Configuration error", "Axis label fontsize incorrect, the size must be an integer");
			return false;
		}
		
		return true;
	},

	createAmchartObject: function(){
		var axis = {id:this.id};
		if (this.type == 'Category' || this.type == 'Time') {
			axis.type='category';
			if (this.type == 'Time') {//time
				axis.dateFormats = [ {
					period : 'fff',
					format : 'JJ:NN:SS'
				}, {
					period : 'ss',
					format : 'JJ:NN:SS'
				}, {
					period : 'mm',
					format : 'JJ:NN'
				}, {
					period : 'hh',
					format : 'JJ:NN'
				}, {
					period : 'DD',
					format : 'MMM DD'
				}, {
					period : 'MM',
					format : 'MMM DD'
				}, {
					period : 'YYYY',
					format : 'YYYY'
				} ];
				axis.parseDates = true;
				axis.equalSpacing = false;
	//			axis.minPeriod = this.defaultPeriod;
				axis.boldPeriodBeginning = true;
				axis.startOnAxis = true;
				axis.autoGridCount = this.autoGridCount;
				axis.gridPosition = "middle";
			}else{//category
				axis.boldPeriodBeginning = true;
				axis.startOnAxis = false;
				axis.autoWrap = true;
			}
			
		} else {
			axis.type = 'value';
			axis.labelsEnabled = true;
			if (this.minimum != undefined) {
				axis.minimum = this.minimum;
			}
			if (this.maximum != undefined) {
				axis.maximum = this.maximum;
			}
						
			if (this.chart.isStacked) {
				if (this.chart.isStacked == true) {
					axis.stackType = "regular";
				} else{
					axis.stackType = this.isStacked;
				}
			}
		}
		
		if(this.line){
			if(this.line.color){
				axis.axisColor = this.line.color;
			}
			if(this.line.visible==false){
				axis.axisAlpha = 0;
			}
			if(this.line.width){
				axis.axisThickness = this.line.width;
			}
			if(this.line.style=="dashed"){
				axis.dashLength = 3;
			}
			if(this.line.style=="dotted"){
				axis.dashLength = 1;
			}
		}
		
		if (this.label) {
			if(this.label.rotation != undefined){
				axis.labelRotation = Math.abs(this.label.rotation);
			}
			if(this.label.visible != undefined){
				axis.labelsEnabled = this.label.visible;
			}
			if(this.label.color){
				axis.color = this.label.color;
			}
			if(this.label.fontSize){
				axis.fontSize = this.label.fontSize;
			}
			
		}
		
		if (this.grid != undefined && this.grid == false) {
			axis.gridAlpha = 0;
		}
		if (this.gridPosition != undefined) {
			axis.gridPosition = this.gridPosition;
		}

		if (this.label) {
			// pl: ##.## %
			if (this.label.precision) {// tizedesjegyek vannak
				axis.precision = this.label.precision;
			}
			if (this.label.unit) {
				axis.unit = this.label.unit;
			}
		}
		
		axis.gridCount = 50;
		axis.labelFrequency = 1;
		
		
		axis.title = this.title;
		axis.position = this.position;
		
		if(this.offset){
			axis.offset = this.offset;
		}
		
		/*if(this.id){
			this.chart.valueAxisArray[this.id] = axis;
		}else{
			this.chart.valueAxisArray[this.position] = axis;
		}*/
		
		this.amchartObject = axis;
		return axis;
	}
	
});

// @tag chart-library
/**
 * Series config object, used by XY (combo) charts
 */

Ext.define('NV.chart.library.utils.Series',{
	config:{
		id: undefined,
		title: undefined,
		field: undefined,			
		axis: undefined,				//reference to the axis object
		stacked: undefined,
		visible: true,
		type: undefined,				//column, line, area, stat, step
		color: undefined,
		label: undefined,
		showKeyOnBalloon: false,
		showTitleOnBalloon: false,
		marker: undefined,				//marker object
		line: undefined,				//line object
		gutter:undefined,
		seriesId:undefined,
		chart:undefined
	},

	constructor: function(config){
		this.initConfig(config);
		if(this.line){
			this.line = Ext.create('NV.chart.library.utils.Line',config.line);
		}
		if(this.marker){
			this.marker = Ext.create('NV.chart.library.utils.Marker',config.marker);
		}
		if(this.label){
			this.label = Ext.create('NV.chart.library.utils.Label',config.label);
		}

		if(!this.axis){
			this.axis = "left";
		}
		
		if(this.stacked) {
			this.chart.isStacked = true;
		}
		
		this.validate();
//		this.createAmchartObject();
	},
	
	validate: function(){
		if (this.type != "stat") {// statisztika chartnál nem kell value
			if (this.field.value == null || this.field.value == undefined) {
				Ext.Msg.alert('Config error', 'missing field "value" on ' + this.seriesId + " series");
				return false;
			}
		}
		
		if(!this.chart.findAxis(this.axis)){
			Ext.Msg.show({
			    title: 'Series config error',
			    msg: "Axis not found!",
			    width: 300,
			    buttons: Ext.Msg.OK,
			    icon: Ext.Msg.ERROR
			});
			return false;
		}
		return true;
	},
	
	createAmchartObject: function(){

		var graph = {};
		
		/*
		 * Marker settings
		 */
		
		if(this.marker){
			if(this.marker.type!="none"){
				graph.markerType = this.marker.type;
			}
			graph.bullet = this.marker.type;
			graph.bulletSize = this.marker.size;
		}
		
		/*
		 * Marker settings end
		 */
		
		/*
		 * Balloon settings begin
		 */
		graph.balloonText = "<b>[[value]]</b>";
		
		if(this.showKeyOnBalloon && !this.showTitleOnBalloon){
			graph.balloonText = "[[key]]:<br><b>[[value]]</b>";
		}
		
		if(!this.showKeyOnBalloon && this.showTitleOnBalloon){
			graph.balloonText = "[[title]]:<br><b>[[value]]</b>";
		}
		
		if(this.showKeyOnBalloon && this.showTitleOnBalloon){
			graph.balloonText = "[[title]]-[[key]]::<br><b>[[value]]</b>";
		}
		
		/*
		 * Balloon settings end
		 */
		
		/*
		 * fill the charts global field map (used on actions)
		 */
		for(var key in this.field) {
	        if (this.field.hasOwnProperty(key)) {
	    		this.chart.globalFieldMap[this.seriesId + "."+key] = "value" + this.field[key];	
	        }
	    }
		/*
		 * Global fieldmap end 
		 */
		
		/*
		 * Color settings begin
		 */
		
		if (this.color) {
			if (!this.color.toUpperCase().match("#[0-9A-F]{6}")) {
				graph.lineColor = this.chart.gradientArray[this.color].colors.reverse()[1];
				
				if(Ext.isIE8 || Ext.isIE9){	//Ie not support gradient
					graph.fillColors = this.chart.gradientArray[this.color].colors.reverse()[1];
				}else{
					graph.fillColors = this.chart.gradientArray[this.color].colors.reverse();
					graph.gradientOrientation = this.chart.gradientArray[this.color].orentation;
				}
			} else {
				graph.lineColor = this.color;
				graph.fillColors = this.color;
				graph.legendColor = this.color;
			}
		}
		/*
		 * Color settings end
		 */
		
		/*
		 * Line settings
		 */
		if(this.line){
			if(this.line.width){
				graph.lineThickness = this.line.width==undefined?1:this.line.width;
			}
			if(this.line.color){
				graph.lineColor = this.line.color;
			}
			
			
			if(!this.line.visible){
				graph.lineAlpha = 0;
			}else{
				graph.lineAlpha = 1;
			}
			
			if(this.line.style=='dotted'){
				graph.dashLength = 1;
			}else if(this.line.style=='dashed'){
				graph.dashLength = 3;
			}
			
		}
		
		/*
		 * Line settings end
		 */
		
		/*
		 * Value label settings
		 */
		
		if(this.label){
			if(this.label.visible){
				graph.labelText = "[[value]]";
			}
			if(this.label.position){
				if (this.label.position.toLowerCase() == "above") {
					graph.labelPosition = "top";
				} else if (this.label.position.toLowerCase() == "below") {
					graph.labelPosition = "bottom";
				} else if (this.label.position.toLowerCase() == "outside") {
					graph.labelPosition = "middle";
				} else {
					graph.labelPosition = this.label.position;
				}
			}
			if(this.label.color){
				graph.color = this.label.color;
			}
			if(this.label.fontSize){
				graph.fontSize = this.label.fontSize;
			}
			if(this.label.format){
				if (this.label.format.substring(this.label.format.lastIndexOf("#") + 1).length > 0) {
					graph.balloonText += "<b>"+this.label.format.substring(this.label.format.lastIndexOf("#") + 1)+"</b>";
					if(this.label.visible){
						graph.labelText = "[[value]]"+this.label.format.substring(this.label.format.lastIndexOf("#") + 1);						
					}
				}
			}
		}
		
		
		/*
		 * End value label settings
		 */
		
		graph.valueAxis = this.axis;
		
		graph.valueField = "value" + this.field.value;
	

		graph.connect = true;
		graph.hidden = !this.visible;
		graph.type = this.type;
		

		
		/*
		 * Type specific settings
		 */
		if (this.type == "column" || this.type == "bar") {
			graph.type = "column";
			graph.fillAlphas = 0.7;
			if (this.gutter != undefined && this.gutter != null) {
				if (this.gutter == 0) {
					graph.columnWidth = 1.05;
				}
				else if(this.gutter.match("%")){
					var intval = parseInt(this.gutter);
					intval/=100;
					graph.columnWidth = 1-intval;
				}else{
					var intval = parseInt(this.gutter);
					intval/=100;
					graph.columnWidth = 1-intval;
				}
				
			}			
			
		} else if (this.type == "line") {			
	//		graph.fillAlphas = 0;
		} else if (this.type == "area" || this.type == "step") {	
	//		graph.fillAlphas = 0.8;
			if(this.type=="area"){
				graph.type = "line";
			}
		} else if (this.type == 'stat') {
			// stat esetén rögtön 2 series-t kell hozzáadni
			graph.type = "candlestick";
			
			graph.fillAlphas = 0.8;
			
			graph.descriptionField = "value" + this.field.description;
			graph.openField = "value" + this.field.open;
			graph.highField = "value" + this.field.high;
		//	graph.valueField = "value" + this.field.avg;
			graph.lowField = "value" + this.field.low;
			graph.closeField = "value" + this.field.close;

			graph.behindColumns = true;
		}
		if(this.stacked) {
			graph.stackable = this.stacked;
		
		}
		if(this.newStack) {
			graph.newStack = true;
			graph.stackable = false;
		}
		

		graph.title = this.title;

		//TODO: ezt a részt átvinni a chart-hoz
/*
		if (this.type == 'stat') {
			var graph = new AmCharts.AmGraph();
			graph.title = "Avg";
			// as candlestick graph looks bad when there are a lot of
			// candlesticks, we set initial type to "line"
			graph.type = "column";
			// graph colors
			graph.lineColor = this.avgColor;
			graph.lineThickness = 2;
			graph.fillAlphas = 1;
			graph.visibleInLegend = false;
			// candlestick graph has 4 fields - open, low, high, close

			// this one is for "line" graph type
			graph.valueField = "value" + this.field.avg;
			graph.openField = "value" + this.field.avg;

			this.chart.addGraph(graph);
			this.technicalseries[this.seriesId] = graph;
			
		}
*/
		this.amchartObject = graph;
		return graph;
	}
	
});

// @tag chart-library
Ext.define('NV.chart.library.utils.DynamicSeries',{
	extend:'NV.chart.library.utils.Series',
	constructor: function(config){
		this.initConfig(config);
		if(this.line){
			this.line = Ext.create('NV.chart.library.utils.Line',config.line);
		}
		if(this.marker){
			this.marker = Ext.create('NV.chart.library.utils.Marker',config.marker);
		}
		if(this.label){
			this.label = Ext.create('NV.chart.library.utils.Label',config.label);
		}

		if(!this.axis){
			this.axis = "left";
		}
	}
});

// @tag chart-library
Ext.define('NV.chart.library.utils.Gradient',{
	config:{
		id : undefined,
		angle: 90,
		stops: undefined
		
	},
	constructor: function(config){
		
		this.initConfig(config);
	}
});

// @tag chart-library
Ext.define('NV.chart.library.utils.Label',{
	config:{		
		visible:true,
		rotation:0,			//not supported on series
		font:undefined,			//not supported on series
		fontSize:undefined,
		bold:false,
		color:undefined,
		format:"",
		position:undefined
		
	},
	
	constructor: function(config){
		this.initConfig(config);
		if (this.format) {
			// pl: ##.## %
			
			if (this.format.substring(this.format.lastIndexOf("#") + 1).length > 0) {
				this.unit = this.format.substring(this.format.lastIndexOf("#") + 1);
				
			}
			if (this.format.match("#.#")) {// tizedesjegyek vannak
				this.precision = this.format.lastIndexOf("#") - this.format.search("[.]");
			}
		}
	},
	
	validate: function(){
		return true;
	}
});

// @tag chart-library
Ext.define('NV.chart.library.utils.Legend',{
	config:{
		position : undefined,
		color : undefined,
		font : undefined,
		fontSize : undefined,
		isVertical : undefined,	//not supported
		background : undefined,
		backgroundAlpha : 0,
		line : undefined,		//partial support 
		margin: undefined		//?supported?
	},
	
	constructor: function(config){
		this.initConfig(config);
		if(this.line){
			this.line = Ext.create('NV.chart.library.utils.Line',this.line);
		}
		if(this.margin){
			this.margin = Ext.create('NV.chart.library.utils.Margin', this.margin);
		}
	}
});

// @tag chart-library
Ext.define('NV.chart.library.utils.Line',{
	config:{
		visible:true,
		style:"solid",			//not supported on legend, on axis -> the grid will be dashed/dotted
		width:1,				//not supported on legend
		color:undefined
	},
	
	constructor: function(config){
		this.initConfig(config);
	}
});

// @tag chart-library
Ext.define('NV.chart.library.utils.Margin',{
	config:{
		left:20,
		right:20,
		top:0,
		bottom:0
	},
	
	constructor: function(config){
		this.initConfig(config);
	}
});

// @tag chart-library
Ext.define('NV.chart.library.utils.Marker',{
	config:{
		size:8,
		type:"none"
	},
	
	constructor: function(config){
		this.initConfig(config);
	},
	
	isValid: function(){
		return true;
	}
	
	
});

// @tag chart-library
Ext.define('NV.chart.library.utils.Range',{
	config:{
		from: undefined,
		to: undefined,
		color: undefined
	},
	
	constructor: function(config){
		this.initConfig(config);
		this.validate();
	},
	
	validate: function(){
		if(this.from==undefined){
			Ext.Msg.alert("Range configuration error", "From field required!");
			return false;
		}
		if(this.to==undefined){
			Ext.Msg.alert("Range configuration error", "To field required!");
			return false;
		}
		if(this.color==undefined){
			Ext.Msg.alert("Range configuration error", "Color field required!");
			return false;
		}
	}
});

Ext.ClassManager.addNameAliasMappings({
  "NV.chart.library.extchart.BasePieChart": [],
  "ChartPieStore": [],
  "NV.ext.ux.chart.series.KPIGauge": [
    "series.kpigauge"
  ],
  "ChartStore": [],
  "NV.chart.library.utils.Legend": [],
  "NV.chart.library.utils.Line": [],
  "NV.chart.library.amchart.AmPieChart": [],
  "NV.chart.library.amchart.AmMeterChart": [],
  "NV.chart.library.amchart.AmBarChart": [],
  "NV.chart.library.otherchart.StatusChart": [],
  "NV.chart.library.otherchart.StatusChartDynamicSize": [],
  "NV.chart.library.extchart.BaseMeterChart": [],
  "NV.chart.library.Chart": [],
  "NV.ext.ux.chart.axis.KPIGauge": [
    "axis.kpigauge"
  ],
  "NV.chart.library.ReportChartDrawer": [],
  "NV.chart.library.amchart.AmComboChart": [],
  "NV.chart.library.utils.Series": [],
  "NV.chart.library.utils.Axis": [],
  "NV.chart.library.utils.Label": [],
  "NV.chart.library.amchart.AmRefreshSeriesChart": [],
  "NV.chart.library.extchart.BaseComboChart": [],
  "ChartTimeStore": [],
  "NV.chart.library.utils.Margin": [],
  "NV.chart.library.utils.DynamicSeries": [],
  "NV.chart.library.utils.Gradient": [],
  "NV.chart.library.utils.Marker": [],
  "NV.chart.library.utils.Range": [],
  "NV.chart.library.ChartDrawer": []
});