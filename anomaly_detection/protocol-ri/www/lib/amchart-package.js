/**
 * @author Beata Pletscher
 * @docauthor Beata Pletscher
 */

/*
 * This file is the Entry Point for the implementation of this ExtJS package.
 * 
 * NOTE: Please DO NOT edit this file unless you know what you are exactly
 * doing.
 */

// BEGIN: Package definition
(function(){
	{
		var pkg =
		{
		  name : 'amchart',
		  namespace : 'AM.chart',
		  path : 'amchart',
		  date : new Date('2014','08','05','15','23','56'), // 2014/08/05 15:23:56
		  version : new Ext.Version('3.4.8.2'),
		  description : 'Amchart Library'
		};
	
		// Register Package
	
		Ext.namespace( 'NV' );
		var packages = NV.$Packages || (NV.$Packages = {});
		packages[pkg.name] = pkg;
	
		Ext.Loader.setPath( pkg.namespace, 'lib/' + pkg.path );
	}
})();
// END: Package definition

// @tag amchart
/**
 * Copyright (c) 2009 Jason S. Kerchner. All rights reserved.
 * Code released under the BSD license:
 * http://livingmachines.net/license
 * Redistribution must include this complete copyright notice.
 */



/**
 * Create a AmCharts namespace for our library.
 * @type object
 */
if (!AmCharts) {
    var AmCharts = {};
    AmCharts.themes = {};
    AmCharts.maps = {};
    AmCharts.inheriting = {};
    AmCharts.charts = [];
    AmCharts.onReadyArray = [];
    AmCharts.useUTC = false;
    AmCharts.updateRate = 40;
    AmCharts.uid = 0;
}

/**
 * Used to indicate that we are in the process of creating a new inherited class.
 * @type object
 */


/**
 * Creates a new constructor function based on the given initialization object.
 * Executing the constructor using the new keyword will create a new class
 * that supports inheritance, property and methods overrides, and the ability
 * to call base class methods.  The following is an example of how to use
 * the Class function.  In this example, we have an already existing class,
 * Person, and we are inheriting a new class from it, Employee.
 *
 * <pre>
 * Employee = Class({
 *
 *   // Inherits from person
 *   inherits: Person,
 *
 *   // This is the constructor
 *   construct: function(first, last, company) {
 *     // Calls base class constructor
 *     Employee.base.construct.call(this, first, last);
 *     this.company = company;
 *   },
 *
 *   // New method added to this class
 *   getWebSite: function() {
 *     return 'http://www.' + this.company + '.com';
 *   },
 *
 *   // Overrides method in Person (and calls base class method)
 *   getFullName: function(firstLastFormat) {
 *     if (firstLastFormat)
 *       return Employee.base.getFullName.call(this);
 *     else
 *       return this.lastName + ', ' + this.firstName;
 *     }
 *
 * });
 * </pre>
 *
 * @param {Object} init The initialization object.
 * @return {Function} Returns the new constructor function (e.g. the class)
 */
AmCharts.Class = function (init) {
    // Create constructor function that will check if we are inheriting,
    // then call real constructor
    var cstr = function () {
        if (arguments[0] === AmCharts.inheriting) return;
        this.events = {};
        this.construct.apply(this, arguments);
    };

    // If we are inheriting, copy the prototype, otherwise assign a new prototype
    if (init.inherits) {
        cstr.prototype = new init.inherits(AmCharts.inheriting);
        cstr.base = init.inherits.prototype;
        delete init.inherits; // Keeps it from being added to the prototype later
    } else {

        // Since we are not inheriting, then we must add event methods,
        // otherwise they will be included via inheritance.
        cstr.prototype.createEvents = function ( /* event */ ) {
            for (var i = 0, len = arguments.length; i < len; i++)
            this.events[arguments[i]] = [];
        };

        cstr.prototype.listenTo = function (obj, event, handler) {

            this.removeListener(obj, event, handler);

            obj.events[event].push({
                handler: handler,
                scope: this
            });
        };

        cstr.prototype.addListener = function (event, handler, obj) {

            this.removeListener(this, event, handler);

            this.events[event].push({
                handler: handler,
                scope: obj
            });
        };

        cstr.prototype.removeListener = function (obj, event, handler) {
            if(obj){
                if(obj.events){
                    var ev = obj.events[event];
                    // Loop down, just in case handler was added multiple times (and will be removed multiple times)
                    for (var i = ev.length - 1; i >= 0; i--) {
                        if (ev[i].handler === handler) ev.splice(i, 1); // Deletes one element starting at index i
                    }
                }
            }
        };

        cstr.prototype.fire = function (event, data) {
            var handlers = this.events[event];
            for (var i = 0, len = handlers.length; i < len; i++) {
                var h = handlers[i];
                h.handler.call(h.scope, data);
            }
        };
    }

    // Copy init properties to the prototype (adds/overrides base class methods)
    for (var p in init)
    cstr.prototype[p] = init[p];

    // Return the constructor function (this is the class)
    return cstr;

};



AmCharts.addChart = function (chart) {
    AmCharts.charts.push(chart);
};

AmCharts.removeChart = function (chart) {
    var charts = AmCharts.charts;
    for (var i = charts.length - 1; i >= 0; i--) {
        if (charts[i] == chart) {
            charts.splice(i, 1);
        }
    }
};


// check ie version
AmCharts.IEversion = 0;
AmCharts.isModern = true;

AmCharts.navigator = navigator.userAgent.toLowerCase();
if (AmCharts.navigator.indexOf("msie") != -1) {
    AmCharts.IEversion = parseInt(AmCharts.navigator.split('msie')[1]);

    if (document.documentMode) {
        AmCharts.IEversion = Number(document.documentMode);
    }
    if (AmCharts.IEversion < 9) {
        AmCharts.isModern = false;
    }
}

AmCharts.dx = 0;
AmCharts.dy = 0;

// check browser
if (document.addEventListener || window.opera) {
    AmCharts.isNN = true;
    AmCharts.isIE = false;
    AmCharts.dx = 0.5;
    AmCharts.dy = 0.5;
}

if (document.attachEvent) {
    AmCharts.isNN = false;
    AmCharts.isIE = true;
    if (!AmCharts.isModern) {
        AmCharts.dx = 0;
        AmCharts.dy = 0;
    }
}



if (window.chrome) {
    AmCharts.chrome = true;
}

// event handlers
AmCharts.handleResize = function () {
    var charts = AmCharts.charts;

    for (var i = 0; i < charts.length; i++) {
        var chart = charts[i];

        if (chart) {
            if (chart.div) {
                chart.handleResize();
            }
        }
    }
};

AmCharts.handleMouseUp = function (e) {
    var charts = AmCharts.charts;

    for (var i = 0; i < charts.length; i++) {
        var chart = charts[i];

        if (chart) {
            chart.handleReleaseOutside(e);
        }
    }
};

AmCharts.handleMouseMove = function (e) {
    var charts = AmCharts.charts;
    for (var i = 0; i < charts.length; i++) {
        var chart = charts[i];

        if (chart) {
            chart.handleMouseMove(e);
        }
    }
};

AmCharts.resetMouseOver = function () {
    var charts = AmCharts.charts;
    for (var i = 0; i < charts.length; i++) {
        var chart = charts[i];

        if (chart) {
            chart.mouseIsOver = false;
        }
    }
};


AmCharts.ready = function (value) {
    AmCharts.onReadyArray.push(value);
};

AmCharts.handleLoad = function () {
    AmCharts.isReady = true;
    var onReadyArray = AmCharts.onReadyArray;
    for (var i = 0; i < onReadyArray.length; i++) {
        var fnc = onReadyArray[i];
        if(isNaN(AmCharts.processDelay)){
            fnc();
        }
        else{
            setTimeout(fnc, AmCharts.processDelay * i);
        }
    }
};


AmCharts.getUniqueId = function () {
    AmCharts.uid++;
    return "AmChartsEl-" + AmCharts.uid;
};

// add events for NN/FF/etc
if (AmCharts.isNN) {
    document.addEventListener('mousemove', AmCharts.handleMouseMove, true);
    window.addEventListener('resize', AmCharts.handleResize, true);
    document.addEventListener("mouseup", AmCharts.handleMouseUp, true);
    window.addEventListener('load', AmCharts.handleLoad, true);
}

if (AmCharts.isIE) {
    document.attachEvent('onmousemove', AmCharts.handleMouseMove);
    window.attachEvent('onresize', AmCharts.handleResize);
    document.attachEvent("onmouseup", AmCharts.handleMouseUp);
    window.attachEvent('onload', AmCharts.handleLoad);
}

AmCharts.clear = function () {

    var charts = AmCharts.charts;
    if (charts) {
        for (var i = 0; i < charts.length; i++) {
            charts[i].clear();
        }
    }

    AmCharts.charts = null;

    if (AmCharts.isNN) {
        document.removeEventListener('mousemove', AmCharts.handleMouseMove, true);
        window.removeEventListener('resize', AmCharts.handleResize, true);
        document.removeEventListener("mouseup", AmCharts.handleMouseUp, true);
        window.removeEventListener('load', AmCharts.handleLoad, true);
    }

    if (AmCharts.isIE) {
        document.detachEvent('onmousemove', AmCharts.handleMouseMove);
        window.detachEvent('onresize', AmCharts.handleResize);
        document.detachEvent("onmouseup", AmCharts.handleMouseUp);
        window.detachEvent('onload', AmCharts.handleLoad);
    }
};


AmCharts.makeChart =  function(div, config, amDelay){
    var type = config.type;
    var theme = config.theme;

    if(AmCharts.isString(theme)){
        theme = AmCharts.themes[theme];
        config.theme = theme;
    }

    var chart;
    switch (type){
        case "serial":
            chart = new AmCharts.AmSerialChart(theme);
            break;
        case "xy":
            chart = new AmCharts.AmXYChart(theme);
            break;
        case "pie":
            chart = new AmCharts.AmPieChart(theme);
            break;
        case "radar":
            chart = new AmCharts.AmRadarChart(theme);
            break;
        case "gauge":
            chart = new AmCharts.AmAngularGauge(theme);
            break;
        case "funnel":
            chart = new AmCharts.AmFunnelChart(theme);
            break;
        case "map":
            chart = new AmCharts.AmMap(theme);
            break;
        case "stock":
            chart = new AmCharts.AmStockChart(theme);
            break;
    }

    AmCharts.extend(chart, config);

    if(AmCharts.isReady){
        if(isNaN(amDelay)){
            chart.write(div);
        }
        else{
            setTimeout(function() {
                AmCharts.realWrite(chart, div);
            }, amDelay);
        }
    }
    else{
        AmCharts.ready(function () {
            if(isNaN(amDelay)){
                chart.write(div);
            }
            else{
                setTimeout(function() {
                    AmCharts.realWrite(chart, div);
                }, amDelay);
            }
        });
    }
    return chart;
};

AmCharts.realWrite = function(chart, div){
    chart.write(div);
};// @tag amchart
AmCharts.formatMilliseconds = function (string, date) {
    if (string.indexOf("fff") != -1) {
        var milliseconds = date.getMilliseconds();
        var mString = String(milliseconds);
        if (milliseconds < 10) {
            mString = "00" + milliseconds;
        }
        if (milliseconds >= 10 && milliseconds < 100) {
            mString = "0" + milliseconds;
        }

        string = string.replace(/fff/g, mString);
    }

    return string;
};

AmCharts.extractPeriod = function (period) {
    var cleanPeriod = AmCharts.stripNumbers(period);
    var count = 1;
    if (cleanPeriod != period) {
        count = Number(period.slice(0, period.indexOf(cleanPeriod)));
    }
    return {
        period: cleanPeriod,
        count: count
    };
};


// RESET DATE'S LOWER PERIODS TO MIN
AmCharts.resetDateToMin = function (date, period, count, firstDateOfWeek) {
    if (firstDateOfWeek === undefined) {
        firstDateOfWeek = 1;
    }

    var year;
    var month;
    var day;
    var hours;
    var minutes;
    var seconds;
    var milliseconds;
    var week_day;

    if (AmCharts.useUTC) {
        year = date.getUTCFullYear();
        month = date.getUTCMonth();
        day = date.getUTCDate();
        hours = date.getUTCHours();
        minutes = date.getUTCMinutes();
        seconds = date.getUTCSeconds();
        milliseconds = date.getUTCMilliseconds();
        week_day = date.getUTCDay();
    } else {
        year = date.getFullYear();
        month = date.getMonth();
        day = date.getDate();
        hours = date.getHours();
        minutes = date.getMinutes();
        seconds = date.getSeconds();
        milliseconds = date.getMilliseconds();
        week_day = date.getDay();
    }

    switch (period) {
        case "YYYY":
            year = Math.floor(year / count) * count;
            month = 0;
            day = 1;
            hours = 0;
            minutes = 0;
            seconds = 0;
            milliseconds = 0;
            break;

        case "MM":
            month = Math.floor(month / count) * count;
            day = 1;
            hours = 0;
            minutes = 0;
            seconds = 0;
            milliseconds = 0;
            break;

        case "WW":
            if (week_day === 0 && firstDateOfWeek > 0) {
                week_day = 7;
            }
            day = day - week_day + firstDateOfWeek;
            hours = 0;
            minutes = 0;
            seconds = 0;
            milliseconds = 0;
            break;

        case "DD":
            //day = Math.floor(day / count) * count;
            day = day;
            hours = 0;
            minutes = 0;
            seconds = 0;
            milliseconds = 0;
            break;

        case "hh":
            hours = Math.floor(hours / count) * count;
            minutes = 0;
            seconds = 0;
            milliseconds = 0;
            break;

        case "mm":
            minutes = Math.floor(minutes / count) * count;
            seconds = 0;
            milliseconds = 0;
            break;

        case "ss":
            seconds = Math.floor(seconds / count) * count;
            milliseconds = 0;
            break;

        case "fff":
            milliseconds = Math.floor(milliseconds / count) * count;
            break;
    }

    if (AmCharts.useUTC) {
        date = new Date();
        date.setUTCFullYear(year, month, day);
        //date.setUTCMonth(month);
        //date.setUTCDate(day);
        date.setUTCHours(hours, minutes, seconds, milliseconds);
        //date.setUTCMinutes(minutes);
        //date.setUTCSeconds(seconds);
        //date.setUTCMilliseconds(milliseconds);
    } else {
        date = new Date(year, month, day, hours, minutes, seconds, milliseconds);
    }


    return date;
};

AmCharts.getPeriodDuration = function (period, count) {
    if (count === undefined) {
        count = 1;
    }
    var duration;
    switch (period) {
        case "YYYY":
            duration = 31622400000;
            break;
        case "MM":
            duration = 2678400000;
            break;
        case "WW":
            duration = 604800000;
            break;
        case "DD":
            duration = 86400000;
            break;
        case "hh":
            duration = 3600000;
            break;
        case "mm":
            duration = 60000;
            break;
        case "ss":
            duration = 1000;
            break;
        case "fff":
            duration = 1;
            break;
    }
    return duration * count;
};


AmCharts.intervals = {
    s: {
        nextInterval: "ss",
        contains: 1000
    },
    ss: {
        nextInterval: "mm",
        contains: 60,
        count: 0
    },
    mm: {
        nextInterval: "hh",
        contains: 60,
        count: 1
    },
    hh: {
        nextInterval: "DD",
        contains: 24,
        count: 2
    },
    DD: {
        nextInterval: "",
        contains: Infinity,
        count: 3
    }
};

AmCharts.getMaxInterval = function (duration, interval) {
    var intervals = AmCharts.intervals;
    if (duration >= intervals[interval].contains) {
        duration = Math.round(duration / intervals[interval].contains);
        interval = intervals[interval].nextInterval;

        return AmCharts.getMaxInterval(duration, interval);
    } else {
        if (interval == "ss") {
            return intervals[interval].nextInterval;
        } else {
            return interval;
        }
    }
};


AmCharts.dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
AmCharts.shortDayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];

AmCharts.monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
AmCharts.shortMonthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];


AmCharts.getWeekNumber = function (d) {
    d = new Date(d);
    d.setHours(0, 0, 0);
    d.setDate(d.getDate() + 4 - (d.getDay() || 7));
    var yearStart = new Date(d.getFullYear(), 0, 1);
    var weekNo = Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
    return weekNo;
};


AmCharts.stringToDate = function (str, format) {
    var values = {};

    var patterns = [{
        pattern: "YYYY",
        period: "year"
    }, {
        pattern: "YY",
        period: "year"
    }, {
        pattern: "MM",
        period: "month"
    }, {
        pattern: "M",
        period: "month"
    },

    {
        pattern: "DD",
        period: "date"
    }, {
        pattern: "D",
        period: "date"
    },

    {
        pattern: "JJ",
        period: "hours"
    }, {
        pattern: "J",
        period: "hours"
    }, {
        pattern: "HH",
        period: "hours"
    }, {
        pattern: "H",
        period: "hours"
    }, {
        pattern: "KK",
        period: "hours"
    }, {
        pattern: "K",
        period: "hours"
    }, {
        pattern: "LL",
        period: "hours"
    }, {
        pattern: "L",
        period: "hours"
    },

    {
        pattern: "NN",
        period: "minutes"
    }, {
        pattern: "N",
        period: "minutes"
    },

    {
        pattern: "SS",
        period: "seconds"
    }, {
        pattern: "S",
        period: "seconds"
    },

    {
        pattern: "QQQ",
        period: "milliseconds"
    }, {
        pattern: "QQ",
        period: "milliseconds"
    }, {
        pattern: "Q",
        period: "milliseconds"
    }];

    var am = true;
    var amIndex = format.indexOf("AA");
    if (amIndex != -1) {
        str.substr(amIndex, 2);
        if (str.toLowerCase == "pm") {
            am = false;
        }
    }

    var realFormat = format;
    var pattern;
    var period;
    var i;
    for (i = 0; i < patterns.length; i++) {
        pattern = patterns[i].pattern;
        period = patterns[i].period;

        values[period] = 0;
        if (period == "date") {
            values[period] = 1;
        }
    }
    for (i = 0; i < patterns.length; i++) {
        pattern = patterns[i].pattern;
        period = patterns[i].period;

        if (format.indexOf(pattern) != -1) {
            var value = AmCharts.getFromDateString(pattern, str, realFormat);

            format = format.replace(pattern, "");

            if (pattern == "KK" || pattern == "K" || pattern == "LL" || pattern == "L") {
                if (!am) {
                    value += 12;
                }
            }
            values[period] = value;
        }
    }

    var date = new Date(values.year, values.month, values.date, values.hours, values.minutes, values.seconds, values.milliseconds);

    return date;
};

AmCharts.getFromDateString = function (what, date, format) {
    var i = format.indexOf(what);

    var valueStr = date.substr(i, what.length);

    if (valueStr.charAt(0) == "0") {
        valueStr = valueStr.substr(1, valueStr.length - 1);
    }

    var value = Number(valueStr);

    if (isNaN(value)) {
        value = 0;
    }

    if (what.indexOf("M") != -1) {
        value--;
    }

    return value;
};



AmCharts.formatDate = function (d, f) {
    var year;
    var month;
    var date;
    var day;
    var hours;
    var minutes;
    var seconds;
    var milliseconds;
    var weekNo = AmCharts.getWeekNumber(d);

    if (AmCharts.useUTC) {
        year = d.getUTCFullYear();
        month = d.getUTCMonth();
        date = d.getUTCDate();
        day = d.getUTCDay();
        hours = d.getUTCHours();
        minutes = d.getUTCMinutes();
        seconds = d.getUTCSeconds();
        milliseconds = d.getUTCMilliseconds();
    } else {
        year = d.getFullYear();
        month = d.getMonth();
        date = d.getDate();
        day = d.getDay();
        hours = d.getHours();
        minutes = d.getMinutes();
        seconds = d.getSeconds();
        milliseconds = d.getMilliseconds();
    }


    var shortYear = String(year).substr(2, 2);
    var monthStr = month + 1;

    if (month < 9) {
        monthStr = "0" + monthStr;
    }



    var dayStr = "0" + day;

    // WEAK NUMBER
    f = f.replace(/W/g, weekNo);

    // HOURS
    var jhours = hours;
    if (jhours == 24) {
        jhours = 0;
    }
    var jjhours = jhours;
    if (jjhours < 10) {
        jjhours = "0" + jjhours;
    }

    f = f.replace(/JJ/g, jjhours);
    f = f.replace(/J/g, jhours);

    var hhours = hours;
    if (hhours === 0) {
        hhours = 24;
        if(f.indexOf('H') != -1){
            date --;
        }
    }

    var dateStr = date;
    if (date < 10) {
        dateStr = "0" + date;
    }

    var hhhours = hhours;
    if (hhhours < 10) {
        hhhours = "0" + hhhours;
    }
    f = f.replace(/HH/g, hhhours);
    f = f.replace(/H/g, hhours);

    var khours = hours;
    if (khours > 11) {
        khours -= 12;
    }
    var kkhours = khours;
    if (kkhours < 10) {
        kkhours = "0" + kkhours;
    }
    f = f.replace(/KK/g, kkhours);
    f = f.replace(/K/g, khours);


    var lhours = hours;
    if (lhours === 0) {
        lhours = 12;
    }

    if (lhours > 12) {
        lhours -= 12;
    }
    var llhours = lhours;
    if (llhours < 10) {
        llhours = "0" + llhours;
    }
    f = f.replace(/LL/g, llhours);
    f = f.replace(/L/g, lhours);

    // MINUTES
    var nnminutes = minutes;
    if (nnminutes < 10) {
        nnminutes = "0" + nnminutes;
    }
    f = f.replace(/NN/g, nnminutes);
    f = f.replace(/N/g, minutes);

    var ssseconds = seconds;
    if (ssseconds < 10) {
        ssseconds = "0" + ssseconds;
    }
    f = f.replace(/SS/g, ssseconds);
    f = f.replace(/S/g, seconds);


    var qqqms = milliseconds;
    if (qqqms < 10) {
        qqqms = "00" + qqqms;
    }
    if (qqqms < 100) {
        qqqms = "0" + qqqms;
    }

    var qqms = milliseconds;
    if (qqms < 10) {
        qqms = "00" + qqms;
    }

    f = f.replace(/QQQ/g, qqqms);
    f = f.replace(/QQ/g, qqms);
    f = f.replace(/Q/g, milliseconds);

    if (hours < 12) {
        f = f.replace(/A/g, "am");
    } else {
        f = f.replace(/A/g, "pm");
    }


    f = f.replace(/YYYY/g, '@IIII@');
    f = f.replace(/YY/g, '@II@');

    f = f.replace(/MMMM/g, '@XXXX@');
    f = f.replace(/MMM/g, '@XXX@');
    f = f.replace(/MM/g, '@XX@');
    f = f.replace(/M/g, '@X@');

    f = f.replace(/DD/g, '@RR@');
    f = f.replace(/D/g, '@R@');

    f = f.replace(/EEEE/g, '@PPPP@');
    f = f.replace(/EEE/g, '@PPP@');
    f = f.replace(/EE/g, '@PP@');
    f = f.replace(/E/g, '@P@');

    f = f.replace(/@IIII@/g, year);
    f = f.replace(/@II@/g, shortYear);

    f = f.replace(/@XXXX@/g, AmCharts.monthNames[month]);
    f = f.replace(/@XXX@/g, AmCharts.shortMonthNames[month]);
    f = f.replace(/@XX@/g, monthStr);
    f = f.replace(/@X@/g, (month + 1));

    f = f.replace(/@RR@/g, dateStr);
    f = f.replace(/@R@/g, date);

    f = f.replace(/@PPPP@/g, AmCharts.dayNames[day]);
    f = f.replace(/@PPP@/g, AmCharts.shortDayNames[day]);
    f = f.replace(/@PP@/g, dayStr);
    f = f.replace(/@P@/g, day);

    return f;
};


AmCharts.changeDate = function (date, period, count, forward, full) {
    var k = -1;

    if (forward === undefined) {
        forward = true;
    }

    if (full === undefined) {
        full = false;
    }

    if (forward === true) {
        k = 1;
    }

    switch (period) {
        case "YYYY":
            date.setFullYear(date.getFullYear() + count * k);
            if (!forward && !full) {
                date.setDate(date.getDate() + 1);
            }
            break;

        case "MM":
            var previousMonth = date.getMonth();
            date.setMonth(date.getMonth() + count * k);
            if (date.getMonth() > previousMonth + count * k) {
                date.setDate(date.getDate() - 1);
            }
            if (!forward && !full) {
                date.setDate(date.getDate() + 1);
            }
            break;

        case "DD":
            date.setDate(date.getDate() + count * k);
            break;

        case "WW":
            //date.setDate(date.getDate() + count * k * 7 + 1); //3.1 - in case sunday, skips one week
            date.setDate(date.getDate() + count * k * 7);
            break;

        case "hh":
            date.setHours(date.getHours() + count * k);
            break;

        case "mm":
            date.setMinutes(date.getMinutes() + count * k);
            break;

        case "ss":
            date.setSeconds(date.getSeconds() + count * k);
            break;

        case "fff":
            date.setMilliseconds(date.getMilliseconds() + count * k);
            break;
    }
    return date;
};// @tag amchart
AmCharts.toBoolean = function(str, ifUndefined) {
    if (str === undefined) {
        return ifUndefined;
    }
    switch (String(str).toLowerCase()) {
        case "true":
        case "yes":
        case "1":
            return true;
        case "false":
        case "no":
        case "0":
        case null:
            return false;
        default:
            return Boolean(str);
    }
};

AmCharts.removeFromArray = function(arr, el) {
    var i;
    for (i = arr.length - 1; i >= 0; i--) {
        if (arr[i] == el) {
            arr.splice(i, 1);
            continue;
        }
    }
};

AmCharts.getDecimals = function(val) {
    var numbersAfterDecimal = 0;
    if (!isNaN(val)) {
        var str = String(val);

        if (str.indexOf("e-") != -1) {
            numbersAfterDecimal = Number(str.split("-")[1]);
        } else if (str.indexOf(".") != -1) {
            numbersAfterDecimal = str.split(".")[1].length;
        }
    }
    return numbersAfterDecimal;
};

AmCharts.wrappedText = function(container, value, color, fontFamily, textSize, align, bold, textWidth, counter) {
    var text = AmCharts.text(container, value, color, fontFamily, textSize, align, bold);

    var separator = "\n";
    if(!AmCharts.isModern){
        separator = "<br>";
    }

    if(counter > 10){
        return text;
    }

    if(text){
        var bbox = text.getBBox();
        if (bbox.width > textWidth) {
            text.remove();
            var indices = [];
            var startIndex = 0;
            while ((index = value.indexOf(" ", startIndex)) > -1) {
                indices.push(index);
                startIndex = index + 1;
            }

            var middle = Math.round(value.length / 2);
            var smallestDif = 1000;
            var wrapAt;
            var i;

            for(i = 0; i < indices.length; i++){
                var diff = Math.abs(indices[i] - middle);
                if(diff < smallestDif){
                    wrapAt = indices[i];
                    smallestDif = diff;
                }
            }


            if(isNaN(wrapAt)){
                var wrappCount = Math.ceil(bbox.width / textWidth);

                for(i = 1; i < wrappCount; i++){
                    wrapAt = Math.round(value.length / wrappCount * i);
                    value = value.substr(0, wrapAt) + separator + value.substr(wrapAt);
                }
                return AmCharts.text(container, value, color, fontFamily, textSize, align, bold);
            }
            else{
                value = value.substr(0, wrapAt) + separator + value.substr(wrapAt + 1);
                return AmCharts.wrappedText(container, value, color, fontFamily, textSize, align, bold, textWidth, counter + 1);
            }



        } else {
            return text;
        }
    }
};

AmCharts.getStyle = function(oElm, strCssRule) {
    var strValue = "";
    if (document.defaultView && document.defaultView.getComputedStyle) {
        strValue = document.defaultView.getComputedStyle(oElm, "").getPropertyValue(strCssRule);
    } else if (oElm.currentStyle) {
        strCssRule = strCssRule.replace(/\-(\w)/g, function(strMatch, p1) {
            return p1.toUpperCase();
        });
        strValue = oElm.currentStyle[strCssRule];
    }
    return strValue;
};

AmCharts.removePx = function(value) {
    if(value != undefined){
        return Number(value.substring(0, value.length - 2));
    }
};

AmCharts.getURL = function(url, urlTarget) {
    if (url) {
        if (urlTarget == "_self" || !urlTarget) {
            window.location.href = url;
        } else if (urlTarget == "_top" && window.top) {
            window.top.location.href = url;
        } else if (urlTarget == "_parent" && window.parent) {
            window.parent.location.href = url;
        } else {
            var iFrame = document.getElementsByName(urlTarget)[0];

            if (iFrame) {
                iFrame.src = url;
            } else {
                window.open(url);
            }
        }
    }
};


AmCharts.ifArray = function(arr) {
    if (arr) {
        if (arr.length > 0) {
            return true;
        }
    }
    return false;
};


AmCharts.callMethod = function(method, arr) {
    var j;
    for (j = 0; j < arr.length; j++) {
        var object = arr[j];

        if (object) {
            if (object[method]) {
                object[method]();
            }
            var length = object.length;
            if (length > 0) {
                var i;
                for (i = 0; i < length; i++) {
                    var obj = object[i];
                    if (obj) {
                        if (obj[method]) {
                            obj[method]();
                        }
                    }
                }
            }
        }
    }
};


AmCharts.toNumber = function(val) {
    if (typeof(val) == 'number') {
        return val;
    } else {
        return Number(String(val).replace(/[^0-9\-.]+/g, ''));
    }
};

AmCharts.toColor = function(str) {
    if (str !== '' && str !== undefined) {
        if (str.indexOf(',') != -1) {
            var arr = str.split(',');
            var i;
            for (i = 0; i < arr.length; i++) {
                var cc = arr[i].substring(arr[i].length - 6, arr[i].length);
                arr[i] = '#' + cc;
            }
            str = arr;
        } else {
            str = str.substring(str.length - 6, str.length);
            str = '#' + str;
        }
    }
    return str;
};

AmCharts.toCoordinate = function(val, full, full2) {
    var coord;

    if (val !== undefined) {
        val = String(val);
        if (full2) {
            if (full2 < full) {
                full = full2;
            }
        }

        coord = Number(val);
        // if there is ! in the beginning, then calculate right or bottom
        if (val.indexOf("!") != -1) {
            coord = full - Number(val.substr(1));
        }
        // if values is set in percents, recalculate to pixels
        if (val.indexOf("%") != -1) {
            coord = full * Number(val.substr(0, val.length - 1)) / 100;
        }
    }
    return coord;
};

AmCharts.fitToBounds = function(number, min, max) {
    if (number < min) {
        number = min;
    }

    if (number > max) {
        number = max;
    }
    return number;
};

AmCharts.isDefined = function(value) {
    if (value === undefined) {
        return false;
    } else {
        return true;
    }
};

AmCharts.stripNumbers = function(str) {
    return str.replace(/[0-9]+/g, '');
};

AmCharts.roundTo = function(num, precision) {
    if (precision < 0) {
        return num;
    } else {
        var d = Math.pow(10, precision);
        return Math.round(num * d) / d;
    }
};

AmCharts.toFixed = function(number, precision) {
    var num = String(Math.round(number * Math.pow(10, precision)));

    if (precision > 0) {
        var length = num.length;

        if (length < precision) {
            var i;
            for (i = 0; i < precision - length; i++) {
                num = "0" + num;
            }
        }

        var base = num.substring(0, num.length - precision);
        if (base === "") {
            base = 0;
        }
        return base + "." + num.substring(num.length - precision, num.length);
    } else {
        return String(num);
    }
};

AmCharts.formatDuration = function(duration, interval, result, units, maxInterval, numberFormat) {
    var intervals = AmCharts.intervals;
    var decimalSeparator = numberFormat.decimalSeparator;
    if (duration >= intervals[interval].contains) {
        var value = duration - Math.floor(duration / intervals[interval].contains) * intervals[interval].contains;

        if (interval == "ss") {
            value = AmCharts.formatNumber(value, numberFormat);
            if (value.split(decimalSeparator)[0].length == 1) {
                value = "0" + value;
            }
        }

        if ((interval == "mm" || interval == "hh") && value < 10) {
            value = "0" + value;
        }

        result = value + "" + units[interval] + "" + result;

        duration = Math.floor(duration / intervals[interval].contains);
        interval = intervals[interval].nextInterval;

        return AmCharts.formatDuration(duration, interval, result, units, maxInterval, numberFormat);
    } else {
        if (interval == "ss") {
            duration = AmCharts.formatNumber(duration, numberFormat);

            if (duration.split(decimalSeparator)[0].length == 1) {
                duration = "0" + duration;
            }
        }

        if ((interval == "mm" || interval == "hh") && duration < 10) {
            duration = "0" + duration;
        }

        result = duration + "" + units[interval] + "" + result;

        if (intervals[maxInterval].count > intervals[interval].count) {
            var i;
            for (i = intervals[interval].count; i < intervals[maxInterval].count; i++) {
                interval = intervals[interval].nextInterval;

                if (interval == "ss" || interval == "mm" || interval == "hh") {
                    result = "00" + units[interval] + "" + result;
                } else if (interval == "DD") {
                    result = "0" + units[interval] + "" + result;
                }
            }
        }
        if (result.charAt(result.length - 1) == ":") {
            result = result.substring(0, result.length - 1);
        }
        return result;
    }
};


AmCharts.formatNumber = function(num, format, zeroCount, addPlus, addPercents) {
    num = AmCharts.roundTo(num, format.precision);


    if (isNaN(zeroCount)) {
        zeroCount = format.precision;
    }

    var dSep = format.decimalSeparator;
    var tSep = format.thousandsSeparator;

    // check if negative
    var negative;
    if (num < 0) {
        negative = "-";
    } else {
        negative = "";
    }

    num = Math.abs(num);

    var numStr = String(num);

    var exp = false;

    if (numStr.indexOf('e') != -1) {
        exp = true;
    }

    if (zeroCount >= 0 && !exp) {
        numStr = AmCharts.toFixed(num, zeroCount);
    }
    var formated = "";
    if (!exp) {
        var array = numStr.split(".");

        var string = String(array[0]);
        var i;
        for (i = string.length; i >= 0; i = i - 3) {
            if (i != string.length) {
                if (i !== 0) {
                    formated = string.substring(i - 3, i) + tSep + formated;
                } else {
                    formated = string.substring(i - 3, i) + formated;
                }
            } else {
                formated = string.substring(i - 3, i);
            }
        }

        if (array[1] !== undefined) {
            formated = formated + dSep + array[1];
        }
        if (zeroCount !== undefined && zeroCount > 0 && formated != "0") {
            formated = AmCharts.addZeroes(formated, dSep, zeroCount);
        }
    } else {
        formated = numStr;
    }

    formated = negative + formated;

    if (negative === "" && addPlus === true && num !== 0) {
        formated = "+" + formated;
    }

    if (addPercents === true) {
        formated = formated + "%";
    }

    return (formated);
};

AmCharts.addZeroes = function(number, dSep, count) {
    var array = number.split(dSep);

    if (array[1] === undefined && count > 0) {
        array[1] = "0";
    }
    if (array[1].length < count) {
        array[1] = array[1] + "0";
        return AmCharts.addZeroes(array[0] + dSep + array[1], dSep, count);
    } else {
        if (array[1] !== undefined) {
            return array[0] + dSep + array[1];
        } else {
            return array[0];
        }
    }
};

AmCharts.scientificToNormal = function(num) {
    var str = String(num);
    var newNumber;
    var arr = str.split("e");
    var i;
    // small numbers
    if (arr[1].substr(0, 1) == "-") {
        newNumber = "0.";

        for (i = 0; i < Math.abs(Number(arr[1])) - 1; i++) {
            newNumber += "0";
        }
        newNumber += arr[0].split(".").join("");
    } else {
        var digitsAfterDec = 0;
        var tmp = arr[0].split(".");
        if (tmp[1]) {
            digitsAfterDec = tmp[1].length;
        }

        newNumber = arr[0].split(".").join("");

        for (i = 0; i < Math.abs(Number(arr[1])) - digitsAfterDec; i++) {
            newNumber += "0";
        }
    }
    return newNumber;
};


AmCharts.toScientific = function(num, dSep) {
    if (num === 0) {
        return "0";
    }
    var exponent = Math.floor(Math.log(Math.abs(num)) * Math.LOG10E);
    var tenToPower = Math.pow(10, exponent);
    mantissa = String(mantissa).split(".").join(dSep);
    return String(mantissa) + "e" + exponent;
};


AmCharts.randomColor = function() {
    return '#' + ('00000' + (Math.random() * 16777216 << 0).toString(16)).substr(-6);
};

AmCharts.hitTest = function(bbox1, bbox2, abort) {
    var hit = false;

    var x1 = bbox1.x;
    var x2 = bbox1.x + bbox1.width;
    var y1 = bbox1.y;
    var y2 = bbox1.y + bbox1.height;
    var isInRectangle = AmCharts.isInRectangle;

    if (!hit) {
        hit = isInRectangle(x1, y1, bbox2);
    }
    if (!hit) {
        hit = isInRectangle(x1, y2, bbox2);
    }
    if (!hit) {
        hit = isInRectangle(x2, y1, bbox2);
    }
    if (!hit) {
        hit = isInRectangle(x2, y2, bbox2);
    }
    if (!hit && abort !== true) {
        hit = AmCharts.hitTest(bbox2, bbox1, true);
    }
    return hit;
};

AmCharts.isInRectangle = function(x, y, box) {
    if (x >= box.x - 5 && x <= box.x + box.width + 5 && y >= box.y - 5 && y <= box.y + box.height + 5) {
        return true;
    } else {
        return false;
    }
};

AmCharts.isPercents = function(s) {
    if (String(s).indexOf("%") != -1) {
        return true;
    }
};

AmCharts.findPosX = function(obj) {
    var tobj = obj;
    var pos = obj.offsetLeft;

    if (obj.offsetParent) {
        while ((obj = obj.offsetParent)) {
            pos += obj.offsetLeft;
        }

        while ((tobj = tobj.parentNode) && tobj != document.body) {
            pos -= tobj.scrollLeft || 0;
        }
    }
    return pos;
};

AmCharts.findPosY = function(obj) {
    var tobj = obj;
    var pos = obj.offsetTop;

    if (obj.offsetParent) {
        while ((obj = obj.offsetParent)) {
            pos += obj.offsetTop;
        }

        while ((tobj = tobj.parentNode) && tobj != document.body) {
            pos -= tobj.scrollTop || 0;
        }
    }

    return pos;
};

AmCharts.findIfFixed = function(obj) {
    if (obj.offsetParent) {
        while ((obj = obj.offsetParent)) {
            if (AmCharts.getStyle(obj, "position") == "fixed") {
                return true;
            }
        }
    }
    return false;
};

AmCharts.findIfAuto = function(obj) {
    if (obj.style) {
        if (AmCharts.getStyle(obj, "overflow") == "auto") {
            return true;
        }
    }
    if (obj.parentNode) {
        return AmCharts.findIfAuto(obj.parentNode);
    }

    return false;
};

AmCharts.findScrollLeft = function(obj, value) {
    if (obj.scrollLeft) {
        value += obj.scrollLeft;
    }
    if (obj.parentNode) {
        return AmCharts.findScrollLeft(obj.parentNode, value);
    }

    return value;
};

AmCharts.findScrollTop = function(obj, value) {
    if (obj.scrollTop) {
        value += obj.scrollTop;
    }
    if (obj.parentNode) {
        return AmCharts.findScrollTop(obj.parentNode, value);
    }

    return value;
};

AmCharts.formatValue = function(string, data, keys, numberFormatter, addString, usePrefixes, prefixesSmall, prefixesBig) {
    if (data) {
        if (addString === undefined) {
            addString = "";
        }
        var i;
        for (i = 0; i < keys.length; i++) {
            var key = keys[i];
            var value = data[key];
            if (value !== undefined) {
                var stringValue;
                if (usePrefixes) {
                    stringValue = AmCharts.addPrefix(value, prefixesBig, prefixesSmall, numberFormatter);
                } else {
                    stringValue = AmCharts.formatNumber(value, numberFormatter);
                }
                var regExp = new RegExp("\\[\\[" + addString + "" + key + "\\]\\]", "g");
                string = string.replace(regExp, stringValue);
            }
        }
    }
    return string;
};

AmCharts.formatDataContextValue = function(string, data) {
    if (string) {
        var items = string.match(/\[\[.*?\]\]/g);
        var i;
        for (i = 0; i < items.length; i++) {
            var item = items[i];
            var pureItem = item.substr(2, item.length - 4);

            if (data[pureItem] !== undefined) {
                var regExp = new RegExp("\\[\\[" + pureItem + "\\]\\]", "g");
                string = string.replace(regExp, data[pureItem]);
            }
        }
    }
    return string;
};

AmCharts.massReplace = function(string, replObj) {
    var key;
    for (key in replObj) {
        if (replObj.hasOwnProperty(key)) {
            var value = replObj[key];
            if (value === undefined) {
                value = "";
            }
            string = string.replace(key, value);
        }
    }

    return string;
};

AmCharts.cleanFromEmpty = function(str) {
    return str.replace(/\[\[[^\]]*\]\]/g, "");
};

AmCharts.addPrefix = function(value, prefixesOfBigNumbers, prefixesOfSmallNumbers, numberFormat, strict) {
    var str = AmCharts.formatNumber(value, numberFormat);
    var sign = "";
    var c;
    var newVal;
    var prec;

    if (value === 0) {
        return "0";
    }

    if (value < 0) {
        sign = "-";
    }

    value = Math.abs(value);

    if (value > 1) {
        for (c = prefixesOfBigNumbers.length - 1; c > -1; c--) {
            if (value >= prefixesOfBigNumbers[c].number) {
                newVal = value / prefixesOfBigNumbers[c].number;

                prec = Number(numberFormat.precision);

                if (prec < 1) {
                    prec = 1;
                }

                var newVal2 = AmCharts.roundTo(newVal, prec);

                var nf = {
                    precision: -1,
                    decimalSeparator: numberFormat.decimalSeparator,
                    thousandsSeparator: numberFormat.thousandsSeparator
                };

                var stringValue = AmCharts.formatNumber(newVal2, nf);

                if (strict) {
                    if (newVal != newVal2) {
                        continue;
                    }
                }

                str = sign + "" + stringValue + "" + prefixesOfBigNumbers[c].prefix;
                break;
            }
        }
    } else {
        for (c = 0; c < prefixesOfSmallNumbers.length; c++) {
            if (value <= prefixesOfSmallNumbers[c].number) {
                newVal = value / prefixesOfSmallNumbers[c].number;

                prec = Math.abs(Math.round(Math.log(newVal) * Math.LOG10E));
                newVal = AmCharts.roundTo(newVal, prec);

                str = sign + "" + newVal + "" + prefixesOfSmallNumbers[c].prefix;
                break;
            }
        }
    }
    return str;
};


AmCharts.remove = function(obj) {
    if (obj) {
        obj.remove();
    }
};



AmCharts.recommended = function() {
    var recommended = "js";
    var svg = document.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1");
    if (!svg) {
        if (swfobject) {
            if (swfobject.hasFlashPlayerVersion("8")) {
                recommended = "flash";
            }
        }
    }
    return recommended;
};

AmCharts.getEffect = function(val) {
    if (val == ">") {
        val = "easeOutSine";
    }
    if (val == "<") {
        val = "easeInSine";
    }
    if (val == "elastic") {
        val = "easeOutElastic";
    }
    return val;
};

AmCharts.getObjById = function(objects, id) {
    var _this = this;
    var currentObj;
    var i;
    for (i = 0; i < objects.length; i++) {
        var obj = objects[i];
        if (obj.id == id) {
            currentObj = obj;
        }
    }
    return currentObj;
};

AmCharts.applyTheme = function(object, theme, className) {

    if(!theme){
        theme = AmCharts.theme;
    }

    if (theme) {
        if (theme[className]) {
            AmCharts.extend(object, theme[className]);
        }
    }
};



AmCharts.isString = function(value) {
    if (typeof(value) == "string") {
        return true;
    } else {
        return false;
    }
};

AmCharts.extend = function(obj1, obj2, firstIsPriority) {
    var i;
    for (i in obj2) {
        if (firstIsPriority) {
            if (!obj1.hasOwnProperty(i)) {
                obj1[i] = obj2[i];
            }
        } else {
            obj1[i] = obj2[i];
        }

    }
    return obj1;
};


AmCharts.copyProperties = function(fromObject, toObject) {
    var i;
    for (i in fromObject) {
        if (fromObject.hasOwnProperty(i)) {
            if (i != "events" && fromObject[i] !== undefined && typeof(fromObject[i]) != "function" && i != "cname") {
                toObject[i] = fromObject[i];
            }
        }
    }
};

AmCharts.processObject = function(object, objectClass, theme) {
    if ((object instanceof objectClass) === false) {
        object = AmCharts.extend(new objectClass(theme), object);
    }
    return object;
};


AmCharts.fixNewLines = function(text) {
    //if (!AmCharts.isModern) {
        var from = "\\n";
        var to = "<br />";
        var rgx = new RegExp(from, "g");
        if (text) {
            text = text.replace(rgx, to);
        }
    //}
    return text;
};


AmCharts.fixBrakes = function(text) {
    if (!AmCharts.isModern) {
        text = AmCharts.fixNewLines(text);
    }
    else{
        var from = "<br>";
        var to = "\n";
        var rgx = new RegExp(from, "g");
        if (text) {
            text = text.replace(rgx, to);
        }
    }
    return text;
};


AmCharts.deleteObject = function(object, size) {
    if (!object) {
        return;
    }
    if (size === undefined || size === null) {
        size = 20;
    }
    if (size === 0) {
        return;
    }
    if (Object.prototype.toString.call(object) === '[object Array]') {
        for (var i = 0; i < object.length; i++) {
            AmCharts.deleteObject(object[i], size - 1);
            object[i] = null;
        }
    } else if (object && !object['tagName']) {  // added 3.3.6 to avoid destroying dom
    //}else{
        try {
            for (var prop in object) {
                if (!object[prop]) {
                    continue;
                }
                if (typeof object[prop] == "object") {
                    AmCharts.deleteObject(object[prop], size - 1);
                }
                if (typeof object[prop] == "function") {
                    continue;
                }
                object[prop] = null;
            }
        } catch (e) {}
    }
    object = null;
};



// borrowed from jquery
AmCharts.bounce = function(x, t, b, c, d) {
    if ((t /= d) < (1 / 2.75)) {
        return c * (7.5625 * t * t) + b;
    } else if (t < (2 / 2.75)) {
        return c * (7.5625 * (t -= (1.5 / 2.75)) * t + 0.75) + b;
    } else if (t < (2.5 / 2.75)) {
        return c * (7.5625 * (t -= (2.25 / 2.75)) * t + 0.9375) + b;
    } else {
        return c * (7.5625 * (t -= (2.625 / 2.75)) * t + 0.984375) + b;
    }
};

AmCharts.easeInSine = function(x, t, b, c, d) {
    return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;
};
AmCharts.easeOutSine = function(x, t, b, c, d) {
    return c * Math.sin(t / d * (Math.PI / 2)) + b;
};

AmCharts.easeOutElastic = function(x, t, b, c, d) {
    var s = 1.70158;
    var p = 0;
    var a = c;
    if (t === 0) {
        return b;
    }
    if ((t /= d) == 1) {
        return b + c;
    }
    if (!p) {
        p = d * 0.3;
    }
    if (a < Math.abs(c)) {
        a = c;
        s = p / 4;
    } else {
        s = p / (2 * Math.PI) * Math.asin(c / a);
    }
    return a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * (2 * Math.PI) / p) + c + b;
};// @tag amchart
AmCharts.AmDraw = AmCharts.Class({
    construct: function (div, w, h, chart) {
        AmCharts.SVG_NS = "http://www.w3.org/2000/svg";
        AmCharts.SVG_XLINK = 'http://www.w3.org/1999/xlink';
        AmCharts.hasSVG = !! document.createElementNS && !! document.createElementNS(AmCharts.SVG_NS, 'svg').createSVGRect;

        if (w < 1) {
            w = 10;
        }

        if (h < 1) {
            h = 10;
        }

        var _this = this;
        _this.div = div;
        _this.width = w;
        _this.height = h;
        _this.rBin = document.createElement("div");

        if (AmCharts.hasSVG) {
            AmCharts.SVG = true;
            var svg = _this.createSvgElement("svg");
            svg.style.position = "absolute";
            svg.style.width = w + "px";
            svg.style.height = h + "px";

            var desc = _this.createSvgElement("desc");
            desc.appendChild(document.createTextNode('JavaScript chart by amCharts ' + chart.version));
            svg.appendChild(desc);


            if (AmCharts.rtl) {
                svg.setAttribute("direction", "rtl");
                svg.style.left = "auto";
                svg.style.right = "0px";
            }

            svg.setAttribute("version", "1.1");
            div.appendChild(svg);

            _this.container = svg;
            _this.R = new AmCharts.SVGRenderer(_this);
        } else if (AmCharts.isIE) {
            if (AmCharts.VMLRenderer) {
                AmCharts.VML = true;
                if (!AmCharts.vmlStyleSheet) {
                    document.namespaces.add('amvml', 'urn:schemas-microsoft-com:vml');
                    var rule = "behavior:url(#default#VML); display:inline-block; antialias:true";

                    if (document.styleSheets.length < 31) {
                        var ss = document.createStyleSheet();
                        ss.addRule(".amvml", rule);
                        AmCharts.vmlStyleSheet = ss;
                    } else {
                        document.styleSheets[0].addRule(".amvml", rule);
                    }
                }

                _this.container = div;
                _this.R = new AmCharts.VMLRenderer(_this, chart);
                _this.R.disableSelection(div);
            }
        }
    },

    createSvgElement: function (name) {
        return document.createElementNS(AmCharts.SVG_NS, name);
    },

    circle: function (x, y, r, container) {
        var _this = this;

        var c = new AmCharts.AmDObject("circle", _this);
        c.attr({
            r: r,
            cx: x,
            cy: y
        });

        _this.addToContainer(c.node, container);

        return c;
    },

    setSize: function (w, h) {
        if (w > 0 && h > 0) {
            this.container.style.width = w + "px";
            this.container.style.height = h + "px";
        }
    },

    rect: function (x, y, w, h, cr, bw, container) {
        var _this = this;

        var r = new AmCharts.AmDObject("rect", _this);

        if (AmCharts.VML) {
            cr = cr * 100 / Math.min(w, h);
            w += bw * 2;
            h += bw * 2;
            r.bw = bw;
            r.node.style.marginLeft = -bw;
            r.node.style.marginTop = -bw;
        }
        if (w < 1) {
            w = 1;
        }

        if (h < 1) {
            h = 1;
        }

        r.attr({
            x: x,
            y: y,
            width: w,
            height: h,
            rx: cr,
            ry: cr,
            'stroke-width': bw
        });
        _this.addToContainer(r.node, container);
        return r;
    },

    image: function (path, x, y, w, h, container) {
        var _this = this;
        var i = new AmCharts.AmDObject("image", _this);
        i.attr({
            x: x,
            y: y,
            width: w,
            height: h
        });
        _this.R.path(i, path);
        _this.addToContainer(i.node, container);
        return i;
    },

    addToContainer: function (node, container) {
        if (!container) {
            container = this.container;
        }
        container.appendChild(node);
    },

    text: function (text, attr, container) {
        return this.R.text(text, attr, container);
    },

    path: function (pathStr, container, parsed, cs) {
        var _this = this;

        var p = new AmCharts.AmDObject("path", _this);

        if (!cs) {
            cs = "100,100";
        }

        p.attr({
            "cs": cs
        });

        if (parsed) {
            p.attr({
                "dd": pathStr
            });
        } else {
            p.attr({
                "d": pathStr
            });
        }

        _this.addToContainer(p.node, container);

        return p;
    },

    set: function (arr) {
        return this.R.set(arr);
    },

    remove: function (node) {
        if (node) {
            var rBin = this.rBin;
            rBin.appendChild(node);
            rBin.innerHTML = "";
        }
    },

    renderFix: function () {
        var container = this.container;
        var style = container.style;
        var position;

        try {
            position = container.getScreenCTM() || container.createSVGMatrix();
        } catch (e) {
            position = container.createSVGMatrix();
        }
        var left = 1 - position.e % 1;
        var top = 1 - position.f % 1;

        if (left > 0.5) {
            left -= 1;
        }

        if (top > 0.5) {
            top -= 1;
        }

        if (left) {
            style.left = left + "px";
        }
        if (top) {
            style.top = top + "px";
        }
    },

    update: function (){
        this.R.update();
    }



});// @tag amchart
AmCharts.AmDObject = AmCharts.Class({
    construct: function (name, amDraw) {
        var _this = this;
        _this.D = amDraw;
        _this.R = amDraw.R;
        var node = _this.R.create(this, name);
        _this.node = node;
        _this.x = 0;
        _this.y = 0;
        _this.scale = 1;
    },

    attr: function (attributes) {
        this.R.attr(this, attributes);
        return this;
    },

    getAttr: function (attr) {
        return this.node.getAttribute(attr);
    },

    setAttr: function (attr, value) {
        this.R.setAttr(this, attr, value);
        return this;
    },

    clipRect: function (x, y, w, h) {
        this.R.clipRect(this, x, y, w, h);
    },

    translate: function (x, y, scale, noRound) {
        var _this = this;

        if (!noRound) {
            x = Math.round(x);
            y = Math.round(y);
        }

        this.R.move(this, x, y, scale);
        _this.x = x;
        _this.y = y;

        _this.scale = scale;
        if (_this.angle) {
            _this.rotate(_this.angle);
        }
    },

    rotate: function (angle, bgColor) {
        this.R.rotate(this, angle, bgColor);
        this.angle = angle;
    },

    animate: function (attributes, time, effect) {
        var a;
        for (a in attributes) {
            if (attributes.hasOwnProperty(a)) {
                var attribute = a;
                var to = attributes[a];

                effect = AmCharts.getEffect(effect);

                this.R.animate(this, attribute, to, time, effect);
            }
        }
    },

    push: function (obj) {
        if (obj) {
            var node = this.node;

            node.appendChild(obj.node);

            var clipPath = obj.clipPath;
            if (clipPath) {
                node.appendChild(clipPath);
            }

            var grad = obj.grad;
            if (grad) {
                node.appendChild(grad);
            }
        }
    },

    text: function (str) {
        this.R.setText(this, str);
    },

    remove: function () {
        this.R.remove(this);
    },

    clear: function () {
        var node = this.node;
        if (node.hasChildNodes()) {
            while (node.childNodes.length >= 1) {
                node.removeChild(node.firstChild);
            }
        }
    },

    hide: function () {
        this.setAttr("visibility", "hidden");
    },

    show: function () {
        this.setAttr("visibility", "visible");
    },

    getBBox: function () {
        return this.R.getBBox(this);
    },

    toFront: function () {
        var node = this.node;

        if (node) {
            this.prevNextNode = node.nextSibling;
            var parent = node.parentNode;

            if (parent) {
                parent.appendChild(node);
            }
        }

    },

    toPrevious: function () {
        var node = this.node;
        if (node) {
            if (this.prevNextNode) {
                var parent = node.parentNode;

                if (parent) {
                    parent.insertBefore(this.prevNextNode, null);
                }
            }
        }
    },

    toBack: function () {
        var node = this.node;
        if (node) {
            this.prevNextNode = node.nextSibling;
            var parent = node.parentNode;
            if (parent) {
                var firstChild = parent.firstChild;
                if (firstChild) {
                    parent.insertBefore(node, firstChild);
                }
            }
        }
    },

    mouseover: function (f) {
        this.R.addListener(this, "mouseover", f);
        return this;
    },

    mouseout: function (f) {
        this.R.addListener(this, "mouseout", f);
        return this;
    },

    click: function (f) {
        this.R.addListener(this, "click", f);
        return this;
    },

    dblclick: function (f) {
        this.R.addListener(this, "dblclick", f);
        return this;
    },

    mousedown: function (f) {
        this.R.addListener(this, "mousedown", f);
        return this;
    },

    mouseup: function (f) {
        this.R.addListener(this, "mouseup", f);
        return this;
    },


    touchstart: function (f) {
        this.R.addListener(this, "touchstart", f);
        return this;
    },

    touchend: function (f) {
        this.R.addListener(this, "touchend", f);
        return this;
    },

    contextmenu: function (f) {
        if (this.node.addEventListener) {
            this.node.addEventListener("contextmenu", f, true);
        } else {
            this.R.addListener(this, "contextmenu", f);
        }
        return this;
    },

    stop: function (f) {
        var _this = this;
        var animationX = _this.animationX;

        if (animationX) {
            AmCharts.removeFromArray(_this.R.animations, animationX);
        }

        var animationY = _this.animationY;

        if (animationY) {
            AmCharts.removeFromArray(_this.R.animations, animationY);
        }
    },


    length: function () {
        return this.node.childNodes.length;
    },

    gradient: function (type, colors, rotation) {
        this.R.gradient(this, type, colors, rotation);
    },

    pattern: function (patternURL, scale) {
        if(patternURL){
            this.R.pattern(this, patternURL, scale);
        }
    }

});// @tag amchart
AmCharts.AmDSet = AmCharts.Class({
    construct: function (arr) {
        var _this = this;
        var group = _this.create("g");
    },

    attr: function (attributes) {
        this.R.attr(this.node, attributes);
    },

    move: function (x, y) {
        this.R.move(this.node, x, y);
    }
});// @tag amchart
AmCharts.SVGRenderer = AmCharts.Class({
    construct: function (amDraw) {
        var _this = this;
        _this.D = amDraw;
        _this.animations = [];
    },

    create: function (obj, name) {
        return document.createElementNS(AmCharts.SVG_NS, name);
    },

    attr: function (obj, attributes) {
        var a;
        for (a in attributes) {
            if (attributes.hasOwnProperty(a)) {
                this.setAttr(obj, a, attributes[a]);
            }
        }
    },

    setAttr: function (obj, attr, value) {
        if (value !== undefined) {
            obj.node.setAttribute(attr, value);
        }
    },

    animate: function (obj, attribute, to, time, effect) {
        
        var _this = this;
        var node = obj.node;
        var from;
        
        if (obj["an_" + attribute]) {
            AmCharts.removeFromArray(_this.animations, obj["an_" + attribute]);
        }        

        if (attribute == "translate") {

            from = node.getAttribute("transform");

            if (!from) {
                from = "0,0";
            } else {
                from = String(from).substring(10, from.length - 1);
            }

            from = from.split(", ").join(" ");
            from = from.split(" ").join(",");

            if (from === 0) {
                from = "0,0";
            }
        } else {
            from = Number(node.getAttribute(attribute));            
        }
        
        var animationObj = {
            obj: obj,
            frame: 0,
            attribute: attribute,
            from: from,
            to: to,
            time: time,
            effect: effect
        };        
        
        _this.animations.push(animationObj);

        obj["an_" + attribute] = animationObj;
    },

    update: function () {
        var _this = this;
        var i;       
        var animations = _this.animations;
        var count = animations.length - 1;                
        for (i = count; i >= 0; i--) {
            var animation = animations[i];
            
            var totalCount = animation.time * 1000 / AmCharts.updateRate;
            var frame = animation.frame + 1;
            var obj = animation.obj;
            var attribute = animation.attribute;

            var fromXY;
            var fromX;
            var fromY;
            var toXY;
            var toX;
            var toY;
            var to;

            if (frame <= totalCount) {
                var value;
                animation.frame++;
                if (attribute == "translate") {
                    fromXY = animation.from.split(",");
                    fromX = Number(fromXY[0]);
                    fromY = Number(fromXY[1]);
                    
                    if(isNaN(fromY)){
                        fromY = 0;
                    }

                    toXY = animation.to.split(",");
                    toX = Number(toXY[0]);
                    toY = Number(toXY[1]);

                    var valueX;
                    if (toX - fromX === 0) {
                        valueX = toX;
                    } else {
                        valueX = Math.round(AmCharts[animation.effect](0, frame, fromX, toX - fromX, totalCount));
                    }

                    var valueY;
                    if (toY - fromY === 0) {
                        valueY = toY;
                    } else {
                        valueY = Math.round(AmCharts[animation.effect](0, frame, fromY, toY - fromY, totalCount));
                    }                    
                    attribute = "transform";
                    value = "translate(" + valueX + "," + valueY + ")";
                    
                    
                } else {
                    var from = Number(animation.from);
                    to = Number(animation.to);
                    var change = to - from;

                    value = AmCharts[animation.effect](0, frame, from, change, totalCount);
                    
                    if(isNaN(value)){
                        value = to;
                    }

                    if (change === 0) {
                        _this.animations.splice(i, 1);
                    }
                }

                _this.setAttr(obj, attribute, value);
            } else {
                if (attribute == "translate") {
                    toXY = animation.to.split(",");
                    toX = Number(toXY[0]);
                    toY = Number(toXY[1]);

                    obj.translate(toX, toY);
                } else {
                    to = Number(animation.to);
                    _this.setAttr(obj, attribute, to);
                }

                _this.animations.splice(i, 1);
            }
        }
    },

    getBBox: function (obj) {
        var node = obj.node;
        var bbox = {
            width: 0,
            height: 0,
            x: 0,
            y: 0
        };
        if (node) {
            try {
                return node.getBBox();
            } catch (err) {

            }
        }

        return bbox;
    },

    path: function (obj, p) {
        obj.node.setAttributeNS(AmCharts.SVG_XLINK, "xlink:href", p);
    },

    clipRect: function (obj, x, y, w, h) {
        var _this = this;
        var node = obj.node;

        var old = obj.clipPath;
        if (old) {
            _this.D.remove(old);
        }

        var parent = node.parentNode;
        if (parent) {
            var clipPath = document.createElementNS(AmCharts.SVG_NS, "clipPath");
            var uniqueId = AmCharts.getUniqueId();
            clipPath.setAttribute("id", uniqueId);

            var rect = _this.D.rect(x, y, w, h, 0, 0, clipPath);

            parent.appendChild(clipPath);
            var url = "#";
            if (AmCharts.baseHref && !AmCharts.isIE) {
                url = window.location.href + url;
            }
            _this.setAttr(obj, "clip-path", "url(" + url + uniqueId + ")");
            _this.clipPathC++;

            // save reference in order not to get by id when removing
            obj.clipPath = clipPath;
        }
    },

    text: function (text, attr, container) {
        var _this = this;
        var t = new AmCharts.AmDObject("text", _this.D);

        var textArray = String(text).split("\n");
        var fontSize = attr['font-size'];
        var i;
        for (i = 0; i < textArray.length; i++) {
            var tspan = _this.create(null, "tspan");
            tspan.appendChild(document.createTextNode(textArray[i]));
            tspan.setAttribute("y", (fontSize + 2) * i + Math.round(fontSize / 2));
            tspan.setAttribute("x", 0);
            t.node.appendChild(tspan);
        }
        t.node.setAttribute("y", Math.round(fontSize / 2));


        _this.attr(t, attr);
        _this.D.addToContainer(t.node, container);

        return t;
    },


    setText: function (obj, str) {
        var node = obj.node;
        if (node) {
            node.removeChild(node.firstChild);
            node.appendChild(document.createTextNode(str));
        }
    },

    move: function (obj, x, y, scale) {
        var val = "translate(" + x + "," + y + ")";
        if (scale) {
            val = val + " scale(" + scale + ")";
        }

        this.setAttr(obj, "transform", val);
    },


    rotate: function (obj, angle) {
        var node = obj.node;
        var transform = node.getAttribute("transform");
        var val = "rotate(" + angle + ")";
        if (transform) {
            val = transform + " " + val;
        }
        this.setAttr(obj, "transform", val);
    },

    set: function (arr) {
        var _this = this;
        var s = new AmCharts.AmDObject("g", _this.D);
        _this.D.container.appendChild(s.node);

        if (arr) {
            var i;
            for (i = 0; i < arr.length; i++) {
                s.push(arr[i]);
            }
        }
        return s;
    },

    addListener: function (obj, event, f) {
        obj.node["on" + event] = f;
    },

    gradient: function (obj, type, colors, rotation) {
        var _this = this;
        var node = obj.node;

        var old = obj.grad;
        if (old) {
            _this.D.remove(old);
        }

        var gradient = document.createElementNS(AmCharts.SVG_NS, type);
        var uniqueId = AmCharts.getUniqueId();
        gradient.setAttribute("id", uniqueId);

        if (!isNaN(rotation)) {
            var x1 = 0;
            var x2 = 0;
            var y1 = 0;
            var y2 = 0;

            if (rotation == 90) {
                y1 = 100;
            } else if (rotation == 270) {
                y2 = 100;
            } else if (rotation == 180) {
                x1 = 100;
            } else if (rotation === 0) {
                x2 = 100;
            }

            var p = "%";

            gradient.setAttribute("x1", x1 + p);
            gradient.setAttribute("x2", x2 + p);
            gradient.setAttribute("y1", y1 + p);
            gradient.setAttribute("y2", y2 + p);
        }
        var i;
        for (i = 0; i < colors.length; i++) {
            var stop = document.createElementNS(AmCharts.SVG_NS, "stop");
            var offset = 100 * i / (colors.length - 1);
            if (i === 0) {
                offset = 0;
            }
            stop.setAttribute("offset", offset + "%");
            stop.setAttribute("stop-color", colors[i]);
            gradient.appendChild(stop);
        }
        node.parentNode.appendChild(gradient);        

        var url = "#";
        if (AmCharts.baseHref && !AmCharts.isIE) {
            url = window.location.href + url;
        }

        node.setAttribute("fill", "url(" + url + uniqueId + ")");

        obj.grad = gradient;
    },
    
    
    pattern: function (obj, pattern, scale) {
        var _this = this;
        var node = obj.node;
        
        if(isNaN(scale)){
            scale = 1;
        }
        
        var old = obj.patternNode;
        if (old) {
            _this.D.remove(old);
        }
        
        var patternNode = document.createElementNS(AmCharts.SVG_NS, "pattern");
        var uniqueId = AmCharts.getUniqueId();
        var url = pattern;
        if(pattern.url){
            url = pattern.url;
        }
        
        
        var width = Number(pattern.width);
        if(isNaN(width)){
            width = 4;
        }
        
        var height = Number(pattern.height);
        if(isNaN(height)){
            height = 4;
        }
        
        width = width / scale;
        height = height / scale;
        
        var x = pattern.x;        
        if(isNaN(x)){
            x = 0;
        }
        var randomX = -Math.random() * Number(pattern.randomX);
        if(!isNaN(randomX)){
            x = randomX;
        }
        
        var y = pattern.y;        
        if(isNaN(y)){
            y = 0;
        }
        var randomY = -Math.random() * Number(pattern.randomY);
        if(!isNaN(randomY)){
            y = randomY;
        }        
        
        patternNode.setAttribute("id", uniqueId);
        patternNode.setAttribute("width", width);
        patternNode.setAttribute("height", height);
        patternNode.setAttribute('patternUnits','userSpaceOnUse');
        patternNode.setAttribute("xlink:href", url);
        
        var image = _this.D.image(url, 0, 0, width, height, patternNode);
        image.translate(x, y)
        
       
        var url = "#";
        if (AmCharts.baseHref && !AmCharts.isIE) {
            url = window.location.href + url;
        }

        node.setAttribute("fill", "url(" + url + uniqueId + ")");

        obj.patternNode = patternNode;
        node.parentNode.appendChild(patternNode);
    },    
    

    remove: function (obj) {
        var _this = this;

        if (obj.clipPath) {
            _this.D.remove(obj.clipPath);
        }

        if (obj.grad) {
            _this.D.remove(obj.grad);
        }
        
        if (obj.patternNode) {
            _this.D.remove(obj.patternNode);
        }
        
        _this.D.remove(obj.node);
    }

});
// @tag amchart
AmCharts.VMLRenderer = AmCharts.Class({
    construct: function (amDraw, chart) {
        var _this = this;
        _this.chart = chart;
        _this.D = amDraw;
        _this.cNames = {
            circle: "oval",
            rect: "roundrect",
            path: "shape"
        };
        _this.styleMap = {
            "x": "left",
                "y": "top",
                "width": "width",
                "height": "height",
                "font-family": "fontFamily",
                "font-size": "fontSize",
                "visibility": "visibility"
        };
    },

    create: function (obj, name) {
        var node;
        if (name == "group") {
            node = document.createElement("div");
            obj.type = "div";
        } else if (name == "text") {
            node = document.createElement("div");
            obj.type = "text";
        } else if (name == "image") {
            node = document.createElement("img");
            obj.type = "image";
        } else {
            obj.type = "shape";
            obj.shapeType = this.cNames[name];

            node = document.createElement("amvml:" + this.cNames[name]);
            var stroke = document.createElement("amvml:stroke");
            node.appendChild(stroke);
            obj.stroke = stroke;

            var fill = document.createElement("amvml:fill");
            node.appendChild(fill);
            obj.fill = fill;
            fill.className = "amvml";
            stroke.className = "amvml";
            node.className = "amvml";
        }

        node.style.position = "absolute";
        node.style.top = 0;
        node.style.left = 0;

        return node;
    },

    path: function (obj, p) {
        obj.node.setAttribute("src", p);
    },


    setAttr: function (obj, attr, value) {
        if (value !== undefined) {
            var mode8;
            if (document.documentMode === 8) {
                mode8 = true;
            }

            var node = obj.node;

            var _this = this;
            var type = obj.type;
            var shapeType = obj.shapeType;
            var nodeStyle = node.style;


            // circle radius
            if (attr == "r") {
                nodeStyle.width = value * 2;
                nodeStyle.height = value * 2;
            }

            if (obj.shapeType == "roundrect") {
                if (attr == "width" || attr == "height") {
                    value -= 1;
                }
            }

            if (attr == "cursor") {
                nodeStyle.cursor = value;
            }

            // circle x
            if (attr == "cx") {
                nodeStyle.left = value - AmCharts.removePx(nodeStyle.width) / 2;
            }
            // circle y
            if (attr == "cy") {
                nodeStyle.top = value - AmCharts.removePx(nodeStyle.height) / 2;
            }

            var styleName = _this.styleMap[attr];
            if (styleName !== undefined) {
                nodeStyle[styleName] = value;
            }

            if (type == "text") {
                if (attr == "text-anchor") {
                    var px = "px";
                    obj.anchor = value;

                    var textWidth = node.clientWidth;

                    if (value == "end") {
                        nodeStyle.marginLeft = -textWidth + px;
                    }
                    if (value == "middle") {
                        nodeStyle.marginLeft = -(textWidth / 2) + px;
                        nodeStyle.textAlign = "center";
                    }
                    if (value == "start") {
                        nodeStyle.marginLeft = 0 + px;
                    }
                }
                if (attr == "fill") {
                    nodeStyle.color = value;
                }
                if (attr == "font-weight") {
                    nodeStyle.fontWeight = value;
                }
            }

            var children = obj.children;
            if (children) {
                var i;
                for (i = 0; i < children.length; i++) {
                    children[i].setAttr(attr, value);
                }
            }

            // path
            if (type == "shape") {
                if (attr == "cs") {
                    node.style.width = "100px";
                    node.style.height = "100px";
                    node.setAttribute("coordsize", value);
                }

                if (attr == "d") {
                    node.setAttribute("path", _this.svgPathToVml(value));
                }

                if (attr == "dd") {
                    node.setAttribute("path", value);
                }

                var stroke = obj.stroke;
                var fill = obj.fill;

                if (attr == "stroke") {
                    if (mode8) {
                        stroke.color = value;
                    } else {
                        stroke.setAttribute("color", value);
                    }
                }

                if (attr == "stroke-width") {
                    if (mode8) {
                        stroke.weight = value;
                    } else {
                        stroke.setAttribute("weight", value);
                    }
                }

                if (attr == "stroke-opacity") {
                    if (mode8) {
                        stroke.opacity = value;
                    } else {
                        stroke.setAttribute("opacity", value);
                    }
                }
                if (attr == "stroke-dasharray") {
                    var val = "solid";
                    if (value > 0 && value < 3) {
                        val = "dot";
                    }
                    if (value >= 3 && value <= 6) {
                        val = "dash";
                    }
                    if (value > 6) {
                        val = "longdash";
                    }
                    if (mode8) {
                        stroke.dashstyle = val;
                    } else {
                        stroke.setAttribute("dashstyle", val);
                    }
                }
                if (attr == "fill-opacity" || attr == "opacity") {
                    if (value === 0) {
                        if (mode8) {
                            fill.on = false;
                        } else {
                            fill.setAttribute("on", false);
                        }
                    } else {
                        if (mode8) {
                            fill.opacity = value;
                        } else {
                            fill.setAttribute("opacity", value);
                        }
                    }

                }

                if (attr == "fill") {
                    if (mode8) {
                        fill.color = value;
                    } else {
                        fill.setAttribute("color", value);
                    }
                }

                if (attr == "rx") {
                    if (mode8) {
                        node.arcSize = value + "%";
                    } else {
                        node.setAttribute("arcsize", value + "%");
                    }
                }
            }
        }
    },

    attr: function (obj, attributes) {
        var _this = this;
        var a;
        for (a in attributes) {
            if (attributes.hasOwnProperty(a)) {
                _this.setAttr(obj, a, attributes[a]);
            }
        }
    },

    text: function (text, attr, container) {
        var _this = this;

        var t = new AmCharts.AmDObject("text", _this.D);
        var node = t.node;
        node.style.whiteSpace = "pre";
        //var txt = document.createTextNode(text);

        node.innerHTML = text;
        _this.D.addToContainer(node, container);
        _this.attr(t, attr);

        return t;
    },

    getBBox: function (obj) {
        var node = obj.node;
        var box = this.getBox(node);
        return box;
    },

    getBox: function (node) {
        var x = node.offsetLeft;
        var y = node.offsetTop;

        var width = node.offsetWidth;
        var height = node.offsetHeight;

        var bbox;

        if (node.hasChildNodes()) {
            var xs;
            var ys;
            var i;
            for (i = 0; i < node.childNodes.length; i++) {
                var childNode = node.childNodes[i];
                bbox = this.getBox(childNode);
                var xx = bbox.x;

                if (!isNaN(xx)) {
                    if (isNaN(xs)) {
                        xs = xx;
                    } else if (xx < xs) {
                        xs = xx;
                    }
                }

                var yy = bbox.y;

                if (!isNaN(yy)) {
                    if (isNaN(ys)) {
                        ys = yy;
                    } else if (yy < ys) {
                        ys = yy;
                    }
                }


                var ww = bbox.width + xx;

                if (!isNaN(ww)) {
                    width = Math.max(width, ww);
                }

                var hh = bbox.height + yy;

                if (!isNaN(hh)) {
                    height = Math.max(height, hh);
                }
            }

            if (xs < 0) {
                x += xs;
            }
            if (ys < 0) {
                y += ys;
            }
        }

        return ({
            x: x,
            y: y,
            width: width,
            height: height
        });
    },

    setText: function (obj, str) {
        var node = obj.node;
        if (node) {
            node.innerHTML = str;
        }
        this.setAttr(obj, "text-anchor", obj.anchor);
    },

    addListener: function (obj, event, f) {
        obj.node["on" + event] = f;
    },

    move: function (obj, x, y) {
        var _this = this;
        var node = obj.node;
        var nodeStyle = node.style;

        if (obj.type == "text") {
            y -= AmCharts.removePx(nodeStyle.fontSize) / 2 - 1;
        }

        if (obj.shapeType == "oval") {
            x -= AmCharts.removePx(nodeStyle.width) / 2;
            y -= AmCharts.removePx(nodeStyle.height) / 2;
        }

        var bw = obj.bw;

        if (!isNaN(bw)) {
            x -= bw;
            y -= bw;
        }

        var px = "px";
        if (!isNaN(x) && !isNaN(y)) {
            node.style.left = x + px;
            node.style.top = y + px;
        }
    },

    svgPathToVml: function (path) {
        var pathArray = path.split(" ");
        path = "";
        var previousArray;
        var round = Math.round;
        var comma = ",";
        var i;
        for (i = 0; i < pathArray.length; i++) {
            var el = pathArray[i];
            var letter = el.substring(0, 1);
            var numbers = el.substring(1);
            var numbersArray = numbers.split(",");

            var rounded = round(numbersArray[0]) + comma + round(numbersArray[1]);

            if (letter == "M") {
                path += " m " + rounded;
            }
            if (letter == "L") {
                path += " l " + rounded;
            }
            if (letter == "Z") {
                path += " x e";
            }
            if (letter == "Q") {
                var length = previousArray.length;
                var qp0x = previousArray[length - 2];
                var qp0y = previousArray[length - 1];

                var qp1x = numbersArray[0];
                var qp1y = numbersArray[1];

                var qp2x = numbersArray[2];
                var qp2y = numbersArray[3];

                var cp1x = round(qp0x / 3 + 2 / 3 * qp1x);
                var cp1y = round(qp0y / 3 + 2 / 3 * qp1y);

                var cp2x = round(2 / 3 * qp1x + qp2x / 3);
                var cp2y = round(2 / 3 * qp1y + qp2y / 3);

                path += " c " + cp1x + comma + cp1y + comma + cp2x + comma + cp2y + comma + qp2x + comma + qp2y;
            }

            if (letter == "A") {
                path += " wa " + numbers;
            }

            if (letter == "B") {
                path += " at " + numbers;
            }

            previousArray = numbersArray;
        }

        return path;
    },


    animate: function (obj, attribute, to, time, effect) {
        var _this = this;
        var node = obj.node;
        var nodeStyle = node.style;
        var from;
        var chart = _this.chart;

        if (attribute == "translate") {
            var toA = to.split(",");
            var toX = toA[0];
            var toY = toA[1];

            var fromX = node.offsetLeft;
            var fromY = node.offsetTop;

            chart.animate(obj, "left", fromX, toX, time, effect, "px");
            chart.animate(obj, "top", fromY, toY, time, effect, "px");
        }
    },



    clipRect: function (obj, x, y, w, h) {
        var node = obj.node;
        var PX = "px";
        if (x === 0 && y === 0) {
            node.style.width = w + PX;
            node.style.height = h + PX;
            node.style.overflow = "hidden";
        } else {
            node.style.clip = "rect(" + y + "px " + (x + w) + "px " + (y + h) + "px " + x + "px)";
        }
    },

    rotate: function (obj, deg, bgColor) {
        if (Number(deg) !== 0) {
            var node = obj.node;
            var style = node.style;

            if(!bgColor){
                bgColor = this.getBGColor(node.parentNode);
            }

            style.backgroundColor = bgColor;
            style.paddingLeft = 1;

            var rad = deg * Math.PI / 180;
            var costheta = Math.cos(rad);
            var sintheta = Math.sin(rad);

            var left = AmCharts.removePx(style.left);
            var top = AmCharts.removePx(style.top);
            var width = node.offsetWidth;
            var height = node.offsetHeight;

            var sign = deg / Math.abs(deg);

            style.left = left + width / 2 - width / 2 * Math.cos(rad) - sign * height / 2 * Math.sin(rad) + 3;
            style.top = top - sign * width / 2 * Math.sin(rad) + sign * height / 2 * Math.sin(rad);

            style.cssText = style.cssText + "; filter:progid:DXImageTransform.Microsoft.Matrix(M11='" + costheta + "', M12='" + -sintheta + "', M21='" + sintheta + "', M22='" + costheta + "', sizingmethod='auto expand');";
        }
    },


    getBGColor: function (node) {
        var style = node.style;
        var bgColor = "#FFFFFF";

        if (style) {
            var color = node.style.backgroundColor;
            if (color !== "") {
                bgColor = color;
            } else if (node.parentNode) {
                bgColor = this.getBGColor(node.parentNode);
            }
        }
        return bgColor;
    },

    set: function (arr) {
        var _this = this;
        var s = new AmCharts.AmDObject("group", _this.D);
        _this.D.container.appendChild(s.node);

        if (arr) {
            var i;
            for (i = 0; i < arr.length; i++) {
                s.push(arr[i]);
            }
        }
        return s;
    },

    gradient: function (obj, type, colors, rotation) {
        var _this = this;

        var c = "";

        if (type == "radialGradient") {
            type = "gradientradial";
            colors.reverse();
        }

        if (type == "linearGradient") {
            type = "gradient";
        }
        var i;
        for (i = 0; i < colors.length; i++) {
            var offset = Math.round(i * 100 / (colors.length - 1));

            c += offset + "% " + colors[i];
            if (i < colors.length - 1) {
                c += ",";
            }
        }

        var fill = obj.fill;

        if (rotation == 90) {
            rotation = 0;
        } else if (rotation == 270) {
            rotation = 180;
        } else if (rotation == 180) {
            rotation = 90;
        } else if (rotation === 0) {
            rotation = 270;
        }

        if (document.documentMode === 8) {
            fill.type = type;
            fill.angle = rotation;
        } else {
            fill.setAttribute("type", type);
            fill.setAttribute("angle", rotation);
        }
        if (c) {
            fill.colors.value = c;
        }
    },

    remove: function (obj) {
        var _this = this;

        if (obj.clipPath) {
            _this.D.remove(obj.clipPath);
        }
        _this.D.remove(obj.node);
    },

    disableSelection: function (target) {
        if (typeof target.onselectstart !== undefined) {
            target.onselectstart = function () {
                return false;
            };
        }
        target.style.cursor = "default";
    },

    pattern: function (obj, pattern) {
        var _this = this;
        var node = obj.node;

        var fill = obj.fill;
        var type = "tile";

        node.fillColor = "none";
        if (document.documentMode === 8) {
            fill.type = type;
            fill.src = pattern.url;
        } else {
            fill.setAttribute("type", type);
            fill.setAttribute("src", pattern.url);
        }
    },

    update: function () {
        // void
    }


});// @tag amchart
AmCharts.AmChart = AmCharts.Class({

    construct: function(theme) {
        var _this = this;
        _this.theme = theme;
        _this.version = "3.4.8";
        AmCharts.addChart(_this);
        _this.createEvents('dataUpdated', 'init', 'rendered', 'drawn');
        _this.width = '100%';
        _this.height = '100%';
        _this.dataChanged = true;
        _this.chartCreated = false;
        _this.previousHeight = 0;
        _this.previousWidth = 0;
        _this.backgroundColor = "#FFFFFF";
        _this.backgroundAlpha = 0;
        _this.borderAlpha = 0;
        _this.borderColor = "#000000";
        _this.color = "#000000";
        _this.fontFamily = "Verdana";
        _this.fontSize = 11;
        _this.usePrefixes = false;
/*
        _this.numberFormatter = {
            precision: -1,
            decimalSeparator: '.',
            thousandsSeparator: ','
        };
        _this.percentFormatter = {
            precision: 2,
            decimalSeparator: '.',
            thousandsSeparator: ','
        };
*/
        _this.precision = -1;
        _this.percentPrecision = 2;
        _this.decimalSeparator = ".";
        _this.thousandsSeparator = ",";

        _this.labels = [];
        _this.allLabels = [];
        _this.titles = [];
        _this.autoMarginOffset = 0;
        _this.marginLeft = 0;
        _this.marginRight = 0;
        _this.timeOuts = [];
        _this.creditsPosition = "top-left";

        var chartDiv = document.createElement("div");
        var chartStyle = chartDiv.style;
        chartStyle.overflow = "hidden";
        chartStyle.position = "relative";
        chartStyle.textAlign = "left";
        _this.chartDiv = chartDiv;

        var legendDiv = document.createElement("div");
        var legendStyle = legendDiv.style;
        legendStyle.overflow = "hidden";
        legendStyle.position = "relative";
        legendStyle.textAlign = "left";
        _this.legendDiv = legendDiv;

        _this.titleHeight = 0;
        _this.hideBalloonTime = 150;

        _this.handDrawScatter = 2;
        _this.handDrawThickness = 1;


        _this.prefixesOfBigNumbers = [{
            number: 1e+3,
            prefix: "k"
        }, {
            number: 1e+6,
            prefix: "M"
        }, {
            number: 1e+9,
            prefix: "G"
        }, {
            number: 1e+12,
            prefix: "T"
        }, {
            number: 1e+15,
            prefix: "P"
        }, {
            number: 1e+18,
            prefix: "E"
        }, {
            number: 1e+21,
            prefix: "Z"
        }, {
            number: 1e+24,
            prefix: "Y"
        }];
        _this.prefixesOfSmallNumbers = [{
            number: 1e-24,
            prefix: "y"
        }, {
            number: 1e-21,
            prefix: "z"
        }, {
            number: 1e-18,
            prefix: "a"
        }, {
            number: 1e-15,
            prefix: "f"
        }, {
            number: 1e-12,
            prefix: "p"
        }, {
            number: 1e-9,
            prefix: "n"
        }, {
            number: 1e-6,
            prefix: ""
        }, {
            number: 1e-3,
            prefix: "m"
        }];
        _this.panEventsEnabled = true; // changed since 3.4.4
        AmCharts.bezierX = 3;
        AmCharts.bezierY = 6;

        _this.product = "amcharts";

        _this.animations = [];

        _this.balloon = new AmCharts.AmBalloon(_this.theme);
        _this.balloon.chart = this;

        AmCharts.applyTheme(_this, theme, "AmChart");
    },

    drawChart: function() {
        var _this = this;

        _this.drawBackground();

        _this.redrawLabels();

        _this.drawTitles();

        _this.brr();
    },

    drawBackground: function() {
        var _this = this;
        AmCharts.remove(_this.background);
        var container = _this.container;
        var backgroundColor = _this.backgroundColor;
        var backgroundAlpha = _this.backgroundAlpha;
        var set = _this.set;

        if (!AmCharts.isModern && backgroundAlpha === 0) {
            backgroundAlpha = 0.001;
        }

        var realWidth = _this.updateWidth();
        _this.realWidth = realWidth;

        var realHeight = _this.updateHeight();
        _this.realHeight = realHeight;

        var background = AmCharts.polygon(container, [0, realWidth - 1, realWidth - 1, 0], [0, 0, realHeight - 1, realHeight - 1], backgroundColor, backgroundAlpha, 1, _this.borderColor, _this.borderAlpha);
        _this.background = background;
        set.push(background);

        var backgroundImage = _this.backgroundImage;
        if (backgroundImage) {
            if (_this.path) {
                backgroundImage = _this.path + backgroundImage;
            }

            var bgImg = container.image(backgroundImage, 0, 0, realWidth, realHeight);
            _this.bgImg = bgImg;
            set.push(bgImg);
        }
    },

    drawTitles: function() {
        var _this = this;
        var titles = _this.titles;
        if (AmCharts.ifArray(titles)) {
            var nextY = 20;
            var i;
            for (i = 0; i < titles.length; i++) {
                var title = titles[i];
                var color = title.color;
                if (color === undefined) {
                    color = _this.color;
                }
                var size = title.size;

                if(isNaN(size)){
                    size = _this.fontSize + 2;
                }

                var alpha = title.alpha;
                if (isNaN(alpha)) {
                    alpha = 1;
                }

                var marginLeft = _this.marginLeft;
                var titleLabel = AmCharts.text(_this.container, title.text, color, _this.fontFamily, size);
                titleLabel.translate(marginLeft + (_this.realWidth - _this.marginRight - marginLeft) / 2, nextY);

                var bold = true;
                if (title.bold !== undefined) {
                    bold = title.bold;
                }
                if (bold) {
                    titleLabel.attr({
                        'font-weight': 'bold'
                    });
                }

                titleLabel.attr({opacity:title.alpha});

                nextY += size + 6;
                _this.freeLabelsSet.push(titleLabel);
            }
        }
    },

    write: function(divId) {

        var _this = this;

        var div;
        if (typeof(divId) != "object") {
            div = document.getElementById(divId);
        } else {
            div = divId;
        }
        div.innerHTML = "";
        _this.div = div;
        div.style.overflow = "hidden";
        div.style.textAlign = "left";

        var chartDiv = _this.chartDiv;
        var legendDiv = _this.legendDiv;
        var legend = _this.legend;
        var legendStyle = legendDiv.style;
        var chartStyle = chartDiv.style;
        _this.measure();

        var UNDEFINED;
        var ABSOLUTE = "absolute";
        var RELATIVE = "relative";
        var PX = "px";
        var containerStyle;

        var container = document.createElement("div");
        containerStyle = container.style;
        containerStyle.position = RELATIVE;
        _this.containerDiv = container;
        div.appendChild(container);

        var exportConfig = _this.exportConfig;
        if (exportConfig && AmCharts.AmExport) {
            var amExport = _this.AmExport;
            if (!amExport) {
                _this.AmExport = new AmCharts.AmExport(this, exportConfig);
            }
        }

        if (legend) {

            legend = _this.addLegend(legend, legend.divId);

            switch (legend.position) {
                case "bottom":
                    container.appendChild(chartDiv);
                    container.appendChild(legendDiv);
                    break;
                case "top":
                    container.appendChild(legendDiv);
                    container.appendChild(chartDiv);
                    break;
                case ABSOLUTE:
                    containerStyle.width = div.style.width;
                    containerStyle.height = div.style.height;

                    legendStyle.position = ABSOLUTE;
                    chartStyle.position = ABSOLUTE;
                    if (legend.left !== UNDEFINED) {
                        legendStyle.left = legend.left + PX;
                    }
                    if (legend.right !== UNDEFINED) {
                        legendStyle.right = legend.right + PX;
                    }
                    if (legend.top !== UNDEFINED) {
                        legendStyle.top = legend.top + PX;
                    }
                    if (legend.bottom !== UNDEFINED) {
                        legendStyle.bottom = legend.bottom + PX;
                    }
                    legend.marginLeft = 0;
                    legend.marginRight = 0;

                    container.appendChild(chartDiv);
                    container.appendChild(legendDiv);
                    break;
                case "right":
                    containerStyle.width = div.style.width;
                    containerStyle.height = div.style.height;

                    legendStyle.position = RELATIVE;
                    chartStyle.position = ABSOLUTE;
                    container.appendChild(chartDiv);
                    container.appendChild(legendDiv);
                    break;
                case "left":
                    containerStyle.width = div.style.width;
                    containerStyle.height = div.style.height;
                    legendStyle.position = ABSOLUTE;
                    chartStyle.position = RELATIVE;
                    container.appendChild(chartDiv);
                    container.appendChild(legendDiv);
                    break;
                case "outside":
                    container.appendChild(chartDiv);
                    break;
            }
        } else {
            container.appendChild(chartDiv);
        }

        if (!_this.listenersAdded) {
            _this.addListeners();
            _this.listenersAdded = true;
        }

        _this.initChart();
    },

    createLabelsSet: function() {
        var _this = this;
        AmCharts.remove(_this.labelsSet);
        _this.labelsSet = _this.container.set();
        _this.freeLabelsSet.push(_this.labelsSet);
    },

    initChart: function() {

        var _this = this;

        // this is to handle backwards compatibility when numberFormatter and percentFromatter were objects
        var numberFormatter = _this.numberFormatter;
        if(numberFormatter){
            if(!isNaN(numberFormatter.precision)){
                _this.precision = numberFormatter.precision;
            }

            if(numberFormatter.thousandsSeparator !== undefined){
                _this.thousandsSeparator = numberFormatter.thousandsSeparator;
            }

            if(numberFormatter.decimalSeparator !== undefined){
                _this.decimalSeparator = numberFormatter.decimalSeparator;
            }
        }

        var percentFormatter = _this.percentFormatter;
        if(percentFormatter){
            if(!isNaN(percentFormatter.precision)){
                _this.percentPrecision = percentFormatter.precision;
            }
        }

        _this.nf = {precision:_this.precision, thousandsSeparator:_this.thousandsSeparator, decimalSeparator:_this.decimalSeparator};
        _this.pf = {precision:_this.percentPrecision, thousandsSeparator:_this.thousandsSeparator, decimalSeparator:_this.decimalSeparator};

        _this.divIsFixed = AmCharts.findIfFixed(_this.chartDiv);

        _this.previousHeight = _this.divRealHeight;
        _this.previousWidth = _this.divRealWidth;
        _this.destroy();

        _this.startInterval();

        var mouseMode = 0;
        if (document.attachEvent && !window.opera) {
            mouseMode = 1;
        }

        _this.dmouseY = 0;
        _this.dmouseX = 0;

        var element = document.getElementsByTagName('html')[0];
        if (element) {
            if (window.getComputedStyle) {
                var style = window.getComputedStyle(element, null);
                if (style) {
                    _this.dmouseY = AmCharts.removePx(style.getPropertyValue('margin-top'));
                    _this.dmouseX = AmCharts.removePx(style.getPropertyValue('margin-left'));
                }
            }
        }

        _this.mouseMode = mouseMode;

        var container = new AmCharts.AmDraw(_this.chartDiv, _this.realWidth, _this.realHeight, _this);
        container.handDrawn = _this.handDrawn;
        container.handDrawScatter = _this.handDrawScatter;
        container.handDrawThickness = _this.handDrawThickness;
        _this.container = container;


        if (AmCharts.VML || AmCharts.SVG) {
            container = _this.container;
            _this.set = container.set();
            //_this.set.setAttr("id", "mainSet");

            _this.gridSet = container.set();
            //_this.gridSet.setAttr("id", "grid");
            _this.cursorLineSet = container.set();

            _this.graphsBehindSet = container.set();

            _this.bulletBehindSet = container.set();

            _this.columnSet = container.set();
            //_this.columnSet.setAttr("id", "columns");
            _this.graphsSet = container.set();

            _this.trendLinesSet = container.set();
            //_this.trendLinesSet.setAttr("id", "trendlines");
            _this.axesLabelsSet = container.set();
            //_this.axesLabelsSet.setAttr("id", "axes labels");
            _this.axesSet = container.set();
            //_this.axesSet.setAttr("id", "axes");
            _this.cursorSet = container.set();
            //_this.cursorSet.setAttr("id", "cursor");
            _this.scrollbarsSet = container.set();
            //_this.scrollbarsSet.setAttr("id", "scrollbars");
            _this.bulletSet = container.set();
            //_this.bulletSet.setAttr("id", "bullets");
            _this.freeLabelsSet = container.set();
            //_this.freeLabelsSet.setAttr("id", "free labels");
            _this.balloonsSet = container.set();
            _this.balloonsSet.setAttr("id", "balloons");

            _this.zoomButtonSet = container.set();
            //_this.zoomButtonSet.setAttr("id", "zoom out button");
            _this.linkSet = container.set();

            _this.renderFix();
        }
    },

    measure: function() {
        var _this = this;

        var div = _this.div;
        var chartDiv = _this.chartDiv;
        var divRealWidth = div.offsetWidth;
        var divRealHeight = div.offsetHeight;
        var container = _this.container;
        var PX = "px";

        if (div.clientHeight) {
            divRealWidth = div.clientWidth;
            divRealHeight = div.clientHeight;
        }

        var paddingLeft = AmCharts.removePx(AmCharts.getStyle(div, "padding-left"));
        var paddingRight = AmCharts.removePx(AmCharts.getStyle(div, "padding-right"));
        var paddingTop = AmCharts.removePx(AmCharts.getStyle(div, "padding-top"));
        var paddingBottom = AmCharts.removePx(AmCharts.getStyle(div, "padding-bottom"));

        if (!isNaN(paddingLeft)) {
            divRealWidth -= paddingLeft;
        }
        if (!isNaN(paddingRight)) {
            divRealWidth -= paddingRight;
        }
        if (!isNaN(paddingTop)) {
            divRealHeight -= paddingTop;
        }
        if (!isNaN(paddingBottom)) {
            divRealHeight -= paddingBottom;
        }

        var divStyle = div.style;
        var w = divStyle.width;
        var h = divStyle.height;

        if (w.indexOf(PX) != -1) {
            divRealWidth = AmCharts.removePx(w);
        }
        if (h.indexOf(PX) != -1) {
            divRealHeight = AmCharts.removePx(h);
        }

        var realWidth = AmCharts.toCoordinate(_this.width, divRealWidth);
        var realHeight = AmCharts.toCoordinate(_this.height, divRealHeight);

        _this.balloon = AmCharts.processObject(_this.balloon, AmCharts.AmBalloon, _this.theme);
        _this.balloon.chart = this;

        if (realWidth != _this.previousWidth || realHeight != _this.previousHeight) {
            chartDiv.style.width = realWidth + PX;
            chartDiv.style.height = realHeight + PX;

            if (container) {
                container.setSize(realWidth, realHeight);
            }
        }
        _this.balloon.setBounds(2, 2, realWidth - 2, realHeight);

        _this.realWidth = realWidth;
        _this.realHeight = realHeight;
        _this.divRealWidth = divRealWidth;
        _this.divRealHeight = divRealHeight;
    },

    destroy: function() {
        var _this = this;
        _this.chartDiv.innerHTML = "";
        _this.clearTimeOuts();
        if (_this.interval) {
            clearInterval(_this.interval);
        }
        _this.interval = NaN;
    },

    clearTimeOuts: function() {
        var _this = this;
        var timeOuts = _this.timeOuts;
        if (timeOuts) {
            var i;
            for (i = 0; i < timeOuts.length; i++) {
                clearTimeout(timeOuts[i]);
            }
        }
        _this.timeOuts = [];
    },

    clear: function(keepChart) {
        var _this = this;
        AmCharts.callMethod("clear", [_this.chartScrollbar, _this.scrollbarV, _this.scrollbarH, _this.chartCursor]);
        _this.chartScrollbar = null;
        _this.scrollbarV = null;
        _this.scrollbarH = null;
        _this.chartCursor = null;
        _this.clearTimeOuts();

        if (_this.interval) {
            clearInterval(_this.interval);
        }

        if (_this.container) {
            _this.container.remove(_this.chartDiv);
            _this.container.remove(_this.legendDiv);
        }
        if (!keepChart) {
            AmCharts.removeChart(this);
        }
    },

    setMouseCursor: function(cursor) {
        if (cursor == "auto" && AmCharts.isNN) {
            cursor = "default";
        }
        this.chartDiv.style.cursor = cursor;
        this.legendDiv.style.cursor = cursor;
    },

    redrawLabels: function() {
        var _this = this;
        _this.labels = [];
        var allLabels = _this.allLabels;

        _this.createLabelsSet();

        var i;
        for (i = 0; i < allLabels.length; i++) {
            _this.drawLabel(allLabels[i]);
        }
    },

    drawLabel: function(label) {
        var _this = this;

        if (_this.container) {
            var x = label.x;
            var y = label.y;
            var text = label.text;
            var align = label.align;
            var size = label.size;
            var color = label.color;
            var rotation = label.rotation;
            var alpha = label.alpha;
            var bold = label.bold;
            var UNDEFINED;

            var nx = AmCharts.toCoordinate(x, _this.realWidth);
            var ny = AmCharts.toCoordinate(y, _this.realHeight);

            if (!nx) {
                nx = 0;
            }

            if (!ny) {
                ny = 0;
            }

            if (color === UNDEFINED) {
                color = _this.color;
            }
            if (isNaN(size)) {
                size = _this.fontSize;
            }
            if (!align) {
                align = "start";
            }
            if (align == "left") {
                align = "start";
            }
            if (align == "right") {
                align = "end";
            }
            if (align == "center") {
                align = "middle";
                if (!rotation) {
                    nx = _this.realWidth / 2 - nx;
                } else {
                    ny = _this.realHeight - ny + ny / 2;
                }
            }
            if (alpha === UNDEFINED) {
                alpha = 1;
            }
            if (rotation === UNDEFINED) {
                rotation = 0;
            }

            ny += size / 2;

            var labelObj = AmCharts.text(_this.container, text, color, _this.fontFamily, size, align, bold, alpha);
            labelObj.translate(nx, ny);

            if (rotation !== 0) {
                labelObj.rotate(rotation);
            }

            if (label.url) {
                labelObj.setAttr("cursor", "pointer");
                labelObj.click(function() {
                    AmCharts.getURL(label.url);
                });
            }

            _this.labelsSet.push(labelObj);
            _this.labels.push(labelObj);
        }
    },

    addLabel: function(x, y, text, align, size, color, rotation, alpha, bold, url) {
        var _this = this;
        var label = {
            x: x,
            y: y,
            text: text,
            align: align,
            size: size,
            color: color,
            alpha: alpha,
            rotation: rotation,
            bold: bold,
            url: url
        };

        if (_this.container) {
            _this.drawLabel(label);
        }
        _this.allLabels.push(label);
    },

    clearLabels: function() {
        var _this = this;
        var labels = _this.labels;
        var i;
        for (i = labels.length - 1; i >= 0; i--) {
            labels[i].remove();
        }
        _this.labels = [];
        _this.allLabels = [];
    },

    updateHeight: function() {
        var _this = this;
        var height = _this.divRealHeight;

        var legend = _this.legend;
        if (legend) {
            var legendHeight = _this.legendDiv.offsetHeight;

            var lPosition = legend.position;
            if (lPosition == "top" || lPosition == "bottom") {
                height -= legendHeight;
                if (height < 0 || isNaN(height)) {
                    height = 0;
                }
                _this.chartDiv.style.height = height + "px";
            }
        }
        return height;
    },


    updateWidth: function() {
        var _this = this;
        var width = _this.divRealWidth;
        var height = _this.divRealHeight;
        var legend = _this.legend;
        if (legend) {
            var legendDiv = _this.legendDiv;
            var legendWidth = legendDiv.offsetWidth;
            if(!isNaN(legend.width)){
                legendWidth = legend.width;
            }
            var legendHeight = legendDiv.offsetHeight;
            var legendStyle = legendDiv.style;

            var chartDiv = _this.chartDiv;
            var chartStyle = chartDiv.style;

            var lPosition = legend.position;
            var px = "px";

            if (lPosition == "right" || lPosition == "left") {
                width -= legendWidth;
                if (width < 0 || isNaN(width)) {
                    width = 0;
                }
                chartStyle.width = width + px;

                if (lPosition == "left") {
                    //chartStyle.left = (AmCharts.findPosX(_this.div) + legendWidth) + px;
                    chartStyle.left = legendWidth + px;
                } else {
                    legendStyle.left = width + px;
                }
                legendStyle.top = (height - legendHeight) / 2 + px;
            }
        }
        return width;
    },


    getTitleHeight: function() {
        var titleHeight = 0;
        var titles = this.titles;
        if (titles.length > 0) {
            titleHeight = 15;
            var i;
            for (i = 0; i < titles.length; i++) {
                var title = titles[i];
                var size = title.size;
                if(isNaN(size)){
                    size = this.fontSize + 2;
                }
                titleHeight += size + 6;
            }
        }
        return titleHeight;
    },

    addTitle: function(text, size, color, alpha, bold) {
        var _this = this;

        if (isNaN(size)) {
            size = _this.fontSize + 2;
        }
        var tObj = {
            text: text,
            size: size,
            color: color,
            alpha: alpha,
            bold: bold
        };
        _this.titles.push(tObj);
        return tObj;
    },

    addMouseWheel: function() {
        var _this = this;

        if (window.addEventListener) {
            window.addEventListener('DOMMouseScroll', function(event) {
                _this.handleWheel.call(_this, event);
            }, false);

            document.addEventListener('mousewheel', function(event) {
                _this.handleWheel.call(_this, event);
            }, false);
        }

    },

    handleWheel: function(event) {

        var _this = this;

        if (_this.mouseIsOver) {

            var delta = 0;
            if (!event) {
                event = window.event;
            }
            if (event.wheelDelta) {
                delta = event.wheelDelta / 120;
            } else if (event.detail) {
                delta = -event.detail / 3;
            }
            if (delta) {
                _this.handleWheelReal(delta, event.shiftKey);
            }
            if (event.preventDefault) {
                event.preventDefault();
            }
        }
    },

    handleWheelReal: function(delta) {
        // void
    },

    addListeners: function() {
        var _this = this;
        var chartDiv = _this.chartDiv;

        if (document.addEventListener) {

            if (_this.panEventsEnabled) {
                if ('ontouchstart' in document.documentElement) {
                    chartDiv.addEventListener('touchstart', function(event) {
                        _this.handleTouchMove.call(_this, event);
                        _this.handleTouchStart.call(_this, event);
                    }, true);

                    chartDiv.addEventListener('touchmove', function(event) {
                        _this.handleTouchMove.call(_this, event);
                    }, true);

                    chartDiv.addEventListener("touchend", function(event) {
                        _this.handleTouchEnd.call(_this, event);
                    }, true);
                }
            }

            chartDiv.addEventListener("mousedown", function(event) {
                _this.handleMouseDown.call(_this, event);
            }, true);

            chartDiv.addEventListener("mouseover", function(event) {
                _this.handleMouseOver.call(_this, event);
            }, true);

            chartDiv.addEventListener("mouseout", function(event) {
                _this.handleMouseOut.call(_this, event);
            }, true);
        } else {
            chartDiv.attachEvent("onmousedown", function(event) {
                _this.handleMouseDown.call(_this, event);
            });

            chartDiv.attachEvent("onmouseover", function(event) {
                _this.handleMouseOver.call(_this, event);
            });

            chartDiv.attachEvent("onmouseout", function(event) {
                _this.handleMouseOut.call(_this, event);
            });
        }
    },

    dispDUpd: function() {
        var _this = this;
        var type;
        if (_this.dispatchDataUpdated) {
            _this.dispatchDataUpdated = false;
            type = 'dataUpdated';
            _this.fire(type, {
                type: type,
                chart: _this
            });
        }
        if (!_this.chartCreated) {
            type = 'init';
            _this.fire(type, {
                type: type,
                chart: _this
            });
        }

        if (!_this.chartRendered) {
            type = 'rendered';
            _this.fire(type, {
                type: type,
                chart: _this
            });
            _this.chartRendered = true;
        }
        type = 'drawn';
        _this.fire(type, {
            type: type,
            chart: _this
        });
    },




    validateSize: function() {
        var _this = this;
        _this.measure();
        var legend = _this.legend;

        if (_this.realWidth != _this.previousWidth || _this.realHeight != _this.previousHeight) {

            if (_this.realWidth > 0 && _this.realHeight > 0) {
                _this.sizeChanged = true;
                if (legend) {
                    clearTimeout(_this.legendInitTO);
                    var legendInitTO = setTimeout(function() {
                        legend.invalidateSize();
                    }, 100);
                    _this.timeOuts.push(legendInitTO);
                    _this.legendInitTO = legendInitTO;
                }

                if (_this.type != "xy") {
                    _this.marginsUpdated = false;
                } else {
                    _this.marginsUpdated = true;
                }

                clearTimeout(_this.initTO);
                var initTO = setTimeout(function() {
                    _this.initChart();
                }, 150);
                _this.timeOuts.push(initTO);
                _this.initTO = initTO;
            }
        }
        _this.renderFix();
        if (legend) {
            legend.renderFix();
        }
    },

    invalidateSize: function() {
        var _this = this;
        _this.previousWidth = NaN;
        _this.previousHeight = NaN;
        _this.invalidateSizeReal();
    },

    invalidateSizeReal: function() {
        var _this = this;
        _this.marginsUpdated = false;
        clearTimeout(_this.validateTO);
        var validateTO = setTimeout(function() {
            _this.validateSize();
        }, 5);
        _this.timeOuts.push(validateTO);
        _this.validateTO = validateTO;
    },

    validateData: function(noReset) {
        var _this = this;
        if (_this.chartCreated) {
            _this.dataChanged = true;
            if (_this.type != "xy") {
                _this.marginsUpdated = false;
            } else {
                _this.marginsUpdated = true;
            }
            _this.initChart(noReset);
        }
    },

    validateNow: function() {
        var _this = this;
        _this.listenersAdded = false;
        _this.chartRendered = false;
        _this.write(_this.div);
    },

    showItem: function(dItem) {
        var _this = this;
        dItem.hidden = false;
        _this.initChart();
    },

    hideItem: function(dItem) {
        var _this = this;
        dItem.hidden = true;
        _this.initChart();
    },

    hideBalloon: function() {
        var _this = this;
        clearInterval(_this.hoverInt);
        clearTimeout(_this.balloonTO);
        _this.hoverInt = setTimeout(function() {
            _this.hideBalloonReal.call(_this);
        }, _this.hideBalloonTime);
    },

    cleanChart: function() {
        // do not delete
    },

    hideBalloonReal: function() {
        var balloon = this.balloon;
        if (balloon) {
            balloon.hide();
        }
    },

    showBalloon: function(text, color, follow, x, y) {
        var _this = this;
        clearTimeout(_this.balloonTO);
        clearInterval(_this.hoverInt);
        _this.balloonTO = setTimeout(function() {
            _this.showBalloonReal.call(_this, text, color, follow, x, y);
        }, 1);
    },

    showBalloonReal: function(text, color, follow, x, y) {
        var _this = this;
        _this.handleMouseMove();

        var balloon = _this.balloon;
        if (balloon.enabled) {
            balloon.followCursor(false);
            balloon.changeColor(color);

            if (!follow || balloon.fixedPosition) {
                balloon.setPosition(x, y);
                balloon.followCursor(false);
            } else {
                balloon.followCursor(true);
            }
            if (text) {
                balloon.showBalloon(text);
            }
        }
    },


    // EVENT HANDLERS
    handleTouchMove: function(e) {
        var _this = this;
        _this.hideBalloon();
        var x;
        var y;
        var div = _this.chartDiv;

        if (e.touches) {
            var targetEvent = e.touches.item(0);

            _this.mouseX = targetEvent.pageX - AmCharts.findPosX(div);
            _this.mouseY = targetEvent.pageY - AmCharts.findPosY(div);
        }
    },

    handleMouseOver: function(e) {
        AmCharts.resetMouseOver();
        this.mouseIsOver = true;
    },

    handleMouseOut: function(e) {
        AmCharts.resetMouseOver();
        this.mouseIsOver = false;
    },

    handleMouseMove: function(e) {
        var _this = this;
        if (_this.mouseIsOver) {

            var div = _this.chartDiv;
            if (!e) {
                e = window.event;
            }

            var x;
            var y;

            if (e) {

                _this.posX = AmCharts.findPosX(div);
                _this.posY = AmCharts.findPosY(div);

                switch (_this.mouseMode) {
                    case 1:
                        x = e.clientX - _this.posX;
                        y = e.clientY - _this.posY;

                        if (!_this.divIsFixed) {
                            var body = document.body;
                            var x1;
                            var x2;

                            if (body) {
                                x1 = body.scrollLeft;
                                y1 = body.scrollTop;
                            }

                            var documentElement = document.documentElement;
                            if (documentElement) {
                                x2 = documentElement.scrollLeft;
                                y2 = documentElement.scrollTop;
                            }

                            var dx = Math.max(x1, x2);
                            var dy = Math.max(y1, y2);

                            x += dx;
                            y += dy;
                        }
                        break;
                    case 0:
                        if (_this.divIsFixed) {
                            x = e.clientX - _this.posX;
                            y = e.clientY - _this.posY;
                        } else {
                            x = e.pageX - _this.posX;
                            y = e.pageY - _this.posY;
                        }
                        break;
                }

                if (e.touches) {
                    var targetEvent = e.touches.item(0);

                    x = targetEvent.pageX - _this.posX;
                    y = targetEvent.pageY - _this.posY;
                }

                _this.mouseX = x - _this.dmouseX;
                _this.mouseY = y - _this.dmouseY;
            }
        }
    },

    handleTouchStart: function(e) {
        this.handleMouseDown(e);
    },

    handleTouchEnd: function(e) {
        AmCharts.resetMouseOver();
        this.handleReleaseOutside(e);
    },

    handleReleaseOutside: function(e) {
        // void
    },

    handleMouseDown: function(e) {
        AmCharts.resetMouseOver();
        this.mouseIsOver = true;

        if (e) {
            if (e.preventDefault) {
                e.preventDefault();
            }
        }
    },



    addLegend: function(legend, divId) {

        var _this = this;
        legend = AmCharts.processObject(legend, AmCharts.AmLegend, _this.theme);
        legend.divId = divId;

        var div;
        if (typeof(divId) != "object" && divId) {
            div = document.getElementById(divId);
        } else {
            div = divId;
        }

        _this.legend = legend;
        legend.chart = this;
        if (div) {
            legend.div = div;
            legend.position = "outside";
            legend.autoMargins = false;
        } else {
            legend.div = _this.legendDiv;
        }
        var handleLegendEvent = _this.handleLegendEvent;

        _this.listenTo(legend, "showItem", handleLegendEvent);
        _this.listenTo(legend, "hideItem", handleLegendEvent);
        _this.listenTo(legend, "clickMarker", handleLegendEvent);
        _this.listenTo(legend, "rollOverItem", handleLegendEvent);
        _this.listenTo(legend, "rollOutItem", handleLegendEvent);
        _this.listenTo(legend, "rollOverMarker", handleLegendEvent);
        _this.listenTo(legend, "rollOutMarker", handleLegendEvent);
        _this.listenTo(legend, "clickLabel", handleLegendEvent);
        return legend;
    },

    removeLegend: function() {
        this.legend = undefined;
        this.legendDiv.innerHTML = "";
    },

    handleResize: function() {
        var _this = this;

        if (AmCharts.isPercents(_this.width) || AmCharts.isPercents(_this.height)) {
            _this.invalidateSizeReal();
        }
        _this.renderFix();
    },

    renderFix: function() {
        if (!AmCharts.VML) {
            var container = this.container;
            if (container) {
                container.renderFix();
            }
        }
    },

    getSVG: function() {
        if (AmCharts.hasSVG) {
            return this.container;
        }
    },

    animate: function(obj, attribute, from, to, time, effect, suffix) {
        var _this = this;
        var node = obj.node;
        var nodeStyle = node.style;

        if (obj["an_" + attribute]) {
            AmCharts.removeFromArray(_this.animations, obj["an_" + attribute]);
        }

        var animation = {
            obj: obj,
            frame: 0,
            attribute: attribute,
            from: from,
            to: to,
            time: time,
            effect: effect,
            suffix: suffix
        };
        obj["an_" + attribute] = animation;
        _this.animations.push(animation);

        return animation;
    },

    setLegendData: function(data) {
        var _this = this;
        var legend = _this.legend;
        if (legend) {
            legend.setData(data);
        }
    },

    startInterval: function() {
        var _this = this;
        clearInterval(_this.interval);

        _this.interval = setInterval(function() {
            _this.updateAnimations.call(_this);
        }, AmCharts.updateRate);
    },

    stopAnim: function(animation) {
        var _this = this;
        AmCharts.removeFromArray(_this.animations, animation);
    },

    updateAnimations: function() {
        var _this = this;
        var i;

        if (_this.container) {
            _this.container.update();
        }

        for (i = _this.animations.length - 1; i >= 0; i--) {
            var animation = _this.animations[i];
            var totalCount = animation.time * 1000 / AmCharts.updateRate;
            var frame = animation.frame + 1;
            var obj = animation.obj;
            var attribute = animation.attribute;

            if (frame <= totalCount) {
                var value;
                animation.frame++;

                var from = Number(animation.from);
                var to = Number(animation.to);

                var change = to - from;

                value = AmCharts[animation.effect](0, frame, from, change, totalCount);

                if (change === 0) {
                    _this.animations.splice(i, 1);
                } else {
                    obj.node.style[attribute] = value + animation.suffix;
                }
            } else {
                obj.node.style[attribute] = Number(animation.to) + animation.suffix;
                _this.animations.splice(i, 1);
            }
        }
    },

    brr: function() {
/*
        var _this = this;
        var product = _this.product;
        var url = "amcharts.com";

        var host = window.location.hostname;
        var har = host.split(".");
        var mh;
        if (har.length >= 2) {
            mh = har[har.length - 2] + "." + har[har.length - 1];
        }

        if(_this.amLink){
            var parent = _this.amLink.parentNode;
            if(parent){
                parent.removeChild(_this.amLink);
            }
        }
        var creditsPosition =_this.creditsPosition;
        var PX = "px";

        if(mh != url){

            var x0 = 0;
            var y0 = 0;
            var w = _this.realWidth;
            var h = _this.realHeight;

            if(_this.type == "serial" || _this.type == "xy"){
                x0 = _this.marginLeftReal;
                y0 = _this.marginTopReal;
                w = x0 + _this.plotAreaWidth;
                h = y0 + _this.plotAreaHeight;
            }

            var link = "http://www.amcharts.com/javascript-charts/";
            var title = "JavaScript charts";
            var txt = "JS chart by amCharts";
            if(_this.product == "ammap"){
               link = "http://www.ammap.com/javascript-maps/";
               title = "Interactive JavaScript maps";
               txt = "JS map by amCharts";
            }

            var a = document.createElement('a');
            var aLabel = document.createTextNode(txt);
            a.setAttribute('href', link);
            a.setAttribute('title', title);
            a.appendChild(aLabel);
            _this.chartDiv.appendChild(a);

            _this.amLink = a;

            var astyle = a.style;
            astyle.position = "absolute";
            astyle.textDecoration = "none";
            astyle.color = _this.color;
            astyle.fontFamily = _this.fontFamily;
            astyle.fontSize = _this.fontSize + PX;
            astyle.opacity = 0.7;
            astyle.display = "block";

            var linkWidth = a.offsetWidth;
            var linkHeight = a.offsetHeight;

            var left = 5 + x0;
            var top = y0 + 5;

            if(creditsPosition == "bottom-left"){
                left = 5 + x0;
                top = h - linkHeight - 3;
            }

            if(creditsPosition == "bottom-right"){
                left = w - linkWidth - 5;
                top = h - linkHeight - 3;
            }

            if(creditsPosition == "top-right"){
                left = w - linkWidth - 5;
                top = y0 + 5;
            }

            astyle.left = left + PX;
            astyle.top = top + PX;
        }
*/
    }

});

// declaring only
AmCharts.Slice = AmCharts.Class({
    construct: function() {}
});
AmCharts.SerialDataItem = AmCharts.Class({
    construct: function() {}
});
AmCharts.GraphDataItem = AmCharts.Class({
    construct: function() {}
});
AmCharts.Guide = AmCharts.Class({
    construct: function(theme) {
        var _this = this;
        _this.cname = "Guide";
        AmCharts.applyTheme(_this, theme, _this.cname);
    }
});// @tag amchart
AmCharts.AmBalloon = AmCharts.Class({

    construct: function (theme) {
        var _this = this;
        _this.cname = "AmBalloon";
        _this.enabled = true;
        _this.fillColor = '#FFFFFF';
        _this.fillAlpha = 0.8;
        _this.borderThickness = 2;
        _this.borderColor = '#FFFFFF';
        _this.borderAlpha = 1;
        _this.cornerRadius = 0;
        _this.maximumWidth = 220;
        _this.horizontalPadding = 8;
        _this.verticalPadding = 4;
        _this.pointerWidth = 6;
        _this.pointerOrientation = "V";
        _this.color = '#000000';
        _this.adjustBorderColor = true;
        _this.showBullet = false;
        _this.follow = false;
        _this.show = false;
        _this.bulletSize = 3;
        _this.shadowAlpha = 0.4;
        _this.shadowColor = "#000000";
        _this.animationDuration = 0.3;
        _this.fadeOutDuration = 0.3;
        _this.fixedPosition = false;
        _this.offsetY = 6;
        _this.offsetX = 1;
        _this.textAlign = "center";

        if (!AmCharts.isModern) {
            _this.offsetY *= 1.5;
        }
        AmCharts.applyTheme(_this, theme, _this.cname);
    },

    draw: function () {
        var _this = this;
        var ptx = _this.pointToX;
        var pty = _this.pointToY;
        var PX = "px";
        _this.deltaSignY = 1;
        _this.deltaSignX = 1;
        var chart = _this.chart;
        var UNDEFINED;

        if (AmCharts.VML) {
            _this.fadeOutDuration = 0;
        }

        if (_this.xAnim) {
            chart.stopAnim(_this.xAnim);
        }
        if (_this.yAnim) {
            chart.stopAnim(_this.yAnim);
        }

        if (!isNaN(ptx)) {
            var follow = _this.follow;
            var container = chart.container;
            var set = _this.set;
            AmCharts.remove(set);

            _this.removeDiv();

            set = container.set();
            _this.set = set;

            chart.balloonsSet.push(set);

            if (_this.show) {
                var ll = _this.l;
                var tt = _this.t;
                var rr = _this.r;
                var bb = _this.b;

                var balloonColor = _this.balloonColor;
                var fillColor = _this.fillColor;
                var borderColor = _this.borderColor;
                var pointerColor = fillColor;

                if (balloonColor != UNDEFINED) {
                    if (_this.adjustBorderColor) {
                        borderColor = balloonColor;
                        pointerColor = borderColor;
                    } else {
                        fillColor = balloonColor;
                    }
                }

                var horizontalPadding = _this.horizontalPadding;
                var verticalPadding = _this.verticalPadding;
                var pointerWidth = _this.pointerWidth;
                var pointerOrientation = _this.pointerOrientation;
                var cornerRadius = _this.cornerRadius;
                var fontFamily = chart.fontFamily;
                var textSize = _this.fontSize;

                if (textSize == UNDEFINED) {
                    textSize = chart.fontSize;
                }

                var textDiv = document.createElement("div");
                var divStyle = textDiv.style;
                divStyle.position = "absolute";

                var minWidth = _this.minWidth;
                var minWidthStyle = "";
                if(!isNaN(minWidth)){
                    minWidthStyle = "min-width:" + (minWidth - horizontalPadding * 2) + "px; ";
                }

                var text = '<div style="text-align:' + _this.textAlign + '; '+ minWidthStyle +'max-width:' + _this.maxWidth + 'px; font-size:' + textSize + 'px; color:' + _this.color + '; font-family:' + fontFamily + '">' + _this.text + '</div>';
                textDiv.innerHTML = text;
                chart.chartDiv.appendChild(textDiv);
                _this.textDiv = textDiv;

                var divWidth = textDiv.offsetWidth;
                var divHeight = textDiv.offsetHeight;

                if (textDiv.clientHeight) {
                    divWidth = textDiv.clientWidth;
                    divHeight = textDiv.clientHeight;
                }

                var h = divHeight + 2 * verticalPadding;
                var w = divWidth + 2 * horizontalPadding;


                if(!isNaN(minWidth) && w < minWidth){
                    w = minWidth;
                }

                if (window.opera) {
                    h += 2;
                }

                var cx;
                var cy;

                var switched = false;
                var offsetY = _this.offsetY;
                if(chart.handDrawn){
                    offsetY += chart.handDrawScatter + 2;
                }

                // position of the balloon
                if (pointerOrientation != "H") {
                    cx = ptx - w / 2;
                    if (pty < tt + h + 10 && pointerOrientation != "down") {
                        switched = true;
                        if (follow) {
                            pty += offsetY;
                        }
                        cy = pty + pointerWidth;
                        _this.deltaSignY = -1;

                    } else {
                        if (follow) {
                            pty -= offsetY;
                        }
                        cy = pty - h - pointerWidth;
                        _this.deltaSignY = 1;
                        ty = -(pointerWidth + h - verticalPadding);
                    }

                } else {
                    if (pointerWidth * 2 > h) {
                        pointerWidth = h / 2;
                    }

                    cy = pty - h / 2;
                    if (ptx < ll + (rr - ll) / 2) {
                        cx = ptx + pointerWidth;
                        _this.deltaSignX = -1;
                    } else {
                        cx = ptx - w - pointerWidth;
                        _this.deltaSignX = 1;
                    }

                }
                // fit to bounds
                if (cy + h >= bb) {
                    cy = bb - h;
                }
                if (cy < tt) {
                    cy = tt;
                }
                if (cx < ll) {
                    cx = ll;
                }
                if (cx + w > rr) {
                    cx = rr - w;
                }


                var ty = cy + verticalPadding;
                var tx = cx + horizontalPadding;


                var shadowAlpha = _this.shadowAlpha;
                var shadowColor = _this.shadowColor;
                var borderThickness = _this.borderThickness;
                //place the ballloon
                var bg;
                var bulletSize = _this.bulletSize;
                var bgShadow;
                var pointer;
                if (cornerRadius > 0 || pointerWidth === 0) {
                    if (shadowAlpha > 0) {
                        bgShadow = AmCharts.rect(container, w, h, fillColor, 0, borderThickness + 1, shadowColor, shadowAlpha, _this.cornerRadius);
                        if (AmCharts.isModern) {
                            bgShadow.translate(1, 1);
                        } else {
                            bgShadow.translate(4, 4);
                        }

                        set.push(bgShadow);
                    }

                    bg = AmCharts.rect(container, w, h, fillColor, _this.fillAlpha, borderThickness, borderColor, _this.borderAlpha, _this.cornerRadius);
                    if (_this.showBullet) {
                        pointer = AmCharts.circle(container, bulletSize, pointerColor, _this.fillAlpha);
                        set.push(pointer);
                    }

                } else {
                    var xx = [];
                    var yy = [];
                    if (pointerOrientation != "H") {
                        var zx = ptx - cx; // center of the pointer root
                        if (zx > w - pointerWidth) {
                            zx = w - pointerWidth;
                        }

                        if (zx < pointerWidth) {
                            zx = pointerWidth;
                        }

                        xx = [0, zx - pointerWidth, ptx - cx, zx + pointerWidth, w, w, 0, 0];

                        if (switched) {
                            yy = [0, 0, pty - cy, 0, 0, h, h, 0];
                        } else {
                            yy = [h, h, pty - cy, h, h, 0, 0, h];
                        }
                    } else {
                        var zy = pty - cy; // center of the pointer root
                        if (zy > h - pointerWidth) {
                            zy = h - pointerWidth;
                        }

                        if (zy < pointerWidth) {
                            zy = pointerWidth;
                        }

                        yy = [0, zy - pointerWidth, pty - cy, zy + pointerWidth, h, h, 0, 0];

                        var midX;
                        if (ptx < ll + (rr - ll) / 2) {

                            if (cx < ptx) {
                                midX = 0;
                            } else {
                                midX = ptx - cx;
                            }

                            xx = [0, 0, midX, 0, 0, w, w, 0];
                        } else {


                            if (cx + w > ptx) {
                                midX = w;
                            } else {
                                midX = ptx - cx;
                            }

                            xx = [w, w, midX, w, w, 0, 0, w];
                        }
                    }

                    if (shadowAlpha > 0) {
                        bgShadow = AmCharts.polygon(container, xx, yy, fillColor, 0, borderThickness, shadowColor, shadowAlpha);
                        bgShadow.translate(1, 1);
                        set.push(bgShadow);
                    }

                    bg = AmCharts.polygon(container, xx, yy, fillColor, _this.fillAlpha, borderThickness, borderColor, _this.borderAlpha);

                }
                _this.bg = bg;
                set.push(bg);
                bg.toFront();

                var dx = 1 * _this.deltaSignX;

                divStyle.left = tx + PX;
                divStyle.top = ty + PX;

                set.translate(cx - dx, cy);
                var bgbox = bg.getBBox();
                _this.bottom = cy + h + 1;
                _this.yPos = bgbox.y + cy;

                if (pointer) {
                    pointer.translate(_this.pointToX - cx + dx, pty - cy);
                }

                var animationDuration = _this.animationDuration;
                if (_this.animationDuration > 0 && !follow) {
                    var effect = "easeOutSine";
                    if (!isNaN(_this.prevX)) {
                        set.translate(_this.prevX, _this.prevY);
                        set.animate({
                            'translate': cx - dx + ',' + cy
                        }, animationDuration, effect);

                        if (textDiv) {
                            divStyle.left = _this.prevTX + PX;
                            divStyle.top = _this.prevTY + PX;
                            _this.xAnim = chart.animate({
                                node: textDiv
                            }, 'left', _this.prevTX, tx, animationDuration, effect, PX);
                            _this.yAnim = chart.animate({
                                node: textDiv
                            }, 'top', _this.prevTY, ty, animationDuration, effect, PX);
                        }
                    }
                }

                _this.prevX = cx - dx;
                _this.prevY = cy;
                _this.prevTX = tx;
                _this.prevTY = ty;
            }
        }
    },

    followMouse: function () {
        var _this = this;
        if (_this.follow && _this.show) {
            var ptx = _this.chart.mouseX - (_this.offsetX * _this.deltaSignX);
            var pty = _this.chart.mouseY;
            _this.pointToX = ptx;
            _this.pointToY = pty;

            if (ptx != _this.previousX || pty != _this.previousY) {
                _this.previousX = ptx;
                _this.previousY = pty;
                if (_this.cornerRadius === 0) {
                    _this.draw();
                } else {
                    var set = _this.set;
                    if (set) {
                        var bb = set.getBBox();

                        var x = ptx - bb.width / 2;
                        var y = pty - bb.height - 10;

                        if (x < _this.l) {
                            x = _this.l;
                        }
                        if (x > _this.r - bb.width) {
                            x = _this.r - bb.width;
                        }

                        if (y < _this.t) {
                            y = pty + 10;
                        }

                        set.translate(x, y);
                        var divStyle = _this.textDiv.style;
                        divStyle.left = x + _this.horizontalPadding + "px";
                        divStyle.top = y + _this.verticalPadding + "px";
                    }
                }
            }
        }
    },

    changeColor: function (color) {
        this.balloonColor = color;
    },

    setBounds: function (l, t, r, b) {
        var _this = this;
        _this.l = l;
        _this.t = t;
        _this.r = r;
        _this.b = b;
        if (_this.destroyTO) {
            clearTimeout(_this.destroyTO);
        }
    },

    showBalloon: function (value) {
        var _this = this;
        _this.text = value;
        _this.show = true;
        if (_this.destroyTO) {
            clearTimeout(_this.destroyTO);
        }
        var chart = _this.chart;

        if(_this.fadeAnim1){
            chart.stopAnim(_this.fadeAnim1);
        }

        if(_this.fadeAnim2){
            chart.stopAnim(_this.fadeAnim2);
        }

        _this.draw();
    },

    hide: function () {
        var _this = this;
        var fadeOutDuration = _this.fadeOutDuration;
        var chart = _this.chart;
        if (fadeOutDuration > 0) {
            _this.destroyTO = setTimeout(function () {
                _this.destroy.call(_this);
            }, fadeOutDuration * 1000);

            _this.follow = false;
            _this.show = false;
            var set = _this.set;

            if (set) {
                set.setAttr("opacity", _this.fillAlpha);
                _this.fadeAnim1 = set.animate({
                    opacity: 0
                }, fadeOutDuration, "easeInSine");
            }

            if (_this.textDiv) {
                _this.fadeAnim2 = chart.animate({
                    node: _this.textDiv
                }, 'opacity', 1, 0, fadeOutDuration, "easeInSine", "");
            }
        } else {
            _this.show = false;
            _this.follow = false;
            _this.destroy();
        }
    },


    setPosition: function (x, y, redraw) {
        var _this = this;

        _this.pointToX = x;
        _this.pointToY = y;

        if (redraw) {
            if (x != _this.previousX || y != _this.previousY) {
                _this.draw();
            }
        }
        _this.previousX = x;
        _this.previousY = y;
    },

    followCursor: function (value) {
        var _this = this;
        _this.follow = value;
        if (value) {
            _this.pShowBullet = _this.showBullet;
            _this.showBullet = false;
        } else {
            if (_this.pShowBullet !== undefined) {
                _this.showBullet = _this.pShowBullet;
            }
        }
        clearInterval(_this.interval);

        var mouseX = _this.chart.mouseX;
        var mouseY = _this.chart.mouseY;

        if (!isNaN(mouseX)) {
            if (value) {
                _this.pointToX = mouseX - (_this.offsetX * _this.deltaSignX);
                _this.pointToY = mouseY;
                _this.followMouse();
                _this.interval = setInterval(function () {
                    _this.followMouse.call(_this);
                }, 40);
            }
        }
    },

    removeDiv: function () {
        var _this = this;
        if (_this.textDiv) {
            var parent = _this.textDiv.parentNode;
            if (parent) {
                parent.removeChild(_this.textDiv);
            }
        }
    },

    destroy: function () {
        var _this = this;
        clearInterval(_this.interval);
        AmCharts.remove(_this.set);
        _this.removeDiv();
        _this.set = null;
    }


});// @tag amchart
AmCharts.TrendLine = AmCharts.Class({

    construct: function(theme) {
        var _this = this;
        _this.cname = "TrendLine";
        _this.createEvents('click');
        _this.isProtected = false;
        _this.dashLength = 0;
        _this.lineColor = "#00CC00";
        _this.lineAlpha = 1;
        _this.lineThickness = 1;

        AmCharts.applyTheme(_this, theme, _this.cname);
    },

    draw: function() {
        var _this = this;
        _this.destroy();
        var chart = _this.chart;
        var container = chart.container;

        var x1;
        var x2;
        var y1;
        var y2;

        var categoryAxis = _this.categoryAxis;
        var initialDate = _this.initialDate;
        var initialCategory = _this.initialCategory;
        var finalDate = _this.finalDate;
        var finalCategory = _this.finalCategory;
        var valueAxis = _this.valueAxis;
        var valueAxisX = _this.valueAxisX;
        var initialXValue = _this.initialXValue;
        var finalXValue = _this.finalXValue;
        var initialValue = _this.initialValue;
        var finalValue = _this.finalValue;

        var recalculateToPercents = valueAxis.recalculateToPercents;
        var dataDateFormat = chart.dataDateFormat;

        if (categoryAxis) {
            if (initialDate) {
                if (!(initialDate instanceof Date)) {
                    if (dataDateFormat) {
                        initialDate = AmCharts.stringToDate(initialDate, dataDateFormat);
                    } else {
                        initialDate = new Date(initialDate);
                    }
                }
                _this.initialDate = initialDate;
                x1 = categoryAxis.dateToCoordinate(initialDate);
            }
            if (initialCategory) {
                x1 = categoryAxis.categoryToCoordinate(initialCategory);
            }
            if (finalDate) {
                if (!(finalDate instanceof Date)) {
                    if (dataDateFormat) {
                        finalDate = AmCharts.stringToDate(finalDate, dataDateFormat);
                    } else {
                        finalDate = new Date(finalDate);
                    }
                }
                _this.finalDate = finalDate;
                x2 = categoryAxis.dateToCoordinate(finalDate);
            }
            if (finalCategory) {
                x2 = categoryAxis.categoryToCoordinate(finalCategory);
            }
        }

        if (valueAxisX) {
            if (!recalculateToPercents) {
                if (!isNaN(initialXValue)) {
                    x1 = valueAxisX.getCoordinate(initialXValue);
                }
                if (!isNaN(finalXValue)) {
                    x2 = valueAxisX.getCoordinate(finalXValue);
                }
            }
        }

        if (valueAxis) {
            if (!recalculateToPercents) {
                if (!isNaN(initialValue)) {
                    y1 = valueAxis.getCoordinate(initialValue);
                }
                if (!isNaN(finalValue)) {
                    y2 = valueAxis.getCoordinate(finalValue);
                }
            }
        }

        if (!isNaN(x1) && !isNaN(x2) && !isNaN(y1) && !isNaN(y1)) {
            var rotate = chart.rotate;
            var xa;
            var ya;

            if (rotate) {
                xa = [y1, y2];
                ya = [x1, x2];
            } else {
                xa = [x1, x2];
                ya = [y1, y2];
            }

            var lineColor = _this.lineColor;
            var line = AmCharts.line(container, xa, ya, lineColor, _this.lineAlpha, _this.lineThickness, _this.dashLength);

            var xArray = xa;
            var yArray = ya;

            var a = (xa[1] - xa[0]);
            var b = (ya[1] - ya[0]);
            if(a === 0){
                a = 0.01;
            }

            if(b === 0){
                b = 0.01;
            }

            var signX = a / Math.abs(a);
            var signY = b / Math.abs(b);

            var sign = (a * b) / Math.abs(a * b);

            var c = sign * Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));

            var delta = 5;

            var angle1 = Math.asin(a / c);
            var angle2 = 90 * Math.PI / 180 - angle1;

            var dy = Math.abs(Math.cos(angle2) * delta);
            var dx = Math.abs(Math.sin(angle2) * delta);


            xArray.push(xa[1] - signX * dx, xa[0] - signX * dx);
            yArray.push(ya[1] + signY * dy, ya[0] + signY * dy);

            var hoverLine = AmCharts.polygon(container, xArray, yArray, lineColor, 0.005, 0);

            var set = container.set([hoverLine, line]);
            set.translate(chart.marginLeftReal, chart.marginTopReal);
            chart.trendLinesSet.push(set);

            _this.line = line;
            _this.set = set;

            hoverLine.mouseup(function() {
                _this.handleLineClick();
            }).mouseover(function() {
                _this.handleLineOver();
            }).mouseout(function() {
                _this.handleLineOut();
            });

            if (hoverLine.touchend) {
                hoverLine.touchend(function() {
                    _this.handleLineClick();
                });
            }
        }
    },

    handleLineClick: function() {
        var _this = this;
        var event = {
            type: "click",
            trendLine: this,
            chart: _this.chart
        };
        _this.fire(event.type, event);
    },

    handleLineOver: function() {
        var _this = this;
        var rollOverColor = _this.rollOverColor;
        if (rollOverColor !== undefined) {
            _this.line.attr({
                stroke: rollOverColor
            });
        }
    },

    handleLineOut: function() {
        var _this = this;
        _this.line.attr({
            stroke: _this.lineColor
        });
    },

    destroy: function() {
        AmCharts.remove(this.set);
    }
});// @tag amchart
AmCharts.AmCoordinateChart = AmCharts.Class({

    inherits: AmCharts.AmChart,

    construct: function (theme) {
        var _this = this;
        AmCharts.AmCoordinateChart.base.construct.call(_this, theme);
        _this.theme = theme;
        _this.createEvents('rollOverGraphItem', 'rollOutGraphItem', 'clickGraphItem', 'doubleClickGraphItem', 'rightClickGraphItem', 'clickGraph', 'rollOverGraph', 'rollOutGraph');
        _this.startAlpha = 1;
        _this.startDuration = 0;
        _this.startEffect = 'elastic';
        _this.sequencedAnimation = true;
        _this.colors = ['#FF6600', '#FCD202', '#B0DE09', '#0D8ECF', '#2A0CD0', '#CD0D74', '#CC0000', '#00CC00', '#0000CC', '#DDDDDD', '#999999', '#333333', '#990000'];
        _this.balloonDateFormat = "MMM DD, YYYY";
        _this.valueAxes = [];
        _this.graphs = [];
        _this.guides = [];
        _this.gridAboveGraphs = false;

        AmCharts.applyTheme(_this, theme, "AmCoordinateChart");
    },

    initChart: function () {
        var _this = this;
        AmCharts.AmCoordinateChart.base.initChart.call(_this);

        var categoryAxis = _this.categoryAxis;
        if(categoryAxis){
            _this.categoryAxis = AmCharts.processObject(categoryAxis, AmCharts.CategoryAxis, _this.theme);
        }

        _this.processValueAxes();

        _this.createValueAxes();

        _this.processGraphs();

        _this.processGuides();

        if (AmCharts.VML) {
            _this.startAlpha = 1;
        }
        _this.setLegendData(_this.graphs);

        if(_this.gridAboveGraphs){
            _this.gridSet.toFront();
        }
    },


    createValueAxes: function () {
        var _this = this;
        if (_this.valueAxes.length === 0) {
            var valueAxis = new AmCharts.ValueAxis();
            _this.addValueAxis(valueAxis);
        }
    },


    parseData: function () {
        var _this = this;
        _this.processValueAxes();
        _this.processGraphs();
    },

    parseSerialData: function () {
        var _this = this;

        var graphs = _this.graphs;
        var graph;
        var emptyObj = {};
        var seriesIdField = _this.seriesIdField;
        if (!seriesIdField) {
            seriesIdField = _this.categoryField;
        }

        _this.chartData = [];
        var dataProvider = _this.dataProvider;
        if (dataProvider) {
            var parseDates = false;
            var categoryFunction;
            var categoryAxis = _this.categoryAxis;
            var forceShowField;
            if (categoryAxis) {
                parseDates = categoryAxis.parseDates;
                forceShowField = categoryAxis.forceShowField;
                categoryFunction = categoryAxis.categoryFunction;
            }

            var periodObj;
            var cleanPeriod;
            var periodCount;
            var previousTime;
            var periodDuration;

            if (parseDates) {
                periodObj = AmCharts.extractPeriod(categoryAxis.minPeriod);
                cleanPeriod = periodObj.period;
                periodCount = periodObj.count;
                periodDuration = AmCharts.getPeriodDuration(cleanPeriod, periodCount);
            }

            var lookupTable = {};
            _this.lookupTable = lookupTable;

            var i;
            var dataDateFormat = _this.dataDateFormat;
            var previousDataItem;


            for (i = 0; i < dataProvider.length; i++) {
                var serialDataItem = {};
                var dataItemRaw = dataProvider[i];
                var value = dataItemRaw[_this.categoryField];
                serialDataItem.dataContext = dataItemRaw;

                if (categoryFunction) {
                    serialDataItem.category = categoryFunction(value, dataItemRaw, categoryAxis);
                } else {
                    serialDataItem.category = String(value);
                }

                if (forceShowField) {
                    serialDataItem.forceShow = dataItemRaw[forceShowField];
                }

                var seriesId = dataItemRaw[seriesIdField];
                lookupTable[seriesId] = serialDataItem;

                if (parseDates) {

                    if (categoryAxis.categoryFunction) {
                        value = categoryAxis.categoryFunction(value, dataItemRaw, categoryAxis);
                    } else {
                        if (value instanceof Date) {
                            // it is required to get each period, as in case milliseconds are used, FF and IE won't get them
                            if (categoryAxis.minPeriod == "fff") {
                                if (AmCharts.useUTC) {
                                    value = new Date(value.getUTCFullYear(), value.getUTCMonth(), value.getUTCDate(), value.getUTCHours(), value.getUTCMinutes(), value.getUTCSeconds(), value.getUTCMilliseconds());
                                } else {
                                    value = new Date(value.getFullYear(), value.getMonth(), value.getDate(), value.getHours(), value.getMinutes(), value.getSeconds(), value.getMilliseconds());
                                }
                            }
                            // the above would do the same, but this is faster
                            else {
                                value = new Date(value);
                            }
                        } else if (dataDateFormat) {
                            value = AmCharts.stringToDate(value, dataDateFormat);
                        } else {
                            value = new Date(value);
                        }
                    }

                    value = AmCharts.resetDateToMin(value, cleanPeriod, periodCount, categoryAxis.firstDayOfWeek);

                    serialDataItem.category = value;
                    serialDataItem.time = value.getTime();
                }

                var valueAxes = _this.valueAxes;
                serialDataItem.axes = {};
                serialDataItem.x = {};
                var j;
                for (j = 0; j < valueAxes.length; j++) {
                    var axisId = valueAxes[j].id;

                    serialDataItem.axes[axisId] = {};
                    serialDataItem.axes[axisId].graphs = {};
                    var k;
                    for (k = 0; k < graphs.length; k++) {
                        graph = graphs[k];
                        var graphId = graph.id;

                        var periodValue = graph.periodValue;

                        if (graph.valueAxis.id == axisId) {
                            serialDataItem.axes[axisId].graphs[graphId] = {};

                            var graphDataItem = {};
                            graphDataItem.index = i;

                            var rawItem = dataItemRaw;
                            if (graph.dataProvider) {
                                rawItem = emptyObj;
                            }

                            graphDataItem.values = _this.processValues(rawItem, graph, periodValue);

                            if(!graph.connect){
                                if(previousDataItem){
                                    if(serialDataItem.time - previousTime > periodDuration * 1.1){
                                        previousDataItem.gap = true;
                                    }
                                }
                            }

                            _this.processFields(graph, graphDataItem, rawItem);

                            graphDataItem.category = serialDataItem.category;
                            graphDataItem.serialDataItem = serialDataItem;
                            graphDataItem.graph = graph;
                            serialDataItem.axes[axisId].graphs[graphId] = graphDataItem;
                        }
                    }
                }
                _this.chartData[i] = serialDataItem;
                previousTime = serialDataItem.time;
                previousDataItem = graphDataItem;
            }
        }

        var g;
        for (g = 0; g < graphs.length; g++) {
            graph = graphs[g];
            if (graph.dataProvider) {
                _this.parseGraphData(graph);
            }
        }
    },


    processValues: function (dataItemRaw, graph, periodValue) {
        var values = {};
        var val;
        var candle = false;
        if ((graph.type == "candlestick" || graph.type == "ohlc") && periodValue !== "") {
            candle = true;
        }
        val = Number(dataItemRaw[graph.valueField + periodValue]);

        if (!isNaN(val)) {
            values.value = val;
        }

        // error
        val = Number(dataItemRaw[graph.errorField + periodValue]);

        if (!isNaN(val)) {
            values.error = val;
        }
        // end of error

        if (candle) {
            periodValue = "Open";
        }

        val = Number(dataItemRaw[graph.openField + periodValue]);

        if (!isNaN(val)) {
            values.open = val;
        }

        if (candle) {
            periodValue = "Close";
        }

        val = Number(dataItemRaw[graph.closeField + periodValue]);
        if (!isNaN(val)) {
            values.close = val;
        }

        if (candle) {
            periodValue = "Low";
        }

        val = Number(dataItemRaw[graph.lowField + periodValue]);
        if (!isNaN(val)) {
            values.low = val;
        }

        if (candle) {
            periodValue = "High";
        }

        val = Number(dataItemRaw[graph.highField + periodValue]);
        if (!isNaN(val)) {
            values.high = val;
        }

        return values;
    },


    parseGraphData: function (graph) {
        var _this = this;
        var dataProvider = graph.dataProvider;
        var categoryField = graph.categoryField;
        if (!categoryField) {
            categoryField = _this.categoryField;
        }

        var seriesIdField = graph.seriesIdField;
        if (!seriesIdField) {
            seriesIdField = _this.seriesIdField;
        }
        if (!seriesIdField) {
            seriesIdField = _this.categoryField;
        }
        var i;
        for (i = 0; i < dataProvider.length; i++) {
            var dataItemRaw = dataProvider[i];
            var seriesId = String(dataItemRaw[seriesIdField]);
            var serialDataItem = _this.lookupTable[seriesId];
            var chartId = graph.chart.id;
            var axisId = graph.valueAxis.id;

            if (serialDataItem) {
                var graphDataItem = serialDataItem.axes[axisId].graphs[graph.id];
                graphDataItem.serialDataItem = serialDataItem;
                var periodValue = graph.periodValue;
                graphDataItem.values = _this.processValues(dataItemRaw, graph, periodValue);
                _this.processFields(graph, graphDataItem, dataItemRaw);
            }
        }
    },


    addValueAxis: function (axis) {
        var _this = this;
        axis.chart = this;
        _this.valueAxes.push(axis);
        _this.validateData();
    },

    removeValueAxesAndGraphs: function () {
        var _this = this;
        var valueAxes = _this.valueAxes;
        var i;
        for (i = valueAxes.length - 1; i > -1; i--) {
            _this.removeValueAxis(valueAxes[i]);
        }
    },

    removeValueAxis: function (valueAxis) {
        var _this = this;
        var graphs = _this.graphs;
        var i;

        for (i = graphs.length - 1; i >= 0; i--) {
            var graph = graphs[i];
            if (graph) {
                if (graph.valueAxis == valueAxis) {
                    _this.removeGraph(graph);
                }
            }
        }

        var valueAxes = _this.valueAxes;

        for (i = valueAxes.length - 1; i >= 0; i--) {
            if (valueAxes[i] == valueAxis) {
                valueAxes.splice(i, 1);
            }
        }
        _this.validateData();
    },

    addGraph: function (graph) {
        var _this = this;
        _this.graphs.push(graph);
        _this.chooseGraphColor(graph, _this.graphs.length - 1);
        _this.validateData();
    },

    removeGraph: function (graph) {
        var _this = this;
        var graphs = _this.graphs;
        var i;
        for (i = graphs.length - 1; i >= 0; i--) {
            if (graphs[i] == graph) {
                graphs.splice(i, 1);
                graph.destroy();
            }
        }
        _this.validateData();
    },

    processValueAxes: function () {
        var _this = this;
        var valueAxes = _this.valueAxes;
        var i;

        for (i = 0; i < valueAxes.length; i++) {
            var valueAxis = valueAxes[i];
            valueAxis = AmCharts.processObject(valueAxis, AmCharts.ValueAxis, _this.theme);
            valueAxes[i] = valueAxis;
            valueAxis.chart = this;

            if (!valueAxis.id) {
                valueAxis.id = "valueAxisAuto" + i + "_" + new Date().getTime();
            }
            if (valueAxis.usePrefixes === undefined) {
                valueAxis.usePrefixes = _this.usePrefixes;
            }
        }
    },

    processGuides: function () {
        var _this = this;
        var guides = _this.guides;
        var categoryAxis = _this.categoryAxis;
        if(guides){
            for(var i = 0; i < guides.length; i++){
                var guide = guides[i];
                if(guide.category !== undefined || guide.date !== undefined){
                    if(categoryAxis){
                        categoryAxis.addGuide(guide);
                    }
                }
                if(guide.valueAxis){
                    guide.valueAxis.addGuide(guide);
                }
                else if(!isNaN(guide.value)){
                    _this.valueAxes[0].addGuide(guide);
                }
            }
        }
    },

    processGraphs: function () {
        var _this = this;
        var graphs = _this.graphs;
        var i;

        for (i = 0; i < graphs.length; i++) {
            var graph = graphs[i];

            graph = AmCharts.processObject(graph, AmCharts.AmGraph, _this.theme);
            graphs[i] = graph;
            _this.chooseGraphColor(graph, i);

            graph.chart = this;

            if(AmCharts.isString(graph.valueAxis)){
                graph.valueAxis = _this.getValueAxisById(graph.valueAxis);
            }

            if (!graph.valueAxis) {
                graph.valueAxis = _this.valueAxes[0];
            }

            if (!graph.id) {
                graph.id = "graphAuto" + i + "_" + new Date().getTime();
            }
        }
    },

    formatString: function (text, dItem, noFixBrakes) {
        var _this = this;
        var graph = dItem.graph;

        // format duration
        var valAxis = graph.valueAxis;
        if (valAxis.duration) {
            if (dItem.values.value) {
                var duration = AmCharts.formatDuration(dItem.values.value, valAxis.duration, "", valAxis.durationUnits, valAxis.maxInterval, valAxis.numberFormatter);
                text = text.split("[[value]]").join(duration);
            }
        }

        text = AmCharts.massReplace(text, {
            "[[title]]": graph.title,
                "[[description]]": dItem.description
        });
        if(!noFixBrakes){
           text = AmCharts.fixBrakes(text);
        }
        else{
            // balloon
           text = AmCharts.fixNewLines(text);
        }
        text = AmCharts.cleanFromEmpty(text);

        return text;
    },


    getBalloonColor: function (graph, graphDataItem, graphIsPriority) {
        var _this = this;
        var color = graph.lineColor;
        var balloonColor = graph.balloonColor;

        if(graphIsPriority){
            balloonColor = color;
        }

        var fillColors = graph.fillColorsR;
        var UNDEFINED;

        if (typeof (fillColors) == 'object') {
            color = fillColors[0];
        } else if (fillColors !== UNDEFINED) {
            color = fillColors;
        }

        if (graphDataItem.isNegative) {
            var negativeColor = graph.negativeLineColor;
            var negativeFillColors = graph.negativeFillColors;
            if (typeof (negativeFillColors) == 'object') {
                negativeColor = negativeFillColors[0];
            } else if (negativeFillColors !== UNDEFINED) {
                negativeColor = negativeFillColors;
            }

            if (negativeColor !== UNDEFINED) {
                color = negativeColor;
            }
        }

        if (graphDataItem.color !== UNDEFINED) {
            color = graphDataItem.color;
        }

        if (balloonColor === UNDEFINED) {
            balloonColor = color;
        }
        return balloonColor;
    },

    getGraphById: function (id) {
        return AmCharts.getObjById(this.graphs, id);
    },

    getValueAxisById: function (id) {
        return AmCharts.getObjById(this.valueAxes, id);
    },


    processFields: function (graph, graphDataItem, dataItemRaw) {
        var _this = this;
        if (graph.itemColors) {
            var itemColors = graph.itemColors;
            var index = graphDataItem.index;

            if (index < itemColors.length) {
                graphDataItem.color = itemColors[index];
            } else {
                graphDataItem.color = AmCharts.randomColor();
            }
        }

        var fields = ['lineColor', 'color', 'alpha', 'fillColors', 'description', 'bullet', 'customBullet', 'bulletSize', 'bulletConfig', 'url', 'labelColor', 'dashLength', 'pattern'];
        var i;
        for (i = 0; i < fields.length; i++) {
            var field = fields[i];
            var fieldName = graph[field + 'Field'];

            if (fieldName) {
                var val = dataItemRaw[fieldName];
                if (AmCharts.isDefined(val)) {
                    graphDataItem[field] = val;
                }
            }
        }
        graphDataItem.dataContext = dataItemRaw;
    },

    chooseGraphColor: function (graph, index) {

        var _this = this;
        if (!graph.lineColor) {
            var color;
            if (_this.colors.length > index) {
                color = _this.colors[index];
            } else {
                color = AmCharts.randomColor();
            }

            graph.lineColorR = color;
        }
        else{
            graph.lineColorR = graph.lineColor;
        }
        if(!graph.fillColors){
            graph.fillColorsR = graph.lineColorR;
        }
        else{
            graph.fillColorsR = graph.fillColors;
        }
        if(!graph.bulletBorderColor){
            if(graph.useLineColorForBulletBorder){
                graph.bulletBorderColorR = graph.lineColorR;
            }
            else{
                graph.bulletBorderColorR = graph.bulletColor;
            }
        }
        else{
            graph.bulletBorderColorR = graph.bulletBorderColor;
        }

        if(!graph.bulletColor){
            graph.bulletColorR =graph.lineColorR;
        }
        else{
            graph.bulletColorR = graph.bulletColor;
        }

        var patterns = _this.patterns;
        if(patterns){
            graph.pattern = patterns[index];
        }
    },

    handleLegendEvent: function (event) {
        var _this = this;
        var type = event.type;
        var dataItem = event.dataItem;
        if(!_this.legend.data){
            if (dataItem) {
                var hidden = dataItem.hidden;
                var showBalloon = dataItem.showBalloon;

                switch (type) {
                    case 'clickMarker':
                        if (showBalloon) {
                            _this.hideGraphsBalloon(dataItem);
                        } else {
                            _this.showGraphsBalloon(dataItem);
                        }
                        break;

                    case 'clickLabel':

                        if (showBalloon) {
                            _this.hideGraphsBalloon(dataItem);
                        } else {
                            _this.showGraphsBalloon(dataItem);
                        }
                        break;

                    case 'rollOverItem':
                        if (!hidden) {
                            _this.highlightGraph(dataItem);
                        }
                        break;

                    case 'rollOutItem':
                        if (!hidden) {
                            _this.unhighlightGraph();
                        }
                        break;

                    case 'hideItem':
                        _this.hideGraph(dataItem);
                        break;

                    case 'showItem':
                        _this.showGraph(dataItem);
                        break;
                }
            }
        }
    },


    highlightGraph: function (thisGraph) {
        var _this = this;
        var graphs = _this.graphs;
        var i;
        var alpha = 0.2;

        if (_this.legend) {
            alpha = _this.legend.rollOverGraphAlpha;
        }

        if (alpha != 1) {
            for (i = 0; i < graphs.length; i++) {
                var graph = graphs[i];
                if (graph != thisGraph) {
                    graph.changeOpacity(alpha);
                }
            }
        }
    },

    unhighlightGraph: function () {
        var _this = this;
        var alpha;

        if (_this.legend) {
            alpha = _this.legend.rollOverGraphAlpha;
        }

        if (alpha != 1) {
            var graphs = _this.graphs;
            var i;
            for (i = 0; i < graphs.length; i++) {
                var graph = graphs[i];
                graph.changeOpacity(1);
            }
        }
    },

    showGraph: function (graph) {
        var _this = this;
        graph.hidden = false;
        _this.dataChanged = true;
        _this.marginsUpdated = false;
        if (_this.chartCreated) {
            _this.initChart();
        }
    },

    hideGraph: function (graph) {
        var _this = this;
        _this.dataChanged = true;
        _this.marginsUpdated = false;
        graph.hidden = true;
        if (_this.chartCreated) {
            _this.initChart();
        }
    },

    hideGraphsBalloon: function (graph) {
        var _this = this;
        graph.showBalloon = false;
        _this.updateLegend();
    },

    showGraphsBalloon: function (graph) {
        var _this = this;
        graph.showBalloon = true;
        _this.updateLegend();
    },

    updateLegend: function () {
        var _this = this;
        if (_this.legend) {
            _this.legend.invalidateSize();
        }
    },

    resetAnimation: function () {
        var _this = this;
        var graphs = _this.graphs;
        if (graphs) {
            var i;
            for (i = 0; i < graphs.length; i++) {
                graphs[i].animationPlayed = false;
            }
        }
    },

    animateAgain: function () {
        var _this = this;
        _this.resetAnimation();
        _this.validateNow();
    }

});// @tag amchart
AmCharts.AmRectangularChart = AmCharts.Class({

    inherits: AmCharts.AmCoordinateChart,

    construct: function (theme) {
        var _this = this;
        AmCharts.AmRectangularChart.base.construct.call(_this, theme);
        _this.theme = theme;
        _this.createEvents('zoomed');

        _this.marginLeft = 20;
        _this.marginTop = 20;
        _this.marginBottom = 20;
        _this.marginRight = 20;
        _this.angle = 0;
        _this.depth3D = 0;
        _this.horizontalPosition = 0;
        _this.verticalPosition = 0;
        _this.widthMultiplier = 1;
        _this.heightMultiplier = 1;

        _this.plotAreaFillColors = "#FFFFFF";
        _this.plotAreaFillAlphas = 0;
        _this.plotAreaBorderColor = "#000000";
        _this.plotAreaBorderAlpha = 0;

        // this one is deprecated since 3.2.1
        /*
        _this.zoomOutButton = {
            backgroundColor: '#e5e5e5',
            backgroundAlpha: 1
        };*/

        _this.zoomOutButtonImageSize = 17;
        _this.zoomOutButtonImage = "lens.png";
        _this.zoomOutText = "Show all";
        _this.zoomOutButtonColor = '#e5e5e5';
        _this.zoomOutButtonAlpha = 0;
        _this.zoomOutButtonRollOverAlpha = 1;
        _this.zoomOutButtonPadding = 8;
        //_this.zoomOutButtonFontSize;
        //_this.zoomOutButtonFontColor;

        _this.trendLines = [];
        _this.autoMargins = true;
        _this.marginsUpdated = false;
        _this.autoMarginOffset = 10;

        AmCharts.applyTheme(_this, theme, "AmRectangularChart");
    },

    initChart: function () {
        var _this = this;
        AmCharts.AmRectangularChart.base.initChart.call(_this);
        _this.updateDxy();

        var updateGraphs = true;
        if (!_this.marginsUpdated && _this.autoMargins) {
            _this.resetMargins();
            updateGraphs = false;
        }
        _this.processScrollbars();
        _this.updateMargins();
        _this.updatePlotArea();
        _this.updateScrollbars();
        _this.updateTrendLines();
        _this.updateChartCursor();
        _this.updateValueAxes();

        // no need to draw graphs for the first time, as only axes are rendered to measure margins
        if (updateGraphs) {
            if (!_this.scrollbarOnly) {
                _this.updateGraphs();
            }
        }
    },

    drawChart: function () {
        var _this = this;
        AmCharts.AmRectangularChart.base.drawChart.call(_this);
        _this.drawPlotArea();
        var chartData = _this.chartData;
        if (AmCharts.ifArray(chartData)) {
            var chartCursor = _this.chartCursor;
            if (chartCursor) {
                chartCursor.draw();
            }
            var zoomOutText = _this.zoomOutText;
            if (zoomOutText !== "" && zoomOutText) {
                _this.drawZoomOutButton();
            }
        }
    },


    resetMargins: function () {
        var _this = this;

        var fixMargins = {};
        var i;

        if (_this.type == "serial") {
            var valueAxes = _this.valueAxes;

            for (i = 0; i < valueAxes.length; i++) {
                var valueAxis = valueAxes[i];
                if (!valueAxis.ignoreAxisWidth) {
                    valueAxis.setOrientation(_this.rotate);
                    valueAxis.fixAxisPosition();
                    fixMargins[valueAxis.position] = true;
                }
            }

            var categoryAxis = _this.categoryAxis;
            if (categoryAxis) {
                if (!categoryAxis.ignoreAxisWidth) {
                    categoryAxis.setOrientation(!_this.rotate);
                    categoryAxis.fixAxisPosition();
                    categoryAxis.fixAxisPosition();
                    fixMargins[categoryAxis.position] = true;
                }
            }
        }
        // xy
        else {
            var xAxes = _this.xAxes;
            var yAxes = _this.yAxes;

            for (i = 0; i < xAxes.length; i++) {
                var xAxis = xAxes[i];
                if (!xAxis.ignoreAxisWidth) {
                    xAxis.setOrientation(true);
                    xAxis.fixAxisPosition();
                    fixMargins[xAxis.position] = true;
                }
            }
            for (i = 0; i < yAxes.length; i++) {
                var yAxis = yAxes[i];
                if (!yAxis.ignoreAxisWidth) {
                    yAxis.setOrientation(false);
                    yAxis.fixAxisPosition();
                    fixMargins[yAxis.position] = true;
                }
            }
        }


        if (fixMargins.left) {
            _this.marginLeft = 0;
        }
        if (fixMargins.right) {
            _this.marginRight = 0;
        }
        if (fixMargins.top) {
            _this.marginTop = 0;
        }
        if (fixMargins.bottom) {
            _this.marginBottom = 0;
        }

        _this.fixMargins = fixMargins;
    },

    measureMargins: function () {

        var _this = this;
        var valueAxes = _this.valueAxes;
        var bounds;
        var autoMarginOffset = _this.autoMarginOffset;
        var fixMargins = _this.fixMargins;
        var realWidth = _this.realWidth;
        var realHeight = _this.realHeight;

        var l = autoMarginOffset;
        var t = autoMarginOffset;
        var r = realWidth; //3.4.3 - autoMarginOffset;
        var b = realHeight; // 3.4.3 - autoMarginOffset;
        var i;
        for (i = 0; i < valueAxes.length; i++) {
            bounds = _this.getAxisBounds(valueAxes[i], l, r, t, b);
            l = Math.round(bounds.l);
            r = Math.round(bounds.r);
            t = Math.round(bounds.t);
            b = Math.round(bounds.b);
        }

        var categoryAxis = _this.categoryAxis;
        if (categoryAxis) {
            bounds = _this.getAxisBounds(categoryAxis, l, r, t, b);
            l = Math.round(bounds.l);
            r = Math.round(bounds.r);
            t = Math.round(bounds.t);
            b = Math.round(bounds.b);
        }

        if (fixMargins.left && l < autoMarginOffset) {
            _this.marginLeft = Math.round(-l + autoMarginOffset);
        }
        if (fixMargins.right && r >= realWidth - autoMarginOffset) {
            _this.marginRight = Math.round(r - realWidth + autoMarginOffset);
        }
        if (fixMargins.top && t < autoMarginOffset + _this.titleHeight) {
            _this.marginTop = Math.round(_this.marginTop - t + autoMarginOffset + _this.titleHeight);
        }
        if (fixMargins.bottom && b > realHeight - autoMarginOffset) {
            _this.marginBottom = Math.round(_this.marginBottom + b - realHeight + autoMarginOffset);
        }
        //_this.resetAnimation();
        _this.initChart();
    },

    getAxisBounds: function (axis, l, r, t, b) {
        var x;
        var y;

        if (!axis.ignoreAxisWidth) {
            var set = axis.labelsSet;
            var tickLength = axis.tickLength;
            if (axis.inside) {
                tickLength = 0;
            }

            if (set) {
                var bbox = axis.getBBox();

                switch (axis.position) {
                    case "top":
                        y = bbox.y;

                        if (t > y) {
                            t = y;
                        }

                        break;
                    case "bottom":
                        y = bbox.y + bbox.height;

                        if (b < y) {
                            b = y;
                        }
                        break;
                    case "right":

                        x = bbox.x + bbox.width + tickLength + 3;

                        if (r < x) {
                            r = x;
                        }

                        break;
                    case "left":
                        x = bbox.x - tickLength;

                        if (l > x) {
                            l = x;
                        }
                        break;
                }
            }
        }

        return ({
            l: l,
            t: t,
            r: r,
            b: b
        });
    },


    drawZoomOutButton: function () {
        var _this = this;
        var zbSet = _this.container.set();
        _this.zoomButtonSet.push(zbSet);
        var color = _this.color;
        var fontSize = _this.fontSize;
        var zoomOutButtonImageSize = _this.zoomOutButtonImageSize;
        var zoomOutButtonImage = _this.zoomOutButtonImage;
        var zoomOutText = _this.zoomOutText;
        var zoomOutButtonColor = _this.zoomOutButtonColor;
        var zoomOutButtonAlpha = _this.zoomOutButtonAlpha;
        var zoomOutButtonFontSize = _this.zoomOutButtonFontSize;
        var zoomOutButtonPadding = _this.zoomOutButtonPadding;
        if(!isNaN(zoomOutButtonFontSize)){
            fontSize = zoomOutButtonFontSize;
        }
        var zoomOutButtonFontColor = _this.zoomOutButtonFontColor;
        if(zoomOutButtonFontColor){
            color = zoomOutButtonFontColor;
        }

        // this one is depracated, but still checking
        var zoomOutButton = _this.zoomOutButton;
        var bbox;

        if (zoomOutButton) {
            if (zoomOutButton.fontSize) {
                fontSize = zoomOutButton.fontSize;
            }
            if (zoomOutButton.color) {
                color = zoomOutButton.color;
            }
            if(zoomOutButton.backgroundColor){
                zoomOutButtonColor = zoomOutButton.backgroundColor;
            }
            if(!isNaN(zoomOutButton.backgroundAlpha)){
                _this.zoomOutButtonRollOverAlpha = zoomOutButton.backgroundAlpha;
            }
        }

        var labelX = 0;
        var labelY = 0;
        if (_this.pathToImages !== undefined && zoomOutButtonImage){
            var image = _this.container.image(_this.pathToImages + zoomOutButtonImage, 0, 0, zoomOutButtonImageSize, zoomOutButtonImageSize);
            zbSet.push(image);

            bbox = image.getBBox();
            labelX = bbox.width + 5;
        }

        if(zoomOutText !== undefined){
            var label = AmCharts.text(_this.container, zoomOutText, color, _this.fontFamily, fontSize, 'start');
            var labelBox = label.getBBox();

            if(bbox){
                labelY = bbox.height / 2 - 3;
            }
            else{
                labelY = labelBox.height / 2;
            }
            label.translate(labelX, labelY);
            zbSet.push(label);
        }

        bbox = zbSet.getBBox();
        var borderAlpha = 1;
        if(!AmCharts.isModern){
            borderAlpha = 0;
        }

        var bg = AmCharts.rect(_this.container, bbox.width + zoomOutButtonPadding * 2 + 5, bbox.height + zoomOutButtonPadding * 2 - 2, zoomOutButtonColor, 1, 1, zoomOutButtonColor, borderAlpha);
        bg.setAttr("opacity", zoomOutButtonAlpha);
        bg.translate(-zoomOutButtonPadding, -zoomOutButtonPadding);
        zbSet.push(bg);
        bg.toBack();
        _this.zbBG = bg;

        bbox = bg.getBBox();
        zbSet.translate((_this.marginLeftReal + _this.plotAreaWidth - bbox.width + zoomOutButtonPadding), _this.marginTopReal + zoomOutButtonPadding);
        zbSet.hide();

        zbSet.mouseover(function () {
            _this.rollOverZB();
        }).mouseout(function () {
            _this.rollOutZB();
        }).click(function () {
            _this.clickZB();
        }).touchstart(function () {
            _this.rollOverZB();
        }).touchend(function () {
            _this.rollOutZB();
            _this.clickZB();
        });
        var j;
        for (j = 0; j < zbSet.length; j++) {
            zbSet[j].attr({
                cursor: 'pointer'
            });
        }
        _this.zbSet = zbSet;
    },

    rollOverZB: function () {
        this.zbBG.setAttr("opacity", this.zoomOutButtonRollOverAlpha);
    },

    rollOutZB: function () {
        this.zbBG.setAttr("opacity", this.zoomOutButtonAlpha);
    },

    clickZB: function () {
        this.zoomOut();
    },

    zoomOut: function () {
        var _this = this;
        _this.updateScrollbar = true;
        _this.zoom();
    },

    drawPlotArea: function () {
        var _this = this;
        var dx = _this.dx;
        var dy = _this.dy;
        var x0 = _this.marginLeftReal;
        var y0 = _this.marginTopReal;
        var w = _this.plotAreaWidth - 1;
        var h = _this.plotAreaHeight - 1;
        var color = _this.plotAreaFillColors;
        var alpha = _this.plotAreaFillAlphas;
        var plotAreaBorderColor = _this.plotAreaBorderColor;
        var plotAreaBorderAlpha = _this.plotAreaBorderAlpha;

        // clip trend lines set
        _this.trendLinesSet.clipRect(x0, y0, w, h);

        if (typeof (alpha) == 'object') {
            alpha = alpha[0];
        }

        var bg = AmCharts.polygon(_this.container, [0, w, w, 0, 0], [0, 0, h, h, 0], color, alpha, 1, plotAreaBorderColor, plotAreaBorderAlpha, _this.plotAreaGradientAngle);
        bg.translate(x0 + dx, y0 + dy);
        //bg.node.setAttribute("class", "amChartsPlotArea"); // this made IE8 work incorrectly
        _this.set.push(bg);

        if (dx !== 0 && dy !== 0) {
            color = _this.plotAreaFillColors;
            if (typeof (color) == 'object') {
                color = color[0];
            }
            color = AmCharts.adjustLuminosity(color, -0.15);

            var attr = {
                'fill': color,
                    'fill-opacity': alpha,
                    'stroke': _this.plotAreaBorderColor,
                    'stroke-opacity': _this.plotAreaBorderAlpha
            };

            var hSide = AmCharts.polygon(_this.container, [0, dx, w + dx, w, 0], [0, dy, dy, 0, 0], color, alpha, 1, plotAreaBorderColor, plotAreaBorderAlpha);
            hSide.translate(x0, (y0 + h));
            _this.set.push(hSide);

            var vSide = AmCharts.polygon(_this.container, [0, 0, dx, dx, 0], [0, h, h + dy, dy, 0], color, alpha, 1, plotAreaBorderColor, plotAreaBorderAlpha);
            vSide.translate(x0, y0);
            _this.set.push(vSide);
        }

        var bbset = _this.bbset;
        if(bbset){
            if(_this.scrollbarOnly){
                bbset.remove();
            }
        }

    },

    updatePlotArea: function () {
        var _this = this;
        var realWidth = _this.updateWidth();
        var realHeight = _this.updateHeight();
        var container = _this.container;

        _this.realWidth = realWidth;
        _this.realWidth = realHeight;

        if (container) {
            _this.container.setSize(realWidth, realHeight);
        }

        var dx = _this.dx;
        var dy = _this.dy;
        var x0 = _this.marginLeftReal;
        var y0 = _this.marginTopReal;

        var w = realWidth - x0 - _this.marginRightReal - dx;
        var h = realHeight - y0 - _this.marginBottomReal;

        if (w < 1) {
            w = 1;
        }

        if (h < 1) {
            h = 1;
        }

        _this.plotAreaWidth = Math.round(w);
        _this.plotAreaHeight = Math.round(h);
    },

    updateDxy: function () {
        var _this = this;
        _this.dx = Math.round(_this.depth3D * Math.cos(_this.angle * Math.PI / 180));
        _this.dy = Math.round(-_this.depth3D * Math.sin(_this.angle * Math.PI / 180));

        _this.d3x = Math.round(_this.columnSpacing3D * Math.cos(_this.angle * Math.PI / 180));
        _this.d3y = Math.round(-_this.columnSpacing3D * Math.sin(_this.angle * Math.PI / 180));
    },

    updateMargins: function () {
        var _this = this;
        var titleHeight = _this.getTitleHeight();
        _this.titleHeight = titleHeight;
        _this.marginTopReal = _this.marginTop - _this.dy + titleHeight;
        _this.marginBottomReal = _this.marginBottom;
        _this.marginLeftReal = _this.marginLeft;
        _this.marginRightReal = _this.marginRight;
    },

    updateValueAxes: function () {
        var _this = this;
        var valueAxes = _this.valueAxes;

        var marginLeftReal = this.marginLeftReal;
        var marginTopReal = this.marginTopReal;
        var plotAreaHeight = _this.plotAreaHeight;
        var plotAreaWidth = _this.plotAreaWidth;
        var i;
        for (i = 0; i < valueAxes.length; i++) {
            var valueAxis = valueAxes[i];
            valueAxis.axisRenderer = AmCharts.RecAxis;
            valueAxis.guideFillRenderer = AmCharts.RecFill;
            valueAxis.axisItemRenderer = AmCharts.RecItem;
            valueAxis.dx = _this.dx;
            valueAxis.dy = _this.dy;
            valueAxis.viW = plotAreaWidth - 1;
            valueAxis.viH = plotAreaHeight - 1;
            valueAxis.marginsChanged = true;
            valueAxis.viX = marginLeftReal;
            valueAxis.viY = marginTopReal;
            _this.updateObjectSize(valueAxis);
        }
    },

    // graphs and value axes are updated using this method
    updateObjectSize: function (obj) {
        var _this = this;
        obj.width = (_this.plotAreaWidth - 1) * _this.widthMultiplier;
        obj.height = (_this.plotAreaHeight - 1) * _this.heightMultiplier;
        obj.x = _this.marginLeftReal + _this.horizontalPosition;
        obj.y = _this.marginTopReal + _this.verticalPosition;
    },

    updateGraphs: function () {
        var _this = this;
        var graphs = _this.graphs;
        var i;
        for (i = 0; i < graphs.length; i++) {
            var graph = graphs[i];
            graph.x = _this.marginLeftReal + _this.horizontalPosition;
            graph.y = _this.marginTopReal + _this.verticalPosition;
            graph.width = _this.plotAreaWidth * _this.widthMultiplier;
            graph.height = _this.plotAreaHeight * _this.heightMultiplier;
            graph.index = i;
            graph.dx = _this.dx;
            graph.dy = _this.dy;
            graph.rotate = _this.rotate;
        }
    },


    updateChartCursor: function () {
        var _this = this;
        var chartCursor = _this.chartCursor;

        if (chartCursor) {
            chartCursor = AmCharts.processObject(chartCursor, AmCharts.ChartCursor, _this.theme);
            _this.addChartCursor(chartCursor);

            chartCursor.x = _this.marginLeftReal;
            chartCursor.y = _this.marginTopReal;
            chartCursor.width = _this.plotAreaWidth - 1;
            chartCursor.height = _this.plotAreaHeight - 1;
            chartCursor.chart = this;
        }
    },

    processScrollbars: function () {
        var _this = this;
        var chartScrollbar = _this.chartScrollbar;
        if (chartScrollbar) {
            chartScrollbar = AmCharts.processObject(chartScrollbar, AmCharts.ChartScrollbar, _this.theme);
            _this.addChartScrollbar(chartScrollbar);
        }
    },

    updateScrollbars: function(){
        // void
    },

    addChartCursor: function (chartCursor) {
        var _this = this;
        AmCharts.callMethod("destroy", [_this.chartCursor]);

        if (chartCursor) {
            _this.listenTo(chartCursor, "changed", _this.handleCursorChange);
            _this.listenTo(chartCursor, "zoomed", _this.handleCursorZoom);
        }
        _this.chartCursor = chartCursor;
    },

    removeChartCursor: function () {
        var _this = this;
        AmCharts.callMethod("destroy", [_this.chartCursor]);
        _this.chartCursor = null;
    },

    zoomTrendLines: function () {
        var _this = this;
        var trendLines = _this.trendLines;
        var i;
        for (i = 0; i < trendLines.length; i++) {
            var trendLine = trendLines[i];

            if (!trendLine.valueAxis.recalculateToPercents) {
                trendLine.x = _this.marginLeftReal + _this.horizontalPosition;
                trendLine.y = _this.marginTopReal + _this.verticalPosition;
                trendLine.draw();
            } else {
                if (trendLine.set) {
                    trendLine.set.hide();
                }
            }
        }
    },

    addTrendLine: function (trendLine) {
        this.trendLines.push(trendLine);
    },



    removeTrendLine: function (trendLine) {
        var trendLines = this.trendLines;
        var i;
        for (i = trendLines.length - 1; i >= 0; i--) {
            if (trendLines[i] == trendLine) {
                trendLines.splice(i, 1);
            }
        }
    },


    adjustMargins: function (scrollbar, rotate) {
        var _this = this;
        var position = scrollbar.position;
        var scrollbarHeight = scrollbar.scrollbarHeight + scrollbar.offset;

        if (position == "top") {
            if (rotate) {
                _this.marginLeftReal += scrollbarHeight;
            } else {
                _this.marginTopReal += scrollbarHeight;
            }
        } else {
            if (rotate) {
                _this.marginRightReal += scrollbarHeight;
            } else {
                _this.marginBottomReal += scrollbarHeight;
            }
        }
    },


    getScrollbarPosition: function (scrollbar, rotate, axisPosition) {
        var _this = this;
        var scrollbarPosition;

        if (rotate) {
            if (axisPosition == "bottom" || axisPosition == "left") {
                scrollbarPosition = "bottom";
            } else {
                scrollbarPosition = "top";
            }
        } else {
            if (axisPosition == "top" || axisPosition == "right") {
                scrollbarPosition = "bottom";
            } else {
                scrollbarPosition = "top";
            }
        }
        scrollbar.position = scrollbarPosition;
    },


    updateChartScrollbar: function (scrollbar, rotate) {
        var _this = this;
        if (scrollbar) {
            scrollbar.rotate = rotate;
            var position = scrollbar.position;
            var marginTopReal = _this.marginTopReal;
            var marginLeftReal = _this.marginLeftReal;
            var scrollbarHeight = scrollbar.scrollbarHeight;
            var dx = _this.dx;
            var dy = _this.dy;
            var offset = scrollbar.offset;

            if (position == "top") {
                if (rotate) {
                    scrollbar.y = marginTopReal;
                    scrollbar.x = marginLeftReal - scrollbarHeight - offset;
                } else {
                    scrollbar.y = marginTopReal - scrollbarHeight + dy - 1 - offset;
                    scrollbar.x = marginLeftReal + dx;
                }
            } else {
                if (rotate) {
                    scrollbar.y = marginTopReal + dy;
                    scrollbar.x = marginLeftReal + _this.plotAreaWidth + dx + offset;
                } else {
                    scrollbar.y = marginTopReal + _this.plotAreaHeight + offset;
                    scrollbar.x = _this.marginLeftReal;
                }
            }
        }
    },

    showZB: function (show) {
        var _this = this;
        var zbSet = _this.zbSet;
        if (zbSet) {
            if (show) {
                zbSet.show();
            } else {
                zbSet.hide();
            }
            _this.rollOutZB();
        }
    },

    handleReleaseOutside: function (e) {
        var _this = this;
        AmCharts.AmRectangularChart.base.handleReleaseOutside.call(_this, e);

        var chartCursor = _this.chartCursor;
        if (chartCursor) {
            chartCursor.handleReleaseOutside();
        }
    },

    handleMouseDown: function (e) {
        var _this = this;
        AmCharts.AmRectangularChart.base.handleMouseDown.call(_this, e);
        var chartCursor = _this.chartCursor;
        if (chartCursor) {
            chartCursor.handleMouseDown(e);
        }
    },


    handleCursorChange: function (event) {
        //void
    }

});// @tag amchart
AmCharts.AmGraph = AmCharts.Class({

    construct: function(theme) {
        var _this = this;
        _this.cname = "AmGraph";
        _this.createEvents('rollOverGraphItem', 'rollOutGraphItem', 'clickGraphItem', 'doubleClickGraphItem', 'rightClickGraphItem', 'clickGraph', 'rollOverGraph', 'rollOutGraph');
        _this.type = "line";
        _this.stackable = true;
        _this.columnCount = 1;
        _this.columnIndex = 0;
        _this.showBalloon = true;
        _this.centerCustomBullets = true;
        _this.maxBulletSize = 50;
        _this.minBulletSize = 4;
        _this.balloonText = "[[value]]";
        _this.animationPlayed = false;
        _this.scrollbar = false;
        _this.hidden = false;
        //_this.columnWidth;
        _this.pointPosition = "middle";
        _this.depthCount = 1;
        _this.includeInMinMax = true;
        _this.negativeBase = 0;
        _this.visibleInLegend = true;
        _this.showAllValueLabels = false;
        _this.showBalloonAt = "close";
        _this.showBulletsAt = "close";
        _this.lineThickness = 1;
        _this.dashLength = 0;
        _this.connect = true;
        _this.lineAlpha = 1;
        _this.bullet = "none";
        _this.bulletBorderThickness = 2;
        _this.bulletBorderAlpha = 0;
        _this.bulletAlpha = 1;
        _this.bulletSize = 8;
        _this.bulletOffset = 0;
        _this.hideBulletsCount = 0;
        _this.labelPosition = "top";
        _this.cornerRadiusTop = 0;
        _this.cursorBulletAlpha = 1;
        _this.gradientOrientation = "vertical";
        _this.dx = 0;
        _this.dy = 0;
        _this.periodValue = "";
        _this.clustered = true;
        _this.periodSpan = 1;
        //_this.useLineColorForBulletBorder = false;
        //_this.showHandOnHover;
        _this.x = 0;
        _this.y = 0;
        _this.minDistance = 1;
        //_this.legendPeriodValueText;
        AmCharts.applyTheme(_this, theme, _this.cname);
    },

    draw: function() {

        var _this = this;
        var chart = _this.chart;
        // handling backwards compatibility with numberformatter
        if(!isNaN(_this.precision)){
            if(!_this.numberFormatter){
                _this.numberFormatter = {precision:_this.precision, decimalSeparator:chart.decimalSeparator, thousandsSeparator:chart.thousandsSeparator};
            }
            else{
                _this.numberFormatter.precision = _this.precision;
            }
        }

        var container = chart.container;
        _this.container = container;

        _this.destroy();
        var set = container.set();
        var bulletSet = container.set();


        if (_this.behindColumns) {
            chart.graphsBehindSet.push(set);
            chart.bulletBehindSet.push(bulletSet);
        } else {
            chart.graphsSet.push(set);
            chart.bulletSet.push(bulletSet);
        }

        var bulletAxis = _this.bulletAxis;
        if (AmCharts.isString(bulletAxis)) {
            _this.bulletAxis = chart.getValueAxisById(bulletAxis);
        }

        _this.bulletSet = bulletSet;

        if (!_this.scrollbar) {
            var x = chart.marginLeftReal;
            var y = chart.marginTopReal;
            set.translate(x, y);
            bulletSet.translate(x, y);
        }


        var columnsSet = container.set();
        AmCharts.remove(_this.columnsSet);
        set.push(columnsSet);
        _this.set = set;
        _this.columnsSet = columnsSet;

        _this.columnsArray = [];
        _this.ownColumns = [];
        _this.allBullets = [];
        _this.animationArray = [];

        if (AmCharts.ifArray(_this.data)) {
            var create = false;

            if (_this.chart.type == "xy") {
                if (_this.xAxis.axisCreated && _this.yAxis.axisCreated) {
                    create = true;
                }
            } else {
                if (_this.valueAxis.axisCreated) {
                    create = true;
                }
            }
            if (!_this.hidden && create) {
                _this.createGraph();
            }
        }
    },


    createGraph: function() {
        var _this = this;
        var chart = _this.chart;
        var UNDEFINED;

        if (_this.labelPosition == "inside" && _this.type != "column") {
            _this.labelPosition = "bottom";
        }

        _this.startAlpha = chart.startAlpha;

        _this.seqAn = chart.sequencedAnimation;
        _this.baseCoord = _this.valueAxis.baseCoord;

        if (_this.fillAlphas === UNDEFINED) {
            _this.fillAlphas = 0;
        }

        _this.bulletColorR = _this.bulletColor;
        if (_this.bulletColorR === UNDEFINED) {
            _this.bulletColorR = _this.lineColorR;
            _this.bulletColorNegative = _this.negativeLineColor;
        }

        if (_this.bulletAlpha === UNDEFINED) {
            _this.bulletAlpha = _this.lineAlpha;
        }

        /*
        if (!_this.bulletBorderColor) {
            _this.bulletBorderAlpha = 0;
        }
       */

        clearTimeout(_this.playedTO);
        if (!isNaN(_this.valueAxis.min) && !isNaN(_this.valueAxis.max)) {
            switch (chart.type) {
                case "serial":
                    if (_this.categoryAxis) {
                        _this.createSerialGraph();

                        if (_this.type == "candlestick") {
                            var valueAxis = _this.valueAxis;
                            if (valueAxis.minMaxMultiplier < 1) {
                                _this.positiveClip(_this.set);
                            }
                        }
                    }

                    break;
                case "radar":
                    _this.createRadarGraph();
                    break;
                case "xy":
                    _this.createXYGraph();
                    _this.positiveClip(_this.set);
                    break;
            }

            _this.playedTO = setTimeout(function() {
                _this.setAnimationPlayed.call(_this);
            }, _this.chart.startDuration * 500);
        }
    },

    setAnimationPlayed: function() {
        this.animationPlayed = true;
    },

    createXYGraph: function() {
        var _this = this;
        var labelPosition = _this.labelPosition;
        var xx = [];
        var yy = [];

        var xAxis = _this.xAxis;
        var yAxis = _this.yAxis;

        _this.pmh = yAxis.viH + 1;
        _this.pmw = xAxis.viW + 1;
        _this.pmx = 0;
        _this.pmy = 0;
        var i;

        for (i = _this.start; i <= _this.end; i++) {
            var serialDataItem = _this.data[i];
            var graphDataItem = serialDataItem.axes[xAxis.id].graphs[_this.id];

            var values = graphDataItem.values;
            var xValue = values.x;
            var yValue = values.y;
            var value = values.value;

            var xxx = xAxis.getCoordinate(xValue);
            var yyy = yAxis.getCoordinate(yValue);

            if (!isNaN(xValue) && !isNaN(yValue)) {
                xx.push(xxx);
                yy.push(yyy);

                var bulletSize = _this.createBullet(graphDataItem, xxx, yyy, i);
                if (!bulletSize) {
                    bulletSize = 0;
                }

                // LABELS ////////////////////////////////////////////////////////
                var labelText = _this.labelText;
                if (labelText) {
                    var lText = _this.createLabel(graphDataItem, xxx, yyy, labelText);
                    _this.allBullets.push(lText);
                    _this.positionLabel(xxx, yyy, lText, _this.labelPosition, bulletSize);
                }
            }
        }
        _this.drawLineGraph(xx, yy);
        _this.launchAnimation();
    },


    createRadarGraph: function() {
        var _this = this;
        var stackType = _this.valueAxis.stackType;
        var xx = [];
        var yy = [];
        var firstX;
        var firstY;

        var i;
        for (i = _this.start; i <= _this.end; i++) {
            var serialDataItem = _this.data[i];
            var graphDataItem = serialDataItem.axes[_this.valueAxis.id].graphs[_this.id];

            var close;

            if (stackType == "none" || stackType == "3d") {
                close = graphDataItem.values.value;
            } else {
                close = graphDataItem.values.close;
            }


            if (isNaN(close)) {
                _this.drawLineGraph(xx, yy);
                xx = [];
                yy = [];
            } else {
                var coord = _this.y - (_this.valueAxis.getCoordinate(close) - _this.height);
                var angle = 180 - 360 / (_this.end - _this.start + 1) * i;

                var xxx = (coord * Math.sin((angle) / (180) * Math.PI));
                var yyy = (coord * Math.cos((angle) / (180) * Math.PI));

                xx.push(xxx);
                yy.push(yyy);

                var bulletSize = _this.createBullet(graphDataItem, xxx, yyy, i);

                if (!bulletSize) {
                    bulletSize = 0;
                }

                // LABELS ////////////////////////////////////////////////////////
                var labelText = _this.labelText;
                if (labelText) {
                    var lText = _this.createLabel(graphDataItem, xxx, yyy, labelText);
                    _this.allBullets.push(lText);
                    _this.positionLabel(xxx, yyy, lText, _this.labelPosition, bulletSize);
                }
                if (isNaN(firstX)) {
                    firstX = xxx;
                }
                if (isNaN(firstY)) {
                    firstY = yyy;
                }
            }
        }
        xx.push(firstX);
        yy.push(firstY);

        _this.drawLineGraph(xx, yy);
        _this.launchAnimation();
    },


    positionLabel: function(x, y, lText, labelPosition, bulletSize) {
        var _this = this;
        var bbox = lText.getBBox();
        var fontSize = _this.fontSize;
        if (fontSize === undefined) {
            fontSize = _this.chart.fontSize;
        }

        var dx = 0;
        var dy = 0;
        switch (labelPosition) {
            case "left":
                x -= ((bbox.width + bulletSize) / 2 + 2);
                dx = bbox.width / 2;
                dy = -2;
                break;
            case "top":
                y -= ((bulletSize + bbox.height) / 2 + 1);
                break;
            case "right":
                x += (bbox.width + bulletSize) / 2 + 2;
                dx = bbox.width / 2;
                dy = -2;
                break;
            case "bottom":
                y += (bulletSize + bbox.height) / 2 + 1;
                break;
        }

        lText.translate(x, y);
    },

    getGradRotation: function() {
        var _this = this;
        var gradientRotation = 270;
        if (_this.gradientOrientation == "horizontal") {
            gradientRotation = 0;
        }
        _this.gradientRotation = gradientRotation;
        return gradientRotation;
    },

    createSerialGraph: function() {

        var _this = this;
        var UNDEFINED;
        _this.lineColorSwitched = UNDEFINED;
        _this.fillColorsSwitched = UNDEFINED;
        _this.dashLengthSwitched = UNDEFINED;
        var chart = _this.chart;
        var id = _this.id;
        var index = _this.index;
        var data = _this.data;
        var container = _this.chart.container;
        var valueAxis = _this.valueAxis;
        var type = _this.type;
        var columnWidth = _this.columnWidthReal;
        var showBulletsAt = _this.showBulletsAt;

        if (!isNaN(_this.columnWidth)) {
            columnWidth = _this.columnWidth;
        }

        if (isNaN(columnWidth)) {
            columnWidth = 0.8; // this is mainly for scrollbar
        }

        var width = _this.width;
        var height = _this.height;
        var x = _this.x;
        var y = _this.y;
        var rotate = _this.rotate;
        var columnCount = _this.columnCount;
        var crt = AmCharts.toCoordinate(_this.cornerRadiusTop, columnWidth / 2);
        var connect = _this.connect;
        var xx = [];
        var yy = [];
        var previousxClose;
        var previousyClose;
        var previousxOpen;
        var previousyOpen;
        var totalGarphs = _this.chart.graphs.length;
        var depth;
        var dx = _this.dx / _this.depthCount;
        var dy = _this.dy / _this.depthCount;
        var stackType = valueAxis.stackType;
        var labelPosition = _this.labelPosition;
        var start = _this.start;
        var end = _this.end;
        var scrollbar = _this.scrollbar;
        var categoryAxis = _this.categoryAxis;
        var baseCoord = _this.baseCoord;
        var negativeBase = _this.negativeBase;
        var columnIndex = _this.columnIndex;
        var lineThickness = _this.lineThickness;
        var lineAlpha = _this.lineAlpha;
        var lineColor = _this.lineColorR;
        var dashLength = _this.dashLength;
        var set = _this.set;

        // backward compatibility with old flash version
        /*
        if (labelPosition == "above") {
            labelPosition = "top";
        }
        if (labelPosition == "below") {
            labelPosition = "bottom";
        }*/
        var labelPositionOriginal = labelPosition;
        var timeout;

        var gradientRotation = _this.getGradRotation();

        var columnSpacing = _this.chart.columnSpacing;
        var cellWidth = categoryAxis.cellWidth;
        var maxSpacing = (cellWidth * columnWidth - columnCount) / columnCount;
        if (columnSpacing > maxSpacing) {
            columnSpacing = maxSpacing;
        }

        var serialDataItem;
        var graphDataItem;
        var value;

        // dimensions and position of positive mask
        var pmh = height + 1;
        var pmw = width + 1;
        var pmx = 0;
        var pmy = 0;
        // dimensions and position of negative mask
        var nmh;
        var nmw;
        var nmx;
        var nmy;

        var fillColors = _this.fillColorsR;
        var negativeFillColors = _this.negativeFillColors;
        var negativeLineColor = _this.negativeLineColor;
        var fillAlphas = _this.fillAlphas;
        var negativeFillAlphas = _this.negativeFillAlphas;

        // arrays of fillAlphas are not supported, but might be received, take first value only.
        if (typeof(fillAlphas) == 'object') {
            fillAlphas = fillAlphas[0];
        }
        if (typeof(negativeFillAlphas) == 'object') {
            negativeFillAlphas = negativeFillAlphas[0];
        }

        // get coordinate of minimum axis value
        var minCoord = valueAxis.getCoordinate(valueAxis.min);

        if (valueAxis.logarithmic) {
            minCoord = valueAxis.getCoordinate(valueAxis.minReal);
        }
        _this.minCoord = minCoord;

        // bullet could be set previously if only one data point was available
        if (_this.resetBullet) {
            _this.bullet = "none";
        }
        // if it's line/smoothedLine/step graph, mask (clip rectangle will be applied on a line. Calculate mask dimensions here.
        if (!scrollbar && (type == "line" || type == "smoothedLine" || type == "step")) {
            // if it's line/smoothedLine and there is one data point only, set bullet to round if not set any
            if (data.length == 1 && type != "step" && _this.bullet == "none") {
                _this.bullet = "round";
                _this.resetBullet = true;
            }
            // only need to do adjustments if negative colors are set
            if (negativeFillColors || negativeLineColor != UNDEFINED) {
                var zeroValue = negativeBase;
                if (zeroValue > valueAxis.max) {
                    zeroValue = valueAxis.max;
                }

                if (zeroValue < valueAxis.min) {
                    zeroValue = valueAxis.min;
                }

                if (valueAxis.logarithmic) {
                    zeroValue = valueAxis.minReal;
                }

                var zeroCoord = valueAxis.getCoordinate(zeroValue);

                var maxCoord = valueAxis.getCoordinate(valueAxis.max);

                if (rotate) {
                    pmh = height;
                    pmw = Math.abs(maxCoord - zeroCoord);
                    nmh = height;
                    nmw = Math.abs(minCoord - zeroCoord);

                    pmy = 0;
                    nmy = 0;

                    if (valueAxis.reversed) {
                        pmx = 0;
                        nmx = zeroCoord;
                    } else {
                        pmx = zeroCoord;
                        nmx = 0;
                    }
                } else {
                    pmw = width;
                    pmh = Math.abs(maxCoord - zeroCoord);
                    nmw = width;
                    nmh = Math.abs(minCoord - zeroCoord);

                    pmx = 0;
                    nmx = 0;

                    if (valueAxis.reversed) {
                        nmy = y;
                        pmy = zeroCoord;
                    } else {
                        nmy = zeroCoord + 1;
                    }
                }
            }
        }
        var round = Math.round;

        _this.pmx = round(pmx);
        _this.pmy = round(pmy);
        _this.pmh = round(pmh);
        _this.pmw = round(pmw);

        _this.nmx = round(nmx);
        _this.nmy = round(nmy);
        _this.nmh = round(nmh);
        _this.nmw = round(nmw);

        if (!AmCharts.isModern) {
            _this.nmx = 0;
            _this.nmy = 0;
            _this.nmh = _this.height;
        }

        // get column width
        if (type == "column") {
            columnWidth = (cellWidth * columnWidth - (columnSpacing * (columnCount - 1))) / columnCount;
        } else {
            columnWidth = cellWidth * columnWidth;
        }
        // set one pixel if actual width is less
        if (columnWidth < 1) {
            columnWidth = 1;
        }

        // find first not missing value
        var i;
        if (type == "line" || type == "step" || type == "smoothedLine") {
            if (start > 0) {
                for (i = start - 1; i > -1; i--) {
                    serialDataItem = data[i];
                    graphDataItem = serialDataItem.axes[valueAxis.id].graphs[id];
                    value = graphDataItem.values.value;

                    if (!isNaN(value)) {
                        start = i;
                        break;
                    }
                }
                // if lineColorField or other simmilar are set, we need to check if there are any set before
                if (_this.lineColorField) {
                    for (i = start; i > -1; i--) {

                        serialDataItem = data[i];
                        graphDataItem = serialDataItem.axes[valueAxis.id].graphs[id];

                        if (graphDataItem.lineColor) {
                            _this.lineColorSwitched = graphDataItem.lineColor;
                            _this.bulletColorSwitched = _this.lineColorSwitched;
                            break;
                        }
                    }
                }

                if (_this.fillColorsField) {
                    for (i = start; i > -1; i--) {

                        serialDataItem = data[i];
                        graphDataItem = serialDataItem.axes[valueAxis.id].graphs[id];

                        if (graphDataItem.fillColors) {
                            _this.fillColorsSwitched = graphDataItem.fillColors;
                            break;
                        }
                    }
                }

                if (_this.dashLengthField) {
                    for (i = start; i > -1; i--) {

                        serialDataItem = data[i];
                        graphDataItem = serialDataItem.axes[valueAxis.id].graphs[id];

                        if (!isNaN(graphDataItem.dashLength)) {
                            _this.dashLengthSwitched = graphDataItem.dashLength;
                            break;
                        }
                    }
                }

            }
            if (end < data.length - 1) {
                for (i = end + 1; i < data.length; i++) {
                    serialDataItem = data[i];
                    graphDataItem = serialDataItem.axes[valueAxis.id].graphs[id];
                    value = graphDataItem.values.value;

                    if (!isNaN(value)) {
                        end = i;
                        break;
                    }
                }
            }
        }
        // add one more
        if (end < data.length - 1) {
            end++;
        }

        var sxx = [];
        var syy = [];

        var stackableLine = false;
        if (type == "line" || type == "step" || type == "smoothedLine") {
            if (_this.stackable && stackType == "regular" || stackType == "100%" || _this.fillToGraph) {
                stackableLine = true;
            }
        }

        var noStepRisers = _this.noStepRisers;

        var previousLX = -1000;
        var previousLY = -1000;
        var minDistance = _this.minDistance;
        ///////////////////////////////////////////////////////////////////////////
        // now go through all data items and get coordinates or draw actual objects
        for (i = start; i <= end; i++) {
            serialDataItem = data[i];
            graphDataItem = serialDataItem.axes[valueAxis.id].graphs[id];
            graphDataItem.index = i;

            var cx;
            var cy;
            var cw;
            var ch;
            var finalDimension;
            var property;
            var xxx = NaN;
            var xClose = NaN;
            var yClose = NaN;
            var xOpen = NaN;
            var yOpen = NaN;
            var xLow = NaN;
            var yLow = NaN;
            var xHigh = NaN;
            var yHigh = NaN;

            var labelX = NaN;
            var labelY = NaN;
            var bulletX = NaN;
            var bulletY = NaN;

            var close = NaN;
            var high = NaN;
            var low = NaN;
            var open = NaN;
            var cuboid = UNDEFINED;

            var fillColorsReal = fillColors;
            var fillAlphasReal = fillAlphas;
            var lineColorReal = lineColor;
            var borderColor;
            var cset;

            var pattern = _this.pattern;
            if (graphDataItem.pattern != UNDEFINED) {
                pattern = graphDataItem.pattern;
            }

            if (graphDataItem.color != UNDEFINED) {
                fillColorsReal = graphDataItem.color;
            }

            if (graphDataItem.fillColors) {
                fillColorsReal = graphDataItem.fillColors;
            }

            if (!isNaN(graphDataItem.alpha)) {
                fillAlphasReal = graphDataItem.alpha;
            }

            if (!isNaN(graphDataItem.dashLength)) {
                dashLength = graphDataItem.dashLength;
            }

            var values = graphDataItem.values;
            if (valueAxis.recalculateToPercents) {
                values = graphDataItem.percents;
            }

            if (values) {
                if (!_this.stackable || stackType == "none" || stackType == "3d") {
                    close = values.value;
                } else {
                    close = values.close;
                }

                // in case candlestick
                if (type == "candlestick" || type == "ohlc") {
                    close = values.close;
                    low = values.low;
                    yLow = valueAxis.getCoordinate(low);

                    high = values.high;
                    yHigh = valueAxis.getCoordinate(high);
                }

                open = values.open;
                yClose = valueAxis.getCoordinate(close);

                if (!isNaN(open)) {
                    yOpen = valueAxis.getCoordinate(open);
                }

                // do not store y if this is scrollbar
                if (!scrollbar) {
                    switch (_this.showBalloonAt) {
                        case "close":
                            graphDataItem.y = yClose;
                            break;
                        case "open":
                            graphDataItem.y = yOpen;
                            break;
                        case "high":
                            graphDataItem.y = yHigh;
                            break;
                        case "low":
                            graphDataItem.y = yLow;
                            break;
                    }
                }

                // x coordinate
                xxx = serialDataItem.x[categoryAxis.id];
                var periodSpan = _this.periodSpan - 1;

                var stepLineDelta1 = Math.floor(cellWidth / 2) + Math.floor(periodSpan * cellWidth / 2);
                var stepLineDelta2 = stepLineDelta1;
                var stepShift = 0;
                if(_this.stepDirection == "left"){
                    stepShift = (cellWidth * 2 + periodSpan * cellWidth) / 2;
                    xxx -= stepShift;
                }

                if (_this.pointPosition == "start") {
                    xxx -= cellWidth / 2 +  Math.floor(periodSpan * cellWidth / 2);
                    stepLineDelta1 = 0;
                    stepLineDelta2 = Math.floor(cellWidth) + Math.floor(periodSpan * cellWidth);
                }

                if (_this.pointPosition == "end") {
                    xxx += cellWidth / 2 + Math.floor(periodSpan * cellWidth / 2);
                    stepLineDelta1 = Math.floor(cellWidth) + Math.floor(periodSpan * cellWidth);
                    stepLineDelta2 = 0;
                }

                if (noStepRisers) {
                    var stepWidth = _this.columnWidth;

                    if (!isNaN(stepWidth)) {
                        stepLineDelta1 = stepWidth * stepLineDelta1;
                        stepLineDelta2 = stepWidth * stepLineDelta2;
                    }
                }

                if (!scrollbar) {
                    graphDataItem.x = xxx;
                }

                // fix to avoid wrong behavior when lines are too long
                // theorethically this is not 100% correct approach, but visually there is no any diference.
                var maxmax = 100000;

                if (xxx < -maxmax) {
                    xxx = -maxmax;
                }

                if (xxx > width + maxmax) {
                    xxx = width + maxmax;
                }

                if (rotate) {
                    xClose = yClose;
                    xOpen = yOpen;

                    yClose = xxx;
                    yOpen = xxx;

                    if (isNaN(open) && !_this.fillToGraph) {
                        xOpen = baseCoord;
                    }

                    xLow = yLow;
                    xHigh = yHigh;
                } else {
                    xClose = xxx;
                    xOpen = xxx;

                    if (isNaN(open) && !_this.fillToGraph) {
                        yOpen = baseCoord;
                    }
                }

                if (close < open) {
                    graphDataItem.isNegative = true;

                    if (negativeFillColors) {
                        fillColorsReal = negativeFillColors;
                    }

                    if (negativeFillAlphas) {
                        fillAlphasReal = negativeFillAlphas;
                    }

                    if (negativeLineColor != UNDEFINED) {
                        lineColorReal = negativeLineColor;
                    }
                }



                switch (type) {
                    // LINE
                    case "line":
                        if (!isNaN(close)) {
                            if (close < negativeBase) {
                                graphDataItem.isNegative = true;
                            } else {
                                graphDataItem.isNegative = false;
                            }

                            if(Math.abs(xClose - previousLX) >= minDistance || Math.abs(yClose - previousLY) >= minDistance){
                                xx.push(xClose);
                                yy.push(yClose);

                                previousLX = xClose;
                                previousLY = yClose;
                            }

                            labelX = xClose;
                            labelY = yClose;
                            bulletX = xClose;
                            bulletY = yClose;

                            if (stackableLine) {
                                if (!isNaN(yOpen) && !isNaN(xOpen)) {
                                    sxx.push(xOpen);
                                    syy.push(yOpen);
                                }
                            }
                            if (graphDataItem.lineColor != UNDEFINED || graphDataItem.fillColors != UNDEFINED || !isNaN(graphDataItem.dashLength)) {
                                _this.drawLineGraph(xx, yy, sxx, syy);
                                xx = [xClose];
                                yy = [yClose];

                                sxx = [];
                                syy = [];

                                if(stackableLine){
                                    if (!isNaN(yOpen) && !isNaN(xOpen)) {
                                        sxx.push(xOpen);
                                        syy.push(yOpen);
                                    }
                                }

                                _this.lineColorSwitched = graphDataItem.lineColor;
                                _this.fillColorsSwitched = graphDataItem.fillColors;
                                _this.dashLengthSwitched = graphDataItem.dashLength;
                            }

                            if(graphDataItem.gap){
                                _this.drawLineGraph(xx, yy, sxx, syy);
                                xx = [];
                                yy = [];

                                sxx = [];
                                syy = [];
                            }

                        } else if (!connect) {
                            _this.drawLineGraph(xx, yy, sxx, syy);
                            xx = [];
                            yy = [];

                            sxx = [];
                            syy = [];
                        }
                        break;

                    case "smoothedLine":
                        if (!isNaN(close)) {
                            if (close < negativeBase) {
                                graphDataItem.isNegative = true;
                            } else {
                                graphDataItem.isNegative = false;
                            }


                            if(Math.abs(xClose - previousLX) >= minDistance || Math.abs(yClose - previousLY) >= minDistance){
                                xx.push(xClose);
                                yy.push(yClose);

                                previousLX = xClose;
                                previousLY = yClose;
                            }

                            labelX = xClose;
                            labelY = yClose;
                            bulletX = xClose;
                            bulletY = yClose;

                            if (stackableLine) {
                                if (!isNaN(yOpen) && !isNaN(xOpen)) {
                                    sxx.push(xOpen);
                                    syy.push(yOpen);
                                }
                            }
                            if (graphDataItem.lineColor != UNDEFINED || graphDataItem.fillColors != UNDEFINED || !isNaN(graphDataItem.dashLength)) {
                                _this.drawSmoothedGraph(xx, yy, sxx, syy);
                                xx = [xClose];
                                yy = [yClose];

                                sxx = [];
                                syy = [];

                                if(stackableLine){
                                    if (!isNaN(yOpen) && !isNaN(xOpen)) {
                                        sxx.push(xOpen);
                                        syy.push(yOpen);
                                    }
                                }

                                _this.lineColorSwitched = graphDataItem.lineColor;
                                _this.fillColorsSwitched = graphDataItem.fillColors;
                                _this.dashLengthSwitched = graphDataItem.dashLength;
                            }
                            if(graphDataItem.gap){
                                _this.drawSmoothedGraph(xx, yy, sxx, syy);
                                xx = [];
                                yy = [];

                                sxx = [];
                                syy = [];
                            }

                        } else if (!connect) {
                            _this.drawSmoothedGraph(xx, yy, sxx, syy);
                            xx = [];
                            yy = [];

                            sxx = [];
                            syy = [];
                        }
                        break;

                        // STEP
                    case "step":
                        if (!isNaN(close)) {
                            if (close < negativeBase) {
                                graphDataItem.isNegative = true;
                            } else {
                                graphDataItem.isNegative = false;
                            }

                            if (graphDataItem.lineColor != UNDEFINED || graphDataItem.fillColors != UNDEFINED || !isNaN(graphDataItem.dashLength)) {
                                _this.drawLineGraph(xx, yy, sxx, syy);
                                xx = [];
                                yy = [];

                                sxx = [];
                                syy = [];
                                _this.lineColorSwitched = graphDataItem.lineColor;
                                _this.fillColorsSwitched = graphDataItem.fillColors;
                                _this.dashLengthSwitched = graphDataItem.dashLength;
                            }

                            if (rotate) {
                                if (!isNaN(previousxClose)) {
                                    xx.push(previousxClose);
                                    yy.push(yClose - stepLineDelta1);
                                }
                                yy.push(yClose - stepLineDelta1);
                                xx.push(xClose);
                                yy.push(yClose + stepLineDelta2);
                                xx.push(xClose);

                                if (stackableLine) {
                                    if (!isNaN(yOpen) && !isNaN(xOpen)) {
                                        sxx.push(previousxOpen);
                                        syy.push(yOpen - stepLineDelta1);
                                        sxx.push(xOpen);
                                        syy.push(yOpen - stepLineDelta1);
                                        sxx.push(xOpen);
                                        syy.push(yOpen + stepLineDelta2);
                                    }
                                }
                            } else {
                                if (!isNaN(previousyClose)) {
                                    yy.push(previousyClose);
                                    xx.push(previousxClose);

                                    yy.push(previousyClose);
                                    xx.push(xClose - stepLineDelta1);
                                }
                                xx.push(xClose - stepLineDelta1);
                                yy.push(yClose);
                                xx.push(xClose + stepLineDelta2);
                                yy.push(yClose);

                                if (stackableLine) {
                                    if (!isNaN(yOpen) && !isNaN(xOpen)) {
                                        sxx.push(xOpen - stepLineDelta1);
                                        syy.push(previousyOpen);

                                        sxx.push(xOpen - stepLineDelta1);
                                        syy.push(yOpen);
                                        sxx.push(xOpen + stepLineDelta2);
                                        syy.push(yOpen);
                                    }
                                }
                            }
                            previousxClose = xClose;
                            previousyClose = yClose;
                            previousxOpen = xOpen;
                            previousyOpen = yOpen;
                            labelX = xClose;
                            labelY = yClose;
                            bulletX = xClose;
                            bulletY = yClose;

                            if (noStepRisers || graphDataItem.gap) {
                                previousyClose = NaN;
                                previousxClose = NaN;

                                _this.drawLineGraph(xx, yy, sxx, syy);
                                xx = [];
                                yy = [];

                                sxx = [];
                                syy = [];
                            }
                        } else if (!connect) {
                            if (_this.periodSpan <= 1 || (_this.periodSpan > 1 && xClose - previousxClose > stepLineDelta1 + stepLineDelta2)) {
                                previousyClose = NaN;
                                previousxClose = NaN;
                            }
                            _this.drawLineGraph(xx, yy, sxx, syy);
                            xx = [];
                            yy = [];

                            sxx = [];
                            syy = [];
                        }
                        break;


                        // COLUMN
                    case "column":
                        borderColor = lineColorReal;
                        if (graphDataItem.lineColor != UNDEFINED) {
                            borderColor = graphDataItem.lineColor;
                        }

                        if (!isNaN(close)) {
                            if (close < negativeBase) {
                                graphDataItem.isNegative = true;

                                if (negativeFillColors) {
                                    fillColorsReal = negativeFillColors;
                                }

                                if (negativeLineColor != UNDEFINED) {
                                    borderColor = negativeLineColor;
                                }
                            } else {
                                graphDataItem.isNegative = false;
                            }
                            var min = valueAxis.min;
                            var max = valueAxis.max;

                            if ((close < min && open < min) || (close > max && open > max)) {
                                // void
                            } else {
                                if (rotate) {
                                    if (stackType == '3d') {
                                        cy = yClose - 0.5 * (columnWidth + columnSpacing) + columnSpacing / 2 + dy * columnIndex;
                                        cx = xOpen + dx * columnIndex;
                                    } else {
                                        cy = Math.floor(yClose - (columnCount / 2 - columnIndex) * (columnWidth + columnSpacing) + columnSpacing / 2);
                                        cx = xOpen;
                                    }

                                    cw = columnWidth;

                                    labelX = xClose;
                                    labelY = cy + columnWidth / 2;

                                    bulletX = xClose;
                                    bulletY = cy + columnWidth / 2;

                                    if (cy + cw > height) {
                                        cw = height - cy;
                                    }

                                    if (cy < 0) {
                                        cw += cy;
                                        cy = 0;
                                    }

                                    ch = xClose - xOpen;
                                    var cxr = cx;
                                    cx = AmCharts.fitToBounds(cx, 0, width);
                                    ch = ch + (cxr - cx);
                                    ch = AmCharts.fitToBounds(ch, -cx, width - cx + dx * columnIndex);

                                    if (cy < height && cw > 0) {
                                        cuboid = new AmCharts.Cuboid(container, ch, cw, dx - chart.d3x, dy - chart.d3y, fillColorsReal, fillAlphasReal, lineThickness, borderColor, lineAlpha, gradientRotation, crt, rotate, dashLength, pattern);

                                        if (labelPosition != "bottom" && labelPosition != "inside" && labelPosition != "middle") {
                                            if (!valueAxis.reversed) {
                                                labelPosition = "right";
                                            } else {
                                                labelPosition = "left";
                                            }

                                            if (close < 0) {
                                                if (!valueAxis.reversed) {
                                                    labelPosition = "left";
                                                } else {
                                                    labelPosition = "right";
                                                }
                                            } else {
                                                if (stackType == "regular" || stackType == "100%") {
                                                    labelX += _this.dx;
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if (stackType == '3d') {
                                        cx = xClose - 0.5 * (columnWidth + columnSpacing) + columnSpacing / 2 + dx * columnIndex;
                                        cy = yOpen + dy * columnIndex;
                                    } else {
                                        cx = xClose - (columnCount / 2 - columnIndex) * (columnWidth + columnSpacing) + columnSpacing / 2;
                                        cy = yOpen;
                                    }
                                    cw = columnWidth;

                                    labelX = cx + columnWidth / 2;
                                    labelY = yClose;

                                    bulletX = cx + columnWidth / 2;
                                    bulletY = yClose;

                                    if (cx + cw > width + columnIndex * dx) {
                                        cw = width - cx + columnIndex * dx;
                                    }

                                    if (cx < 0) {
                                        cw += cx;
                                        cx = 0;
                                    }

                                    ch = yClose - yOpen;

                                    var cyr = cy;
                                    cy = AmCharts.fitToBounds(cy, _this.dy, height);
                                    ch = ch + (cyr - cy);
                                    ch = AmCharts.fitToBounds(ch, -cy + dy * columnIndex, height - cy);

                                    if (cx < width + columnIndex * dx && cw > 0) {
                                        cuboid = new AmCharts.Cuboid(container, cw, ch, dx - chart.d3x, dy - chart.d3y, fillColorsReal, fillAlphasReal, lineThickness, borderColor, _this.lineAlpha, gradientRotation, crt, rotate, dashLength, pattern);

                                        if (close < 0 && labelPosition != "middle" && labelPosition != "inside") {
                                            labelPosition = "bottom";
                                        } else {
                                            labelPosition = labelPositionOriginal;
                                            if (stackType == "regular" || stackType == "100%") {
                                                labelY += _this.dy;
                                            }
                                        }
                                    }
                                }
                            }


                            if (cuboid) {
                                cset = cuboid.set;

                                cset.translate(cx, cy);
                                _this.columnsSet.push(cset);

                                if (graphDataItem.url || _this.showHandOnHover) {
                                    cset.setAttr("cursor", "pointer");
                                }

                                // in case columns array is passed (it is not passed only for the scrollers chart, as it can't be 3d
                                // all columns are placed into array with predicted depth, then sorted by depth in Serial Chart and
                                // added to columnsContainer which was created in AmSerialChart class
                                if (!scrollbar) {
                                    if (stackType == "none") {
                                        if (rotate) {
                                            depth = (_this.end + 1 - i) * totalGarphs - index;
                                        } else {
                                            depth = totalGarphs * i + index;
                                        }
                                    }

                                    if (stackType == "3d") {
                                        if (rotate) {
                                            depth = (totalGarphs - index) * (_this.end + 1 - i);
                                            labelX += dx * _this.columnIndex;
                                            bulletX += dx * _this.columnIndex;
                                            graphDataItem.y += dx * _this.columnIndex;

                                        } else {
                                            depth = (totalGarphs - index) * (i + 1);
                                            labelX += 3;
                                            labelY += dy * _this.columnIndex + 7;
                                            bulletY += dy * _this.columnIndex;
                                            graphDataItem.y += dy * _this.columnIndex;
                                        }

                                    }
                                    if (stackType == "regular" || stackType == "100%") {
                                        if (labelPosition != "inside") {
                                            labelPosition = "middle";
                                        }
                                        if (rotate) {
                                            if (values.value > 0) {
                                                depth = (_this.end + 1 - i) * totalGarphs + index;
                                            } else {
                                                depth = (_this.end + 1 - i) * totalGarphs - index;
                                            }
                                        } else {
                                            if (values.value > 0) {
                                                depth = (totalGarphs * i) + index;
                                            } else {
                                                depth = totalGarphs * i - index;
                                            }
                                        }
                                    }

                                    _this.columnsArray.push({
                                        column: cuboid,
                                        depth: depth
                                    });

                                    if (rotate) {
                                        graphDataItem.x = cy + cw / 2;
                                    } else {
                                        graphDataItem.x = cx + cw / 2;
                                    }
                                    _this.ownColumns.push(cuboid);
                                    _this.animateColumns(cuboid, i, xClose, xOpen, yClose, yOpen);
                                    _this.addListeners(cset, graphDataItem);
                                }
                                //graphDataItem.columnSprite = cset;
                            }
                        }
                        break;
                        // CANDLESTICK
                    case "candlestick":
                        if (!isNaN(open) && !isNaN(close)) {

                            var highLine;
                            var lowLine;

                            borderColor = lineColorReal;
                            if (graphDataItem.lineColor != UNDEFINED) {
                                borderColor = graphDataItem.lineColor;
                            }

                            if (rotate) {
                                cy = yClose - columnWidth / 2;
                                cx = xOpen;

                                cw = columnWidth;
                                if (cy + cw > height) {
                                    cw = height - cy;
                                }

                                if (cy < 0) {
                                    cw += cy;
                                    cy = 0;
                                }

                                if (cy < height && cw > 0) {
                                    var xArrayHigh;
                                    var xArrayLow;

                                    if (close > open) {
                                        xArrayHigh = [xClose, xHigh];
                                        xArrayLow = [xOpen, xLow];
                                    } else {
                                        xArrayHigh = [xOpen, xHigh];
                                        xArrayLow = [xClose, xLow];
                                    }
                                    if (!isNaN(xHigh) && !isNaN(xLow)) {
                                        if (yClose < height && yClose > 0) {
                                            highLine = AmCharts.line(container, xArrayHigh, [yClose, yClose], borderColor, lineAlpha, lineThickness);
                                            lowLine = AmCharts.line(container, xArrayLow, [yClose, yClose], borderColor, lineAlpha, lineThickness);
                                        }
                                    }
                                    ch = xClose - xOpen;

                                    cuboid = new AmCharts.Cuboid(container, ch, cw, dx, dy, fillColorsReal, fillAlphas, lineThickness, borderColor, lineAlpha, gradientRotation, crt, rotate, dashLength, pattern);
                                }
                            } else {
                                cx = xClose - columnWidth / 2;
                                cy = yOpen + lineThickness / 2;

                                cw = columnWidth;
                                if (cx + cw > width) {
                                    cw = width - cx;
                                }

                                if (cx < 0) {
                                    cw += cx;
                                    cx = 0;
                                }

                                ch = yClose - yOpen;

                                if (cx < width && cw > 0) {
                                    cuboid = new AmCharts.Cuboid(container, cw, ch, dx, dy, fillColorsReal, fillAlphasReal, lineThickness, borderColor, lineAlpha, gradientRotation, crt, rotate, dashLength, pattern);
                                    var yArrayHigh;
                                    var yArrayLow;
                                    if (close > open) {
                                        yArrayHigh = [yClose, yHigh];
                                        yArrayLow = [yOpen, yLow];
                                    } else {
                                        yArrayHigh = [yOpen, yHigh];
                                        yArrayLow = [yClose, yLow];
                                    }
                                    if (!isNaN(yHigh) && !isNaN(yLow)) {
                                        if (xClose < width && xClose > 0) {
                                            highLine = AmCharts.line(container, [xClose, xClose], yArrayHigh, borderColor, lineAlpha, lineThickness);
                                            lowLine = AmCharts.line(container, [xClose, xClose], yArrayLow, borderColor, lineAlpha, lineThickness);
                                        }
                                    }
                                }
                            }
                            if (cuboid) {
                                cset = cuboid.set;
                                set.push(cset);
                                cset.translate(cx, cy - lineThickness / 2);

                                if (graphDataItem.url || _this.showHandOnHover) {
                                    cset.setAttr("cursor", "pointer");
                                }

                                if (highLine) {
                                    set.push(highLine);
                                    set.push(lowLine);
                                }

                                labelX = xClose;
                                labelY = yClose;

                                if(rotate){
                                    bulletY = yClose;
                                    bulletX = xClose;
                                    if(showBulletsAt == "open"){
                                        bulletX = xOpen;
                                    }
                                    if(showBulletsAt == "high"){
                                        bulletX = xHigh;
                                    }
                                    if(showBulletsAt == "low"){
                                        bulletX = xLow;
                                    }
                                }
                                else{
                                    bulletY = yClose;
                                    if(showBulletsAt == "open"){
                                        bulletY = yOpen;
                                    }
                                    if(showBulletsAt == "high"){
                                        bulletY = yHigh;
                                    }
                                    if(showBulletsAt == "low"){
                                        bulletY = yLow;
                                    }
                                    bulletX = xClose;
                                }



                                if (!scrollbar) {
                                    if (rotate) {
                                        graphDataItem.x = cy + cw / 2;
                                    } else {
                                        graphDataItem.x = cx + cw / 2;
                                    }

                                    _this.animateColumns(cuboid, i, xClose, xOpen, yClose, yOpen);

                                    _this.addListeners(cset, graphDataItem);
                                }
                            }
                        }
                        break;

                        // OHLC ////////////////////////
                    case "ohlc":
                        if (!isNaN(open) && !isNaN(high) && !isNaN(low) && !isNaN(close)) {
                            if (close < open) {
                                graphDataItem.isNegative = true;

                                if (negativeLineColor != UNDEFINED) {
                                    lineColorReal = negativeLineColor;
                                }
                            }
                            var verticalLine;
                            var openLine;
                            var closeLine;
                            if (rotate) {
                                var y1 = yClose - columnWidth / 2;
                                y1 = AmCharts.fitToBounds(y1, 0, height);
                                var y2 = AmCharts.fitToBounds(yClose, 0, height);
                                var y3 = yClose + columnWidth / 2;
                                y3 = AmCharts.fitToBounds(y3, 0, height);
                                openLine = AmCharts.line(container, [xOpen, xOpen], [y1, y2], lineColorReal, lineAlpha, lineThickness, dashLength);
                                if (yClose > 0 && yClose < height) {
                                    verticalLine = AmCharts.line(container, [xLow, xHigh], [yClose, yClose], lineColorReal, lineAlpha, lineThickness, dashLength);
                                }

                                closeLine = AmCharts.line(container, [xClose, xClose], [y2, y3], lineColorReal, lineAlpha, lineThickness, dashLength);
                            } else {
                                var x1 = xClose - columnWidth / 2;
                                x1 = AmCharts.fitToBounds(x1, 0, width);
                                var x2 = AmCharts.fitToBounds(xClose, 0, width);
                                var x3 = xClose + columnWidth / 2;
                                x3 = AmCharts.fitToBounds(x3, 0, width);
                                openLine = AmCharts.line(container, [x1, x2], [yOpen, yOpen], lineColorReal, lineAlpha, lineThickness, dashLength);
                                if (xClose > 0 && xClose < width) {
                                    verticalLine = AmCharts.line(container, [xClose, xClose], [yLow, yHigh], lineColorReal, lineAlpha, lineThickness, dashLength);
                                }
                                closeLine = AmCharts.line(container, [x2, x3], [yClose, yClose], lineColorReal, lineAlpha, lineThickness, dashLength);
                            }

                            set.push(openLine);
                            set.push(verticalLine);
                            set.push(closeLine);

                            labelX = xClose;
                            labelY = yClose;
                            bulletX = xClose;
                            bulletY = yClose;
                        }
                        break;
                }

                // BULLETS AND LABELS
                if (!scrollbar && !isNaN(close)) {
                    var hideBulletsCount = _this.hideBulletsCount;
                    if (_this.end - _this.start <= hideBulletsCount || hideBulletsCount === 0) {
                        var bulletSize = _this.createBullet(graphDataItem, bulletX, bulletY, i);

                        if (!bulletSize) {
                            bulletSize = 0;
                        }



                        // LABELS ////////////////////////////////////////////////////////
                        var labelText = _this.labelText;
                        if (labelText) {
                            var lText = _this.createLabel(graphDataItem, 0, 0, labelText);
                            var lx = 0;
                            var ly = 0;
                            var bbox = lText.getBBox();
                            var textWidth = bbox.width;
                            var textHeight = bbox.height;

                            switch (labelPosition) {
                                case "left":
                                    lx = -(textWidth / 2 + bulletSize / 2 + 3);
                                    break;
                                case "top":
                                    ly = -(textHeight / 2 + bulletSize / 2 + 3);
                                    break;
                                case "right":
                                    lx = bulletSize / 2 + 2 + textWidth / 2;
                                    break;
                                case "bottom":
                                    if (rotate && type == "column") {
                                        labelX = baseCoord;

                                        if (close < 0 || (close > 0 && valueAxis.reversed)) {
                                            lx = -6;
                                            lText.attr({
                                                'text-anchor': 'end'
                                            });
                                        } else {
                                            lx = 6;
                                            lText.attr({
                                                'text-anchor': 'start'
                                            });
                                        }
                                    } else {
                                        ly = bulletSize / 2 + textHeight / 2;
                                        lText.x = -(textWidth / 2 + 2);
                                    }
                                    break;
                                case "middle":
                                    if (type == "column") {
                                        if (rotate) {
                                            ly = -(textHeight / 2) + _this.fontSize / 2;
                                            lx = -(xClose - xOpen) / 2 - dx;
                                            if (ch < 0) {
                                                lx += dx;
                                            }

                                            if (Math.abs(xClose - xOpen) < textWidth) {
                                                if (!_this.showAllValueLabels) {
                                                    lText.remove();
                                                    lText = null;
                                                }
                                            }
                                        } else {
                                            ly = -(yClose - yOpen) / 2;
                                            if (ch < 0) {
                                                ly -= dy;
                                            }

                                            if (Math.abs(yClose - yOpen) < textHeight) {
                                                if (!_this.showAllValueLabels) {
                                                    lText.remove();
                                                    lText = null;
                                                }
                                            }
                                        }
                                    }
                                    break;
                                case "inside":
                                    if (rotate) {
                                        ly = -(textHeight / 2) + _this.fontSize / 2;
                                        if (ch < 0) {
                                            lx = textWidth / 2 + 6;
                                        } else {
                                            lx = -textWidth / 2 - 6;
                                        }

                                    } else {
                                        if (ch < 0) {
                                            ly = textHeight;
                                        } else {

                                            ly = -textHeight;
                                        }
                                    }

                                    break;
                            }


                            if (lText) {
                                if (!isNaN(labelY) && !isNaN(labelX)) {
                                    labelX += lx;
                                    labelY += ly;
                                    lText.translate(labelX, labelY);

                                    if (rotate) {
                                        if (labelY < 0 || labelY > height) {
                                            lText.remove();
                                            lText = null;
                                        }
                                    } else {
                                        var ddx = 0;
                                        if (stackType == "3d") {
                                            ddx = dx * columnIndex;
                                        }

                                        if (labelX < 0 || labelX > width + ddx) {
                                            lText.remove();
                                            lText = null;
                                        }
                                    }
                                } else {
                                    lText.remove();
                                    lText = null;
                                }
                                if (lText) {
                                    _this.allBullets.push(lText);
                                }

                            }
                        }
                        // TOTALS
                        if (stackType == "regular" || stackType == "100%") {
                            var totalText = valueAxis.totalText;
                            if (totalText) {
                                var tText = _this.createLabel(graphDataItem, 0, 0, totalText, valueAxis.totalTextColor);
                                _this.allBullets.push(tText);

                                var tbox = tText.getBBox();
                                var tWidth = tbox.width;
                                var tHeight = tbox.height;
                                var tx;
                                var ty;

                                var previousTotal = valueAxis.totals[i];
                                if (previousTotal) {
                                    previousTotal.remove();
                                }

                                var lDelta = 0;
                                if (type != "column") {
                                    lDelta = bulletSize;
                                }

                                if (rotate) {
                                    ty = yClose;
                                    if (close < 0) {
                                        tx = xClose - tWidth / 2 - 2 - lDelta;
                                    } else {
                                        tx = xClose + tWidth / 2 + 3 + lDelta;
                                    }
                                } else {
                                    tx = xClose;
                                    if (close < 0) {
                                        ty = yClose + tHeight / 2 + lDelta;
                                    } else {
                                        ty = yClose - tHeight / 2 - 3 - lDelta;
                                    }
                                }
                                tText.translate(tx, ty);
                                valueAxis.totals[i] = tText;

                                if (rotate) {
                                    if (ty < 0 || ty > height) {
                                        tText.remove();
                                    }
                                } else {
                                    if (tx < 0 || tx > width) {
                                        tText.remove();
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }


        if (type == "line" || type == "step" || type == "smoothedLine") {
            if (type == "smoothedLine") {
                _this.drawSmoothedGraph(xx, yy, sxx, syy);
            } else {
                _this.drawLineGraph(xx, yy, sxx, syy);
            }
            if (!scrollbar) {
                _this.launchAnimation();
            }
        }

        if (_this.bulletsHidden) {
            _this.hideBullets();
        }
    },

    animateColumns: function(cuboid, i, xClose, xOpen, yClose, yOpen) {
        var _this = this;

        var duration = _this.chart.startDuration;

        if (duration > 0 && !_this.animationPlayed) {
            if (_this.seqAn) {
                cuboid.set.hide();
                _this.animationArray.push(cuboid);
                var timeout = setTimeout(function() {
                    _this.animate.call(_this);
                }, duration / (_this.end - _this.start + 1) * (i - _this.start) * 1000);
                _this.timeOuts.push(timeout);
            } else {
                _this.animate(cuboid);
            }
        }
    },

    createLabel: function(graphDataItem, labelX, labelY, labelText, textColor) {
        var _this = this;
        var chart = _this.chart;
        var numberFormatter = _this.numberFormatter;
        if (!numberFormatter) {
            numberFormatter = chart.nf;
        }

        var color = graphDataItem.labelColor;
        if (!color) {
            color = _this.color;
        }
        if (!color) {
            color = chart.color;
        }
        if (textColor) {
            color = textColor;
        }

        var fontSize = _this.fontSize;
        if (fontSize === undefined) {
            fontSize = chart.fontSize;
            _this.fontSize = fontSize;
        }

        var text = chart.formatString(labelText, graphDataItem);
        text = AmCharts.cleanFromEmpty(text);

        var lText = AmCharts.text(_this.container, text, color, chart.fontFamily, fontSize);
        lText.translate(labelX, labelY);

        _this.bulletSet.push(lText);
        return lText;
    },

    positiveClip: function(obj) {
        var _this = this;
        obj.clipRect(_this.pmx, _this.pmy, _this.pmw, _this.pmh);
    },

    negativeClip: function(obj) {
        var _this = this;
        obj.clipRect(_this.nmx, _this.nmy, _this.nmw, _this.nmh);
    },


    drawLineGraph: function(xx, yy, sxx, syy) {
        var _this = this;
        if (xx.length > 1) {
            var set = _this.set;
            var container = _this.container;

            var positiveSet = container.set();
            var negativeSet = container.set();

            set.push(negativeSet);
            set.push(positiveSet);


            var lineAlpha = _this.lineAlpha;
            var lineThickness = _this.lineThickness;

            var fillAlphas = _this.fillAlphas;
            var lineColor = _this.lineColorR;


            var negativeLineAlpha = _this.negativeLineAlpha;
            if (isNaN(negativeLineAlpha)) {
                negativeLineAlpha = lineAlpha;
            }

            var lineColorSwitched = _this.lineColorSwitched;
            if (lineColorSwitched) {
                lineColor = lineColorSwitched;
            }

            var fillColors = _this.fillColorsR;

            var fillColorsSwitched = _this.fillColorsSwitched;
            if (fillColorsSwitched) {
                fillColors = fillColorsSwitched;
            }

            var dashLength = _this.dashLength;
            var dashLengthSwitched = _this.dashLengthSwitched;
            if (dashLengthSwitched) {
                dashLength = dashLengthSwitched;
            }

            var negativeLineColor = _this.negativeLineColor;
            var negativeFillColors = _this.negativeFillColors;
            var negativeFillAlphas = _this.negativeFillAlphas;

            var baseCoord = _this.baseCoord;

            if (_this.negativeBase !== 0) {
                baseCoord = _this.valueAxis.getCoordinate(_this.negativeBase);
            }

            // draw lines
            var line = AmCharts.line(container, xx, yy, lineColor, lineAlpha, lineThickness, dashLength, false, true);
            positiveSet.push(line);

            positiveSet.click(function(ev) {
                _this.handleGraphEvent(ev, 'clickGraph');
            }).mouseover(function(ev) {
                _this.handleGraphEvent(ev, 'rollOverGraph');
            }).mouseout(function(ev) {
                _this.handleGraphEvent(ev, 'rollOutGraph');
            });

            if (negativeLineColor !== undefined) {
                var negativeLine = AmCharts.line(container, xx, yy, negativeLineColor, negativeLineAlpha, lineThickness, dashLength, false, true);
                negativeSet.push(negativeLine);
            }

            if (fillAlphas > 0 || negativeFillAlphas > 0) {
                var xxx = xx.join(";").split(";");
                var yyy = yy.join(";").split(";");

                if (_this.chart.type == "serial") {
                    if (sxx.length > 0) {
                        sxx.reverse();
                        syy.reverse();

                        xxx = xx.concat(sxx);
                        yyy = yy.concat(syy);
                    } else {
                        if (_this.rotate) {
                            yyy.push(yyy[yyy.length - 1]);
                            xxx.push(baseCoord);
                            yyy.push(yyy[0]);
                            xxx.push(baseCoord);
                            yyy.push(yyy[0]);
                            xxx.push(xxx[0]);
                        } else {
                            xxx.push(xxx[xxx.length - 1]);
                            yyy.push(baseCoord);
                            xxx.push(xxx[0]);
                            yyy.push(baseCoord);
                            xxx.push(xx[0]);
                            yyy.push(yyy[0]);
                        }
                    }
                }
                var gradientRotation = _this.gradientRotation;

                if (fillAlphas > 0) {
                    var fill = AmCharts.polygon(container, xxx, yyy, fillColors, fillAlphas, 1, "#000", 0, gradientRotation);
                    fill.pattern(_this.pattern);
                    positiveSet.push(fill);
                }

                if (negativeFillColors || negativeLineColor !== undefined) {
                    if (isNaN(negativeFillAlphas)) {
                        negativeFillAlphas = fillAlphas;
                    }
                    if (!negativeFillColors) {
                        negativeFillColors = negativeLineColor;
                    }

                    var negativeFill = AmCharts.polygon(container, xxx, yyy, negativeFillColors, negativeFillAlphas, 1, "#000", 0, gradientRotation);
                    negativeFill.pattern(_this.pattern);
                    negativeSet.push(negativeFill);

                    negativeSet.click(function(ev) {
                        _this.handleGraphEvent(ev, 'clickGraph');
                    }).mouseover(function(ev) {
                        _this.handleGraphEvent(ev, 'rollOverGraph');
                    }).mouseout(function(ev) {
                        _this.handleGraphEvent(ev, 'rollOutGraph');
                    });
                }
            }
            _this.applyMask(negativeSet, positiveSet);

        }
    },

    applyMask: function(negativeSet, positiveSet) {
        var _this = this;
        var length = negativeSet.length();
        if (_this.chart.type == "serial" && !_this.scrollbar) {
            _this.positiveClip(positiveSet);
            if (length > 0) {
                _this.negativeClip(negativeSet);
            }
        }
    },


    drawSmoothedGraph: function(xx, yy, sxx, syy) {
        var _this = this;
        if (xx.length > 1) {
            var set = _this.set;
            var container = _this.container;

            var positiveSet = container.set();
            var negativeSet = container.set();

            set.push(negativeSet);
            set.push(positiveSet);

            var lineAlpha = _this.lineAlpha;
            var lineThickness = _this.lineThickness;
            var dashLength = _this.dashLength;
            var fillAlphas = _this.fillAlphas;
            var lineColor = _this.lineColorR;
            var fillColors = _this.fillColorsR;
            var negativeLineColor = _this.negativeLineColor;
            var negativeFillColors = _this.negativeFillColors;
            var negativeFillAlphas = _this.negativeFillAlphas;
            var baseCoord = _this.baseCoord;

            var lineColorSwitched = _this.lineColorSwitched;
            if (lineColorSwitched) {
                lineColor = lineColorSwitched;
            }

            var fillColorsSwitched = _this.fillColorsSwitched;
            if (fillColorsSwitched) {
                fillColors = fillColorsSwitched;
            }

            var negativeLineAlpha = _this.negativeLineAlpha;
            if (isNaN(negativeLineAlpha)) {
                negativeLineAlpha = lineAlpha;
            }

            // draw lines
            var line = new AmCharts.Bezier(container, xx, yy, lineColor, lineAlpha, lineThickness, fillColors, 0, dashLength);
            positiveSet.push(line.path);

            if (negativeLineColor !== undefined) {
                var negativeLine = new AmCharts.Bezier(container, xx, yy, negativeLineColor, negativeLineAlpha, lineThickness, fillColors, 0, dashLength);
                negativeSet.push(negativeLine.path);
            }

            if (fillAlphas > 0) {
                var xxx = xx.join(";").split(";");
                var yyy = yy.join(";").split(";");

                var endStr = "";
                var comma = ",";

                if (sxx.length > 0) {
                    sxx.push("M");
                    syy.push("M");
                    sxx.reverse();
                    syy.reverse();

                    xxx = xx.concat(sxx);
                    yyy = yy.concat(syy);
                } else {

                    if (_this.rotate) {
                        endStr += " L" + baseCoord + comma + yy[yy.length - 1];
                        endStr += " L" + baseCoord + comma + yy[0];
                        endStr += " L" + xx[0] + comma + yy[0];
                    } else {
                        endStr += " L" + xx[xx.length - 1] + comma + baseCoord;
                        endStr += " L" + xx[0] + comma + baseCoord;
                        endStr += " L" + xx[0] + comma + yy[0];
                    }
                }
                var fill = new AmCharts.Bezier(container, xxx, yyy, NaN, 0, 0, fillColors, fillAlphas, dashLength, endStr);
                fill.path.pattern(_this.pattern);
                positiveSet.push(fill.path);

                if (negativeFillColors || negativeLineColor !== undefined) {
                    if (!negativeFillAlphas) {
                        negativeFillAlphas = fillAlphas;
                    }
                    if (!negativeFillColors) {
                        negativeFillColors = negativeLineColor;
                    }

                    var negativeFill = new AmCharts.Bezier(container, xx, yy, NaN, 0, 0, negativeFillColors, negativeFillAlphas, dashLength, endStr);
                    negativeFill.path.pattern(_this.pattern);
                    negativeSet.push(negativeFill.path);
                }
            }
            _this.applyMask(negativeSet, positiveSet);
        }
    },


    launchAnimation: function() {
        var _this = this;
        var duration = _this.chart.startDuration;

        if (duration > 0 && !_this.animationPlayed) {

            var set = _this.set;
            var bulletSet = _this.bulletSet;

            if (!AmCharts.VML) {
                set.attr({
                    'opacity': _this.startAlpha
                });
                bulletSet.attr({
                    'opacity': _this.startAlpha
                });
            }

            set.hide();
            bulletSet.hide();

            if (_this.seqAn) {
                var t = setTimeout(function() {
                    _this.animateGraphs.call(_this);
                }, _this.index * duration * 1000);
                _this.timeOuts.push(t);
            } else {
                _this.animateGraphs();
            }
        }
    },

    animateGraphs: function() {
        var _this = this;
        var chart = _this.chart;
        var set = _this.set;
        var bulletSet = _this.bulletSet;
        var x = _this.x;
        var y = _this.y;

        set.show();
        bulletSet.show();

        var duration = chart.startDuration;
        var effect = chart.startEffect;

        if (set) {
            if (_this.rotate) {
                set.translate(-1000, y);
                bulletSet.translate(-1000, y);
            } else {
                set.translate(x, -1000);
                bulletSet.translate(x, -1000);
            }
            set.animate({
                opacity: 1,
                translate: x + "," + y
            }, duration, effect);
            bulletSet.animate({
                opacity: 1,
                translate: x + "," + y
            }, duration, effect);
        }
    },

    animate: function(cuboid) {
        var _this = this;
        var chart = _this.chart;
        var container = _this.container;

        var animationArray = _this.animationArray;
        if (!cuboid && animationArray.length > 0) {
            cuboid = animationArray[0];
            animationArray.shift();
        }

        var effect = AmCharts[AmCharts.getEffect(chart.startEffect)];
        var duration = chart.startDuration;

        if (cuboid) {
            if (this.rotate) {
                cuboid.animateWidth(duration, effect);
            } else {
                cuboid.animateHeight(duration, effect);
            }
            var obj = cuboid.set;
            obj.show();
        }
    },

    legendKeyColor: function() {
        var _this = this;
        var color = _this.legendColor;
        var lineAlpha = _this.lineAlpha;

        if (color === undefined) {
            color = _this.lineColorR;

            if (lineAlpha === 0) {
                var colorArray = _this.fillColorsR;
                if (colorArray) {
                    if (typeof(colorArray) == 'object') {
                        color = colorArray[0];
                    } else {
                        color = colorArray;
                    }
                }
            }
        }
        return color;
    },

    legendKeyAlpha: function() {
        var _this = this;
        var alpha = _this.legendAlpha;
        if (alpha === undefined) {
            alpha = _this.lineAlpha;

            if (_this.fillAlphas > alpha) {
                alpha = _this.fillAlphas;
            }

            if (alpha === 0) {
                alpha = _this.bulletAlpha;
            }
            if (alpha === 0) {
                alpha = 1;
            }
        }
        return alpha;
    },


    createBullet: function(graphDataItem, bulletX, bulletY, index) {
        var _this = this;
        var container = _this.container;
        var bulletOffset = _this.bulletOffset;
        var bulletSize = _this.bulletSize;
        if (!isNaN(graphDataItem.bulletSize)) {
            bulletSize = graphDataItem.bulletSize;
        }

        var value = graphDataItem.values.value;
        var maxValue = _this.maxValue;
        var minValue = _this.minValue;
        var maxBulletSize = _this.maxBulletSize;
        var minBulletSize = _this.minBulletSize;
        if (!isNaN(maxValue)) {
            if (!isNaN(value)) {
                //bulletSize = value / _this.maxValue * _this.maxBulletSize;
                bulletSize = (value - minValue) / (maxValue - minValue) * (maxBulletSize - minBulletSize) + minBulletSize;
            }

            if(minValue == maxValue){
                bulletSize = maxBulletSize;
            }
        }

        var originalSize = bulletSize;

        if (_this.bulletAxis) {
            var error = graphDataItem.values.error;

            if (!isNaN(error)) {
                value = error;
            }
            bulletSize = _this.bulletAxis.stepWidth * value;
        }

        if (bulletSize < _this.minBulletSize) {
            bulletSize = _this.minBulletSize;
        }

        if (_this.rotate) {
            if(graphDataItem.isNegative){
                bulletX -= bulletOffset;
            }
            else{
                bulletX += bulletOffset;
            }

        } else {
            if(graphDataItem.isNegative){
                bulletY += bulletOffset;
            }
            else{
                bulletY -= bulletOffset;
            }

        }

        // BULLETS
        var bullet;

        var bulletColor = _this.bulletColorR;

        if (graphDataItem.lineColor) {
            _this.bulletColorSwitched = graphDataItem.lineColor;
        }

        if (_this.bulletColorSwitched) {
            bulletColor = _this.bulletColorSwitched;
        }

        if (graphDataItem.isNegative && _this.bulletColorNegative !== undefined) {
            bulletColor = _this.bulletColorNegative;
        }

        if (graphDataItem.color !== undefined) {
            bulletColor = graphDataItem.color;
        }

        var pattern;
        if(_this.chart.type == "xy"){
            if(_this.valueField){
                pattern = _this.pattern;
                if(graphDataItem.pattern){
                    pattern = graphDataItem.pattern;
                }
            }
        }

        var bulletType = _this.bullet;
        if (graphDataItem.bullet) {
            bulletType = graphDataItem.bullet;
        }

        var bbt = _this.bulletBorderThickness;
        var bbc = _this.bulletBorderColorR;
        var bba = _this.bulletBorderAlpha;
        var bc = bulletColor;
        var ba = _this.bulletAlpha;

        if (!bbc) {
            bbc = bc;
        }
        if(_this.useLineColorForBulletBorder){
            bbc = _this.lineColorR;
        }

        var customAlpha = graphDataItem.alpha;
        if (!isNaN(customAlpha)) {
            ba = customAlpha;
        }

        var extremeLeft = 0;
        if (_this.bullet == "none" && !graphDataItem.bullet) {
            //void
        } else {
            bullet = AmCharts.bullet(container, bulletType, bulletSize, bc, ba, bbt, bbc, bba, originalSize, 0, pattern);
        }
        var dbx = 0;
        var dby = 0;
        if (_this.customBullet || graphDataItem.customBullet) {
            var customBullet = _this.customBullet;

            if (graphDataItem.customBullet) {
                customBullet = graphDataItem.customBullet;
            }

            if (customBullet) {
                if (bullet) {
                    bullet.remove();
                }

                if (typeof(customBullet) == "function") {
                    var customBulletClass = new customBullet();

                    customBulletClass.chart = _this.chart;

                    if (graphDataItem.bulletConfig) {
                        customBulletClass.availableSpace = bulletY;
                        customBulletClass.graph = _this;
                        graphDataItem.bulletConfig.minCoord = _this.minCoord - bulletY;
                        customBulletClass.bulletConfig = graphDataItem.bulletConfig;
                    }
                    customBulletClass.write(container);
                    bullet = customBulletClass.set;
                } else {
                    if (_this.chart.path) {
                        customBullet = _this.chart.path + customBullet;
                    }
                    bullet = container.set();
                    var bulletImage = container.image(customBullet, 0, 0, bulletSize, bulletSize);
                    bullet.push(bulletImage);

                    if (_this.centerCustomBullets) {
                        bulletImage.translate(-bulletSize / 2, -bulletSize / 2);
                    }
                }
            }
        }

        if (bullet) {
            if (graphDataItem.url || _this.showHandOnHover) {
                bullet.setAttr("cursor", "pointer");
            }



            if (_this.chart.type == "serial") {
                if (bulletX - dbx < extremeLeft || bulletX - dbx > _this.width || bulletY < -bulletSize / 2 || bulletY - dby > _this.height) {
                    bullet.remove();
                    bullet = null;
                }
            }
            if (bullet) {
                _this.bulletSet.push(bullet);
                bullet.translate(bulletX, bulletY);
                _this.addListeners(bullet, graphDataItem);
                _this.allBullets.push(bullet);
            }
            graphDataItem.bx = bulletX;
            graphDataItem.by = bulletY;
        }

        graphDataItem.bulletGraphics = bullet;

        return bulletSize;
    },

    showBullets: function() {
        var _this = this;
        var allBullets = _this.allBullets;
        var i;
        _this.bulletsHidden = false;
        for (i = 0; i < allBullets.length; i++) {
            allBullets[i].show();
        }
    },

    hideBullets: function() {
        var _this = this;
        var allBullets = _this.allBullets;
        var i;
        _this.bulletsHidden = true;
        for (i = 0; i < allBullets.length; i++) {
            allBullets[i].hide();
        }
    },


    addListeners: function(obj, dItem) {
        var _this = this;
        obj.mouseover(function(ev) {
            _this.handleRollOver(dItem, ev);
        }).mouseout(function(ev) {
            _this.handleRollOut(dItem, ev);
        }).touchend(function(ev) {
            _this.handleRollOver(dItem, ev);
            if (_this.chart.panEventsEnabled) {
                _this.handleClick(dItem, ev);
            }
        }).touchstart(function(ev) {
            _this.handleRollOver(dItem, ev);
        }).click(function(ev) {
            _this.handleClick(dItem, ev);
        }).dblclick(function(ev) {
            _this.handleDoubleClick(dItem, ev);
        }).contextmenu(function(ev) {
            _this.handleRightClick(dItem, ev);
        });
    },

    handleRollOver: function(dItem, ev) {
        var _this = this;

        if (dItem) {
            var chart = _this.chart;
            var type = 'rollOverGraphItem';
            var event = {
                type: type,
                item: dItem,
                index: dItem.index,
                graph: _this,
                target: _this,
                chart: _this.chart,
                event: ev
            };
            _this.fire(type, event);
            chart.fire(type, event);
            clearTimeout(chart.hoverInt);


            var show = _this.showBalloon;

            if (chart.chartCursor && chart.type == "serial") {
                show = false;
                if (!chart.chartCursor.valueBalloonsEnabled && _this.showBalloon) {
                    show = true;
                }
            }
            if (show) {
                var text = chart.formatString(_this.balloonText, dItem, true);

                var balloonFunction = _this.balloonFunction;
                if (balloonFunction) {
                    text = balloonFunction(dItem, dItem.graph);
                }

                text = AmCharts.cleanFromEmpty(text);
                var color = chart.getBalloonColor(_this, dItem);
                chart.balloon.showBullet = false;
                chart.balloon.pointerOrientation = "V";
                var bx = dItem.x;
                var by = dItem.y;
                if (chart.rotate) {
                    bx = dItem.y;
                    by = dItem.x;
                }
                chart.showBalloon(text, color, true, bx + chart.marginLeftReal, by + chart.marginTopReal);
            }
        }

        _this.handleGraphEvent(ev, 'rollOverGraph');
    },


    handleRollOut: function(dItem, ev) {
        var _this = this;
        _this.chart.hideBalloon();

        if (dItem) {
            var type = 'rollOutGraphItem';
            var event = {
                type: type,
                item: dItem,
                index: dItem.index,
                graph: this,
                target: _this,
                chart: _this.chart,
                event: ev
            };
            _this.fire(type, event);
            _this.chart.fire(type, event);
        }

        _this.handleGraphEvent(ev, 'rollOutGraph');
    },

    handleClick: function(dItem, ev) {
        var _this = this;

        if (dItem) {
            var type = 'clickGraphItem';
            var event = {
                type: type,
                item: dItem,
                index: dItem.index,
                graph: _this,
                target: _this,
                chart: _this.chart,
                event: ev
            };
            _this.fire(type, event);
            _this.chart.fire(type, event);

            AmCharts.getURL(dItem.url, _this.urlTarget);
        }

        _this.handleGraphEvent(ev, 'clickGraph');
    },

    handleGraphEvent: function(ev, type) {
        var _this = this;

        var event = {
            type: type,
            graph: _this,
            target: _this,
            chart: _this.chart,
            event: ev
        };
        _this.fire(type, event);
        _this.chart.fire(type, event);
    },

    handleRightClick: function(dItem, ev) {
        var _this = this;

        if (dItem) {
            var type = 'rightClickGraphItem';
            var event = {
                type: type,
                item: dItem,
                index: dItem.index,
                graph: _this,
                target: _this,
                chart: _this.chart,
                event: ev
            };
            _this.fire(type, event);
            _this.chart.fire(type, event);
        }
    },


    handleDoubleClick: function(dItem, ev) {
        var _this = this;

        if (dItem) {
            var type = 'doubleClickGraphItem';
            var event = {
                type: type,
                item: dItem,
                index: dItem.index,
                graph: _this,
                target: _this,
                chart: _this.chart,
                event: ev
            };
            _this.fire(type, event);
            _this.chart.fire(type, event);
        }
    },

    zoom: function(start, end) {
        var _this = this;
        _this.start = start;
        _this.end = end;
        _this.draw();
    },

    changeOpacity: function(a) {
        var _this = this;
        var set = _this.set;
        var OPACITY = "opacity";
        if (set) {
            set.setAttr(OPACITY, a);
        }
        var ownColumns = _this.ownColumns;
        if (ownColumns) {
            var i;
            for (i = 0; i < ownColumns.length; i++) {
                var cset = ownColumns[i].set;
                if (cset) {
                    cset.setAttr(OPACITY, a);
                }
            }
        }
        var bulletSet = _this.bulletSet;
        if (bulletSet) {
            bulletSet.setAttr(OPACITY, a);
        }
    },

    destroy: function() {
        var _this = this;
        AmCharts.remove(_this.set);
        AmCharts.remove(_this.bulletSet);

        var timeOuts = _this.timeOuts;
        if (timeOuts) {
            var i;
            for (i = 0; i < timeOuts.length; i++) {
                clearTimeout(timeOuts[i]);
            }
        }
        _this.timeOuts = [];
    }

});// @tag amchart
AmCharts.AmSlicedChart = AmCharts.Class({

    inherits: AmCharts.AmChart,

    construct: function (theme) {
        var _this = this;
        _this.createEvents('rollOverSlice', 'rollOutSlice', 'clickSlice', 'pullOutSlice', 'pullInSlice', 'rightClickSlice');

        AmCharts.AmSlicedChart.base.construct.call(_this, theme);

        _this.colors = ["#FF0F00", "#FF6600", "#FF9E01", "#FCD202", "#F8FF01", "#B0DE09", "#04D215", "#0D8ECF", "#0D52D1", "#2A0CD0", "#8A0CCF", "#CD0D74", "#754DEB", "#DDDDDD", "#999999", "#333333", "#000000", "#57032A", "#CA9726", "#990000", "#4B0C25"];
        _this.alpha = 1;
        _this.groupPercent = 0;
        _this.groupedTitle = "Other";
        _this.groupedPulled = false;
        _this.groupedAlpha = 1;
        _this.marginLeft = 0;
        _this.marginTop = 10;
        _this.marginBottom = 10;
        _this.marginRight = 0;
        _this.hoverAlpha = 1;
        _this.outlineColor = '#FFFFFF';
        _this.outlineAlpha = 0;
        _this.outlineThickness = 1;
        _this.startAlpha = 0;
        _this.startDuration = 1;
        _this.startEffect = 'bounce';
        _this.sequencedAnimation = true;
        _this.pullOutDuration = 1;
        _this.pullOutEffect = 'bounce';
        _this.pullOutOnlyOne = false;
        _this.pullOnHover = false;
        _this.labelsEnabled = true;
        _this.labelTickColor = "#000000";
        _this.labelTickAlpha = 0.2;
        _this.hideLabelsPercent = 0;
        _this.urlTarget = "_self";
        _this.autoMarginOffset = 10;
        _this.gradientRatio = [];

        AmCharts.applyTheme(_this, theme, "AmSlicedChart");
    },

    initChart: function () {
        var _this = this;
        AmCharts.AmSlicedChart.base.initChart.call(_this);

        if (_this.dataChanged) {
            _this.parseData();
            _this.dispatchDataUpdated = true;
            _this.dataChanged = false;
            _this.setLegendData(_this.chartData);
        }
        _this.drawChart();
    },


    handleLegendEvent: function (event) {
        var _this = this;
        var type = event.type;
        var dItem = event.dataItem;
        if(!_this.legend.data){
            if (dItem) {
                var hidden = dItem.hidden;

                switch (type) {
                    case 'clickMarker':
                        if (!hidden) {
                            _this.clickSlice(dItem);
                        }
                        break;
                    case 'clickLabel':
                        if (!hidden) {
                            _this.clickSlice(dItem);
                        }
                        break;
                    case 'rollOverItem':
                        if (!hidden) {
                            _this.rollOverSlice(dItem, false);
                        }
                        break;
                    case 'rollOutItem':
                        if (!hidden) {
                            _this.rollOutSlice(dItem);
                        }
                        break;
                    case 'hideItem':
                        _this.hideSlice(dItem);
                        break;
                    case 'showItem':
                        _this.showSlice(dItem);
                        break;
                }
            }
        }
    },

    invalidateVisibility: function () {
        var _this = this;
        _this.recalculatePercents();
        _this.initChart();
        var legend = _this.legend;
        if (legend) {
            legend.invalidateSize();
        }
    },

    addEventListeners: function (wedge, dItem) {
        var _this = this;

        wedge.mouseover(function (ev) {
            _this.rollOverSlice(dItem, true, ev);
        }).mouseout(function (ev) {
            _this.rollOutSlice(dItem, ev);
        }).touchend(function (ev) {
            _this.rollOverSlice(dItem, ev);
            if(_this.panEventsEnabled){
                _this.clickSlice(dItem, ev);
            }
        }).touchstart(function (ev) {
            _this.rollOverSlice(dItem, ev);
        }).click(function (ev) {
            _this.clickSlice(dItem, ev);
        }).contextmenu(function (ev) {
            _this.handleRightClick(dItem, ev);
        });

    },


    formatString: function (text, dItem, noFixBrakes) {
        var _this = this;

        text = AmCharts.formatValue(text, dItem, ["value"], _this.nf, "", _this.usePrefixes, _this.prefixesOfSmallNumbers, _this.prefixesOfBigNumbers);
        text = AmCharts.formatValue(text, dItem, ["percents"], _this.pf);
        text = AmCharts.massReplace(text, {
            "[[title]]": dItem.title,
                "[[description]]": dItem.description
        });

        if (text.indexOf("[[") != -1) {
            text = AmCharts.formatDataContextValue(text, dItem.dataContext);
        }

        if(!noFixBrakes){
            text = AmCharts.fixBrakes(text);
        }
        else{
            // balloon
           text = AmCharts.fixNewLines(text);
        }
        text = AmCharts.cleanFromEmpty(text);

        return text;
    },

    startSlices: function () {
        var _this = this;

        var i;
        for (i = 0; i < _this.chartData.length; i++) {
            if (_this.startDuration > 0 && _this.sequencedAnimation) {
                _this.setStartTO(i);
            } else {
                _this.startSlice(_this.chartData[i]);
            }
        }
    },

    setStartTO: function (i) {
        var _this = this;
        var interval = _this.startDuration / _this.chartData.length * 500;
        var t = setTimeout(function () {
            _this.startSequenced.call(_this);
        }, interval * i);
        _this.timeOuts.push(t);
    },

    pullSlices: function (instant) {
        var _this = this;
        var chartData = _this.chartData;
        var i;
        for (i = 0; i < chartData.length; i++) {
            var slice = chartData[i];
            if (slice.pulled) {
                _this.pullSlice(slice, 1, instant);
            }
        }
    },

    startSequenced: function () {
        var _this = this;
        var chartData = _this.chartData;
        var i;
        for (i = 0; i < chartData.length; i++) {
            if (!chartData[i].started) {
                var dItem = _this.chartData[i];
                _this.startSlice(dItem);
                break;
            }
        }
    },

    startSlice: function (dItem) {
        var _this = this;
        dItem.started = true;
        var w = dItem.wedge;
        var startDuration = _this.startDuration;
        if (w && startDuration > 0) {
            if (dItem.alpha > 0) {
                w.show();
            }

            w.translate(dItem.startX, dItem.startY);
            w.animate({
                'opacity': 1,
                translate: '0,0'
            }, startDuration, _this.startEffect);
        }
    },


    showLabels: function () {
        var _this = this;
        var chartData = _this.chartData;
        var i;
        for (i = 0; i < chartData.length; i++) {
            var dItem = chartData[i];
            if (dItem.alpha > 0) {
                var label = dItem.label;
                if (label) {
                    label.show();
                }
                var tick = dItem.tick;
                if (tick) {
                    tick.show();
                }
            }
        }
    },

    showSlice: function (dItem) {
        var _this = this;
        if (isNaN(dItem)) {
            dItem.hidden = false;
        } else {
            _this.chartData[dItem].hidden = false;
        }
        //_this.hideBalloon();
        _this.invalidateVisibility();
    },

    hideSlice: function (dItem) {
        var _this = this;
        if (isNaN(dItem)) {
            dItem.hidden = true;
        } else {
            _this.chartData[dItem].hidden = true;
        }
        _this.hideBalloon();
        _this.invalidateVisibility();
    },

    rollOverSlice: function (dItem, follow, ev) {
        var _this = this;
        if (!isNaN(dItem)) {
            dItem = _this.chartData[dItem];
        }
        clearTimeout(_this.hoverInt);

        if(!dItem.hidden){

            if (_this.pullOnHover) {
                _this.pullSlice(dItem, 1);
            }

            if (_this.hoverAlpha < 1) {
                var wedge = dItem.wedge;
                if (wedge) {
                    dItem.wedge.attr({
                        'opacity': _this.hoverAlpha
                    });
                }
            }

            var x = dItem.balloonX;
            var y = dItem.balloonY;

            if (dItem.pulled) {
                x += dItem.pullX;
                y += dItem.pullY;
            }

            var text = _this.formatString(_this.balloonText, dItem, true);

            var color = AmCharts.adjustLuminosity(dItem.color, -0.15);

            _this.showBalloon(text, color, follow, x, y);

            var evt = {
                type: 'rollOverSlice',
                dataItem: dItem,
                chart: _this,
                event:ev
            };
            _this.fire(evt.type, evt);
        }
    },

    rollOutSlice: function (dItem, ev) {
        var _this = this;
        if (!isNaN(dItem)) {
            dItem = _this.chartData[dItem];
        }
        var wedge = dItem.wedge;
        if (wedge) {
            dItem.wedge.attr({
                'opacity': 1
            });
        }

        _this.hideBalloon();
        var evt = {
            type: 'rollOutSlice',
            dataItem: dItem,
            chart: _this,
            event:ev
        };
        _this.fire(evt.type, evt);
    },

    clickSlice: function (dItem, ev) {
        var _this = this;
        if (!isNaN(dItem)) {
            dItem = _this.chartData[dItem];
        }

        //_this.hideBalloon();
        if (dItem.pulled) {
            _this.pullSlice(dItem, 0);
        } else {
            _this.pullSlice(dItem, 1);
        }

        AmCharts.getURL(dItem.url, _this.urlTarget);

        var evt = {
            type: 'clickSlice',
            dataItem: dItem,
            chart: _this,
            event:ev
        };
        _this.fire(evt.type, evt);
    },

    handleRightClick: function (dItem, ev) {
        var _this = this;
        if (!isNaN(dItem)) {
            dItem = _this.chartData[dItem];
        }
        var evt = {
            type: 'rightClickSlice',
            dataItem: dItem,
            chart: _this,
            event:ev
        };
        _this.fire(evt.type, evt);
    },

    drawTicks: function () {
        var _this = this;
        var chartData = _this.chartData;
        var i;
        for (i = 0; i < chartData.length; i++) {
            var dItem = chartData[i];
            var label = dItem.label;
            if (label) {
                var x0 = dItem.tx0;
                var y0 = dItem.ty0;
                var x = dItem.tx;
                var x2 = dItem.tx2;
                var y = dItem.ty;
                var radiusReal = _this.radiusReal;

                var tick = AmCharts.line(_this.container, [x0, x, x2], [y0, y, y], _this.labelTickColor, _this.labelTickAlpha);
                dItem.tick = tick;
                dItem.wedge.push(tick);
            }
        }
    },

    initialStart: function () {
        var _this = this;
        var startDuration = _this.startDuration;
        var t = setTimeout(function () {
            _this.showLabels.call(_this);
        }, startDuration * 1000);
        _this.timeOuts.push(t);

        if (_this.chartCreated) {
            _this.pullSlices(true);
        } else {
            var to = setTimeout(function () {
                _this.pullSlices.call(_this);
            }, startDuration * 1200);
            _this.timeOuts.push(to);
            _this.startSlices();
        }
    },

    pullSlice: function (dItem, dir, instant) {
        var _this = this;
        var duration = _this.pullOutDuration;
        if (instant === true) {
            duration = 0;
        }
        var wedge = dItem.wedge;

        var radius = _this.pullOutRadiusReal;
        if (wedge) {
            wedge.animate({
                'translate': (dir * dItem.pullX) + ',' + (dir * dItem.pullY)
            }, duration, _this.pullOutEffect);
        }

        var evt;
        if (dir == 1) {
            dItem.pulled = true;
            if (_this.pullOutOnlyOne) {
                _this.pullInAll(dItem.index);
            }

            evt = {
                type: 'pullOutSlice',
                dataItem: dItem,
                chart: _this
            };
        } else {
            dItem.pulled = false;
            evt = {
                type: 'pullInSlice',
                dataItem: dItem,
                chart: _this
            };
        }
        _this.fire(evt.type, evt);
    },

    pullInAll: function (except) {
        var _this = this;
        var chartData = _this.chartData;
        var i;
        for (i = 0; i < _this.chartData.length; i++) {
            if (i != except) {
                if (chartData[i].pulled) {
                    _this.pullSlice(chartData[i], 0);
                }
            }
        }
    },

    pullOutAll: function (scale) {
        var _this = this;
        var chartData = _this.chartData;
        var i;
        for (i = 0; i < chartData.length; i++) {
            if (!chartData[i].pulled) {
                _this.pullSlice(chartData[i], 1);
            }
        }
    },

    parseData: function () {
        var _this = this;
        var chartData = [];
        _this.chartData = chartData;

        var dp = _this.dataProvider;

        // backward compatibility
        if (!isNaN(_this.pieAlpha)) {
            _this.alpha = _this.pieAlpha;
        }

        if (dp !== undefined) {
            var sliceCount = dp.length;

            var sum = 0;

            // caluclate sum
            var i;
            var dataItem;
            var color;
            for (i = 0; i < sliceCount; i++) {
                dataItem = {};
                var dataSource = dp[i];
                dataItem.dataContext = dataSource;

                dataItem.value = Number(dataSource[_this.valueField]);

                var title = dataSource[_this.titleField];
                if (!title) {
                    title = "";
                }
                dataItem.title = title;

                dataItem.pulled = AmCharts.toBoolean(dataSource[_this.pulledField], false);

                var description = dataSource[_this.descriptionField];
                if (!description) {
                    description = "";
                }
                dataItem.description = description;

                dataItem.labelRadius = Number(dataSource[_this.labelRadiusField]);

                dataItem.url = dataSource[_this.urlField];


                var pattern = dataSource[_this.patternField];
                if(!pattern && _this.patterns){
                    pattern = _this.patterns[i];
                }


                dataItem.pattern = pattern;

                dataItem.visibleInLegend = AmCharts.toBoolean(dataSource[_this.visibleInLegendField], true);

                var alpha = dataSource[_this.alphaField];
                if (alpha !== undefined) {
                    dataItem.alpha = Number(alpha);
                } else {
                    dataItem.alpha = _this.alpha;
                }

                color = dataSource[_this.colorField];
                if (color !== undefined) {
                    dataItem.color = AmCharts.toColor(color);
                }

                dataItem.labelColor = AmCharts.toColor(dataSource[_this.labelColorField]);

                sum += dataItem.value;

                dataItem.hidden = false;

                chartData[i] = dataItem;
            }

            // calculate percents
            var groupCount = 0;

            for (i = 0; i < sliceCount; i++) {
                dataItem = chartData[i];
                dataItem.percents = dataItem.value / sum * 100;

                if (dataItem.percents < _this.groupPercent) {
                    groupCount++;
                }
            }

            // group to others slice
            if (groupCount > 1) {
                _this.groupValue = 0;
                _this.removeSmallSlices();

                var value = _this.groupValue;
                var percents = _this.groupValue / sum * 100;
                chartData.push({
                    title: _this.groupedTitle,
                    value: value,
                    percents: percents,
                    pulled: _this.groupedPulled,
                    color: _this.groupedColor,
                    url: _this.groupedUrl,
                    description: _this.groupedDescription,
                    alpha: _this.groupedAlpha,
                    pattern: _this.groupedPattern,
                    dataContext:{}
                });
            }

            // v2 compatibility
            var baseColor = _this.baseColor;
            if (!baseColor) {
                baseColor = _this.pieBaseColor;
            }

            var brightnessStep = _this.brightnessStep;
            if (!brightnessStep) {
                brightnessStep = _this.pieBrightnessStep;
            }

            // now set colors
            for (i = 0; i < chartData.length; i++) {

                if (baseColor) {
                    color = AmCharts.adjustLuminosity(baseColor, i * brightnessStep / 100);
                } else {
                    color = _this.colors[i];
                    if (color === undefined) {
                        color = AmCharts.randomColor();
                    }
                }
                if (chartData[i].color === undefined) {
                    chartData[i].color = color;
                }
            }

            _this.recalculatePercents();
        }
    },


    recalculatePercents: function () {
        var _this = this;
        var chartData = _this.chartData;
        var sum = 0;
        var i;
        var dItem;
        for (i = 0; i < chartData.length; i++) {
            dItem = chartData[i];
            if (!dItem.hidden && dItem.value > 0) {
                sum += dItem.value;
            }
        }
        for (i = 0; i < chartData.length; i++) {
            dItem = _this.chartData[i];
            if (!dItem.hidden && dItem.value > 0) {
                dItem.percents = dItem.value * 100 / sum;
            } else {
                dItem.percents = 0;
            }
        }
    },


    // remove slices which are less then __config.group.percent
    removeSmallSlices: function () {
        var _this = this;
        var chartData = _this.chartData;
        var i;
        for (i = chartData.length - 1; i >= 0; i--) {
            if (chartData[i].percents < _this.groupPercent) {
                _this.groupValue += chartData[i].value;
                chartData.splice(i, 1);
            }
        }
    },


    animateAgain: function () {
        var _this = this;
        _this.startSlices();
        var t = setTimeout(function () {
            _this.pullSlices.call(_this);
        }, _this.startDuration * 1200);
        _this.timeOuts.push(t);
    },


    measureMaxLabel: function () {
        var _this = this;
        var chartData = _this.chartData;
        var maxWidth = 0;
        var i;
        for (i = 0; i < chartData.length; i++) {
            var dItem = chartData[i];
            var text = _this.formatString(_this.labelText, dItem);
            var txt = AmCharts.text(_this.container, text, _this.color, _this.fontFamily, _this.fontSize);
            var w = txt.getBBox().width;
            if (w > maxWidth) {
                maxWidth = w;
            }
            txt.remove();
        }
        return maxWidth;
    }
});// @tag amchart
AmCharts.ChartCursor = AmCharts.Class({

    construct: function (theme) {
        var _this = this;
        _this.cname = "ChartCursor";
        _this.createEvents('changed', 'zoomed', 'onHideCursor', 'draw', 'selected', "moved");
        _this.enabled = true;
        _this.cursorAlpha = 1;
        _this.selectionAlpha = 0.2;
        _this.cursorColor = '#CC0000';
        _this.categoryBalloonAlpha = 1;
        _this.color = '#FFFFFF';
        _this.type = "cursor";
        _this.zoomed = false;
        _this.zoomable = true;
        _this.pan = false;
        _this.categoryBalloonDateFormat = "MMM DD, YYYY";
        _this.valueBalloonsEnabled = true;
        _this.categoryBalloonEnabled = true;
        _this.rolledOver = false;
        _this.cursorPosition = "middle";
        _this.skipZoomDispatch = false;
        _this.bulletsEnabled = false;
        _this.bulletSize = 8;
        _this.oneBalloonOnly = false;
        _this.selectWithoutZooming = false;
        _this.graphBulletSize = 1.7;
        _this.animationDuration = 0.3;
        _this.zooming = false;
        _this.adjustment = 0;
        //_this.fullWidth;

        AmCharts.applyTheme(_this, theme, _this.cname);
    },

    draw: function () {
        var _this = this;
        _this.destroy();
        var chart = _this.chart;
        var container = chart.container;
        _this.rotate = chart.rotate;
        _this.container = container;

        var set = container.set();
        set.translate(_this.x, _this.y);
        _this.set = set;
        chart.cursorSet.push(set);

        var categoryBalloon = new AmCharts.AmBalloon();
        categoryBalloon.chart = chart;
        _this.categoryBalloon = categoryBalloon;
        AmCharts.copyProperties(chart.balloon, categoryBalloon);
        categoryBalloon.cornerRadius = 0;
        categoryBalloon.shadowAlpha = 0;
        categoryBalloon.borderThickness = 1;
        categoryBalloon.borderAlpha = 1;
        categoryBalloon.showBullet = false;

        var categoryBalloonColor = _this.categoryBalloonColor;
        if (categoryBalloonColor === undefined) {
            categoryBalloonColor = _this.cursorColor;
        }
        categoryBalloon.fillColor = categoryBalloonColor;
        categoryBalloon.fillAlpha = _this.categoryBalloonAlpha;
        categoryBalloon.borderColor = categoryBalloonColor;
        categoryBalloon.color = _this.color;

        if (_this.rotate) {
            categoryBalloon.pointerOrientation = "H";
        }

        _this.extraWidth = 0;
        _this.prevX = [];
        _this.prevY = [];
        _this.prevTX = [];
        _this.prevTY = [];

        // create value balloons
        if (_this.valueBalloonsEnabled) {
            var i;
            for (i = 0; i < chart.graphs.length; i++) {
                var valueBalloon = new AmCharts.AmBalloon();
                valueBalloon.chart = chart;
                AmCharts.copyProperties(chart.balloon, valueBalloon);
                chart.graphs[i].valueBalloon = valueBalloon;
            }
        }

        if (_this.type == "cursor") {
            _this.createCursor();
        } else {
            _this.createCrosshair();
        }

        _this.interval = setInterval(function () {
            _this.detectMovement.call(_this);
        }, 40);
    },

    updateData: function () {
        var _this = this;
        var chart = _this.chart;
        _this.data = chart.chartData;

        _this.firstTime = chart.firstTime;
        _this.lastTime = chart.lastTime;
    },

    createCursor: function () {
        var _this = this;
        var chart = _this.chart;
        var cursorAlpha = _this.cursorAlpha;
        var categoryAxis = chart.categoryAxis;
        var categoryBalloonPosition = categoryAxis.position;
        var inside = categoryAxis.inside;
        var axisThickness = categoryAxis.axisThickness;
        var categoryBalloon = _this.categoryBalloon;
        var xx;
        var yy;
        var dx = chart.dx;
        var dy = chart.dy;
        var x = _this.x;
        var y = _this.y;
        var width = _this.width;
        var height = _this.height;
        var rotate = chart.rotate;
        var tickLength = categoryAxis.tickLength;
        categoryBalloon.pointerWidth = tickLength;

        if (rotate) {
            xx = [0, width, width + dx];
            yy = [0, 0, dy];
        } else {
            xx = [dx, 0, 0];
            yy = [dy, 0, height];
        }

        var line = AmCharts.line(_this.container, xx, yy, _this.cursorColor, cursorAlpha, 1);
        _this.line = line;
        var fullRectSet = _this.fullRectSet;
        if(fullRectSet){
            fullRectSet.push(line);
            fullRectSet.translate(_this.x, _this.y);
        }
        else{
            _this.set.push(line);
        }


        // BOUNDS OF X BALLOON
        // ROTATE
        if (rotate) {
            if (inside) {
                categoryBalloon.pointerWidth = 0;
            }
            // RIGHT
            if (categoryBalloonPosition == "right") {
                // INSIDE
                if (inside) {
                    categoryBalloon.setBounds(x, y + dy, x + width + dx, y + height + dy);
                }
                // OUTSIDE
                else {
                    categoryBalloon.setBounds(x + width + dx + axisThickness, y + dy, x + width + 1000, y + height + dy);
                }
            }
            // LEFT
            else {
                // INSIDE
                if (inside) {
                    categoryBalloon.setBounds(x, y, width + x, height + y);
                }
                // OUTSIDE
                else {
                    categoryBalloon.setBounds(-1000, -1000, x - tickLength - axisThickness, y + height + 15);
                }
            }
        }
        // DO NOT ROTATE
        else {
            categoryBalloon.maxWidth = width;

            if (categoryAxis.parseDates) {
                tickLength = 0;
                categoryBalloon.pointerWidth = 0;
            }

            // TOP
            if (categoryBalloonPosition == "top") {
                // INSIDE
                if (inside) {
                    categoryBalloon.setBounds(x + dx, y + dy, width + dx + x, height + y);
                }
                // OUTSIDE
                else {
                    categoryBalloon.setBounds(x + dx, -1000, width + dx + x, y + dy - tickLength - axisThickness);
                }
            }
            // BOTTOM
            else {
                // INSIDE
                if (inside) {
                    categoryBalloon.setBounds(x, y, width + x, height + y - tickLength);
                }
                // OUTSIDE
                else {
                    categoryBalloon.setBounds(x, y + height + tickLength + axisThickness - 1, x + width, y + height + tickLength + axisThickness);
                }
            }
        }
        _this.hideCursor();
    },

    createCrosshair: function () {
        var _this = this;
        var cursorAlpha = _this.cursorAlpha;
        var container = _this.container;

        var vLine = AmCharts.line(container, [0, 0], [0, _this.height], _this.cursorColor, cursorAlpha, 1);
        var hLine = AmCharts.line(container, [0, _this.width], [0, 0], _this.cursorColor, cursorAlpha, 1);

        _this.set.push(vLine);
        _this.set.push(hLine);

        _this.vLine = vLine;
        _this.hLine = hLine;
        _this.hideCursor();
    },

    detectMovement: function () {
        var _this = this;
        var chart = _this.chart;
        if (chart.mouseIsOver) {
            var mouseX = chart.mouseX - _this.x;
            var mouseY = chart.mouseY - _this.y;

            if (mouseX > 0 && mouseX < _this.width && mouseY > 0 && mouseY < _this.height) {
                if (_this.drawing) {
                    if (!_this.rolledOver) {
                        chart.setMouseCursor("crosshair");
                    }
                } else if (_this.pan) {
                    if (!_this.rolledOver) {
                        chart.setMouseCursor("move");
                    }
                }
                _this.rolledOver = true;
                _this.setPosition();
            } else {
                if (_this.rolledOver) {
                    _this.handleMouseOut();
                    _this.rolledOver = false;
                }
            }
        } else {
            if (_this.rolledOver) {
                _this.handleMouseOut();
                _this.rolledOver = false;
            }
        }
    },

    getMousePosition: function () {
        var _this = this;
        var mousePos;
        var width = _this.width;
        var height = _this.height;
        var chart = _this.chart;

        if (_this.rotate) {
            mousePos = chart.mouseY - _this.y;
            if (mousePos < 0) {
                mousePos = 0;
            }
            if (mousePos > height) {
                mousePos = height;
            }
        } else {
            mousePos = chart.mouseX - _this.x;
            if (mousePos < 0) {
                mousePos = 0;
            }

            if (mousePos > width) {
                mousePos = width;
            }
        }
        return mousePos;
    },


    updateCrosshair: function () {
        var _this = this;
        var chart = _this.chart;
        var mouseX = chart.mouseX - _this.x;
        var mouseY = chart.mouseY - _this.y;

        var vLine = _this.vLine;
        var hLine = _this.hLine;

        mouseX = AmCharts.fitToBounds(mouseX, 0, _this.width);
        mouseY = AmCharts.fitToBounds(mouseY, 0, _this.height);

        if (_this.cursorAlpha > 0) {
            vLine.show();
            hLine.show();

            vLine.translate(mouseX, 0);
            hLine.translate(0, mouseY);
        }
        if (_this.zooming) {
            var xx = mouseX;
            var yy = mouseY;

            if (chart.hideXScrollbar) {
                xx = NaN;
            }
            if (chart.hideYScrollbar) {
                yy = NaN;
            }
            _this.updateSelectionSize(xx, yy);
        }

        _this.fireMoved();

        if (!chart.mouseIsOver && !_this.zooming) {
            _this.hideCursor();
        }
    },

    fireMoved:function(){
        var _this = this;
        var chart = _this.chart;
        var name = "moved";
        var cursorEvent = {
            type: name
        };
        cursorEvent.target = _this;
        cursorEvent.chart = chart;
        cursorEvent.zooming = _this.zooming;

        cursorEvent.x = chart.mouseX - _this.x;
        cursorEvent.y = chart.mouseY - _this.y;

        _this.fire(name, cursorEvent);
    },

    updateSelectionSize: function (xx, yy) {
        var _this = this;
        AmCharts.remove(_this.selection);
        var selectionPosX = _this.selectionPosX;
        var selectionPosY = _this.selectionPosY;
        var x = 0;
        var y = 0;
        var width = _this.width;
        var height = _this.height;

        if (!isNaN(xx)) {
            if (selectionPosX > xx) {
                x = xx;
                width = selectionPosX - xx;
            }

            if (selectionPosX < xx) {
                x = selectionPosX;
                width = xx - selectionPosX;
            }

            if (selectionPosX == xx) {
                x = xx;
                width = 0;
            }

            width += _this.extraWidth;
            x -= _this.extraWidth / 2;
        }

        if (!isNaN(yy)) {
            if (selectionPosY > yy) {
                y = yy;
                height = selectionPosY - yy;
            }

            if (selectionPosY < yy) {
                y = selectionPosY;
                height = yy - selectionPosY;
            }

            if (selectionPosY == yy) {
                y = yy;
                height = 0;
            }

            height += _this.extraWidth;
            y -= _this.extraWidth / 2;
        }

        if (width > 0 && height > 0) {
            var selection = AmCharts.rect(_this.container, width, height, _this.cursorColor, _this.selectionAlpha);
            selection.translate(x + _this.x, y + _this.y);
            _this.selection = selection;
        }
    },

    arrangeBalloons: function () {
        var _this = this;
        var valueBalloons = _this.valueBalloons;
        var x = _this.x;
        var y = _this.y;
        var bottom = _this.height + y;

        valueBalloons.sort(_this.compareY);
        var i;

        for (i = 0; i < valueBalloons.length; i++) {
            var balloon = valueBalloons[i].balloon;
            balloon.setBounds(x, y, x + _this.width, bottom);

            balloon.prevX = _this.prevX[i];
            balloon.prevY = _this.prevY[i];

            balloon.prevTX = _this.prevTX[i];
            balloon.prevTY = _this.prevTY[i];

            balloon.draw();

            bottom = balloon.yPos - 3;
        }
        _this.arrangeBalloons2();
    },


    compareY: function (a, b) {
        if (a.yy < b.yy) {
            return 1;
        } else {
            return -1;
        }
    },

    arrangeBalloons2: function () {
        var _this = this;
        var valueBalloons = _this.valueBalloons;
        valueBalloons.reverse();
        var b;
        var x = _this.x;
        var y = _this.y;
        var bPrevious;
        var i;
        var count = valueBalloons.length;

        for (i = 0; i < count; i++) {
            var balloon = valueBalloons[i].balloon;
            b = balloon.bottom;
            var balloonHeight = balloon.bottom - balloon.yPos;
            var index = count - i - 1;

            if (i > 0) {
                if (b - balloonHeight < bPrevious + 3) {
                    balloon.setBounds(x, bPrevious + 3, x + _this.width, bPrevious + balloonHeight + 3);

                    balloon.prevX = _this.prevX[index];
                    balloon.prevY = _this.prevY[index];

                    balloon.prevTX = _this.prevTX[index];
                    balloon.prevTY = _this.prevTY[index];

                    balloon.draw();
                }
            }
            if (balloon.set) {
                balloon.set.show();
            }

            _this.prevX[index] = balloon.prevX;
            _this.prevY[index] = balloon.prevY;

            _this.prevTX[index] = balloon.prevTX;
            _this.prevTY[index] = balloon.prevTY;

            bPrevious = balloon.bottom;
        }
    },

    showBullets: function () {
        var _this = this;

        AmCharts.remove(_this.allBullets);
        var container = _this.container;

        var allBullets = container.set();
        _this.set.push(allBullets);
        _this.set.show();
        _this.allBullets = allBullets;

        var graphs = _this.chart.graphs;
        var i;
        for (i = 0; i < graphs.length; i++) {
            var graph = graphs[i];


            if (!graph.hidden && graph.balloonText) {
                var serialDataItem = _this.data[_this.index];
                var graphDataItem = serialDataItem.axes[graph.valueAxis.id].graphs[graph.id];
                var yy = graphDataItem.y;

                if (!isNaN(yy)) {
                    var xxx;
                    var bxx;
                    var byy;

                    xxx = graphDataItem.x;

                    if (_this.rotate) {
                        bxx = yy;
                        byy = xxx;
                    } else {
                        bxx = xxx;
                        byy = yy;
                    }
                    var bullet = AmCharts.circle(container, _this.bulletSize / 2, _this.chart.getBalloonColor(graph, graphDataItem, true), graph.cursorBulletAlpha);
                    bullet.translate(bxx, byy);
                    _this.allBullets.push(bullet);
                }
            }
        }
    },


    destroy: function () {
        var _this = this;
        _this.clear();

        AmCharts.remove(_this.selection);
        _this.selection = null;

        var categoryBalloon = _this.categoryBalloon;
        if (categoryBalloon) {
            categoryBalloon.destroy();
        }
        _this.destroyValueBalloons();

        AmCharts.remove(_this.set);
    },

    clear: function () {
        var _this = this;
        clearInterval(_this.interval);
    },

    destroyValueBalloons: function () {

        var _this = this;
        var valueBalloons = _this.valueBalloons;

        if (valueBalloons) {
            var i;
            for (i = 0; i < valueBalloons.length; i++) {
                valueBalloons[i].balloon.hide();
            }
        }
    },

    /**
     * @private
     */
    zoom: function (start, end, startTime, endTime) {
        var _this = this;
        var chart = _this.chart;
        _this.destroyValueBalloons();
        _this.zooming = false;
        var currentMouse;

        if (_this.rotate) {
            currentMouse = chart.mouseY;
            _this.selectionPosY = currentMouse;
        } else {
            currentMouse = chart.mouseX;
            _this.selectionPosX = currentMouse;
        }

        _this.start = start;
        _this.end = end;
        _this.startTime = startTime;
        _this.endTime = endTime;
        _this.zoomed = true;

        var categoryAxis = chart.categoryAxis;
        var rotate = _this.rotate;
        var width = _this.width;
        var height = _this.height;
        var stepWidth = categoryAxis.stepWidth;
        var lineWidth;
        var lineHeight;



        if(_this.fullWidth){

            var mult = 1;
            if (categoryAxis.parseDates && !categoryAxis.equalSpacing) {
                mult = categoryAxis.minDuration();
            }

            if (rotate) {
                lineHeight = stepWidth * mult;
                lineWidth = width;
                _this.extraWidth = lineHeight;
            } else {
                lineWidth = stepWidth * mult;
                lineHeight = height;
                _this.extraWidth = lineWidth;
                _this.categoryBalloon.minWidth = lineWidth;
            }

            if(_this.line){
                _this.line.remove();
            }
            _this.line = AmCharts.rect(_this.container, lineWidth, lineHeight, _this.cursorColor, _this.cursorAlpha, 0);
            if(_this.fullRectSet){
                _this.fullRectSet.push(_this.line);
            }
        }

        _this.stepWidth = stepWidth;
        _this.tempVal = _this.valueBalloonsEnabled;
        _this.valueBalloonsEnabled = false;
        _this.setPosition();
        _this.valueBalloonsEnabled = _this.tempVal;
        _this.hideCursor();
    },

    hideObj: function (obj) {
        if (obj) {
            obj.hide();
        }
    },


    hideCursor: function (dispatch) {
        if (dispatch === undefined) {
            dispatch = true;
        }

        var _this = this;
        _this.hideObj(_this.set);
        _this.hideObj(_this.categoryBalloon);
        _this.hideObj(_this.line);
        _this.hideObj(_this.vLine);
        _this.hideObj(_this.hLine);
        _this.hideObj(_this.allBullets);
        _this.destroyValueBalloons();

        if (!_this.selectWithoutZooming) {
            AmCharts.remove(_this.selection);
        }


        _this.previousIndex = NaN;

        if (dispatch) {
            var type = 'onHideCursor';
            _this.fire(type, {
                type: type,
                chart: _this.chart,
                target: _this
            });
        }
        if (!_this.drawing) {
            _this.chart.setMouseCursor('auto');
        }

        _this.normalizeBulletSize();
    },

    setPosition: function (position, dispatch) {
        var _this = this;
        if (dispatch === undefined) {
            dispatch = true;
        }

        if (_this.type == "cursor") {
            if (AmCharts.ifArray(_this.data)) {
                if (isNaN(position)) {
                    position = _this.getMousePosition();
                }
                if (position != _this.previousMousePosition || _this.zoomed === true || _this.oneBalloonOnly) {
                    if (!isNaN(position)) {
                        var index = _this.chart.categoryAxis.xToIndex(position);

                        if (index != _this.previousIndex || _this.zoomed || _this.cursorPosition == "mouse" || _this.oneBalloonOnly) {
                            _this.updateCursor(index, dispatch);
                            _this.zoomed = false;
                        }
                    }
                }

                _this.previousMousePosition = position;
            }
        } else {
            _this.updateCrosshair();
        }
    },


    normalizeBulletSize: function () {
        var _this = this;
        var resizedBullets = _this.resizedBullets;
        if (resizedBullets) {
            for (var i = 0; i < resizedBullets.length; i++) {
                var graphDataItem = resizedBullets[i];
                var bulletGraphics = graphDataItem.bulletGraphics;
                if (bulletGraphics) {
                    bulletGraphics.translate(graphDataItem.bx, graphDataItem.by, 1);
                }
            }
        }
    },

    updateCursor: function (index, dispatch) {
        var _this = this;
        var chart = _this.chart;
        var fullWidth = _this.fullWidth;

        var mouseX = chart.mouseX - _this.x;
        var mouseY = chart.mouseY - _this.y;

        if (_this.drawingNow) {
            AmCharts.remove(_this.drawingLine);
            _this.drawingLine = AmCharts.line(_this.container, [_this.x + _this.drawStartX, _this.x + mouseX], [_this.y + _this.drawStartY, _this.y + mouseY], _this.cursorColor, 1, 1);
        }

        if (_this.enabled) {
            if (dispatch === undefined) {
                dispatch = true;
            }
            index += _this.adjustment;
            _this.index = index;

            var categoryAxis = chart.categoryAxis;
            var dx = chart.dx;
            var dy = chart.dy;
            var x = _this.x + 1;
            var y = _this.y + 1;
            var width = _this.width;
            var height = _this.height;

            var serialDataItem = _this.data[index];

            _this.fireMoved();

            if (serialDataItem) {
                var xx = serialDataItem.x[categoryAxis.id];
                var rotate = chart.rotate;
                var inside = categoryAxis.inside;
                var stepWidth = _this.stepWidth;
                var categoryBalloon = _this.categoryBalloon;
                var firstTime = _this.firstTime;
                var lastTime = _this.lastTime;
                var cursorPosition = _this.cursorPosition;
                var categoryBalloonPosition = categoryAxis.position;
                var zooming = _this.zooming;
                var panning = _this.panning;
                var graphs = chart.graphs;
                var axisThickness = categoryAxis.axisThickness;
                var cursorEvent;

                if (chart.mouseIsOver || zooming || panning || this.forceShow) {
                    this.forceShow = false;
                    // PANNING
                    if (panning) {
                        var difference;
                        var panClickPos = _this.panClickPos;
                        var panClickEndTime = _this.panClickEndTime;
                        var panClickStartTime = _this.panClickStartTime;
                        var panClickEnd = _this.panClickEnd;
                        var panClickStart = _this.panClickStart;

                        if (rotate) {
                            difference = panClickPos - mouseY;
                        } else {
                            difference = panClickPos - mouseX;
                        }

                        var shiftCount = difference / stepWidth;

                        if (!categoryAxis.parseDates || categoryAxis.equalSpacing) {
                            shiftCount = Math.round(shiftCount);
                        }

                        if (shiftCount !== 0) {
                            cursorEvent = {};
                            cursorEvent.type = "zoomed";
                            cursorEvent.target = _this;
                            cursorEvent.chart = _this.chart;

                            if (categoryAxis.parseDates && !categoryAxis.equalSpacing) {
                                if (panClickEndTime + shiftCount > lastTime) {
                                    shiftCount = lastTime - panClickEndTime;
                                }

                                if (panClickStartTime + shiftCount < firstTime) {
                                    shiftCount = firstTime - panClickStartTime;
                                }

                                cursorEvent.start = Math.round(panClickStartTime + shiftCount);
                                cursorEvent.end = Math.round(panClickEndTime + shiftCount);

                                _this.fire(cursorEvent.type, cursorEvent);

                            } else {
                                if (panClickEnd + shiftCount >= _this.data.length || panClickStart + shiftCount < 0) {
                                    // void
                                } else {
                                    cursorEvent.start = panClickStart + shiftCount;
                                    cursorEvent.end = panClickEnd + shiftCount;
                                    _this.fire(cursorEvent.type, cursorEvent);
                                }
                            }
                        }
                    }
                    // SHOWING INDICATOR
                    else {
                        if (cursorPosition == "start") {
                            xx -= categoryAxis.cellWidth / 2;
                        }
                        else if (cursorPosition == "mouse" && chart.mouseIsOver) {
                            if (rotate) {
                                xx = mouseY - 2;
                            } else {
                                xx = mouseX - 2;
                            }
                        }

                        if (rotate) {
                            if (xx < 0) {
                                if (zooming) {
                                    xx = 0;
                                } else {
                                    _this.hideCursor();
                                    return;
                                }
                            }

                            if (xx > height + 1) {
                                if (zooming) {
                                    xx = height + 1;
                                } else {
                                    _this.hideCursor();
                                    return;
                                }
                            }
                        } else {
                            if (xx < 0) {
                                if (zooming) {
                                    xx = 0;
                                } else {
                                    _this.hideCursor();
                                    return;
                                }
                            }

                            if (xx > width) {
                                if (zooming) {
                                    xx = width;
                                } else {
                                    _this.hideCursor();
                                    return;
                                }
                            }
                        }
                        if (_this.cursorAlpha > 0) {
                            var line = _this.line;
                            var lxx;
                            var lyy;
                            if (rotate) {
                                lxx = 0;
                                lyy = xx + dy;
                                if(fullWidth){
                                    lyy -= categoryAxis.cellWidth / 2;
                                }
                            } else {
                                lxx = xx;
                                lyy = 0;
                                if(fullWidth){
                                    lxx -= categoryAxis.cellWidth / 2;
                                }
                            }
                            var animationDuration = _this.animationDuration;
                            if (animationDuration > 0 && !_this.zooming) {
                                if(!isNaN(_this.previousX)){
                                    line.translate(_this.previousX, _this.previousY);
                                    line.animate({
                                        'translate': lxx + ',' + lyy
                                    }, animationDuration, "easeOutSine");
                                }
                                else{
                                    line.translate(lxx, lyy);
                                }

                            } else {
                                line.translate(lxx, lyy);
                            }

                            _this.previousX = lxx;
                            _this.previousY = lyy;

                            line.show();
                        }

                        if (rotate) {
                            _this.linePos = xx + dy;
                        } else {
                            _this.linePos = xx;
                        }

                        // ZOOMING
                        if (zooming) {
                            if(fullWidth){
                                line.hide();
                            }

                            if (rotate) {
                                _this.updateSelectionSize(NaN, xx);
                            } else {
                                _this.updateSelectionSize(xx, NaN);
                            }
                        }

                        var showBalloons = true;
                        if (zooming) {
                            showBalloons = false;
                        }

                        if (_this.categoryBalloonEnabled && showBalloons) {
                            // POINT BALLOON
                            // ROTATE
                            if (rotate) {
                                // INSIDE requires adjusting bounds every time
                                if (inside) {
                                    // RIGHT
                                    if (categoryBalloonPosition == "right") {
                                        categoryBalloon.setBounds(x, y + dy, x + width + dx, y + xx + dy);
                                    }
                                    // LEFT
                                    else {
                                        categoryBalloon.setBounds(x, y + dy, x + width + dx, y + xx);
                                    }
                                }

                                // RIGHT
                                if (categoryBalloonPosition == "right") {
                                    if (inside) {
                                        categoryBalloon.setPosition(x + width + dx, y + xx + dy);
                                    } else {
                                        categoryBalloon.setPosition(x + width + dx + axisThickness, y + xx + dy);
                                    }
                                }
                                // LEFT
                                else {
                                    if (inside) {
                                        categoryBalloon.setPosition(x, y + xx);
                                    } else {
                                        categoryBalloon.setPosition(x - axisThickness, y + xx);
                                    }
                                }
                            }
                            // DO NOT ROTATE
                            else {
                                // TOP
                                if (categoryBalloonPosition == "top") {
                                    if (inside) {
                                        categoryBalloon.setPosition(x + xx + dx, y + dy);
                                    } else {
                                        categoryBalloon.setPosition(x + xx + dx, y + dy - axisThickness + 1);
                                    }
                                }
                                // BOTTOM
                                else {
                                    if (inside) {
                                        categoryBalloon.setPosition(x + xx, y + height);
                                    } else {
                                        categoryBalloon.setPosition(x + xx, y + height + axisThickness - 1);
                                    }
                                }
                            }

                            var categoryBalloonFunction = _this.categoryBalloonFunction;
                            if (categoryBalloonFunction) {
                                categoryBalloon.showBalloon(categoryBalloonFunction(serialDataItem.category));
                            } else {
                                if (categoryAxis.parseDates) {
                                    var fDate = AmCharts.formatDate(serialDataItem.category, _this.categoryBalloonDateFormat);

                                    if (fDate.indexOf("fff") != -1) {
                                        fDate = AmCharts.formatMilliseconds(fDate, serialDataItem.category);
                                    }

                                    categoryBalloon.showBalloon(fDate);
                                } else {
                                    categoryBalloon.showBalloon(AmCharts.fixNewLines(serialDataItem.category));
                                }
                            }
                        } else {
                            categoryBalloon.hide();
                        }

                        // BULLETS
                        if (graphs && _this.bulletsEnabled) {
                            _this.showBullets();
                        }

                        var graph;
                        var mostCloseGraph;
                        var graphDataItem;
                        var yy;
                        // find most close point if only one balloon at a time can be shown
                        if (_this.oneBalloonOnly) {
                            var mostClosePos = Infinity;

                            for (i = 0; i < graphs.length; i++) {
                                graph = graphs[i];

                                if (graph.showBalloon && !graph.hidden && graph.balloonText) {
                                    graphDataItem = serialDataItem.axes[graph.valueAxis.id].graphs[graph.id];
                                    yy = graphDataItem.y;

                                    if (!isNaN(yy)) {
                                        if (rotate) {
                                            if (Math.abs(mouseX - yy) < mostClosePos) {
                                                mostClosePos = Math.abs(mouseX - yy);
                                                mostCloseGraph = graph;
                                            }
                                        } else {
                                            if (Math.abs(mouseY - yy) < mostClosePos) {
                                                mostClosePos = Math.abs(mouseY - yy);
                                                mostCloseGraph = graph;
                                            }
                                        }
                                    }
                                }
                            }
                            if (_this.mostCloseGraph) {
                                mostCloseGraph = _this.mostCloseGraph;
                            }
                        }

                        // VALUE BALLOONS
                        if (index != _this.previousIndex || mostCloseGraph != _this.previousMostCloseGraph) {
                            _this.normalizeBulletSize();
                            _this.destroyValueBalloons();
                            var i;
                            _this.resizedBullets = [];
                            if (graphs && _this.valueBalloonsEnabled && showBalloons && chart.balloon.enabled) {
                                var valueBalloons = [];
                                _this.valueBalloons = valueBalloons;


                                // display balloons
                                for (i = 0; i < graphs.length; i++) {
                                    graph = graphs[i];

                                    if (_this.oneBalloonOnly && graph != mostCloseGraph) {
                                        // void
                                    } else {
                                        if (graph.showBalloon && !graph.hidden && graph.balloonText) {

                                            if(graph.type == "step" && graph.stepDirection == "left"){
                                                serialDataItem = _this.data[index + 1];
                                            }

                                            if(serialDataItem){
                                                graphDataItem = serialDataItem.axes[graph.valueAxis.id].graphs[graph.id];

                                                yy = graphDataItem.y;

                                                if(_this.showNextAvailable && isNaN(yy)){
                                                    if(index + 1 < _this.data.length){
                                                        for(var n = index + 1; n < _this.data.length; n++){
                                                            var nextSerialDataItem = _this.data[n];
                                                            if(nextSerialDataItem){
                                                                graphDataItem = nextSerialDataItem.axes[graph.valueAxis.id].graphs[graph.id];
                                                                yy = graphDataItem.y;
                                                                if (!isNaN(yy)) {
                                                                    break;
                                                                }
                                                            }
                                                        }
                                                    }
                                                }

                                                if (!isNaN(yy)) {
                                                    var xxx;
                                                    var bxx;
                                                    var byy;

                                                    xxx = graphDataItem.x;

                                                    var create = true;

                                                    if (rotate) {
                                                        bxx = yy;
                                                        byy = xxx;

                                                        if (byy < 0 || byy > height) {
                                                            create = false;
                                                        }
                                                    } else {
                                                        bxx = xxx;
                                                        byy = yy;

                                                        if (bxx < 0 || bxx > width + dx + 1) {
                                                            create = false;
                                                        }
                                                    }

                                                    if (create) {

                                                        if (_this.graphBulletSize != 1 && AmCharts.isModern) {
                                                            var bulletGraphics = graphDataItem.bulletGraphics;
                                                            if (bulletGraphics) {
                                                                var bbox = bulletGraphics.getBBox();
                                                                var bScale = _this.graphBulletSize;
                                                                bulletGraphics.translate(graphDataItem.bx, graphDataItem.by, bScale);
                                                                _this.resizedBullets.push(graphDataItem);
                                                            }
                                                        }

                                                        var valueBalloon = graph.valueBalloon;
                                                        var balloonColor = chart.getBalloonColor(graph, graphDataItem);
                                                        valueBalloon.setBounds(x, y, x + width, y + height);
                                                        valueBalloon.pointerOrientation = "H";
                                                        valueBalloon.changeColor(balloonColor);
                                                        if (graph.balloonAlpha !== undefined) {
                                                            valueBalloon.fillAlpha = graph.balloonAlpha;
                                                        }
                                                        if (graph.balloonTextColor !== undefined) {
                                                            valueBalloon.color = graph.balloonTextColor;
                                                        }

                                                        valueBalloon.setPosition(bxx + x, byy + y);

                                                        var balloonText = chart.formatString(graph.balloonText, graphDataItem, true);


                                                        var balloonFunction = graph.balloonFunction;

                                                        if (balloonFunction) {
                                                            balloonText = balloonFunction(graphDataItem, graph).toString();
                                                        }

                                                        if (balloonText !== "") {
                                                            if (rotate) {
                                                                valueBalloon.showBalloon(balloonText);
                                                            } else {
                                                                valueBalloon.text = balloonText;
                                                                valueBalloon.show = true;
                                                            }
                                                        }
                                                        if (!rotate && valueBalloon.set) {
                                                            valueBalloon.set.hide();
                                                        }

                                                        valueBalloons.push({
                                                            yy: yy,
                                                            balloon: valueBalloon
                                                        });
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }

                                if (!rotate) {
                                    _this.arrangeBalloons();
                                }
                            }
                        }

                        if (dispatch) {
                            var name = "changed";
                            cursorEvent = {
                                type: name
                            };
                            cursorEvent.index = index;
                            cursorEvent.chart = _this.chart;
                            cursorEvent.zooming = zooming;
                            cursorEvent.mostCloseGraph = mostCloseGraph;

                            if (rotate) {
                                cursorEvent.position = mouseY;
                            } else {
                                cursorEvent.position = mouseX;
                            }
                            cursorEvent.target = _this;
                            chart.fire(name, cursorEvent);
                            _this.fire(name, cursorEvent);
                            _this.skipZoomDispatch = false;
                        } else {
                            _this.skipZoomDispatch = true;
                            chart.updateLegendValues(index);
                        }

                        _this.previousIndex = index;
                        _this.previousMostCloseGraph = mostCloseGraph;
                    }
                }
            }
        } else {
            _this.hideCursor();
        }
    },

    enableDrawing: function (value) {
        var _this = this;
        _this.enabled = !value;
        _this.hideCursor();
        _this.rolledOver = false;
        _this.drawing = value;
    },

    isZooming: function (value) {
        var _this = this;
        if (value && value != _this.zooming) {
            _this.handleMouseDown('fake');
        }

        if (!value && value != _this.zooming) {
            _this.handleMouseUp();
        }
    },

    handleMouseOut: function () {
        var _this = this;
        if (_this.enabled) {
            if (_this.zooming) {
                _this.setPosition();
            } else {
                _this.index = undefined;
                var cursorEvent = {};
                var name = "changed";
                cursorEvent.type = name;
                cursorEvent.index = undefined;
                cursorEvent.target = _this;
                cursorEvent.chart = _this.chart;
                _this.fire(name, cursorEvent);
                _this.hideCursor();
            }
        }
    },

    handleReleaseOutside: function () {
        this.handleMouseUp();
    },

    handleMouseUp: function () {
        var _this = this;
        var chart = _this.chart;
        var data = _this.data;
        var cursorEvent;
        if (chart) {
            var mouseX = chart.mouseX - _this.x;
            var mouseY = chart.mouseY - _this.y;

            if (_this.drawingNow) {
                _this.drawingNow = false;
                AmCharts.remove(_this.drawingLine);
                var drawStartX = _this.drawStartX;
                var drawStartY = _this.drawStartY;

                if (Math.abs(drawStartX - mouseX) > 2 || Math.abs(drawStartY - mouseY) > 2) {
                    var drawEvent = {
                        type: "draw",
                        target: _this,
                        chart: chart,
                        initialX: drawStartX,
                        initialY: drawStartY,
                        finalX: mouseX,
                        finalY: mouseY
                    };
                    _this.fire(drawEvent.type, drawEvent);
                }
            }

            if (_this.enabled && data.length > 0) {
                if (_this.pan) {
                    _this.rolledOver = false;
                } else {
                    if (_this.zoomable) {
                        if (_this.zooming) {

                            if (_this.selectWithoutZooming) {
                                cursorEvent = {
                                    type: "selected"
                                };
                            } else {
                                cursorEvent = {
                                    type: "zoomed"
                                };
                            }
                            cursorEvent.target = _this;
                            cursorEvent.chart = chart;

                            if (_this.type == "cursor") {
                                var currentMouse;
                                if (_this.rotate) {
                                    currentMouse = mouseY;
                                    _this.selectionPosY = currentMouse;
                                } else {
                                    currentMouse = mouseX;
                                    _this.selectionPosX = currentMouse;
                                }

                                if (Math.abs(currentMouse - _this.initialMouse) < 2 && _this.fromIndex == _this.index) {
                                    // void
                                } else {
                                    if (_this.index < _this.fromIndex) {
                                        cursorEvent.end = _this.fromIndex;
                                        cursorEvent.start = _this.index;
                                    } else {
                                        cursorEvent.end = _this.index;
                                        cursorEvent.start = _this.fromIndex;
                                    }
                                    var categoryAxis = chart.categoryAxis;
                                    if (categoryAxis.parseDates && !categoryAxis.equalSpacing) {
                                        cursorEvent.start = data[cursorEvent.start].time;
                                        cursorEvent.end = chart.getEndTime(data[cursorEvent.end].time);
                                    }
                                    if (!_this.skipZoomDispatch) {
                                        _this.fire(cursorEvent.type, cursorEvent);
                                    }
                                }
                            } else {
                                var initialMouseX = _this.initialMouseX;
                                var initialMouseY = _this.initialMouseY;

                                if (Math.abs(mouseX - initialMouseX) < 3 && Math.abs(mouseY - initialMouseY) < 3) {
                                    // void
                                } else {
                                    var x0 = Math.min(initialMouseX, mouseX);
                                    var y0 = Math.min(initialMouseY, mouseY);

                                    var width = Math.abs(initialMouseX - mouseX);
                                    var height = Math.abs(initialMouseY - mouseY);

                                    if (chart.hideXScrollbar) {
                                        x0 = 0;
                                        width = _this.width;
                                    }

                                    if (chart.hideYScrollbar) {
                                        y0 = 0;
                                        height = _this.height;
                                    }

                                    cursorEvent.selectionHeight = height;
                                    cursorEvent.selectionWidth = width;
                                    cursorEvent.selectionY = y0;
                                    cursorEvent.selectionX = x0;
                                    if (!_this.skipZoomDispatch) {
                                        _this.fire(cursorEvent.type, cursorEvent);
                                    }
                                }
                            }
                            if (!_this.selectWithoutZooming) {
                                AmCharts.remove(_this.selection);
                            }
                        }
                    }
                }

                _this.skipZoomDispatch = false;
                _this.zooming = false;
                _this.panning = false;
            }
        }
    },

    showCursorAt: function (category) {
        var _this = this;
        var chart = _this.chart;
        var categoryAxis = chart.categoryAxis;
        var coordinate;
        if (categoryAxis.parseDates) {
            coordinate = categoryAxis.dateToCoordinate(category);
        } else {
            coordinate = categoryAxis.categoryToCoordinate(category);
        }

        _this.previousMousePosition = NaN;
        _this.forceShow = true;
        _this.setPosition(coordinate, false);
    },


    handleMouseDown: function (event) {
        var _this = this;
        if (_this.zoomable || _this.pan || _this.drawing) {
            var rotate = _this.rotate;
            var chart = _this.chart;
            var mouseX = chart.mouseX - _this.x;
            var mouseY = chart.mouseY - _this.y;

            if ((mouseX > 0 && mouseX < _this.width && mouseY > 0 && mouseY < _this.height) || event == "fake") {
                _this.setPosition();

                if (_this.selectWithoutZooming) {
                    AmCharts.remove(_this.selection);
                }

                if (_this.drawing) {
                    _this.drawStartY = mouseY;
                    _this.drawStartX = mouseX;
                    _this.drawingNow = true;
                } else if (_this.pan) {
                    _this.zoomable = false;
                    chart.setMouseCursor("move");
                    _this.panning = true;

                    if (rotate) {
                        _this.panClickPos = mouseY;
                    } else {
                        _this.panClickPos = mouseX;
                    }

                    _this.panClickStart = _this.start;
                    _this.panClickEnd = _this.end;
                    _this.panClickStartTime = _this.startTime;
                    _this.panClickEndTime = _this.endTime;
                } else if (_this.zoomable) {
                    if (_this.type == "cursor") {

                        _this.fromIndex = _this.index;

                        if (rotate) {
                            _this.initialMouse = mouseY;
                            _this.selectionPosY = _this.linePos;
                        } else {
                            _this.initialMouse = mouseX;
                            _this.selectionPosX = _this.linePos;
                        }
                    } else {
                        _this.initialMouseX = mouseX;
                        _this.initialMouseY = mouseY;

                        _this.selectionPosX = mouseX;
                        _this.selectionPosY = mouseY;
                    }
                    _this.zooming = true;
                }
            }
        }
    }
});// @tag amchart
AmCharts.SimpleChartScrollbar = AmCharts.Class({

    construct: function (theme) {
        var _this = this;

        _this.createEvents('zoomed');
        _this.backgroundColor = "#D4D4D4";
        _this.backgroundAlpha = 1;
        _this.selectedBackgroundColor = "#EFEFEF";
        _this.selectedBackgroundAlpha = 1;
        _this.scrollDuration = 1;
        _this.resizeEnabled = true;
        _this.hideResizeGrips = false;
        _this.scrollbarHeight = 20;

        _this.updateOnReleaseOnly = false;
        if (document.documentMode < 9) {
            _this.updateOnReleaseOnly = true;
        }
        _this.dragIconWidth = 18;
        _this.dragIconHeight = 25;

        AmCharts.applyTheme(_this, theme, "SimpleChartScrollbar");
    },

    draw: function () {
        var _this = this;
        _this.destroy();
        _this.interval = setInterval(function () {
            _this.updateScrollbar.call(_this);
        }, 40);

        var container = _this.chart.container;
        var rotate = _this.rotate;
        var chart = _this.chart;
        var set = container.set();
        _this.set = set;
        chart.scrollbarsSet.push(set);

        var width;
        var height;

        if (rotate) {
            width = _this.scrollbarHeight;
            height = chart.plotAreaHeight;
        } else {
            height = _this.scrollbarHeight;
            width = chart.plotAreaWidth;
        }

        _this.width = width;
        _this.height = height;

        if (height && width) {
            var bg = AmCharts.rect(container, width, height, _this.backgroundColor, _this.backgroundAlpha, 1, _this.backgroundColor, _this.backgroundAlpha);
            _this.bg = bg;
            set.push(bg);

            var invisibleBg = AmCharts.rect(container, width, height, "#000", 0.005);
            set.push(invisibleBg);
            _this.invisibleBg = invisibleBg;

            invisibleBg.click(function () {
                _this.handleBgClick();
            }).mouseover(function () {
                _this.handleMouseOver();
            }).mouseout(function () {
                _this.handleMouseOut();
            }).touchend(function () {
                _this.handleBgClick();
            });

            var selectedBG = AmCharts.rect(container, width, height, _this.selectedBackgroundColor, _this.selectedBackgroundAlpha);
            _this.selectedBG = selectedBG;
            set.push(selectedBG);

            var dragger = AmCharts.rect(container, width, height, "#000", 0.005);
            _this.dragger = dragger;
            set.push(dragger);

            dragger.mousedown(function (event) {
                _this.handleDragStart(event);
            }).mouseup(function () {
                _this.handleDragStop();
            }).mouseover(function () {
                _this.handleDraggerOver();
            }).mouseout(function () {
                _this.handleMouseOut();
            }).touchstart(function (event) {
                _this.handleDragStart(event);
            }).touchend(function () {
                _this.handleDragStop();
            });

            // drag icons
            var dragIconWidth;
            var dragIconHeight;
            var pathToImages = chart.pathToImages;

            var fileName;
            if (rotate) {
                fileName = pathToImages + "dragIconH.gif";
                dragIconHeight = _this.dragIconWidth;
                dragIconWidth = _this.dragIconHeight;
            } else {
                fileName = pathToImages + "dragIcon.gif";
                dragIconWidth = _this.dragIconWidth;
                dragIconHeight = _this.dragIconHeight;
            }

            var imgLeft = container.image(fileName, 0, 0, dragIconWidth, dragIconHeight);
            var imgRight = container.image(fileName, 0, 0, dragIconWidth, dragIconHeight);

            var iw = 10;
            var ih = 20;
            if (chart.panEventsEnabled) {
                iw = 25;
                ih = _this.scrollbarHeight;
            }

            var rectRight = AmCharts.rect(container, iw, ih, "#000", 0.005);
            var rectLeft = AmCharts.rect(container, iw, ih, "#000", 0.005);
            rectLeft.translate(-(iw - dragIconWidth) / 2, -(ih - dragIconHeight) / 2);
            rectRight.translate(-(iw - dragIconWidth) / 2, -(ih - dragIconHeight) / 2);

            var iconLeft = container.set([imgLeft, rectLeft]);
            var iconRight = container.set([imgRight, rectRight]);

            _this.iconLeft = iconLeft;
            //set.push(_this.iconLeft);  // 3.3.4 - this causes bullets not to export

            _this.iconRight = iconRight;
            //set.push(iconRight);  // 3.3.4 - this causes bullets not to export

            iconLeft.mousedown(function () {
                _this.leftDragStart();
            }).mouseup(function () {
                _this.leftDragStop();
            }).mouseover(function () {
                _this.iconRollOver();
            }).mouseout(function () {
                _this.iconRollOut();
            }).touchstart(function (event) {
                _this.leftDragStart();
            }).touchend(function () {
                _this.leftDragStop();
            });

            iconRight.mousedown(function () {
                _this.rightDragStart();
            }).mouseup(function () {
                _this.rightDragStop();
            }).mouseover(function () {
                _this.iconRollOver();
            }).mouseout(function () {
                _this.iconRollOut();
            }).touchstart(function (event) {
                _this.rightDragStart();
            }).touchend(function () {
                _this.rightDragStop();
            });

            if (AmCharts.ifArray(chart.chartData)) {
                set.show();
            } else {
                set.hide();
            }

            _this.hideDragIcons();
            _this.clipDragger(false);
        }
        set.translate(_this.x, _this.y);
    },


    updateScrollbarSize: function (pos0, pos1) {
        var _this = this;
        var dragger = _this.dragger;
        var clipX;
        var clipY;
        var clipW;
        var clipH;
        var draggerSize;

        if (_this.rotate) {
            clipX = 0;
            clipY = pos0;
            clipW = _this.width + 1;
            clipH = pos1 - pos0;
            draggerSize = pos1 - pos0;
            dragger.setAttr('height', draggerSize);
            dragger.setAttr('y', clipY);
        } else {
            clipX = pos0;
            clipY = 0;
            clipW = pos1 - pos0;
            clipH = _this.height + 1;
            draggerSize = pos1 - pos0;
            dragger.setAttr('width', draggerSize);
            dragger.setAttr('x', clipX);
        }
        _this.clipAndUpdate(clipX, clipY, clipW, clipH);
    },

    updateScrollbar: function () {
        var _this = this;
        var dragerWidth;
        var switchHands = false;
        var prevPos;
        var mousePos;
        var x = _this.x;
        var y = _this.y;
        var dragger = _this.dragger;
        var bbox = _this.getDBox();
        var bboxX = bbox.x + x;
        var bboxY = bbox.y + y;
        var bboxWidth = bbox.width;
        var bboxHeight = bbox.height;
        var rotate = _this.rotate;
        var chart = _this.chart;
        var width = _this.width;
        var height = _this.height;
        var mouseX = chart.mouseX;
        var mouseY = chart.mouseY;

        var initialMouse = _this.initialMouse;

        if (chart.mouseIsOver) {
            if (_this.dragging) {
                var initialCoord = _this.initialCoord;
                if (rotate) {
                    var newY = initialCoord + (mouseY - initialMouse);
                    if (newY < 0) {
                        newY = 0;
                    }
                    var bottomB = height - bboxHeight;

                    if (newY > bottomB) {
                        newY = bottomB;
                    }

                    dragger.setAttr("y", newY);
                } else {
                    var newX = initialCoord + (mouseX - initialMouse);
                    if (newX < 0) {
                        newX = 0;
                    }
                    var rightB = width - bboxWidth;

                    if (newX > rightB) {
                        newX = rightB;
                    }

                    dragger.setAttr("x", newX);
                }
            }



            if (_this.resizingRight) {
                if (rotate) {
                    dragerWidth = mouseY - bboxY;

                    if (dragerWidth + bboxY > height + y) {
                        dragerWidth = height - bboxY + y;
                    }

                    if (dragerWidth < 0) {
                        _this.resizingRight = false;
                        _this.resizingLeft = true;
                        switchHands = true;
                    } else {
                        if (dragerWidth === 0) {
                            dragerWidth = 0.1;
                        }
                        dragger.setAttr('height', dragerWidth);
                    }
                } else {
                    dragerWidth = mouseX - bboxX;

                    if (dragerWidth + bboxX > width + x) {
                        dragerWidth = width - bboxX + x;
                    }

                    if (dragerWidth < 0) {
                        _this.resizingRight = false;
                        _this.resizingLeft = true;
                        switchHands = true;
                    } else {
                        if (dragerWidth === 0) {
                            dragerWidth = 0.1;
                        }
                        dragger.setAttr('width', dragerWidth);
                    }
                }
            }

            if (_this.resizingLeft) {
                if (rotate) {
                    prevPos = bboxY;
                    mousePos = mouseY;

                    // if mouse is out to left
                    if (mousePos < y) {
                        mousePos = y;
                    }
                    //if mouse is out to right
                    if (mousePos > height + y) {
                        mousePos = height + y;
                    }
                    if (switchHands === true) {
                        dragerWidth = prevPos - mousePos;
                    } else {
                        dragerWidth = bboxHeight + prevPos - mousePos;
                    }

                    if (dragerWidth < 0) {
                        _this.resizingRight = true;
                        _this.resizingLeft = false;
                        dragger.setAttr('y', prevPos + bboxHeight - y);
                    } else {
                        if (dragerWidth === 0) {
                            dragerWidth = 0.1;
                        }
                        dragger.setAttr('y', mousePos - y);
                        dragger.setAttr('height', dragerWidth);
                    }
                } else {
                    prevPos = bboxX;
                    mousePos = mouseX;

                    // if mouse is out to left
                    if (mousePos < x) {
                        mousePos = x;
                    }

                    //if mouse is out to right
                    if (mousePos > width + x) {
                        mousePos = width + x;
                    }

                    if (switchHands === true) {
                        dragerWidth = prevPos - mousePos;
                    } else {
                        dragerWidth = bboxWidth + prevPos - mousePos;
                    }

                    if (dragerWidth < 0) {
                        _this.resizingRight = true;
                        _this.resizingLeft = false;
                        dragger.setAttr('x', prevPos + bboxWidth - x);
                    } else {
                        if (dragerWidth === 0) {
                            dragerWidth = 0.1;
                        }

                        dragger.setAttr('x', mousePos - x);
                        dragger.setAttr('width', dragerWidth);
                    }
                }
            }
            _this.clipDragger(true);
        }
    },

    clipDragger: function (dispatch) {
        var _this = this;
        var dragger = _this.dragger;
        var bbox = _this.getDBox();
        if(bbox){
            var bboxX = bbox.x;
            var bboxY = bbox.y;
            var bboxWidth = bbox.width;
            var bboxHeight = bbox.height;

            var update = false;

            if (_this.rotate) {
                bboxX = 0;
                bboxWidth = _this.width + 1;
                if (_this.clipY != bboxY || _this.clipH != bboxHeight) {
                    update = true;
                }
            } else {
                bboxY = 0;
                bboxHeight = _this.height + 1;
                if (_this.clipX != bboxX || _this.clipW != bboxWidth) {
                    update = true;
                }
            }

            if (update) {
                _this.clipAndUpdate(bboxX, bboxY, bboxWidth, bboxHeight);

                if (dispatch) {
                    if (!_this.updateOnReleaseOnly) {
                        _this.dispatchScrollbarEvent();
                    }
                }
            }
        }
    },


    maskGraphs: function () {
        //void
    },

    clipAndUpdate: function (x, y, w, h) {
        var _this = this;
        _this.clipX = x;
        _this.clipY = y;
        _this.clipW = w;
        _this.clipH = h;

        _this.selectedBG.clipRect(x, y, w, h);
        _this.updateDragIconPositions();
        _this.maskGraphs(x, y, w, h);
    },

    dispatchScrollbarEvent: function () {
        var _this = this;
        if (_this.skipEvent) {
            _this.skipEvent = false;
        } else {
            var chart = _this.chart;
            chart.hideBalloon();
            var dBBox = _this.getDBox();
            var xx = dBBox.x;
            var yy = dBBox.y;
            var ww = dBBox.width;
            var hh = dBBox.height;
            var draggerPos;
            var draggerSize;
            var multiplier;

            if (_this.rotate) {
                draggerPos = yy;
                draggerSize = hh;
                multiplier = _this.height / hh;
            } else {
                draggerPos = xx;
                draggerSize = ww;
                multiplier = _this.width / ww;
            }

            var event = {
                type: "zoomed",
                position: draggerPos,
                chart: chart,
                target: _this,
                multiplier: multiplier
            };
            _this.fire(event.type, event);
        }
    },

    updateDragIconPositions: function () {
        var _this = this;
        var bbox = _this.getDBox();
        var xx = bbox.x;
        var yy = bbox.y;
        var iconLeft = _this.iconLeft;
        var iconRight = _this.iconRight;
        var dragIconHeight;
        var dragIconWidth;
        var height = _this.scrollbarHeight;

        if (_this.rotate) {
            dragIconHeight = _this.dragIconWidth;
            dragIconWidth = _this.dragIconHeight;
            iconLeft.translate(_this.x + (height - dragIconWidth) / 2, _this.y + yy - (dragIconHeight) / 2);
            iconRight.translate(_this.x + (height - dragIconWidth) / 2, _this.y + yy + bbox.height - (dragIconHeight) / 2);
        } else {
            dragIconHeight = _this.dragIconHeight;
            dragIconWidth = _this.dragIconWidth;
            iconLeft.translate(_this.x + xx - dragIconWidth / 2,  _this.y + (height - dragIconHeight) / 2);
            iconRight.translate(_this.x + xx - dragIconWidth / 2 + bbox.width,  _this.y + (height - dragIconHeight) / 2);
        }
    },

    showDragIcons: function () {
        var _this = this;
        if (_this.resizeEnabled) {
            _this.iconLeft.show();
            _this.iconRight.show();
        }
    },

    hideDragIcons: function () {
        var _this = this;
        if (!_this.resizingLeft && !_this.resizingRight && !_this.dragging) {
            if (_this.hideResizeGrips || !_this.resizeEnabled) {
                _this.iconLeft.hide();
                _this.iconRight.hide();
            }
            _this.removeCursors();
        }
    },


    removeCursors: function () {
        this.chart.setMouseCursor('auto');
    },

    relativeZoom: function (multiplier, position) {
        var _this = this;
        _this.dragger.stop();
        _this.multiplier = multiplier;
        _this.position = position;

        var pos0 = position;
        var pos1;

        if (_this.rotate) {
            pos1 = pos0 + _this.height / multiplier;
        } else {
            pos1 = pos0 + _this.width / multiplier;
        }

        _this.updateScrollbarSize(pos0, pos1);
    },

    destroy: function () {
        var _this = this;
        _this.clear();
        AmCharts.remove(_this.set);
        AmCharts.remove(_this.iconRight);
        AmCharts.remove(_this.iconLeft);
    },

    clear: function () {
        var _this = this;
        clearInterval(_this.interval);
    },

    handleDragStart: function () {
        var _this = this;
        var chart = _this.chart;
        _this.dragger.stop();

        _this.removeCursors();
        _this.dragging = true;

        var bbox = _this.getDBox();
        if (_this.rotate) {
            _this.initialCoord = bbox.y;
            _this.initialMouse = chart.mouseY;
        } else {
            _this.initialCoord = bbox.x;
            _this.initialMouse = chart.mouseX;
        }
    },

    handleDragStop: function () {
        var _this = this;
        if (_this.updateOnReleaseOnly) {
            _this.updateScrollbar();
            _this.skipEvent = false;
            _this.dispatchScrollbarEvent();
        }

        _this.dragging = false;

        if (_this.mouseIsOver) {
            _this.removeCursors();
        }
        _this.updateScrollbar();
    },

    handleDraggerOver: function () {
        this.handleMouseOver();
    },

    leftDragStart: function () {
        var _this = this;
        _this.dragger.stop();
        _this.resizingLeft = true;
    },

    leftDragStop: function () {
        var _this = this;
        _this.resizingLeft = false;
        if (!_this.mouseIsOver) {
            _this.removeCursors();
        }
        _this.updateOnRelease();
    },

    rightDragStart: function () {
        var _this = this;
        _this.dragger.stop();
        _this.resizingRight = true;
    },


    rightDragStop: function () {
        var _this = this;
        _this.resizingRight = false;
        if (!_this.mouseIsOver) {
            _this.removeCursors();
        }
        _this.updateOnRelease();
    },

    iconRollOut: function () {
        this.removeCursors();
    },

    iconRollOver: function () {
        var _this = this;
        if (_this.rotate) {
            _this.chart.setMouseCursor("n-resize");
        } else {
            _this.chart.setMouseCursor("e-resize");
        }
        _this.handleMouseOver();
    },

    getDBox: function () {
        if(this.dragger){
            var bbox = this.dragger.getBBox();
            return bbox;
        }
    },

    handleBgClick: function () {
        var _this = this;
        if (!_this.resizingRight && !_this.resizingLeft) {
            _this.zooming = true;
            var property;
            var start;
            var end;
            var duration = _this.scrollDuration;
            var dragger = _this.dragger;
            var bbox = _this.getDBox();
            var bboxHeight = bbox.height;
            var bboxWidth = bbox.width;
            var chart = _this.chart;
            var y = _this.y;
            var x = _this.x;
            var rotate = _this.rotate;

            if (rotate) {
                property = "y";
                start = bbox.y;
                end = chart.mouseY - bboxHeight / 2 - y;
                end = AmCharts.fitToBounds(end, 0, _this.height - bboxHeight);
            } else {
                property = "x";
                start = bbox.x;
                end = chart.mouseX - bboxWidth / 2 - x;
                end = AmCharts.fitToBounds(end, 0, _this.width - bboxWidth);
            }
            if (_this.updateOnReleaseOnly) {
                _this.skipEvent = false;
                dragger.setAttr(property, end);
                _this.dispatchScrollbarEvent();
                _this.clipDragger();
            } else {
                end = Math.round(end);
                if (rotate) {
                    dragger.animate({
                        'y': end
                    }, duration, '>');
                } else {
                    dragger.animate({
                        'x': end
                    }, duration, '>');
                }
            }
        }
    },

    updateOnRelease: function () {
        var _this = this;
        if (_this.updateOnReleaseOnly) {
            _this.updateScrollbar();
            _this.skipEvent = false;
            _this.dispatchScrollbarEvent();
        }
    },

    handleReleaseOutside: function () {
        var _this = this;

        if (_this.set) {
            if (_this.resizingLeft || _this.resizingRight || _this.dragging) {
                _this.updateOnRelease();
                _this.removeCursors();
            }

            _this.resizingLeft = false;
            _this.resizingRight = false;
            _this.dragging = false;
            _this.mouseIsOver = false;

            _this.hideDragIcons();
            _this.updateScrollbar();
        }
    },

    handleMouseOver: function () {
        var _this = this;
        _this.mouseIsOver = true;
        _this.showDragIcons();
    },


    handleMouseOut: function () {
        var _this = this;
        _this.mouseIsOver = false;
        _this.hideDragIcons();
    }

});// @tag amchart
AmCharts.ChartScrollbar = AmCharts.Class({

    inherits: AmCharts.SimpleChartScrollbar,

    construct: function (theme) {
        var _this = this;
        _this.cname = "ChartScrollbar";
        AmCharts.ChartScrollbar.base.construct.call(_this, theme);
        _this.graphLineColor = "#BBBBBB";
        _this.graphLineAlpha = 0;
        _this.graphFillColor = "#BBBBBB";
        _this.graphFillAlpha = 1;
        _this.selectedGraphLineColor = "#888888";
        _this.selectedGraphLineAlpha = 0;
        _this.selectedGraphFillColor = "#888888";
        _this.selectedGraphFillAlpha = 1;
        _this.gridCount = 0;
        _this.gridColor = "#FFFFFF";
        _this.gridAlpha = 0.7;
        _this.autoGridCount = false;
        _this.skipEvent = false;
        _this.color = "#FFFFFF";
        _this.scrollbarCreated = false;
        _this.offset = 0;
        // _this.minimum
        // _this.maximum

        AmCharts.applyTheme(_this, theme, _this.cname);
    },


    init: function () {
        var _this = this;
        var categoryAxis = _this.categoryAxis;
        var chart = _this.chart;
        if (!categoryAxis) {
            categoryAxis = new AmCharts.CategoryAxis();
            _this.categoryAxis = categoryAxis;
        }

        categoryAxis.chart = chart;
        categoryAxis.id = "scrollbar";
        categoryAxis.dateFormats = chart.categoryAxis.dateFormats;
        categoryAxis.markPeriodChange = chart.categoryAxis.markPeriodChange;
        categoryAxis.boldPeriodBeginning = chart.categoryAxis.boldPeriodBeginning;
        categoryAxis.axisItemRenderer = AmCharts.RecItem;
        categoryAxis.axisRenderer = AmCharts.RecAxis;
        categoryAxis.guideFillRenderer = AmCharts.RecFill;
        categoryAxis.inside = true;
        categoryAxis.fontSize = _this.fontSize;
        categoryAxis.tickLength = 0;
        categoryAxis.axisAlpha = 0;

        if(AmCharts.isString(_this.graph)){
            _this.graph = AmCharts.getObjById(chart.graphs, _this.graph);
        }

        var graph = _this.graph;

        if (graph) {
            var valueAxis = _this.valueAxis;
            if (!valueAxis) {
                valueAxis = new AmCharts.ValueAxis();
                _this.valueAxis = valueAxis;
                valueAxis.visible = false;
                valueAxis.scrollbar = true;
                valueAxis.axisItemRenderer = AmCharts.RecItem;
                valueAxis.axisRenderer = AmCharts.RecAxis;
                valueAxis.guideFillRenderer = AmCharts.RecFill;
                valueAxis.labelsEnabled = false;
                valueAxis.chart = chart;
            }

            var unselectedGraph = _this.unselectedGraph;
            if (!unselectedGraph) {
                unselectedGraph = new AmCharts.AmGraph();
                unselectedGraph.scrollbar = true;
                _this.unselectedGraph = unselectedGraph;
                unselectedGraph.negativeBase = graph.negativeBase;
                unselectedGraph.noStepRisers = graph.noStepRisers;
            }
            var selectedGraph = _this.selectedGraph;
            if (!selectedGraph) {
                selectedGraph = new AmCharts.AmGraph();
                selectedGraph.scrollbar = true;
                _this.selectedGraph = selectedGraph;
                selectedGraph.negativeBase = graph.negativeBase;
                selectedGraph.noStepRisers = graph.noStepRisers;
            }
        }

        _this.scrollbarCreated = true;
    },


    draw: function () {
        var _this = this;
        AmCharts.ChartScrollbar.base.draw.call(_this);

        if (!_this.scrollbarCreated) {
            _this.init();
        }

        var chart = _this.chart;
        var data = chart.chartData;
        var categoryAxis = _this.categoryAxis;
        var rotate = _this.rotate;
        var x = _this.x;
        var y = _this.y;
        var width = _this.width;
        var height = _this.height;
        var chartCategoryAxis = chart.categoryAxis;
        var set = _this.set;

        categoryAxis.setOrientation(!rotate);
        categoryAxis.parseDates = chartCategoryAxis.parseDates;
        categoryAxis.rotate = rotate;
        categoryAxis.equalSpacing = chartCategoryAxis.equalSpacing;
        categoryAxis.minPeriod = chartCategoryAxis.minPeriod;
        categoryAxis.startOnAxis = chartCategoryAxis.startOnAxis;
        categoryAxis.viW = width;
        categoryAxis.viH = height;
        categoryAxis.width = width;
        categoryAxis.height = height;
        categoryAxis.gridCount = _this.gridCount;
        categoryAxis.gridColor = _this.gridColor;
        categoryAxis.gridAlpha = _this.gridAlpha;
        categoryAxis.color = _this.color;
        categoryAxis.tickLength = 0;
        categoryAxis.axisAlpha = 0;
        categoryAxis.autoGridCount = _this.autoGridCount;

        if (categoryAxis.parseDates && !categoryAxis.equalSpacing) {
            categoryAxis.timeZoom(chart.firstTime, chart.lastTime);
        }
        categoryAxis.zoom(0, data.length - 1);

        var graph = _this.graph;


        if (graph) {
            var valueAxis = _this.valueAxis;
            var graphValueAxis = graph.valueAxis;
            valueAxis.id = graphValueAxis.id;
            valueAxis.rotate = rotate;
            valueAxis.setOrientation(rotate);
            valueAxis.width = width;
            valueAxis.height = height;
            valueAxis.viW = width;
            valueAxis.viH = height;
            valueAxis.dataProvider = data;
            valueAxis.reversed = graphValueAxis.reversed;
            valueAxis.logarithmic = graphValueAxis.logarithmic;
            valueAxis.gridAlpha = 0;
            valueAxis.axisAlpha = 0;
            set.push(valueAxis.set);

            if (rotate) {
                valueAxis.y = y;
                valueAxis.x = 0;
            } else {
                valueAxis.x = x;
                valueAxis.y = 0;
            }

            var min = Infinity;
            var max = -Infinity;
            var i;
            for (i = 0; i < data.length; i++) {
                var values = data[i].axes[graphValueAxis.id].graphs[graph.id].values;
                var k;
                for (k in values) {
                    if (values.hasOwnProperty(k)) {
                        if (k != "percents" && k != "total") {
                            var val = values[k];

                            if (val < min) {
                                min = val;
                            }
                            if (val > max) {
                                max = val;
                            }
                        }
                    }
                }
            }

            if (min != Infinity) {
                valueAxis.minimum = min;
            }
            if (max != -Infinity) {
                valueAxis.maximum = max + (max - min) * 0.1;
            }

            if (min == max) {
                valueAxis.minimum -= 1;
                valueAxis.maximum += 1;
            }

            if (_this.minimum !== undefined) {
                valueAxis.minimum = _this.minimum;
            }

            if (_this.maximum !== undefined) {
                valueAxis.maximum = _this.maximum;
            }

            valueAxis.zoom(0, data.length - 1);

            var ug = _this.unselectedGraph;
            ug.id = graph.id;
            ug.rotate = rotate;
            ug.chart = chart;
            ug.data = data;
            ug.valueAxis = valueAxis;
            ug.chart = graph.chart;
            ug.categoryAxis = _this.categoryAxis;
            ug.periodSpan = graph.periodSpan;
            ug.valueField = graph.valueField;
            ug.openField = graph.openField;
            ug.closeField = graph.closeField;
            ug.highField = graph.highField;
            ug.lowField = graph.lowField;
            ug.lineAlpha = _this.graphLineAlpha;
            ug.lineColorR = _this.graphLineColor;
            ug.fillAlphas = _this.graphFillAlpha;
            ug.fillColorsR = _this.graphFillColor;
            ug.connect = graph.connect;
            ug.hidden = graph.hidden;
            ug.width = width;
            ug.height = height;
            ug.pointPosition = graph.pointPosition;
            ug.stepDirection = graph.stepDirection;
            ug.periodSpan = graph.periodSpan;


            var sg = _this.selectedGraph;
            sg.id = graph.id;
            sg.rotate = rotate;
            sg.chart = chart;
            sg.data = data;
            sg.valueAxis = valueAxis;
            sg.chart = graph.chart;
            sg.categoryAxis = categoryAxis;
            sg.periodSpan = graph.periodSpan;
            sg.valueField = graph.valueField;
            sg.openField = graph.openField;
            sg.closeField = graph.closeField;
            sg.highField = graph.highField;
            sg.lowField = graph.lowField;
            sg.lineAlpha = _this.selectedGraphLineAlpha;
            sg.lineColorR = _this.selectedGraphLineColor;
            sg.fillAlphas = _this.selectedGraphFillAlpha;
            sg.fillColorsR = _this.selectedGraphFillColor;
            sg.connect = graph.connect;
            sg.hidden = graph.hidden;
            sg.width = width;
            sg.height = height;

            sg.pointPosition = graph.pointPosition;
            sg.stepDirection = graph.stepDirection;
            sg.periodSpan = graph.periodSpan;

            var graphType = _this.graphType;

            if (!graphType) {
                graphType = graph.type;
            }

            ug.type = graphType;
            sg.type = graphType;

            var lastIndex = data.length - 1;
            ug.zoom(0, lastIndex);
            sg.zoom(0, lastIndex);

            var dragger = _this.dragger;

            sg.set.click(function () {
                _this.handleBackgroundClick();
            }).mouseover(function () {
                _this.handleMouseOver();
            }).mouseout(function () {
                _this.handleMouseOut();
            });

            ug.set.click(function () {
                _this.handleBackgroundClick();
            }).mouseover(function () {
                _this.handleMouseOver();
            }).mouseout(function () {
                _this.handleMouseOut();
            });
            set.push(ug.set);
            set.push(sg.set);
        }
        set.push(categoryAxis.set);
        set.push(categoryAxis.labelsSet);

        _this.bg.toBack();
        _this.invisibleBg.toFront();
        _this.dragger.toFront();
        _this.iconLeft.toFront();
        _this.iconRight.toFront();
    },

    timeZoom: function (startTime, endTime, dispatch) {
        var _this = this;
        _this.startTime = startTime;
        _this.endTime = endTime;
        _this.timeDifference = endTime - startTime;
        _this.skipEvent = !AmCharts.toBoolean(dispatch);
        _this.zoomScrollbar();

        if(!_this.skipEvent){
            _this.dispatchScrollbarEvent();
        }
    },

    zoom: function (start, end) {
        var _this = this;
        _this.start = start;
        _this.end = end;
        _this.skipEvent = true;
        _this.zoomScrollbar();
    },

    dispatchScrollbarEvent: function () {
        var _this = this;
        if (_this.skipEvent) {
            _this.skipEvent = false;
        } else {
            var data = _this.chart.chartData;
            var draggerPos;
            var draggerSize;
            var dBBox = _this.dragger.getBBox();
            var xx = dBBox.x;
            var yy = dBBox.y;
            var ww = dBBox.width;
            var hh = dBBox.height;
            var chart = _this.chart;

            if (_this.rotate) {
                draggerPos = yy;
                draggerSize = hh;
            } else {
                draggerPos = xx;
                draggerSize = ww;
            }

            var event = {
                type: "zoomed"
            };
            event.target = this;
            event.chart = chart;

            var categoryAxis = _this.categoryAxis;
            var stepWidth = _this.stepWidth;


            if (categoryAxis.parseDates && !categoryAxis.equalSpacing) {
                var lastTime = chart.lastTime;
                var firstTime = chart.firstTime;

                var minDuration = categoryAxis.minDuration();
                var startTime = Math.round(draggerPos / stepWidth) + firstTime;
                var endTime;

                if (!_this.dragging) {
                    endTime = Math.round((draggerPos + draggerSize) / stepWidth) + firstTime;
                } else {
                    endTime = startTime + _this.timeDifference;
                }

                if (startTime > endTime) {
                    startTime = endTime;
                }

                if (startTime != _this.startTime || endTime != _this.endTime) {
                    _this.startTime = startTime;
                    _this.endTime = endTime;
                    event.start = startTime;
                    event.end = endTime;
                    event.startDate = new Date(startTime);
                    event.endDate = new Date(endTime);
                    _this.fire(event.type, event);
                }
            } else {
                if (!categoryAxis.startOnAxis) {
                    var halfStep = stepWidth / 2;
                    draggerPos += halfStep;
                }

                draggerSize -= _this.stepWidth / 2;

                var start = categoryAxis.xToIndex(draggerPos);
                var end = categoryAxis.xToIndex(draggerPos + draggerSize);

                if (start != _this.start || _this.end != end) {
                    if (categoryAxis.startOnAxis) {
                        if (_this.resizingRight && start == end) {
                            end++;
                        }

                        if (_this.resizingLeft && start == end) {
                            if (start > 0) {
                                start--;
                            } else {
                                end = 1;
                            }
                        }
                    }

                    _this.start = start;
                    if (!_this.dragging) {
                        _this.end = end;
                    } else {
                        _this.end = _this.start + _this.difference;
                    }

                    event.start = _this.start;
                    event.end = _this.end;

                    if (categoryAxis.parseDates) {
                        if (data[_this.start]) {
                            event.startDate = new Date(data[_this.start].time);
                        }
                        if (data[_this.end]) {
                            event.endDate = new Date(data[_this.end].time);
                        }
                    }
                    _this.fire(event.type, event);
                }
            }
        }
    },


    zoomScrollbar: function () {
        var _this = this;
        var pos0;
        var pos1;
        var chart = _this.chart;
        var data = chart.chartData;
        var categoryAxis = _this.categoryAxis;
        var stepWidth;

        if (categoryAxis.parseDates && !categoryAxis.equalSpacing) {
            stepWidth = categoryAxis.stepWidth;

            var firstTime = chart.firstTime;

            pos0 = stepWidth * (_this.startTime - firstTime);
            pos1 = stepWidth * (_this.endTime - firstTime);
        } else {
            pos0 = data[_this.start].x[categoryAxis.id];
            pos1 = data[_this.end].x[categoryAxis.id];

            stepWidth = categoryAxis.stepWidth;

            if (!categoryAxis.startOnAxis) {
                var halfStep = stepWidth / 2;
                pos0 -= halfStep;
                pos1 += halfStep;
            }
        }
        _this.stepWidth = stepWidth;
        _this.updateScrollbarSize(pos0, pos1);
    },


    maskGraphs: function (x, y, w, h) {
        var _this = this;
        var selectedGraph = _this.selectedGraph;
        if (selectedGraph) {
            selectedGraph.set.clipRect(x, y, w, h);
        }
    },

    handleDragStart: function () {
        var _this = this;
        AmCharts.ChartScrollbar.base.handleDragStart.call(_this);
        _this.difference = _this.end - _this.start;
        _this.timeDifference = _this.endTime - _this.startTime;
        if (_this.timeDifference < 0) {
            _this.timeDifference = 0;
        }
    },

    handleBackgroundClick: function () {
        var _this = this;
        AmCharts.ChartScrollbar.base.handleBackgroundClick.call(_this);

        if (!_this.dragging) {
            _this.difference = _this.end - _this.start;
            _this.timeDifference = _this.endTime - _this.startTime;
            if (_this.timeDifference < 0) {
                _this.timeDifference = 0;
            }
        }
    }

});// @tag amchart
AmCharts.Bezier = AmCharts.Class({
    construct: function (container, x, y, color, alpha, thickness, fillColor, fillAlpha, dashLength, endStr) {
        var _this = this;

        if (typeof (fillColor) == 'object') {
            fillColor = fillColor[0];
        }
        if (typeof (fillAlpha) == 'object') {
            fillAlpha = fillAlpha[0];
        }

        var attr = {
            'fill': fillColor,
                'fill-opacity': fillAlpha,
                'stroke-width': thickness
        };

        if (dashLength !== undefined && dashLength > 0) {
            attr['stroke-dasharray'] = dashLength;
        }

        if (!isNaN(alpha)) {
            attr['stroke-opacity'] = alpha;
        }

        if (color) {
            attr.stroke = color;
        }

        var letter = "L";
        var lineStr = "M" + Math.round(x[0]) + "," + Math.round(y[0]);
        var points = [];

        var i;
        for (i = 0; i < x.length; i++) {
            points.push({
                x: Number(x[i]),
                y: Number(y[i])
            });
        }

        if (points.length > 1) {
            var interpolatedPoints = _this.interpolate(points);
            lineStr += _this.drawBeziers(interpolatedPoints);
        }

        if (endStr) {
            lineStr += endStr;
        } else {
            if (!AmCharts.VML) {
                // end string is to create area
                // this is the fix to solve straight line in chrome problem
                lineStr += "M0,0 L0,0";
            }
        }

        _this.path = container.path(lineStr).attr(attr);
    },


    interpolate: function (points) {
        var interpolatedPoints = [];
        interpolatedPoints.push({
            x: points[0].x,
            y: points[0].y
        });

        var slope_x = points[1].x - points[0].x;
        var slope_y = points[1].y - points[0].y;

        var dal_x = AmCharts.bezierX;
        var dal_y = AmCharts.bezierY;

        interpolatedPoints.push({
            x: points[0].x + slope_x / dal_x,
            y: points[0].y + slope_y / dal_y
        });
        var i;

        for (i = 1; i < points.length - 1; i++) {


            var point1 = points[i - 1];
            var point2 = points[i];
            var point3 = points[i + 1];

            if(isNaN(point3.x)){
                point3 = point2;
            }

            if(isNaN(point2.x)){
                point2 = point1;
            }

            if(isNaN(point1.x)){
                point1 = point2;
            }

            slope_x = point3.x - point2.x;
            slope_y = point3.y - point1.y;

            var slope_x0 = point2.x - point1.x;

            if (slope_x0 > slope_x) {
                slope_x0 = slope_x;
            }

            interpolatedPoints.push({
                x: point2.x - slope_x0 / dal_x,
                y: point2.y - slope_y / dal_y
            });
            interpolatedPoints.push({
                x: point2.x,
                y: point2.y
            });
            interpolatedPoints.push({
                x: point2.x + slope_x0 / dal_x,
                y: point2.y + slope_y / dal_y
            });
        }

        slope_y = points[points.length - 1].y - points[points.length - 2].y;
        slope_x = points[points.length - 1].x - points[points.length - 2].x;

        interpolatedPoints.push({
            x: points[points.length - 1].x - slope_x / dal_x,
            y: points[points.length - 1].y - slope_y / dal_y
        });
        interpolatedPoints.push({
            x: points[points.length - 1].x,
            y: points[points.length - 1].y
        });

        return interpolatedPoints;
    },

    drawBeziers: function (interpolatedPoints) {
        var str = "";
        var j;
        for (j = 0; j < (interpolatedPoints.length - 1) / 3; j++) {
            str += this.drawBezierMidpoint(interpolatedPoints[3 * j], interpolatedPoints[3 * j + 1], interpolatedPoints[3 * j + 2], interpolatedPoints[3 * j + 3]);
        }
        return str;
    },


    drawBezierMidpoint: function (P0, P1, P2, P3) {
        var round = Math.round;
        // calculates the useful base points
        var PA = this.getPointOnSegment(P0, P1, 3 / 4);
        var PB = this.getPointOnSegment(P3, P2, 3 / 4);

        // get 1/16 of the [P3, P0] segment
        var dx = (P3.x - P0.x) / 16;
        var dy = (P3.y - P0.y) / 16;

        // calculates control point 1
        var Pc_1 = this.getPointOnSegment(P0, P1, 3 / 8);

        // calculates control point 2
        var Pc_2 = this.getPointOnSegment(PA, PB, 3 / 8);
        Pc_2.x -= dx;
        Pc_2.y -= dy;

        // calculates control point 3
        var Pc_3 = this.getPointOnSegment(PB, PA, 3 / 8);
        Pc_3.x += dx;
        Pc_3.y += dy;

        // calculates control point 4
        var Pc_4 = this.getPointOnSegment(P3, P2, 3 / 8);

        // calculates the 3 anchor points
        var Pa_1 = this.getMiddle(Pc_1, Pc_2);
        var Pa_2 = this.getMiddle(PA, PB);
        var Pa_3 = this.getMiddle(Pc_3, Pc_4);

        // draw the four quadratic subsegments
        var comma = ",";

        var str = " Q" + round(Pc_1.x) + comma + round(Pc_1.y) + comma + round(Pa_1.x) + comma + round(Pa_1.y);
        str += " Q" + round(Pc_2.x) + comma + round(Pc_2.y) + comma + round(Pa_2.x) + comma + round(Pa_2.y);
        str += " Q" + round(Pc_3.x) + comma + round(Pc_3.y) + comma + round(Pa_3.x) + comma + round(Pa_3.y);
        str += " Q" + round(Pc_4.x) + comma + round(Pc_4.y) + comma + round(P3.x) + comma + round(P3.y);

        return str;
    },


    getMiddle: function (P0, P1) {
        var point = {
            x: (P0.x + P1.x) / 2,
            y: (P0.y + P1.y) / 2
        };
        return point;
    },

    getPointOnSegment: function (P0, P1, ratio) {
        var point = {
            x: P0.x + (P1.x - P0.x) * ratio,
            y: P0.y + (P1.y - P0.y) * ratio
        };
        return point;
    }

});// @tag amchart
AmCharts.Cuboid = AmCharts.Class({
    construct: function (container, width, height, dx, dy, colors, alpha, bwidth, bcolor, balpha, gradientRotation, cornerRadius, rotate, dashLength, pattern) {
        var _this = this;
        _this.set = container.set();
        _this.container = container;
        _this.h = Math.round(height);
        _this.w = Math.round(width);
        _this.dx = dx;
        _this.dy = dy;
        _this.colors = colors;
        _this.alpha = alpha;
        _this.bwidth = bwidth;
        _this.bcolor = bcolor;
        _this.balpha = balpha;
        _this.colors = colors;
        _this.dashLength = dashLength;
        _this.pattern = pattern;

        if (rotate) {
            if (width < 0 && gradientRotation === 0) {
                gradientRotation = 180;
            }
        } else {
            if (height < 0) {
                if (gradientRotation == 270) {
                    gradientRotation = 90;
                }
            }
        }
        _this.gradientRotation = gradientRotation;

        if (dx === 0 && dy === 0) {
            _this.cornerRadius = cornerRadius;
        }
        _this.draw();
    },

    draw: function () {
        var _this = this;
        var set = _this.set;
        set.clear();

        var container = _this.container;
        var deltaY = 0;

        var w = _this.w;
        var h = _this.h;
        var dx = _this.dx;
        var dy = _this.dy;
        var colors = _this.colors;
        var alpha = _this.alpha;
        var bwidth = _this.bwidth;
        var bcolor = _this.bcolor;
        var balpha = _this.balpha;
        var gradientRotation = _this.gradientRotation;
        var cornerRadius = _this.cornerRadius;
        var dashLength = _this.dashLength;
        var pattern = _this.pattern;

        // bot
        var firstColor = colors;
        var lastColor = colors;

        if (typeof (colors) == "object") {
            firstColor = colors[0];
            lastColor = colors[colors.length - 1];
        }

        var bottom;
        var back;
        var backBorders;
        var lside;
        var rside;
        var rsideBorders;
        var top;
        var topBorders;
        var bottomBorders;

        // if dx or dx > 0, draw other sides
        var tempAlpha = alpha;
        if(pattern){
            alpha = 0;
        }
        if (dx > 0 || dy > 0) {

            var bc = lastColor;
            var ccc = AmCharts.adjustLuminosity(firstColor, -0.2);
            var tc = firstColor;
            var ta = alpha;

            ccc = AmCharts.adjustLuminosity(tc, -0.2);
            bottom = AmCharts.polygon(container, [0, dx, w + dx, w, 0], [0, dy, dy, 0, 0], ccc, alpha, 1, bcolor, 0, gradientRotation);

            if (balpha > 0) {
                bottomBorders = AmCharts.line(container, [0, dx, w + dx], [0, dy, dy], bcolor, balpha, bwidth, dashLength);
            }

            // back
            back = AmCharts.polygon(container, [0, 0, w, w, 0], [0, h, h, 0, 0], ccc, alpha, 1, bcolor, 0, gradientRotation);
            back.translate(dx, dy);

            // back borders
            if (balpha > 0) {
                backBorders = AmCharts.line(container, [dx, dx], [dy, dy + h], bcolor, balpha, bwidth, dashLength);
            }

            // left side
            lside = AmCharts.polygon(container, [0, 0, dx, dx, 0], [0, h, h + dy, dy, 0], ccc, alpha, 1, bcolor, 0, gradientRotation);

            // right side
            rside = AmCharts.polygon(container, [w, w, w + dx, w + dx, w], [0, h, h + dy, dy, 0], ccc, alpha, 1, bcolor, 0, gradientRotation);

            // right side borders
            if (balpha > 0) {
                rsideBorders = AmCharts.line(container, [w, w + dx, w + dx, w], [0, dy, h + dy, h], bcolor, balpha, bwidth, dashLength);
            }
            //}
            ccc = AmCharts.adjustLuminosity(bc, 0.2);
            top = AmCharts.polygon(container, [0, dx, w + dx, w, 0], [h, h + dy, h + dy, h, h], ccc, alpha, 1, bcolor, 0, gradientRotation);

            // bot borders
            if (balpha > 0) {
                topBorders = AmCharts.line(container, [0, dx, w + dx], [h, h + dy, h + dy], bcolor, balpha, bwidth, dashLength);
            }
        }

        alpha = tempAlpha;

        if (Math.abs(h) < 1) {
            h = 0;
        }

        if (Math.abs(w) < 1) {
            w = 0;
        }

        var front;
        if (h === 0) {
            front = AmCharts.line(container, [0, w], [0, 0], bcolor, balpha, bwidth, dashLength);
        } else if (w === 0) {
            front = AmCharts.line(container, [0, 0], [0, h], bcolor, balpha, bwidth, dashLength);
        } else {
            if (cornerRadius > 0) {
                front = AmCharts.rect(container, w, h, colors, alpha, bwidth, bcolor, balpha, cornerRadius, gradientRotation, dashLength);
            } else {
                front = AmCharts.polygon(container, [0, 0, w, w, 0], [0, h, h, 0, 0], colors, alpha, bwidth, bcolor, balpha, gradientRotation, false, dashLength);
            }
        }

        var elements;
        if (h < 0) {
            elements = [bottom, bottomBorders, back, backBorders, lside, rside, rsideBorders, top, topBorders, front];
        } else {
            elements = [top, topBorders, back, backBorders, lside, rside, bottom, bottomBorders, rsideBorders, front];
        }
        var i;
        for (i = 0; i < elements.length; i++) {
            var el = elements[i];
            if (el) {
                set.push(el);
            }
        }

        if(pattern){
            front.pattern(pattern);
        }
    },

    width: function (v) {
        var _this = this;
        _this.w = v;
        _this.draw();
    },

    height: function (v) {
        var _this = this;
        _this.h = v;
        _this.draw();
    },

    animateHeight: function (duration, easingFunction) {
        var _this = this;
        _this.easing = easingFunction;
        _this.totalFrames = 1000 * duration / AmCharts.updateRate;
        _this.rh = _this.h;
        _this.frame = 0;
        _this.height(1);
        setTimeout(function () {
            _this.updateHeight.call(_this);
        }, AmCharts.updateRate);
    },

    updateHeight: function () {
        var _this = this;
        _this.frame++;
        var totalFrames = _this.totalFrames;

        if (_this.frame <= totalFrames) {
            var value = _this.easing(0, _this.frame, 1, _this.rh - 1, totalFrames);
            _this.height(value);
            setTimeout(function () {
                _this.updateHeight.call(_this);
            }, AmCharts.updateRate);
        }
    },

    animateWidth: function (duration, easingFunction) {
        var _this = this;
        _this.easing = easingFunction;
        _this.totalFrames = 1000 * duration / AmCharts.updateRate;
        _this.rw = _this.w;
        _this.frame = 0;
        _this.width(1);
        setTimeout(function () {
            _this.updateWidth.call(_this);
        }, AmCharts.updateRate);
    },

    updateWidth: function () {
        var _this = this;
        _this.frame++;
        var totalFrames = _this.totalFrames;

        if (_this.frame <= totalFrames) {
            var value = _this.easing(0, _this.frame, 1, _this.rw - 1, totalFrames);
            _this.width(value);
            setTimeout(function () {
                _this.updateWidth.call(_this);
            }, AmCharts.updateRate);
        }
    }

});// @tag amchart
AmCharts.circle = function (container, r, color, alpha, bwidth, bcolor, balpha, bubble) {
    var UNDEFINED;
    if (bwidth == UNDEFINED || bwidth === 0) {
        bwidth = 0.01;
    }
    if (bcolor === UNDEFINED) {
        bcolor = '#000000';
    }
    if (balpha === UNDEFINED) {
        balpha = 0;
    }

    var attr = {
        'fill': color,
            'stroke': bcolor,
            'fill-opacity': alpha,
            'stroke-width': bwidth,
            'stroke-opacity': balpha
    };

    var circle = container.circle(0, 0, r).attr(attr);

    if (bubble) {
        circle.gradient("radialGradient", [color, AmCharts.adjustLuminosity(color, -0.6)]);
    }

    return circle;
};

AmCharts.text = function (container, text, color, fontFamily, fontSize, anchor, bold, alpha) {
    if (!anchor) {
        anchor = "middle";
    }
    if (anchor == "right") {
        anchor = "end";
    }
    if(isNaN(alpha)){
        alpha = 1;
    }

    if (text !== undefined) {
        text = String(text);
        if (AmCharts.isIE) {
            if (!AmCharts.isModern) {
                text = text.replace("&amp;", "&");
                text = text.replace("&", "&amp;");
            }
        }
    }

    var attr = {
        'fill': color,
            'font-family': fontFamily,
            'font-size': fontSize,
            'opacity': alpha
    };

    if (bold === true) {
        attr['font-weight'] = 'bold';
    }

    // last as size depends on previous
    attr['text-anchor'] = anchor;

    var txt = container.text(text, attr);

    return txt;
};



AmCharts.polygon = function (container, x, y, colors, alpha, bwidth, bcolor, balpha, gradientRotation, noRound, dashLength) {
    if (isNaN(bwidth)) {
        bwidth = 0.01;
    }

    if (isNaN(balpha)) {
        balpha = alpha;
    }
    var color = colors;
    var gradient = false;

    if (typeof (color) == "object") {
        if (color.length > 1) {
            gradient = true;
            color = color[0];
        }
    }

    if (bcolor === undefined) {
        bcolor = color;
    }
    var attr = {
        'fill': color,
            'stroke': bcolor,
            'fill-opacity': alpha,
            'stroke-width': bwidth,
            'stroke-opacity': balpha
    };

    if (dashLength !== undefined && dashLength > 0) {
        attr['stroke-dasharray'] = dashLength;
    }

    var dx = AmCharts.dx;
    var dy = AmCharts.dy;

    if(container.handDrawn){
        var xy = AmCharts.makeHD(x, y, container.handDrawScatter);
        x = xy[0];
        y = xy[1];
    }

    var round = Math.round;
    if (noRound) {
        round = AmCharts.doNothing;
    }
    var str = "M" + (round(x[0]) + dx) + "," + (round(y[0]) + dy);

    for (var i = 1; i < x.length; i++) {
        str += " L" + (round(x[i]) + dx) + "," + (round(y[i]) + dy);
    }
    str += " Z";
    var p = container.path(str).attr(attr);

    if (gradient) {
        p.gradient("linearGradient", colors, gradientRotation);
    }

    return p;
};


AmCharts.rect = function (container, w, h, colors, alpha, bwidth, bcolor, balpha, cradius, gradientRotation, dashLength) {
    var UNDEFINED;

    if (isNaN(bwidth)) {
        bwidth = 0;
    }
    if (cradius === UNDEFINED) {
        cradius = 0;
    }
    if (gradientRotation === UNDEFINED) {
        gradientRotation = 270;
    }
    if (isNaN(alpha)) {
        alpha = 0;
    }
    var color = colors;
    var gradient = false;
    if (typeof (color) == "object") {
        color = color[0];
        gradient = true;
    }
    if (bcolor === UNDEFINED) {
        bcolor = color;
    }
    if (balpha === UNDEFINED) {
        balpha = alpha;
    }

    w = Math.round(w);
    h = Math.round(h);

    var x = 0;
    var y = 0;

    if (w < 0) {
        w = Math.abs(w);
        x = -w;
    }

    if (h < 0) {
        h = Math.abs(h);
        y = -h;
    }

    x += AmCharts.dx;
    y += AmCharts.dy;

    var attr = {
        'fill': color,
            'stroke': bcolor,
            'fill-opacity': alpha,
            'stroke-opacity': balpha
    };

    if (dashLength !== undefined && dashLength > 0) {
        attr['stroke-dasharray'] = dashLength;
    }


    var r = container.rect(x, y, w, h, cradius, bwidth).attr(attr);

    if (gradient) {
        r.gradient("linearGradient", colors, gradientRotation);
    }

    return r;
};


AmCharts.bullet = function (container, bulletType, bulletSize, bc, ba, bbt, bbc, bba, originalSize, gradientRotation, pattern) {
    var bullet;

    if(bulletType == "circle"){
        bulletType = "round";
    }

    switch (bulletType) {
        case "round":
            bullet = AmCharts.circle(container, bulletSize / 2, bc, ba, bbt, bbc, bba);
            break;
        case "square":
            bullet = AmCharts.polygon(container, [-bulletSize / 2, bulletSize / 2, bulletSize / 2, -bulletSize / 2], [bulletSize / 2, bulletSize / 2, -bulletSize / 2, -bulletSize / 2], bc, ba, bbt, bbc, bba, gradientRotation - 180);
            break;
        case "rectangle":
            bullet = AmCharts.polygon(container, [-bulletSize, bulletSize, bulletSize, -bulletSize], [bulletSize / 2, bulletSize / 2, -bulletSize / 2, -bulletSize / 2], bc, ba, bbt, bbc, bba, gradientRotation - 180);
            break;
        case "diamond":
            bullet = AmCharts.polygon(container, [-bulletSize / 2, 0, bulletSize / 2, 0], [0, -bulletSize / 2, 0, bulletSize / 2], bc, ba, bbt, bbc, bba);
            break;
        case "triangleUp":
            bullet = AmCharts.triangle(container, bulletSize, 0, bc, ba, bbt, bbc, bba);
            break;
        case "triangleDown":
            bullet = AmCharts.triangle(container, bulletSize, 180, bc, ba, bbt, bbc, bba);
            break;
        case "triangleLeft":
            bullet = AmCharts.triangle(container, bulletSize, 270, bc, ba, bbt, bbc, bba);
            break;
        case "triangleRight":
            bullet = AmCharts.triangle(container, bulletSize, 90, bc, ba, bbt, bbc, bba);
            break;
        case "bubble":
            bullet = AmCharts.circle(container, bulletSize / 2, bc, ba, bbt, bbc, bba, true);
            break;
        case "line":
            bullet = AmCharts.line(container, [- bulletSize / 2, bulletSize / 2], [0, 0], bc, ba, bbt, bbc, bba);
            break;
        case "yError":
            bullet = container.set();
            bullet.push(AmCharts.line(container, [0, 0], [-bulletSize / 2, bulletSize / 2], bc, ba, bbt));
            bullet.push(AmCharts.line(container, [-originalSize, originalSize], [-bulletSize / 2, -bulletSize / 2], bc, ba, bbt));
            bullet.push(AmCharts.line(container, [-originalSize, originalSize], [bulletSize / 2, bulletSize / 2], bc, ba, bbt));
            break;

        case "xError":
            bullet = container.set();
            bullet.push(AmCharts.line(container, [-bulletSize / 2, bulletSize / 2], [0, 0], bc, ba, bbt));
            bullet.push(AmCharts.line(container, [-bulletSize / 2, -bulletSize / 2], [-originalSize, originalSize], bc, ba, bbt));
            bullet.push(AmCharts.line(container, [bulletSize / 2, bulletSize / 2], [-originalSize, originalSize], bc, ba, bbt));
            break;
    }
    if(bullet){
        bullet.pattern(pattern);
    }
    return bullet;
};


AmCharts.triangle = function (container, w, rotation, color, alpha, bwidth, bcolor, balpha) {
    var UNDEFINED;

    if (bwidth === UNDEFINED || bwidth === 0) {
        bwidth = 1;
    }
    if (bcolor === UNDEFINED) {
        bcolor = '#000';
    }
    if (balpha === UNDEFINED) {
        balpha = 0;
    }

    var attr = {
        'fill': color,
            'stroke': bcolor,
            'fill-opacity': alpha,
            'stroke-width': bwidth,
            'stroke-opacity': balpha
    };

    var half = w / 2;
    var path;
    var comma = ",";
    var l = " L";
    var m = " M";
    var z = " Z";

    if (rotation === 0) {
        path = m + (-half) + comma + half + l + 0 + comma + (-half) + l + half + comma + half + z;
    }
    if (rotation == 180) {
        path = m + (-half) + comma + (-half) + l + 0 + comma + half + l + half + comma + (-half) + z;
    }
    if (rotation == 90) {
        path = m + (-half) + comma + (-half) + l + half + comma + 0 + l + (-half) + comma + half + z;
    }
    if (rotation == 270) {
        path = m + (-half) + comma + 0 + l + half + comma + half + l + half + comma + (-half) + z;
    }

    var triangle = container.path(path).attr(attr);

    return triangle;
};


AmCharts.line = function (container, x, y, color, alpha, thickness, dashLength, smoothed, doFix, noRound, noHand) {

    var none = "none";

    if(container.handDrawn && !noHand){
        return AmCharts.handDrawnLine(container, x, y, color, alpha, thickness, dashLength, smoothed, doFix, noRound, noHand);
    }
    else{
        var attr = {
            'fill': none,
                'stroke-width': thickness
        };

        if (dashLength !== undefined && dashLength > 0) {
            attr['stroke-dasharray'] = dashLength;
        }

        if (!isNaN(alpha)) {
            attr['stroke-opacity'] = alpha;
        }

        if (color) {
            attr.stroke = color;
        }

        var letter = "L";

        var round = Math.round;

        if (noRound) {
            round = AmCharts.doNothing;
        }

        var dx = AmCharts.dx;
        var dy = AmCharts.dy;
        var str = "M" + (round(x[0]) + dx) + "," + (round(y[0]) + dy);
        var i;
        for (i = 1; i < x.length; i++) {
            str += " " + letter + "" + (round(x[i]) + dx) + "," + (round(y[i]) + dy);
        }


        if (AmCharts.VML) {
            return container.path(str, undefined, true).attr(attr);
        } else {
            if (doFix) {
                str += " M0,0 L0,0";
            }
            return container.path(str).attr(attr);
        }
    }
};

AmCharts.makeHD = function(x, y, scatter){

    var stepSize = 50;

    var xa = [];
    var ya = [];

    for (var i = 1; i < x.length; i++) {

        var x0 = Number(x[i - 1]);
        var y0 = Number(y[i - 1]);
        var x1 = Number(x[i]);
        var y1 = Number(y[i]);

        var distance = Math.sqrt(Math.pow((x1-x0), 2) + Math.pow((y1-y0),2));
        var steps = Math.round(distance / stepSize) + 1;

        var stepX = (x1 - x0) / steps;
        var stepY = (y1 - y0) / steps;

        for(var s = 0; s <= steps; s++){

            var xx = x0 + s * stepX + Math.random() * scatter;
            var yy = y0 + s * stepY + Math.random() * scatter;

            xa.push(xx);
            ya.push(yy);
        }
    }

    return [xa, ya];
}


AmCharts.handDrawnLine = function(container, x, y, color, alpha, thickness, dashLength, smoothed, doFix, noRound, noHand){
    var i;
    var set = container.set();

    for (i = 1; i < x.length; i++) {

        var x0 = x[i - 1];
        var y0 = y[i - 1];
        var x1 = x[i];
        var y1 = y[i];

        var xa = [x0, x1];
        var ya = [y0, y1];

        var newXY = AmCharts.makeHD(xa, ya, container.handDrawScatter);
        xa = newXY[0];
        ya = newXY[1];

        for(var j = 1; j < xa.length; j++){
            set.push(AmCharts.line(container, [xa[j-1], xa[j]], [ya[j-1], ya[j]], color, alpha, thickness + Math.random() * container.handDrawThickness - container.handDrawThickness / 2, dashLength, smoothed, doFix, noRound, true));
        }
    }

    return set;
};

AmCharts.doNothing = function (value) {
    return value;
};

AmCharts.wedge = function (container, x, y, startAngle, arc, radius, yRadius, innerRadius, h, attributes, gradientRatio, pattern) {
    var rad = Math.PI / 180;
    var round = Math.round;

    radius = round(radius);
    yRadius = round(yRadius);

    innerRadius = round(innerRadius);
    var yInnerRadius = round((yRadius / radius) * innerRadius);

    var vml = AmCharts.VML;

    // FAILS IF BIGGER, and the smaller radius, the bigger corection
    var edge = 359.5 + radius / 100;
    if (edge > 359.94) {
        edge = 359.94;
    }

    if (arc >= edge) {
        arc = edge;
    }

    /* to understand what each letter means
     c-----------b
      \          /
       \        /
        \      /
         d----a
          \  /
           \/
           x
    */

    var degToRad = 1 / 180 * Math.PI;
    var ax = x + Math.sin(startAngle * degToRad) * innerRadius;
    var ay = y - Math.cos(startAngle * degToRad) * yInnerRadius;

    var bx = x + Math.sin(startAngle * degToRad) * radius;
    var by = y - Math.cos(startAngle * degToRad) * yRadius;

    var cx = x + Math.sin((startAngle + arc) * degToRad) * radius;
    var cy = y - Math.cos((startAngle + arc) * degToRad) * yRadius;

    var dx = x + Math.sin((startAngle + arc) * degToRad) * innerRadius;
    var dy = y - Math.cos((startAngle + arc) * degToRad) * yInnerRadius;

    var hsb = AmCharts.adjustLuminosity(attributes.fill, -0.2);

    var bparams = {
        'fill': hsb,
        'stroke-opacity': 0,
        'fill-opacity': attributes["fill-opacity"]
    };

    var lf = 0;
    var sf = 1;
    if (Math.abs(arc) > 180) {
        lf = 1;
    }

    var slice = container.set();
    var comma = ",";
    var L = " L";
    var A = " A";
    var Z = " Z";
    var M = " M";
    var B = " B";
    var UNDEFINED;
    var cs = "1000,1000";

    var wpath;
    var isSmall;
    var ten = 10;

    if (vml) {
        ax = round(ten * ax);
        bx = round(ten * bx);
        cx = round(ten * cx);
        dx = round(ten * dx);
        ay = round(ten * ay);
        by = round(ten * by);
        cy = round(ten * cy);
        dy = round(ten * dy);
        x = round(ten * x);
        h = round(ten * h);
        y = round(ten * y);
        radius = ten * radius;
        yRadius = ten * yRadius;
        innerRadius = ten * innerRadius;
        yInnerRadius = ten * yInnerRadius;

        if (Math.abs(arc) < 1 && Math.abs(cx - bx) <= 1 && Math.abs(cy - by) <= 1) {
            isSmall = true;
        }
    }
    var parc = "";
    var path;

    if(pattern){
        bparams["fill-opacity"] = 0;
        bparams['stroke-opacity'] = attributes['stroke-opacity'] / 2;
        bparams['stroke'] = attributes['stroke'];
    }

    if (h > 0) {
        if (vml) {
            path = M + ax + comma + (ay + h) + L + bx + comma + (by + h);

            if (!isSmall) {
                path += A + (x - radius) + comma + (h + y - yRadius) + comma + (x + radius) + comma + (h + y + yRadius) + comma + (bx) + comma + (by + h) + comma + (cx) + comma + (cy + h);
            }

            path += L + dx + comma + (dy + h);

            if (innerRadius > 0) {
                if (!isSmall) {
                    path += " B" + (x - innerRadius) + comma + (h + y - yInnerRadius) + comma + (x + innerRadius) + comma + (h + y + yInnerRadius) + comma + dx + comma + (h + dy) + comma + ax + comma + (h + ay);
                }
            }
        } else {
            path = M + ax + comma + (ay + h) + L + bx + comma + (by + h);
            path += A + radius + comma + yRadius + comma + 0 + comma + lf + comma + sf + comma + cx + comma + (cy + h) + L + dx + comma + (dy + h);

            if (innerRadius > 0) {
                path += A + innerRadius + comma + yInnerRadius + comma + 0 + comma + lf + comma + 0 + comma + ax + comma + (ay + h);
            }
        }

        path += Z;
        var c = container.path(path, UNDEFINED, UNDEFINED, cs).attr(bparams);
        slice.push(c);
        var b1 = container.path(M + ax + comma + ay + L + ax + comma + (ay + h) + L + bx + comma + (by + h) + L + bx + comma + by + L + ax + comma + ay + Z, UNDEFINED, UNDEFINED, cs).attr(bparams);
        var b2 = container.path(M + cx + comma + cy + L + cx + comma + (cy + h) + L + dx + comma + (dy + h) + L + dx + comma + dy + L + cx + comma + cy + Z, UNDEFINED, UNDEFINED, cs).attr(bparams);
        slice.push(b1);
        slice.push(b2);
    }

    if (vml) {
        if (!isSmall) {
            parc = A + round(x - radius) + comma + round(y - yRadius) + comma + round(x + radius) + comma + round(y + yRadius) + comma + round(bx) + comma + round(by) + comma + round(cx) + comma + round(cy);
        }
        wpath = M + round(ax) + comma + round(ay) + L + round(bx) + comma + round(by) + parc + L + round(dx) + comma + round(dy);
    } else {
        parc = A + radius + comma + yRadius + comma + 0 + comma + lf + comma + sf + comma + cx + comma + cy;
        wpath = M + ax + comma + ay + L + bx + comma + by + parc + L + dx + comma + dy;
    }


    if (innerRadius > 0) {
        if (vml) {
            if (!isSmall) {
                wpath += B + (x - innerRadius) + comma + (y - yInnerRadius) + comma + (x + innerRadius) + comma + (y + yInnerRadius) + comma + dx + comma + dy + comma + ax + comma + ay;
            }
        } else {
            wpath += A + innerRadius + comma + yInnerRadius + comma + 0 + comma + lf + comma + 0 + comma + ax + comma + ay;
        }
    }


    if(container.handDrawn){
        var hdLine = AmCharts.line(container, [ax, bx], [ay, by], attributes.stroke, attributes.thickness * Math.random() * container.handDrawThickness, attributes["stroke-opacity"]);
        slice.push(hdLine);
    }


    wpath += Z;

    var w = container.path(wpath, UNDEFINED, UNDEFINED, cs).attr(attributes);

    if (gradientRatio) {
        var gradient = [];
        var i;
        for (i = 0; i < gradientRatio.length; i++) {
            gradient.push(AmCharts.adjustLuminosity(attributes.fill, gradientRatio[i]));
        }
        if (gradient.length > 0) {
            w.gradient("linearGradient", gradient);
        }
    }

    w.pattern(pattern);

    slice.push(w);
    return slice;
};

// Thanks Craig Buckler for this method:
// http://www.sitepoint.com/javascript-generate-lighter-darker-color/
AmCharts.adjustLuminosity = function (hex, lum) {
    hex = String(hex).replace(/[^0-9a-f]/gi, '');
    if (hex.length < 6) {
        hex = String(hex[0]) + String(hex[0]) + String(hex[1]) + String(hex[1]) + String(hex[2]) + String(hex[2]);
    }

    lum = lum || 0;

    var rgb = "#";
    var c;
    var i;

    for (i = 0; i < 3; i++) {
        c = parseInt(hex.substr(i * 2, 2), 16);
        c = Math.round(Math.min(Math.max(0, c + (c * lum)), 255)).toString(16);
        rgb += ("00" + c).substr(c.length);
    }
    return rgb;
};// @tag amchart-static
AmCharts.AmLegend = AmCharts.Class({

    construct: function(theme) {
        var _this = this;
        _this.cname = "AmLegend";
        _this.createEvents('rollOverMarker', 'rollOverItem', 'rollOutMarker', 'rollOutItem', 'showItem', 'hideItem', 'clickMarker', 'rollOverItem', 'rollOutItem', 'clickLabel');
        _this.position = "bottom";
        _this.color = "#000000";
        _this.borderColor = '#000000';
        _this.borderAlpha = 0;
        _this.markerLabelGap = 5;
        _this.verticalGap = 10;
        _this.align = "left";
        _this.horizontalGap = 0;
        _this.spacing = 10;
        _this.markerDisabledColor = "#AAB3B3";
        _this.markerType = "square";
        _this.markerSize = 16;
        _this.markerBorderAlpha = 1;
        _this.markerBorderThickness = 1;
        _this.marginTop = 0;
        _this.marginBottom = 0;
        _this.marginRight = 20;
        _this.marginLeft = 20;
        _this.autoMargins = true;
        _this.valueWidth = 50;
        _this.switchable = true;
        _this.switchType = "x";
        _this.switchColor = "#FFFFFF";
        _this.rollOverColor = "#CC0000";
        //_this.selectedColor;
        _this.reversedOrder = false;
        _this.labelText = "[[title]]";
        _this.valueText = "[[value]]";
        _this.useMarkerColorForLabels = false;
        _this.rollOverGraphAlpha = 1;
        _this.textClickEnabled = false;
        _this.equalWidths = true;
        _this.dateFormat = "DD-MM-YYYY";
        _this.backgroundColor = "#FFFFFF";
        _this.backgroundAlpha = 0;
        _this.useGraphSettings = false;
        //_this.ly;
        //_this.lx;
        _this.showEntries = true;
        //_this.periodValueText;
        AmCharts.applyTheme(_this, theme, _this.cname);
    },

    setData: function(data) {
        var _this = this;
        _this.legendData = data;
        _this.invalidateSize();
    },

    invalidateSize: function() {
        var _this = this;
        _this.destroy();
        _this.entries = [];
        _this.valueLabels = [];
        var data = _this.legendData;
        if (AmCharts.ifArray(data) || AmCharts.ifArray(_this.data)) {
            _this.drawLegend();
        }
    },

    drawLegend: function() {
        var _this = this;
        var chart = _this.chart;
        var position = _this.position;
        var width = _this.width;

        var realWidth = chart.divRealWidth;
        var realHeight = chart.divRealHeight;
        var div = _this.div;
        var data = _this.legendData;

        if (_this.data) {
            data = _this.data;
        }

        if (isNaN(_this.fontSize)) {
            _this.fontSize = chart.fontSize;
        }

        if (position == "right" || position == "left") {
            _this.maxColumns = 1;
            if (_this.autoMargins){
                _this.marginRight = 10;
                _this.marginLeft = 10;
            }
        } else {
            if (_this.autoMargins) {
                _this.marginRight = chart.marginRight;
                _this.marginLeft = chart.marginLeft;
                var autoMarginOffset = chart.autoMarginOffset;
                if (position == "bottom") {
                    _this.marginBottom = autoMarginOffset;
                    _this.marginTop = 0;
                } else {
                    _this.marginTop = autoMarginOffset;
                    _this.marginBottom = 0;
                }
            }
        }

        var divWidth;

        if (width !== undefined) {
            divWidth = AmCharts.toCoordinate(width, realWidth);
        } else {
            if (position != "right" && position != "left") {
                divWidth = chart.realWidth;
            }
        }

        if (position == "outside") {
            divWidth = div.offsetWidth;
            realHeight = div.offsetHeight;

            if (div.clientHeight) {
                divWidth = div.clientWidth;
                realHeight = div.clientHeight;
            }
        } else {
            if(!isNaN(divWidth)){
                div.style.width = divWidth + "px";
            }
            div.className = "amChartsLegend";
        }

        _this.divWidth = divWidth;

        _this.container = new AmCharts.AmDraw(div, divWidth, realHeight, chart);

        _this.lx = 0;
        _this.ly = 8;

        var markerSize = _this.markerSize;

        if (markerSize > _this.fontSize) {
            _this.ly = markerSize / 2 - 1;
        }


        if (markerSize > 0) {
            _this.lx += markerSize + _this.markerLabelGap;
        }

        _this.titleWidth = 0;
        var title = this.title;
        if (title) {
            var label = AmCharts.text(_this.container, title, _this.color, chart.fontFamily, _this.fontSize, 'start', true);
            label.translate(_this.marginLeft, _this.marginTop + _this.verticalGap + _this.ly + 1);
            var titleBBox = label.getBBox();
            _this.titleWidth = titleBBox.width + 15;
            _this.titleHeight = titleBBox.height + 6;
        }

        _this.maxLabelWidth = 0;

        _this.index = 0;

        if (_this.showEntries) {
            var i;
            for (i = 0; i < data.length; i++) {
                _this.createEntry(data[i]);
            }

            _this.index = 0;

            for (i = 0; i < data.length; i++) {
                _this.createValue(data[i]);
            }
        }
        _this.arrangeEntries();
        _this.updateValues();
    },

    arrangeEntries: function() {
        var _this = this;
        var position = _this.position;
        var marginLeft = _this.marginLeft + _this.titleWidth;
        var marginRight = _this.marginRight;
        var marginTop = _this.marginTop;
        var marginBottom = _this.marginBottom;
        var horizontalGap = _this.horizontalGap;
        var div = _this.div;
        var divWidth = _this.divWidth;
        var maxColumns = _this.maxColumns;
        var verticalGap = _this.verticalGap;
        var spacing = _this.spacing;
        var w = divWidth - marginRight - marginLeft;
        var maxWidth = 0;
        var maxHeight = 0;

        var container = _this.container;
        var set = container.set();
        _this.set = set;

        var entriesSet = container.set();
        set.push(entriesSet);

        var entries = _this.entries;
        var bbox;
        var i;
        for (i = 0; i < entries.length; i++) {
            bbox = entries[i].getBBox();
            var ew = bbox.width;
            if (ew > maxWidth) {
                maxWidth = ew;
            }
            var eh = bbox.height;

            if (eh > maxHeight) {
                maxHeight = eh;
            }
        }

        var row = 0;
        var column = 0;
        var nextX = horizontalGap;

        for (i = 0; i < entries.length; i++) {

            var entry = entries[i];
            if (_this.reversedOrder) {
                entry = entries[entries.length - i - 1];
            }

            bbox = entry.getBBox();
            var x;
            if (!_this.equalWidths) {
                x = nextX;
                nextX = nextX + bbox.width + horizontalGap + spacing;
            } else {
                x = horizontalGap + column * (maxWidth + spacing + _this.markerLabelGap);
            }

            if (x + bbox.width > w && i > 0 && column !== 0) {
                row++;
                column = 0;
                x = horizontalGap;
                nextX = x + bbox.width + horizontalGap + spacing;
            }

            var y = (maxHeight + verticalGap) * row;

            entry.translate(x, y);
            column++;

            if (!isNaN(maxColumns)) {
                if (column >= maxColumns) {
                    column = 0;
                    row++;
                }
            }
            entriesSet.push(entry);
        }

        bbox = entriesSet.getBBox();

        var hh = bbox.height + 2 * verticalGap - 1;
        var ww;

        if (position == "left" || position == "right") {
            ww = bbox.width + 2 * horizontalGap;
            divWidth = ww + marginLeft + marginRight;
            div.style.width = divWidth + "px";
        } else {
            ww = divWidth - marginLeft - marginRight - 1;
        }

        var bg = AmCharts.polygon(_this.container, [0, ww, ww, 0], [0, 0, hh, hh], _this.backgroundColor, _this.backgroundAlpha, 1, _this.borderColor, _this.borderAlpha);
        set.push(bg);

        set.translate(marginLeft, marginTop);

        bg.toBack();
        var ex = horizontalGap;
        if (position == "top" || position == "bottom" || position == "absolute" || position == "outside") {
            if (_this.align == "center") {
                ex = horizontalGap + (ww - bbox.width) / 2;
            } else if (_this.align == "right") {
                ex = horizontalGap + ww - bbox.width;
            }
        }

        entriesSet.translate(ex, verticalGap + 1);

        if (this.titleHeight > hh) {
            hh = this.titleHeight;
        }

        var divHeight = hh + marginTop + marginBottom + 1;

        if (divHeight < 0) {
            divHeight = 0;
        }

        div.style.height = Math.round(divHeight) + "px";
    },

    createEntry: function(dItem) {
        if (dItem.visibleInLegend !== false) {
            var _this = this;
            var chart = _this.chart;
            var markerType = dItem.markerType;
            if (!markerType) {
                markerType = _this.markerType;
            }

            var color = dItem.color;
            var alpha = dItem.alpha;

            if (dItem.legendKeyColor) {
                color = dItem.legendKeyColor();
            }

            if (dItem.legendKeyAlpha) {
                alpha = dItem.legendKeyAlpha();
            }
            var UNDEFINED;
            var bulletBorderColor;
            if (dItem.hidden === true) {
                color = _this.markerDisabledColor;
                bulletBorderColor = color;
            }
            var pattern = dItem.pattern;
            var marker;
            var customMarker = dItem.customMarker;
            if (!customMarker) {
                customMarker = _this.customMarker;
            }
            var container = _this.container;
            var markerSize = _this.markerSize;
            var dx = 0;
            var dy = 0;
            var markerX = markerSize / 2;
            if (_this.useGraphSettings) {

                var graphType = dItem.type;
                _this.switchType = undefined;
                if (graphType == "line" || graphType == "step" || graphType == "smoothedLine" || graphType == "ohlc") {

                    marker = container.set();

                    if (!dItem.hidden) {
                        color = dItem.lineColorR;
                        bulletBorderColor = dItem.bulletBorderColorR;
                    }

                    var line = AmCharts.line(container, [0, markerSize * 2], [markerSize / 2, markerSize / 2], color, dItem.lineAlpha, dItem.lineThickness, dItem.dashLength);
                    marker.push(line);

                    if (dItem.bullet) {
                        if (!dItem.hidden) {
                            color = dItem.bulletColorR;
                        }
                        var bullet = AmCharts.bullet(container, dItem.bullet, dItem.bulletSize, color, dItem.bulletAlpha, dItem.bulletBorderThickness, bulletBorderColor, dItem.bulletBorderAlpha);
                        if (bullet) {
                            bullet.translate(markerSize + 1, markerSize / 2);
                            marker.push(bullet);
                        }
                    }
                    markerX = 0;
                    dx = markerSize;
                    dy = markerSize / 3;
                } else {
                    var gradRotation;
                    if (dItem.getGradRotation) {
                        gradRotation = dItem.getGradRotation();
                    }

                    var fillColors = dItem.fillColorsR;
                    if (dItem.hidden === true) {
                        fillColors = color;
                    }

                    marker = _this.createMarker("rectangle", fillColors, dItem.fillAlphas, dItem.lineThickness, color, dItem.lineAlpha, gradRotation, pattern);
                    if (marker) {
                        markerX = markerSize;
                        marker.translate(markerX, markerSize / 2);
                    }
                    dx = markerSize;
                }
            } else if (customMarker) {
                if (chart.path) {
                    customMarker = chart.path + customMarker;
                }

                marker = container.image(customMarker, 0, 0, markerSize, markerSize);
            } else {
                marker = _this.createMarker(markerType, color, alpha, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, pattern);
                if (marker) {
                    marker.translate(markerSize / 2, markerSize / 2);
                }

            }
            _this.addListeners(marker, dItem);
            var entrySet = container.set([marker]);

            if (_this.switchable) {
                entrySet.setAttr('cursor', 'pointer');
            }

            // switch
            var switchType = _this.switchType;
            var mswitch;
            if (switchType && switchType != "none") {
                if (switchType == "x") {
                    mswitch = _this.createX();
                    mswitch.translate(markerSize / 2, markerSize / 2);
                } else {
                    mswitch = _this.createV();
                }

                mswitch.dItem = dItem;

                if (dItem.hidden !== true) {
                    if (switchType == "x") {
                        mswitch.hide();
                    } else {
                        mswitch.show();
                    }
                } else {
                    if (switchType != "x") {
                        mswitch.hide();
                    }
                }

                if (!_this.switchable) {
                    mswitch.hide();
                }
                _this.addListeners(mswitch, dItem);
                dItem.legendSwitch = mswitch;
                entrySet.push(mswitch);
            }
            // end of switch
            var tcolor = _this.color;

            if (dItem.showBalloon && _this.textClickEnabled && _this.selectedColor !== undefined) {
                tcolor = _this.selectedColor;
            }

            if (_this.useMarkerColorForLabels) {
                tcolor = color;
            }
            if (dItem.hidden === true) {
                tcolor = _this.markerDisabledColor;
            }

            var txt = AmCharts.massReplace(_this.labelText, {
                "[[title]]": dItem.title
            });
            var fontSize = _this.fontSize;

            if (marker) {
                if (markerSize <= fontSize) {
                    var newY = markerSize / 2 + _this.ly - fontSize / 2 + (fontSize + 2 - markerSize) / 2 - dy;
                    marker.translate(markerX, newY);
                }
            }

            var label;
            if (txt) {
                txt = AmCharts.fixBrakes(txt);
                dItem.legendTextReal = txt;
                label = AmCharts.text(_this.container, txt, tcolor, chart.fontFamily, fontSize, 'start');
                label.translate(_this.lx + dx, _this.ly);
                entrySet.push(label);

                var bbox = label.getBBox();
                var lWidth = bbox.width;

                if (_this.maxLabelWidth < lWidth) {
                    _this.maxLabelWidth = lWidth;
                }
            }

            _this.entries[_this.index] = entrySet;
            dItem.legendEntry = _this.entries[_this.index];
            dItem.legendLabel = label;
            _this.index++;
        }
    },

    addListeners: function(obj, dItem) {
        var _this = this;
        if (obj) {
            obj.mouseover(function() {
                _this.rollOverMarker(dItem);
            }).mouseout(function() {
                _this.rollOutMarker(dItem);
            }).click(function() {
                _this.clickMarker(dItem);
            });
        }
    },


    rollOverMarker: function(dItem) {
        var _this = this;
        if (_this.switchable) {
            _this.dispatch("rollOverMarker", dItem);
        }
        _this.dispatch("rollOverItem", dItem);
    },

    rollOutMarker: function(dItem) {
        var _this = this;
        if (_this.switchable) {
            _this.dispatch("rollOutMarker", dItem);
        }
        _this.dispatch("rollOutItem", dItem);
    },

    clickMarker: function(dItem) {
        var _this = this;
        if (_this.switchable) {
            if (dItem.hidden === true) {
                _this.dispatch("showItem", dItem);
            } else {
                _this.dispatch("hideItem", dItem);
            }
        }
        _this.dispatch("clickMarker", dItem);
    },


    rollOverLabel: function(dItem) {
        var _this = this;
        if (!dItem.hidden) {
            if (_this.textClickEnabled) {
                if (dItem.legendLabel) {
                    dItem.legendLabel.attr({
                        fill: _this.rollOverColor
                    });
                }
            }
            _this.dispatch("rollOverItem", dItem);
        }
    },

    rollOutLabel: function(dItem) {
        var _this = this;
        if (!dItem.hidden) {
            if (_this.textClickEnabled) {
                if (dItem.legendLabel) {
                    var color = _this.color;
                    if (_this.selectedColor !== undefined && dItem.showBalloon) {
                        color = _this.selectedColor;
                    }
                    if (_this.useMarkerColorForLabels) {
                        color = dItem.lineColor;
                        if (color === undefined) {
                            color = dItem.color;
                        }
                    }

                    dItem.legendLabel.attr({
                        fill: color
                    });
                }
            }
            _this.dispatch("rollOutItem", dItem);
        }
    },

    clickLabel: function(dItem) {
        var _this = this;

        if (_this.textClickEnabled) {
            if (!dItem.hidden) {
                _this.dispatch("clickLabel", dItem);
            }
        } else if (_this.switchable) {
            if (dItem.hidden === true) {
                _this.dispatch("showItem", dItem);
            } else {
                _this.dispatch("hideItem", dItem);
            }
        }
    },

    dispatch: function(name, dItem) {
        var _this = this;
        _this.fire(name, {
            type: name,
            dataItem: dItem,
            target: _this,
            chart: _this.chart
        });
    },

    createValue: function(dItem) {
        var _this = this;
        var fontSize = _this.fontSize;
        var LEFT = "left";
        if (dItem.visibleInLegend !== false) {
            var labelWidth = _this.maxLabelWidth;

            if (!_this.equalWidths) {
                _this.valueAlign = LEFT;
            }

            if (_this.valueAlign == LEFT) {
                labelWidth = dItem.legendEntry.getBBox().width;
            }

            var hitW = labelWidth;
            if (_this.valueText && _this.valueWidth > 0) {
                var tcolor = _this.color;
                if (_this.useMarkerColorForValues) {
                    tcolor = dItem.color;
                    if (dItem.legendKeyColor) {
                        tcolor = dItem.legendKeyColor();
                    }
                }

                if (dItem.hidden === true) {
                    tcolor = _this.markerDisabledColor;
                }

                var txt = _this.valueText;
                var x = labelWidth + _this.lx + _this.markerLabelGap + _this.valueWidth;

                var anchor = "end";
                if (_this.valueAlign == LEFT) {
                    x -= _this.valueWidth;
                    anchor = "start";
                }

                var vlabel = AmCharts.text(_this.container, txt, tcolor, _this.chart.fontFamily, fontSize, anchor);
                vlabel.translate(x, _this.ly);
                _this.entries[_this.index].push(vlabel);

                hitW += _this.valueWidth + _this.markerLabelGap * 2;

                vlabel.dItem = dItem;
                _this.valueLabels.push(vlabel);
            }



            _this.index++;
            var hitH = _this.markerSize;
            if (hitH < fontSize + 7) {
                hitH = fontSize + 7;
                if (AmCharts.VML) {
                    hitH += 3;
                }
            }
            var hitRect = _this.container.rect(_this.markerSize, 0, hitW, hitH, 0, 0).attr({
                'stroke': 'none',
                'fill': '#ffffff',
                'fill-opacity': 0.005
            });

            hitRect.dItem = dItem;

            _this.entries[_this.index - 1].push(hitRect);
            hitRect.mouseover(function() {
                _this.rollOverLabel(dItem);
            }).mouseout(function() {
                _this.rollOutLabel(dItem);
            }).click(function() {
                _this.clickLabel(dItem);
            });
        }
    },

    createV: function() {
        var _this = this;
        var size = _this.markerSize;
        return AmCharts.polygon(_this.container, [size / 5, size / 2, size - size / 5, size / 2], [size / 3, size - size / 5, size / 5, size / 1.7], _this.switchColor);
    },

    createX: function() {
        var _this = this;
        var size = (_this.markerSize - 4) / 2;

        var attr = {
            stroke: _this.switchColor,
            'stroke-width': 3
        };
        var container = _this.container;
        var line1 = AmCharts.line(container, [- size, size], [-size, size]).attr(attr);
        var line2 = AmCharts.line(container, [- size, size], [size, -size]).attr(attr);
        return _this.container.set([line1, line2]);
    },

    createMarker: function(type, color, alpha, thickness, lineColor, lineAlpha, gradientRotation, pattern) {
        var _this = this;
        var size = _this.markerSize;
        var c = _this.container;
        var marker;

        if (!lineColor) {
            lineColor = _this.markerBorderColor;
        }
        if (!lineColor) {
            lineColor = color;
        }
        if (isNaN(thickness)) {
            thickness = _this.markerBorderThickness;
        }

        if (isNaN(lineAlpha)) {
            lineAlpha = _this.markerBorderAlpha;
        }

        marker = AmCharts.bullet(c, type, size, color, alpha, thickness, lineColor, lineAlpha, size, gradientRotation, pattern);

        return marker;
    },


    validateNow: function() {
        this.invalidateSize();
    },

    updateValues: function() {

        var _this = this;
        var valueLabels = _this.valueLabels;
        var chart = _this.chart;
        var i;

        var data = _this.data;


        for (i = 0; i < valueLabels.length; i++) {
            var label = valueLabels[i];
            var dataItem = label.dItem;
            var formattedText = " ";
            // all except slices

            if (!data) {
                if (dataItem.type !== undefined) {
                    var currentDataItem = dataItem.currentDataItem;
                    var periodValueText = _this.periodValueText;
                    if (dataItem.legendPeriodValueText) {
                        periodValueText = dataItem.legendPeriodValueText;
                    }

                    // one value
                    if (currentDataItem) {
                        formattedText = _this.valueText;

                        if (dataItem.legendValueText) {
                            formattedText = dataItem.legendValueText;
                        }

                        formattedText = chart.formatString(formattedText, currentDataItem);
                    }
                    // period values
                    else if (periodValueText) {
                        formattedText = chart.formatPeriodString(periodValueText, dataItem);
                    }
                }
                // slices
                else {
                    formattedText = chart.formatString(_this.valueText, dataItem);
                }

                // this partly fixes IE11 (beta preview) bug with legend
                var legendLabel = dataItem.legendLabel;
                if (legendLabel) {
                    legendLabel.text(dataItem.legendTextReal);
                }
                label.text(formattedText);
            } else {
                if (dataItem.value) {
                    label.text(dataItem.value);
                } else {
                    label.text("");
                }
            }

        }
    },

    renderFix: function() {
        if (!AmCharts.VML) {
            var container = this.container;
            if (container) {
                container.renderFix();
            }
        }
    },

    destroy: function() {
        var _this = this;
        _this.div.innerHTML = "";
        AmCharts.remove(_this.set);
    }
});// @tag amchart-static
AmCharts.AmPieChart = AmCharts.Class({

    inherits: AmCharts.AmSlicedChart,

    construct: function(theme) {
        var _this = this;
        _this.type = "pie";
        AmCharts.AmPieChart.base.construct.call(_this, theme);

        _this.cname = "AmPieChart";
        _this.pieBrightnessStep = 30;
        _this.minRadius = 10;
        _this.depth3D = 0;
        _this.startAngle = 90;
        _this.innerRadius = 0;
        _this.angle = 0;
        _this.startRadius = '500%';
        _this.pullOutRadius = '20%';
        _this.labelRadius = 20;
        _this.labelText = "[[title]]: [[percents]]%";
        _this.balloonText = "[[title]]: [[percents]]% ([[value]])\n[[description]]";
        _this.previousScale = 1;
        AmCharts.applyTheme(_this, theme, _this.cname);
    },

    drawChart: function() {

        var _this = this;

        AmCharts.AmPieChart.base.drawChart.call(_this);
        var chartData = _this.chartData;

        if (AmCharts.ifArray(chartData)) {
            if (_this.realWidth > 0 && _this.realHeight > 0) {
                if (AmCharts.VML) {
                    _this.startAlpha = 1;
                }

                var startDuration = _this.startDuration;
                var container = _this.container;
                var realWidth = _this.updateWidth();
                _this.realWidth = realWidth;

                var realHeight = _this.updateHeight();
                _this.realHeight = realHeight;

                var toCoordinate = AmCharts.toCoordinate;
                var marginLeft = toCoordinate(_this.marginLeft, realWidth);
                var marginRight = toCoordinate(_this.marginRight, realWidth);
                var marginTop = toCoordinate(_this.marginTop, realHeight) + _this.getTitleHeight();
                var marginBottom = toCoordinate(_this.marginBottom, realHeight);

                var pieX;
                var pieY;
                var radius;
                var labelRadius = AmCharts.toNumber(_this.labelRadius);
                var labelWidth = _this.measureMaxLabel();
                var pullOutRadiusReal;

                if (!_this.labelText || !_this.labelsEnabled) {
                    labelWidth = 0;
                    labelRadius = 0;
                }

                if (_this.pieX === undefined) {
                    pieX = (realWidth - marginLeft - marginRight) / 2 + marginLeft;
                } else {
                    pieX = toCoordinate(_this.pieX, _this.realWidth);
                }

                if (_this.pieY === undefined) {
                    pieY = (realHeight - marginTop - marginBottom) / 2 + marginTop;
                } else {
                    pieY = toCoordinate(_this.pieY, realHeight);
                }

                radius = toCoordinate(_this.radius, realWidth, realHeight);

                // if radius is not defined, calculate from margins
                if (!radius) {
                    var pureWidth;

                    if (labelRadius >= 0) {
                        pureWidth = realWidth - marginLeft - marginRight - labelWidth * 2;
                    } else {
                        pureWidth = realWidth - marginLeft - marginRight;
                    }

                    var pureHeight = realHeight - marginTop - marginBottom;
                    radius = Math.min(pureWidth, pureHeight);

                    if (pureHeight < pureWidth) {
                        radius = radius / (1 - _this.angle / 90);

                        if (radius > pureWidth) {
                            radius = pureWidth;
                        }
                    }

                    pullOutRadiusReal = AmCharts.toCoordinate(_this.pullOutRadius, radius);

                    if (labelRadius >= 0) {
                        radius -= (labelRadius + pullOutRadiusReal) * 1.8;
                    } else {
                        radius -= pullOutRadiusReal * 1.8;
                    }
                    radius = radius / 2;
                }

                if (radius < _this.minRadius) {
                    radius = _this.minRadius;
                }

                pullOutRadiusReal = toCoordinate(_this.pullOutRadius, radius);
                var startRadius = AmCharts.toCoordinate(_this.startRadius, radius);
                var innerRadius = toCoordinate(_this.innerRadius, radius);

                if (innerRadius >= radius) {
                    innerRadius = radius - 1;
                }

                var startAngle = AmCharts.fitToBounds(_this.startAngle, 0, 360);

                // in case the pie has 3D depth, start angle can only be equal to 90 or 270
                if (_this.depth3D > 0) {
                    if (startAngle >= 270) {
                        startAngle = 270;
                    } else {
                        startAngle = 90;
                    }
                }

                startAngle -= 90;

                var yRadius = radius - radius * _this.angle / 90;
                var i;
                for (i = 0; i < chartData.length; i++) {
                    var dItem = chartData[i];

                    if (dItem.hidden !== true && dItem.percents > 0) {
                        // SLICE
                        var arc = dItem.percents * 360 / 100;
                        var ix = Math.sin((startAngle + arc / 2) / 180 * Math.PI);
                        var iy = -Math.cos((startAngle + arc / 2) / 180 * Math.PI) * (yRadius / radius);

                        var outlineColor = _this.outlineColor;
                        if(!outlineColor){
                            outlineColor = dItem.color;
                        }

                        var alpha = _this.alpha;
                        if(!isNaN(dItem.alpha)){
                            alpha = dItem.alpha;
                        }

                        var wattr = {
                            'fill': dItem.color,
                            'stroke': outlineColor,
                            'stroke-width': _this.outlineThickness,
                            'stroke-opacity': _this.outlineAlpha,
                            'fill-opacity': alpha
                        };

                        if (dItem.url) {
                            wattr.cursor = 'pointer';
                        }

                        var xx = pieX;
                        var yy = pieY;

                        var wedge = AmCharts.wedge(container, xx, yy, startAngle, arc, radius, yRadius, innerRadius, _this.depth3D, wattr, _this.gradientRatio, dItem.pattern);
                        _this.addEventListeners(wedge, dItem);

                        dItem.startAngle = startAngle;
                        chartData[i].wedge = wedge;
                        if (startDuration > 0) {
                            if (!_this.chartCreated) {
                                wedge.setAttr('opacity', _this.startAlpha);
                            }
                        }

                        // x and y vectors
                        dItem.ix = ix;
                        dItem.iy = iy;
                        dItem.wedge = wedge;
                        dItem.index = i;

                        // LABEL ////////////////////////////////////////////////////////
                        if (_this.labelsEnabled && _this.labelText && dItem.percents >= _this.hideLabelsPercent) {
                            var labelAngle = startAngle + arc / 2;

                            if(labelAngle > 360){
                                labelAngle = labelAngle - 360;
                            }

                            var labelRadiusReal = labelRadius;
                            if (!isNaN(dItem.labelRadius)) {
                                labelRadiusReal = dItem.labelRadius;
                            }

                            var tx = pieX + ix * (radius + labelRadiusReal);
                            var ty = pieY + iy * (radius + labelRadiusReal);

                            var align;
                            var tickL = 0;
                            if (labelRadiusReal >= 0) {
                                var labelQuarter;
                                //q0
                                if (labelAngle <= 90 && labelAngle >= 0) {
                                    labelQuarter = 0;
                                    align = "start";
                                    tickL = 8;
                                }
                                //q1
                                else if (labelAngle >= 90 && labelAngle < 180) {
                                    labelQuarter = 1;
                                    align = "start";
                                    tickL = 8;
                                }
                                //q2
                                else if (labelAngle >= 180 && labelAngle < 270) {
                                    labelQuarter = 2;
                                    align = "end";
                                    tickL = -8;
                                }
                                //q3
                                else if ((labelAngle >= 270 && labelAngle < 360)) {
                                    labelQuarter = 3;
                                    align = "end";
                                    tickL = -8;
                                }

                                dItem.labelQuarter = labelQuarter;
                            } else {
                                align = "middle";
                            }

                            var text = _this.formatString(_this.labelText, dItem);

                            var labelColor = dItem.labelColor;
                            if (!labelColor) {
                                labelColor = _this.color;
                            }

                            var txt = AmCharts.text(container, text, labelColor, _this.fontFamily, _this.fontSize, align);
                            txt.translate(tx + tickL * 1.5, ty);
                            dItem.tx = tx + tickL * 1.5;
                            dItem.ty = ty;




                            if (labelRadiusReal >= 0) {
                                wedge.push(txt);
                            } else {
                                _this.freeLabelsSet.push(txt);
                            }
                            dItem.label = txt;
                            dItem.tx = tx;
                            dItem.tx2 = tx + tickL;

                            dItem.tx0 = pieX + ix * radius;
                            dItem.ty0 = pieY + iy * radius;


                        }
                        var rad = innerRadius + (radius - innerRadius) / 2;
                        if (dItem.pulled) {
                            rad += _this.pullOutRadiusReal;
                        }

                        dItem.balloonX = ix * rad + pieX;
                        dItem.balloonY = iy * rad + pieY;

                        dItem.startX = Math.round(ix * startRadius);
                        dItem.startY = Math.round(iy * startRadius);
                        dItem.pullX = Math.round(ix * pullOutRadiusReal);
                        dItem.pullY = Math.round(iy * pullOutRadiusReal);
                        _this.graphsSet.push(wedge);

                        if (dItem.alpha === 0 || (startDuration > 0 && !_this.chartCreated)) {
                            wedge.hide();
                        }

                        // get start angle of next slice
                        startAngle += dItem.percents * 360 / 100;
                    }
                }

                if (labelRadius > 0 && !_this.labelRadiusField) {
                    _this.arrangeLabels();
                }

                _this.pieXReal = pieX;
                _this.pieYReal = pieY;
                _this.radiusReal = radius;
                _this.innerRadiusReal = innerRadius;

                if (labelRadius > 0) {
                    _this.drawTicks();
                }

                _this.initialStart();

                _this.setDepths();
            }

            var legend = _this.legend;

            if (legend) {
                legend.invalidateSize();
            }
        } else {
            _this.cleanChart();
        }
        _this.dispDUpd();
        _this.chartCreated = true;
    },


    setDepths: function() {
        var chartData = this.chartData;
        var i;
        for (i = 0; i < chartData.length; i++) {
            var dItem = chartData[i];
            var wedge = dItem.wedge;
            var startAngle = dItem.startAngle;
            // find quarter
            //q0 || q1
            if ((startAngle >= 0 && startAngle < 180)) {
                wedge.toFront();
            }
            //q2 || q3
            else if ((startAngle >= 180)) {
                wedge.toBack();
            }
        }
    },



    arrangeLabels: function() {
        var _this = this;
        var chartData = _this.chartData;
        var count = chartData.length;
        var dItem;

        // q0
        var i;
        for (i = count - 1; i >= 0; i--) {
            dItem = chartData[i];
            if (dItem.labelQuarter === 0 && !dItem.hidden) {
                _this.checkOverlapping(i, dItem, 0, true, 0);
            }
        }
        // q1
        for (i = 0; i < count; i++) {
            dItem = chartData[i];
            if (dItem.labelQuarter == 1 && !dItem.hidden) {
                _this.checkOverlapping(i, dItem, 1, false, 0);
            }
        }
        // q2
        for (i = count - 1; i >= 0; i--) {
            dItem = chartData[i];
            if (dItem.labelQuarter == 2 && !dItem.hidden) {
                _this.checkOverlapping(i, dItem, 2, true, 0);
            }
        }
        // q3
        for (i = 0; i < count; i++) {
            dItem = chartData[i];

            if (dItem.labelQuarter == 3 && !dItem.hidden) {
                _this.checkOverlapping(i, dItem, 3, false, 0);
            }
        }
    },

    checkOverlapping: function(index, dItem, quarter, backwards, count) {
        var _this = this;
        var overlapping;
        var i;
        var chartData = _this.chartData;
        var length = chartData.length;
        var label = dItem.label;

        if (label) {
            if (backwards === true) {
                for (i = index + 1; i < length; i++) {
                    if (chartData[i].labelQuarter == quarter) {
                        overlapping = _this.checkOverlappingReal(dItem, chartData[i], quarter);
                        if (overlapping) {
                            i = length;
                        }
                    }
                }
            } else {
                for (i = index - 1; i >= 0; i--) {
                    if (chartData[i].labelQuarter == quarter) {
                        overlapping = _this.checkOverlappingReal(dItem, chartData[i], quarter);
                        if (overlapping) {
                            i = 0;
                        }
                    }
                }
            }

            if (overlapping === true && count < 100) {
                var newY = dItem.ty + (dItem.iy * 3);
                dItem.ty = newY;
                label.translate(dItem.tx2, newY);
                _this.checkOverlapping(index, dItem, quarter, backwards, count + 1);
            }
        }
    },

    checkOverlappingReal: function(dItem1, dItem2, quarter) {
        var overlapping = false;
        var label1 = dItem1.label;
        var label2 = dItem2.label;

        if (dItem1.labelQuarter == quarter && !dItem1.hidden && !dItem2.hidden && label2) {
            var bb1 = label1.getBBox();

            var bbox1 = {};
            bbox1.width = bb1.width;
            bbox1.height = bb1.height;
            bbox1.y = dItem1.ty;
            bbox1.x = dItem1.tx;


            var bb2 = label2.getBBox();
            var bbox2 = {};
            bbox2.width = bb2.width;
            bbox2.height = bb2.height;
            bbox2.y = dItem2.ty;
            bbox2.x = dItem2.tx;

            if (AmCharts.hitTest(bbox1, bbox2)) {
                overlapping = true;
            }
        }
        return overlapping;
    }

});// @tag amchart-static
AmCharts.AmXYChart = AmCharts.Class({

    inherits: AmCharts.AmRectangularChart,

    construct: function (theme) {
        var _this = this;
        _this.type = "xy";
        AmCharts.AmXYChart.base.construct.call(_this, theme);

        _this.cname = "AmXYChart";
        _this.theme = theme;
        _this.createEvents('zoomed');
        //_this.xAxes;
        //_this.yAxes;
        //_this.scrollbarV;
        //_this.scrollbarH;
        _this.maxZoomFactor = 20;
        //_this.hideXScrollbar;
        //_this.hideYScrollbar;
        AmCharts.applyTheme(_this, theme, _this.cname);
    },

    initChart: function () {
        var _this = this;
        AmCharts.AmXYChart.base.initChart.call(_this);
        if (_this.dataChanged) {
            _this.updateData();
            _this.dataChanged = false;
            _this.dispatchDataUpdated = true;
        }
        _this.updateScrollbar = true;
        _this.drawChart();

        if (_this.autoMargins && !_this.marginsUpdated) {
            _this.marginsUpdated = true;
            _this.measureMargins();
        }

        var marginLeftReal = _this.marginLeftReal;
        var marginTopReal = _this.marginTopReal;
        var plotAreaWidth = _this.plotAreaWidth;
        var plotAreaHeight = _this.plotAreaHeight;

        _this.graphsSet.clipRect(marginLeftReal, marginTopReal, plotAreaWidth, plotAreaHeight);
        _this.bulletSet.clipRect(marginLeftReal, marginTopReal, plotAreaWidth, plotAreaHeight);
        _this.trendLinesSet.clipRect(marginLeftReal, marginTopReal, plotAreaWidth, plotAreaHeight);
    },

    prepareForExport: function(){
        var _this = this;
        var obj = _this.bulletSet;
        if(obj.clipPath){
            _this.container.remove(obj.clipPath);
        }
    },


    createValueAxes: function () {
        var _this = this;
        var xAxes = [];
        var yAxes = [];
        _this.xAxes = xAxes;
        _this.yAxes = yAxes;

        // sort axes
        var valueAxes = _this.valueAxes;
        var valueAxis;
        var i;

        for (i = 0; i < valueAxes.length; i++) {
            valueAxis = valueAxes[i];
            var position = valueAxis.position;

            if (position == "top" || position == "bottom") {
                valueAxis.rotate = true;
            }

            valueAxis.setOrientation(valueAxis.rotate);

            var orientation = valueAxis.orientation;
            if (orientation == "V") {
                yAxes.push(valueAxis);
            }

            if (orientation == "H") {
                xAxes.push(valueAxis);
            }
        }
        // create one vertical and horizontal value axis if not found any
        if (yAxes.length === 0) {
            valueAxis = new AmCharts.ValueAxis(_this.theme);
            valueAxis.rotate = false;
            valueAxis.setOrientation(false);
            valueAxes.push(valueAxis);
            yAxes.push(valueAxis);
        }

        if (xAxes.length === 0) {
            valueAxis = new AmCharts.ValueAxis(_this.theme);
            valueAxis.rotate = true;
            valueAxis.setOrientation(true);
            valueAxes.push(valueAxis);
            xAxes.push(valueAxis);
        }

        for (i = 0; i < valueAxes.length; i++) {
            _this.processValueAxis(valueAxes[i], i);
        }

        var graphs = _this.graphs;
        for (i = 0; i < graphs.length; i++) {
            _this.processGraph(graphs[i], i);
        }
    },

    drawChart: function () {
        var _this = this;
        AmCharts.AmXYChart.base.drawChart.call(_this);

        var chartData = _this.chartData;

        if (AmCharts.ifArray(chartData)) {
            if (_this.chartScrollbar) {
                _this.updateScrollbars();
            }

            _this.zoomChart();
        } else {
            _this.cleanChart();
        }

        if (_this.hideXScrollbar) {
            var scrollbarH = _this.scrollbarH;
            if (scrollbarH) {
                _this.removeListener(scrollbarH, "zoomed", _this.handleHSBZoom);
                scrollbarH.destroy();
            }
            _this.scrollbarH = null;
        }


        if (_this.hideYScrollbar) {
            var scrollbarV = _this.scrollbarV;
            if (scrollbarV) {
                _this.removeListener(scrollbarV, "zoomed", _this.handleVSBZoom);
                scrollbarV.destroy();
            }
            _this.scrollbarV = null;
        }

        if (_this.autoMargins && !_this.marginsUpdated) {
            // void
        } else {
            _this.dispDUpd();
            _this.chartCreated = true;
            _this.zoomScrollbars();
        }

    },

    cleanChart: function () {
        var _this = this;
        AmCharts.callMethod("destroy", [_this.valueAxes, _this.graphs, _this.scrollbarV, _this.scrollbarH, _this.chartCursor]);
    },

    zoomChart: function () {
        var _this = this;
        _this.toggleZoomOutButton();
        _this.zoomObjects(_this.valueAxes);
        _this.zoomObjects(_this.graphs);
        _this.zoomTrendLines();
        _this.dispatchAxisZoom();
    },

    toggleZoomOutButton: function () {
        var _this = this;
        if (_this.heightMultiplier == 1 && _this.widthMultiplier == 1) {
            _this.showZB(false);
        } else {
            _this.showZB(true);
        }
    },

    dispatchAxisZoom: function () {
        var _this = this;
        var valueAxes = _this.valueAxes;
        var i;
        for (i = 0; i < valueAxes.length; i++) {
            var valueAxis = valueAxes[i];

            if (!isNaN(valueAxis.min) && !isNaN(valueAxis.max)) {
                var startValue;
                var endValue;

                if (valueAxis.orientation == "V") {
                    startValue = valueAxis.coordinateToValue(-_this.verticalPosition);
                    endValue = valueAxis.coordinateToValue(-_this.verticalPosition + _this.plotAreaHeight);
                } else {
                    startValue = valueAxis.coordinateToValue(-_this.horizontalPosition);
                    endValue = valueAxis.coordinateToValue(-_this.horizontalPosition + _this.plotAreaWidth);
                }

                if (!isNaN(startValue) && !isNaN(endValue)) {
                    if (startValue > endValue) {
                        var temp = endValue;
                        endValue = startValue;
                        startValue = temp;
                    }

                    valueAxis.dispatchZoomEvent(startValue, endValue);
                }
            }
        }
    },

    zoomObjects: function (objects) {
        var _this = this;
        var count = objects.length;
        var i;
        for (i = 0; i < count; i++) {
            var obj = objects[i];
            _this.updateObjectSize(obj);
            obj.zoom(0, _this.chartData.length - 1);
        }
    },

    updateData: function () {
        var _this = this;
        _this.parseData();
        var chartData = _this.chartData;
        var lastIndex = chartData.length - 1;
        var graphs = _this.graphs;
        var dataProvider = _this.dataProvider;

        var maxValue = -Infinity;
        var minValue = Infinity;
        var i;
        var graph;

        for (i = 0; i < graphs.length; i++) {
            graph = graphs[i];
            graph.data = chartData;
            graph.zoom(0, lastIndex);

            var valueField = graph.valueField;

            if (valueField) {
                var j;
                for (j = 0; j < dataProvider.length; j++) {
                    var value = Number(dataProvider[j][valueField]);
                    if (value > maxValue) {
                        maxValue = value;
                    }
                    if (value < minValue) {
                        minValue = value;
                    }
                }
            }
        }

        for (i = 0; i < graphs.length; i++) {
            graph = graphs[i];
            graph.maxValue = maxValue;
            graph.minValue = minValue;
        }


        var chartCursor = _this.chartCursor;
        if (chartCursor) {
            chartCursor.updateData();
            chartCursor.type = "crosshair";
            chartCursor.valueBalloonsEnabled = false;
        }
    },


    zoomOut: function () {
        var _this = this;
        _this.horizontalPosition = 0;
        _this.verticalPosition = 0;
        _this.widthMultiplier = 1;
        _this.heightMultiplier = 1;

        _this.zoomChart();
        _this.zoomScrollbars();
    },


    processValueAxis: function (valueAxis) {
        var _this = this;
        valueAxis.chart = this;

        if (valueAxis.orientation == "H") {
            valueAxis.minMaxField = "x";
        } else {
            valueAxis.minMaxField = "y";
        }

        valueAxis.minTemp = NaN;
        valueAxis.maxTemp = NaN;

        _this.listenTo(valueAxis, "axisSelfZoomed", _this.handleAxisSelfZoom);
    },

    processGraph: function (graph) {
        var _this = this;

        if(AmCharts.isString(graph.xAxis)){
            graph.xAxis = _this.getValueAxisById(graph.xAxis);
        }

        if(AmCharts.isString(graph.yAxis)){
            graph.yAxis = _this.getValueAxisById(graph.yAxis);
        }

        if (!graph.xAxis) {
            graph.xAxis = _this.xAxes[0];
        }
        if (!graph.yAxis) {
            graph.yAxis = _this.yAxes[0];
        }
        graph.valueAxis = graph.yAxis;
    },


    parseData: function () {
        var _this = this;
        AmCharts.AmXYChart.base.parseData.call(_this);

        _this.chartData = [];
        var dataProvider = _this.dataProvider;
        var valueAxes = _this.valueAxes;
        var graphs = _this.graphs;
        var i;
        for (i = 0; i < dataProvider.length; i++) {
            var serialDataItem = {};
            serialDataItem.axes = {};
            serialDataItem.x = {};
            serialDataItem.y = {};

            var dataItemRaw = dataProvider[i];
            var j;
            for (j = 0; j < valueAxes.length; j++) {
                // axis
                var axisId = valueAxes[j].id;

                serialDataItem.axes[axisId] = {};
                serialDataItem.axes[axisId].graphs = {};
                var k;
                for (k = 0; k < graphs.length; k++) {
                    var graph = graphs[k];
                    var graphId = graph.id;

                    if (graph.xAxis.id == axisId || graph.yAxis.id == axisId) {
                        var graphDataItem = {};
                        graphDataItem.serialDataItem = serialDataItem;
                        graphDataItem.index = i;

                        var values = {};

                        var val = Number(dataItemRaw[graph.valueField]);
                        if (!isNaN(val)) {
                            values.value = val;
                        }
                        val = Number(dataItemRaw[graph.xField]);
                        if (!isNaN(val)) {
                            values.x = val;
                        }
                        val = Number(dataItemRaw[graph.yField]);
                        if (!isNaN(val)) {
                            values.y = val;
                        }
                        val = Number(dataItemRaw[graph.errorField]);
                        if (!isNaN(val)) {
                            values.error = val;
                        }

                        graphDataItem.values = values;

                        _this.processFields(graph, graphDataItem, dataItemRaw);

                        graphDataItem.serialDataItem = serialDataItem;
                        graphDataItem.graph = graph;

                        serialDataItem.axes[axisId].graphs[graphId] = graphDataItem;
                    }
                }
            }
            _this.chartData[i] = serialDataItem;
        }
    },


    formatString: function (text, dItem, noFixBrakes) {
        var _this = this;
        var graph = dItem.graph;
        var numberFormatter = graph.numberFormatter;
        if (!numberFormatter) {
            numberFormatter = _this.nf;
        }

        var keys = ["value", "x", "y"];
        text = AmCharts.formatValue(text, dItem.values, keys, numberFormatter);

        if (text.indexOf("[[") != -1) {
            text = AmCharts.formatDataContextValue(text, dItem.dataContext);
        }

        text = AmCharts.AmXYChart.base.formatString.call(_this, text, dItem, noFixBrakes);
        return text;
    },

    addChartScrollbar: function (chartScrollbar) {
        var _this = this;
        AmCharts.callMethod("destroy", [_this.chartScrollbar, _this.scrollbarH, _this.scrollbarV]);

        if (chartScrollbar) {
            _this.chartScrollbar = chartScrollbar;
            _this.scrollbarHeight = chartScrollbar.scrollbarHeight;

            var properties = ["backgroundColor",
                "backgroundAlpha",
                "selectedBackgroundColor",
                "selectedBackgroundAlpha",
                "scrollDuration",
                "resizeEnabled",
                "hideResizeGrips",
                "scrollbarHeight",
                "updateOnReleaseOnly"];

            if (!_this.hideYScrollbar) {
                var scrollbarV = new AmCharts.SimpleChartScrollbar(_this.theme);
                scrollbarV.skipEvent = true;
                scrollbarV.chart = this;
                _this.listenTo(scrollbarV, "zoomed", _this.handleVSBZoom);
                AmCharts.copyProperties(chartScrollbar, scrollbarV, properties);
                scrollbarV.rotate = true;
                _this.scrollbarV = scrollbarV;
            }

            if (!_this.hideXScrollbar) {
                var scrollbarH = new AmCharts.SimpleChartScrollbar(_this.theme);
                scrollbarH.skipEvent = true;
                scrollbarH.chart = this;
                _this.listenTo(scrollbarH, "zoomed", _this.handleHSBZoom);
                AmCharts.copyProperties(chartScrollbar, scrollbarH, properties);
                scrollbarH.rotate = false;
                _this.scrollbarH = scrollbarH;
            }
        }
    },


    updateTrendLines: function () {
        var _this = this;
        var trendLines = _this.trendLines;
        var i;
        for (i = 0; i < trendLines.length; i++) {
            var trendLine = trendLines[i];
            trendLine = AmCharts.processObject(trendLine, AmCharts.TrendLine, _this.theme);
            trendLines[i] = trendLine;
            trendLine.chart = this;

            var valueAxis = trendLine.valueAxis;
            if(AmCharts.isString(valueAxis)){
                trendLine.valueAxis = _this.getValueAxisById(valueAxis);
            }

            var valueAxisX = trendLine.valueAxisX;
            if(AmCharts.isString(valueAxisX)){
                trendLine.valueAxisX = _this.getValueAxisById(valueAxisX);
            }

            if (!trendLine.valueAxis) {
                trendLine.valueAxis = _this.yAxes[0];
            }
            if (!trendLine.valueAxisX) {
                trendLine.valueAxisX = _this.xAxes[0];
            }
        }
    },


    updateMargins: function () {
        var _this = this;
        AmCharts.AmXYChart.base.updateMargins.call(_this);

        var scrollbarV = _this.scrollbarV;
        if (scrollbarV) {
            _this.getScrollbarPosition(scrollbarV, true, _this.yAxes[0].position);
            _this.adjustMargins(scrollbarV, true);
        }

        var scrollbarH = _this.scrollbarH;
        if (scrollbarH) {
            _this.getScrollbarPosition(scrollbarH, false, _this.xAxes[0].position);
            _this.adjustMargins(scrollbarH, false);
        }
    },

    updateScrollbars: function () {
        var _this = this;
        AmCharts.AmXYChart.base.updateScrollbars.call(_this);
        var scrollbarV = _this.scrollbarV;
        if (scrollbarV) {
            _this.updateChartScrollbar(scrollbarV, true);
            scrollbarV.draw();
        }
        var scrollbarH = _this.scrollbarH;
        if (scrollbarH) {
            _this.updateChartScrollbar(scrollbarH, false);
            scrollbarH.draw();
        }
    },

    zoomScrollbars: function () {
        var _this = this;
        var scrollbarH = _this.scrollbarH;
        if (scrollbarH) {
            scrollbarH.relativeZoom(_this.widthMultiplier, -_this.horizontalPosition / _this.widthMultiplier);
        }

        var scrollbarV = _this.scrollbarV;
        if (scrollbarV) {
            scrollbarV.relativeZoom(_this.heightMultiplier, -_this.verticalPosition / _this.heightMultiplier);
        }
    },


    fitMultiplier: function (multiplier) {
        var _this = this;
        if (multiplier > _this.maxZoomFactor) {
            multiplier = _this.maxZoomFactor;
        }
        return multiplier;
    },

    handleHSBZoom: function (event) {
        var _this = this;
        var widthMultiplier = _this.fitMultiplier(event.multiplier);
        var horizontalPosition = -event.position * widthMultiplier;
        var horizontalMax = -(_this.plotAreaWidth * widthMultiplier - _this.plotAreaWidth);

        if (horizontalPosition < horizontalMax) {
            horizontalPosition = horizontalMax;
        }

        _this.widthMultiplier = widthMultiplier;
        _this.horizontalPosition = horizontalPosition;

        _this.zoomChart();
    },

    handleVSBZoom: function (event) {
        var _this = this;
        var heightMultiplier = _this.fitMultiplier(event.multiplier);
        var verticalPosition = -event.position * heightMultiplier;
        var verticalMax = -(_this.plotAreaHeight * heightMultiplier - _this.plotAreaHeight);

        if (verticalPosition < verticalMax) {
            verticalPosition = verticalMax;
        }
        _this.heightMultiplier = heightMultiplier;
        _this.verticalPosition = verticalPosition;

        _this.zoomChart();
    },


    handleAxisSelfZoom: function (event) {
        var _this = this;
        var valueAxis = event.valueAxis;

        if (valueAxis.orientation == "H") {
            var widthMultiplier = _this.fitMultiplier(event.multiplier);
            var horizontalPosition = -event.position * widthMultiplier;
            var horizontalMax = -(_this.plotAreaWidth * widthMultiplier - _this.plotAreaWidth);

            if (horizontalPosition < horizontalMax) {
                horizontalPosition = horizontalMax;
            }
            _this.horizontalPosition = horizontalPosition;
            _this.widthMultiplier = widthMultiplier;
            _this.zoomChart();
        } else {
            var heightMultiplier = _this.fitMultiplier(event.multiplier);

            var verticalPosition = -event.position * heightMultiplier;

            var verticalMax = -(_this.plotAreaHeight * heightMultiplier - _this.plotAreaHeight);

            if (verticalPosition < verticalMax) {
                verticalPosition = verticalMax;
            }
            _this.verticalPosition = verticalPosition;
            _this.heightMultiplier = heightMultiplier;
            _this.zoomChart();
        }
        var graphs = _this.graphs;
        for (var i = 0; i < graphs.length; i++) {
            graphs[i].setAnimationPlayed();
        }

        _this.zoomScrollbars();
    },

    handleCursorZoom: function (event) {
        var _this = this;
        var widthMultiplier = (_this.widthMultiplier * _this.plotAreaWidth) / event.selectionWidth;
        var heightMultiplier = (_this.heightMultiplier * _this.plotAreaHeight) / event.selectionHeight;

        widthMultiplier = _this.fitMultiplier(widthMultiplier);
        heightMultiplier = _this.fitMultiplier(heightMultiplier);

        _this.horizontalPosition = (_this.horizontalPosition - event.selectionX) * widthMultiplier / _this.widthMultiplier;
        _this.verticalPosition = (_this.verticalPosition - event.selectionY) * heightMultiplier / _this.heightMultiplier;

        _this.widthMultiplier = widthMultiplier;
        _this.heightMultiplier = heightMultiplier;

        _this.zoomChart();
        _this.zoomScrollbars();
    },


    removeChartScrollbar: function () {
        var _this = this;
        AmCharts.callMethod("destroy", [_this.scrollbarH, _this.scrollbarV]);
        _this.scrollbarH = null;
        _this.scrollbarV = null;
    },

    handleReleaseOutside: function (e) {
        var _this = this;
        AmCharts.AmXYChart.base.handleReleaseOutside.call(_this, e);
        AmCharts.callMethod("handleReleaseOutside", [_this.scrollbarH, _this.scrollbarV]);
    }
});// @tag amchart-static
AmCharts.AmSerialChart = AmCharts.Class({

    inherits: AmCharts.AmRectangularChart,

    construct: function (theme) {
        var _this = this;
        _this.type = "serial";
        AmCharts.AmSerialChart.base.construct.call(_this, theme);
        _this.cname = "AmSerialChart";

        _this.theme = theme;

        _this.createEvents('changed');

        _this.columnSpacing = 5;
        _this.columnSpacing3D = 0;
        _this.columnWidth = 0.8;
        _this.updateScrollbar = true;

        var categoryAxis = new AmCharts.CategoryAxis(theme);
        categoryAxis.chart = this;
        _this.categoryAxis = categoryAxis;


        _this.zoomOutOnDataUpdate = true;
        _this.skipZoom = false;
        _this.rotate = false;

        _this.mouseWheelScrollEnabled = false;

        // _this.maxSelectedSeries;
        // _this.maxSelectedTime;
        _this.minSelectedTime = 0;

        AmCharts.applyTheme(_this, theme, _this.cname);
    },

    initChart: function () {
        var _this = this;
        AmCharts.AmSerialChart.base.initChart.call(_this);

        _this.updateCategoryAxis(_this.categoryAxis, _this.rotate, "categoryAxis");

        if (_this.dataChanged) {
            _this.updateData();
            _this.dataChanged = false;
            _this.dispatchDataUpdated = true;
        }

        var chartCursor = _this.chartCursor;
        if (chartCursor) {
            chartCursor.updateData();

            // rectangle behind graphs
            if(chartCursor.fullWidth){
                chartCursor.fullRectSet = _this.cursorLineSet;
            }
        }

        var columnCount = _this.countColumns();

        var graphs = _this.graphs;
        var i;
        for (i = 0; i < graphs.length; i++) {
            var graph = graphs[i];
            graph.columnCount = columnCount;
        }

        _this.updateScrollbar = true;
        _this.drawChart();

        if (_this.autoMargins && !_this.marginsUpdated) {
            _this.marginsUpdated = true;
            _this.measureMargins();
        }

        if (_this.mouseWheelScrollEnabled) {
            _this.addMouseWheel();
        }
    },


    handleWheelReal: function (delta, shift) {

        var _this = this;

        if (!_this.wheelBusy) {
            var categoryAxis = _this.categoryAxis;
            var parseDates = categoryAxis.parseDates;
            var minDuration = categoryAxis.minDuration();

            var startSign = 1;
            var endSign = 1;

            if(shift){
                startSign = - 1;
            }

            if(delta < 0){
                if(parseDates){
                    if(_this.endTime < _this.lastTime){
                        _this.zoomToDates(new Date(_this.startTime + startSign * minDuration), new Date(_this.endTime + endSign * minDuration));
                    }
                }
                else{
                    if(_this.end < _this.chartData.length - 1){
                        _this.zoomToIndexes(_this.start + startSign, _this.end + endSign);
                    }
                }
            }
            else{
                if(parseDates){
                    if(_this.startTime > _this.firstTime){
                        _this.zoomToDates(new Date(_this.startTime - startSign * minDuration), new Date(_this.endTime - endSign * minDuration));
                    }
                }
                else{
                    if(_this.start > 0){
                        _this.zoomToIndexes(_this.start - startSign, _this.end - endSign);
                    }
                }
            }
        }
    },


    validateData: function (resetZoom) {
        var _this = this;

        _this.marginsUpdated = false;
        if (_this.zoomOutOnDataUpdate && !resetZoom) {
            _this.start = NaN;
            _this.startTime = NaN;
            _this.end = NaN;
            _this.endTime = NaN;
        }

        AmCharts.AmSerialChart.base.validateData.call(_this);
    },


    drawChart: function () {
        var _this = this;
        AmCharts.AmSerialChart.base.drawChart.call(_this);

        var chartData = _this.chartData;

        if (AmCharts.ifArray(chartData)) {

            var chartScrollbar = _this.chartScrollbar;
            if (chartScrollbar) {
                chartScrollbar.draw();
            }

            if (_this.realWidth > 0 && _this.realHeight > 0) {
                // zoom
                var last = chartData.length - 1;
                var start;
                var end;

                var categoryAxis = _this.categoryAxis;
                if (categoryAxis.parseDates && !categoryAxis.equalSpacing) {
                    start = _this.startTime;
                    end = _this.endTime;

                    if (isNaN(start) || isNaN(end)) {
                        start = _this.firstTime;
                        end = _this.lastTime;
                    }
                } else {
                    start = _this.start;
                    end = _this.end;

                    if (isNaN(start) || isNaN(end)) {
                        start = 0;
                        end = last;
                    }
                }

                _this.start = undefined;
                _this.end = undefined;
                _this.startTime = undefined;
                _this.endTime = undefined;
                _this.zoom(start, end);
            }

        } else {
            _this.cleanChart();
        }
        _this.dispDUpd();
        _this.chartCreated = true;
    },

    cleanChart: function () {
        var _this = this;
        AmCharts.callMethod("destroy", [_this.valueAxes, _this.graphs, _this.categoryAxis, _this.chartScrollbar, _this.chartCursor]);
    },


    updateCategoryAxis: function (categoryAxis, rotate, id) {
        var _this = this;

        categoryAxis.chart = this;
        categoryAxis.id = id;
        categoryAxis.rotate = rotate;
        categoryAxis.axisRenderer = AmCharts.RecAxis;
        categoryAxis.guideFillRenderer = AmCharts.RecFill;
        categoryAxis.axisItemRenderer = AmCharts.RecItem;
        categoryAxis.setOrientation(!_this.rotate);
        categoryAxis.x = _this.marginLeftReal;
        categoryAxis.y = _this.marginTopReal;
        categoryAxis.dx = _this.dx;
        categoryAxis.dy = _this.dy;
        categoryAxis.width = _this.plotAreaWidth - 1;
        categoryAxis.height = _this.plotAreaHeight - 1;
        categoryAxis.viW = _this.plotAreaWidth - 1;
        categoryAxis.viH = _this.plotAreaHeight - 1;
        categoryAxis.viX = _this.marginLeftReal;
        categoryAxis.viY = _this.marginTopReal;
        categoryAxis.marginsChanged = true;
    },

    updateValueAxes: function () {
        var _this = this;
        AmCharts.AmSerialChart.base.updateValueAxes.call(_this);

        var valueAxes = _this.valueAxes;
        var i;
        for (i = 0; i < valueAxes.length; i++) {
            var valueAxis = valueAxes[i];
            var rotate = _this.rotate;
            valueAxis.rotate = rotate;
            valueAxis.setOrientation(rotate);

            var categoryAxis = _this.categoryAxis;

            if (!categoryAxis.startOnAxis || categoryAxis.parseDates) {
                valueAxis.expandMinMax = true;
            }
        }
    },

    updateData: function () {
        var _this = this;

        _this.parseData();
        var graphs = _this.graphs;
        var i;
        var chartData = _this.chartData;
        for (i = 0; i < graphs.length; i++) {
            var graph = graphs[i];
            graph.data = chartData;
        }
        if (chartData.length > 0) {
            _this.firstTime = _this.getStartTime(chartData[0].time);
            _this.lastTime = _this.getEndTime(chartData[chartData.length - 1].time);
        }
    },


    getStartTime: function (time) {
        var _this = this;
        var categoryAxis = _this.categoryAxis;

        return AmCharts.resetDateToMin(new Date(time), categoryAxis.minPeriod, 1, categoryAxis.firstDayOfWeek).getTime();
    },

    getEndTime: function (time) {
        var _this = this;
        var categoryAxis = _this.categoryAxis;
        var minPeriodObj = AmCharts.extractPeriod(categoryAxis.minPeriod);
        return AmCharts.changeDate(new Date(time), minPeriodObj.period, minPeriodObj.count, true).getTime() - 1;
    },

    updateMargins: function () {
        var _this = this;
        AmCharts.AmSerialChart.base.updateMargins.call(_this);

        var scrollbar = _this.chartScrollbar;

        if (scrollbar) {
            _this.getScrollbarPosition(scrollbar, _this.rotate, _this.categoryAxis.position);
            _this.adjustMargins(scrollbar, _this.rotate);
        }
    },

    updateScrollbars: function () {
        var _this = this;
        AmCharts.AmSerialChart.base.updateScrollbars.call(_this);
        _this.updateChartScrollbar(_this.chartScrollbar, _this.rotate);
    },


    zoom: function (start, end) {
        var _this = this;
        var categoryAxis = _this.categoryAxis;

        if (categoryAxis.parseDates && !categoryAxis.equalSpacing) {
            _this.timeZoom(start, end);
        } else {
            _this.indexZoom(start, end);
        }

        _this.updateLegendValues();
    },


    timeZoom: function (startTime, endTime) {
        var _this = this;
        var maxSelectedTime = _this.maxSelectedTime;
        if (!isNaN(maxSelectedTime)) {
            if (endTime != _this.endTime) {
                if (endTime - startTime > maxSelectedTime) {
                    startTime = endTime - maxSelectedTime;
                    _this.updateScrollbar = true;
                }
            }

            if (startTime != _this.startTime) {
                if (endTime - startTime > maxSelectedTime) {
                    endTime = startTime + maxSelectedTime;
                    _this.updateScrollbar = true;
                }
            }
        }

        var minSelectedTime = _this.minSelectedTime;
        if (minSelectedTime > 0 && endTime - startTime < minSelectedTime) {
            var middleTime = Math.round(startTime + (endTime - startTime) / 2);
            var delta = Math.round(minSelectedTime / 2);
            startTime = middleTime - delta;
            endTime = middleTime + delta;
        }

        var chartData = _this.chartData;
        var categoryAxis = _this.categoryAxis;

        if (AmCharts.ifArray(chartData)) {
            if (startTime != _this.startTime || endTime != _this.endTime) {
                // check whether start and end time is not the same (or the difference is less then the duration of the shortest period)
                var minDuration = categoryAxis.minDuration();

                var firstTime = _this.firstTime;
                var lastTime = _this.lastTime;

                if (!startTime) {
                    startTime = firstTime;
                    if (!isNaN(maxSelectedTime)) {
                        startTime = lastTime - maxSelectedTime;
                    }
                }

                if (!endTime) {
                    endTime = lastTime;
                }

                if (startTime > lastTime) {
                    startTime = lastTime;
                }

                if (endTime < firstTime) {
                    endTime = firstTime;
                }

                if (startTime < firstTime) {
                    startTime = firstTime;
                }

                if (endTime > lastTime) {
                    endTime = lastTime;
                }

                if (endTime < startTime) {
                    endTime = startTime + minDuration;
                }

                if (endTime - startTime < minDuration / 5) {
                    if (endTime < lastTime) {
                        endTime = startTime + minDuration / 5;
                    } else {
                        startTime = endTime - minDuration / 5;
                    }

                }

                _this.startTime = startTime;
                _this.endTime = endTime;

                var lastIndex = chartData.length - 1;
                var start = _this.getClosestIndex(chartData, "time", startTime, true, 0, lastIndex);
                var end = _this.getClosestIndex(chartData, "time", endTime, false, start, lastIndex);

                categoryAxis.timeZoom(startTime, endTime);
                categoryAxis.zoom(start, end);

                _this.start = AmCharts.fitToBounds(start, 0, lastIndex);
                _this.end = AmCharts.fitToBounds(end, 0, lastIndex);

                _this.zoomAxesAndGraphs();
                _this.zoomScrollbar();

                if (startTime != firstTime || endTime != lastTime) {
                    _this.showZB(true);
                } else {
                    _this.showZB(false);
                }

                _this.updateColumnsDepth();
                _this.dispatchTimeZoomEvent();
            }
        }
    },

    indexZoom: function (start, end) {
        var _this = this;
        var maxSelectedSeries = _this.maxSelectedSeries;
        if (!isNaN(maxSelectedSeries)) {
            if (end != _this.end) {
                if (end - start > maxSelectedSeries) {
                    start = end - maxSelectedSeries;
                    _this.updateScrollbar = true;
                }
            }

            if (start != _this.start) {
                if (end - start > maxSelectedSeries) {
                    end = start + maxSelectedSeries;
                    _this.updateScrollbar = true;
                }
            }
        }

        if (start != _this.start || end != _this.end) {
            var last = _this.chartData.length - 1;

            if (isNaN(start)) {
                start = 0;

                if (!isNaN(maxSelectedSeries)) {
                    start = last - maxSelectedSeries;
                }
            }

            if (isNaN(end)) {
                end = last;
            }

            if (end < start) {
                end = start;
            }

            if (end > last) {
                end = last;
            }

            if (start > last) {
                start = last - 1;
            }

            if (start < 0) {
                start = 0;
            }

            _this.start = start;
            _this.end = end;

            _this.categoryAxis.zoom(start, end);
            _this.zoomAxesAndGraphs();

            _this.zoomScrollbar();

            if (start !== 0 || end != _this.chartData.length - 1) {
                _this.showZB(true);
            } else {
                _this.showZB(false);
            }
            _this.updateColumnsDepth();
            _this.dispatchIndexZoomEvent();
        }
    },

    updateGraphs: function () {
        var _this = this;
        AmCharts.AmSerialChart.base.updateGraphs.call(_this);

        var graphs = _this.graphs;
        var i;
        for (i = 0; i < graphs.length; i++) {
            var graph = graphs[i];
            graph.columnWidthReal = _this.columnWidth;
            graph.categoryAxis = _this.categoryAxis;

            if(AmCharts.isString(graph.fillToGraph)){
                graph.fillToGraph = _this.getGraphById(graph.fillToGraph);
            }
        }
    },


    updateColumnsDepth: function () {
        var _this = this;
        var i;
        var graphs = _this.graphs;
        var graph;
        AmCharts.remove(_this.columnsSet);
        _this.columnsArray = [];

        for (i = 0; i < graphs.length; i++) {
            graph = graphs[i];

            var graphColumnsArray = graph.columnsArray;

            if (graphColumnsArray) {
                var j;
                for (j = 0; j < graphColumnsArray.length; j++) {
                    _this.columnsArray.push(graphColumnsArray[j]);
                }
            }
        }

        _this.columnsArray.sort(_this.compareDepth);

        var count = _this.columnsArray.length;
        if (count > 0) {
            var columnsSet = _this.container.set();
            _this.columnSet.push(columnsSet);

            for (i = 0; i < _this.columnsArray.length; i++) {
                columnsSet.push(_this.columnsArray[i].column.set);
            }

            if (graph) {
                columnsSet.translate(graph.x, graph.y);
            }

            _this.columnsSet = columnsSet;
        }
    },

    compareDepth: function (a, b) {
        if (a.depth > b.depth) {
            return 1;
        } else {
            return -1;
        }
    },

    zoomScrollbar: function () {
        var _this = this;
        var chartScrollbar = _this.chartScrollbar;
        var categoryAxis = _this.categoryAxis;
        if (chartScrollbar) {
            if (_this.updateScrollbar) {
                if (categoryAxis.parseDates && !categoryAxis.equalSpacing) {
                    chartScrollbar.timeZoom(_this.startTime, _this.endTime);
                } else {
                    chartScrollbar.zoom(_this.start, _this.end);
                }
                _this.updateScrollbar = true;
            }
        }
    },

    updateTrendLines: function () {
        var _this = this;

        var trendLines = _this.trendLines;
        var i;
        for (i = 0; i < trendLines.length; i++) {
            var trendLine = trendLines[i];
            trendLine = AmCharts.processObject(trendLine, AmCharts.TrendLine, _this.theme);
            trendLines[i] = trendLine;
            trendLine.chart = this;


            if(AmCharts.isString(trendLine.valueAxis)){
                trendLine.valueAxis = _this.getValueAxisById(trendLine.valueAxis);
            }

            if (!trendLine.valueAxis) {
                trendLine.valueAxis = _this.valueAxes[0];
            }
            trendLine.categoryAxis = _this.categoryAxis;
        }
    },


    zoomAxesAndGraphs: function () {
        var _this = this;
        if (!_this.scrollbarOnly) {
            var valueAxes = _this.valueAxes;
            var i;
            for (i = 0; i < valueAxes.length; i++) {
                var valueAxis = valueAxes[i];
                valueAxis.zoom(_this.start, _this.end);
            }

            var graphs = _this.graphs;
            for (i = 0; i < graphs.length; i++) {
                var graph = graphs[i];
                graph.zoom(_this.start, _this.end);
            }

            _this.zoomTrendLines();

            var chartCursor = _this.chartCursor;
            if (chartCursor) {
                chartCursor.zoom(_this.start, _this.end, _this.startTime, _this.endTime);
            }
        }
    },

    countColumns: function () {
        var _this = this;
        var count = 0;

        var axisCount = _this.valueAxes.length;
        var graphCount = _this.graphs.length;
        var graph;
        var axis;
        var counted = false;

        var j;
        var i;
        for (i = 0; i < axisCount; i++) {
            axis = _this.valueAxes[i];
            var stackType = axis.stackType;

            if (stackType == "100%" || stackType == "regular") {
                counted = false;
                for (j = 0; j < graphCount; j++) {
                    graph = _this.graphs[j];
                    if (!graph.hidden) {
                        if (graph.valueAxis == axis && graph.type == "column") {
                            if (!counted && graph.stackable) {
                                count++;
                                counted = true;
                            }

                            if ((!graph.stackable && graph.clustered) || graph.newStack) {
                                count++;
                            }

                            graph.columnIndex = count - 1;

                            if (!graph.clustered) {
                                graph.columnIndex = 0;
                            }
                        }
                    }
                }
            }

            if (stackType == "none" || stackType == "3d") {
                for (j = 0; j < graphCount; j++) {
                    graph = _this.graphs[j];
                    if (!graph.hidden) {
                        if (graph.valueAxis == axis && graph.type == "column" && graph.clustered) {
                            graph.columnIndex = count;
                            count++;
                        }
                    }
                }
            }
            if (stackType == "3d") {
                for (i = 0; i < graphCount; i++) {
                    graph = _this.graphs[i];
                    graph.depthCount = count;
                }
                count = 1;
            }
        }
        return count;
    },


    parseData: function () {
        var _this = this;
        AmCharts.AmSerialChart.base.parseData.call(_this);
        _this.parseSerialData();
    },

    getCategoryIndexByValue: function (value) {
        var _this = this;
        var chartData = _this.chartData;
        var index;
        var i;
        for (i = 0; i < chartData.length; i++) {
            if (chartData[i].category == value) {
                index = i;
            }
        }
        return index;
    },

    handleCursorChange: function (event) {
        this.updateLegendValues(event.index);
    },

    handleCursorZoom: function (event) {
        var _this = this;
        _this.updateScrollbar = true;
        _this.zoom(event.start, event.end);
    },

    handleScrollbarZoom: function (event) {
        var _this = this;
        _this.updateScrollbar = false;
        _this.zoom(event.start, event.end);
    },

    dispatchTimeZoomEvent: function () {
        var _this = this;
        if (_this.prevStartTime != _this.startTime || _this.prevEndTime != _this.endTime) {
            var e = {};
            e.type = "zoomed";
            e.startDate = new Date(_this.startTime);
            e.endDate = new Date(_this.endTime);
            e.startIndex = _this.start;
            e.endIndex = _this.end;
            _this.startIndex = _this.start;
            _this.endIndex = _this.end;
            _this.startDate = e.startDate;
            _this.endDate = e.endDate;

            _this.prevStartTime = _this.startTime;
            _this.prevEndTime = _this.endTime;
            var categoryAxis = _this.categoryAxis;

            var minPeriod = AmCharts.extractPeriod(categoryAxis.minPeriod).period;
            var dateFormat = categoryAxis.dateFormatsObject[minPeriod];

            e.startValue = AmCharts.formatDate(e.startDate, dateFormat);
            e.endValue = AmCharts.formatDate(e.endDate, dateFormat);
            e.chart = _this;
            e.target = _this;
            _this.fire(e.type, e);
        }
    },

    dispatchIndexZoomEvent: function () {
        var _this = this;
        if (_this.prevStartIndex != _this.start || _this.prevEndIndex != _this.end) {
            _this.startIndex = _this.start;
            _this.endIndex = _this.end;
            var chartData = _this.chartData;
            if (AmCharts.ifArray(chartData)) {
                if (!isNaN(_this.start) && !isNaN(_this.end)) {
                    var e = {};
                    e.chart = _this;
                    e.target = _this;
                    e.type = "zoomed";
                    e.startIndex = _this.start;
                    e.endIndex = _this.end;
                    e.startValue = chartData[_this.start].category;
                    e.endValue = chartData[_this.end].category;

                    if (_this.categoryAxis.parseDates) {
                        _this.startTime = chartData[_this.start].time;
                        _this.endTime = chartData[_this.end].time;

                        e.startDate = new Date(_this.startTime);
                        e.endDate = new Date(_this.endTime);
                    }
                    _this.prevStartIndex = _this.start;
                    _this.prevEndIndex = _this.end;

                    _this.fire(e.type, e);
                }
            }
        }
    },

    updateLegendValues: function (index) {
        var _this = this;
        var graphs = _this.graphs;
        var i;
        for (i = 0; i < graphs.length; i++) {
            var graph = graphs[i];

            if (isNaN(index)) {
                graph.currentDataItem = undefined;
            } else {
                var serialDataItem = _this.chartData[index];
                var graphDataItem = serialDataItem.axes[graph.valueAxis.id].graphs[graph.id];
                graph.currentDataItem = graphDataItem;
            }
        }
        if (_this.legend) {
            _this.legend.updateValues();
        }
    },


    getClosestIndex: function (ac, field, value, first, start, end) {
        var _this = this;
        if (start < 0) {
            start = 0;
        }

        if (end > ac.length - 1) {
            end = ac.length - 1;
        }

        // middle index
        var index = start + Math.round((end - start) / 2);
        // middle value
        var valueAtIndex = ac[index][field];
        if (end - start <= 1) {
            if (first) {
                return start;
            } else {
                var valueAtStart = ac[start][field];
                var valueAtEnd = ac[end][field];

                if (Math.abs(valueAtStart - value) < Math.abs(valueAtEnd - value)) {
                    return start;
                } else {
                    return end;
                }
            }
        }

        if (value == valueAtIndex) {
            return index;
        }
        // go to left
        else if (value < valueAtIndex) {
            return _this.getClosestIndex(ac, field, value, first, start, index);
        }
        // go to right
        else {
            return _this.getClosestIndex(ac, field, value, first, index, end);
        }
    },

    zoomToIndexes: function (start, end) {
        var _this = this;
        _this.updateScrollbar = true;
        var chartData = _this.chartData;
        if (chartData) {
            var length = chartData.length;
            if (length > 0) {
                if (start < 0) {
                    start = 0;
                }

                if (end > length - 1) {
                    end = length - 1;
                }

                var categoryAxis = _this.categoryAxis;
                if (categoryAxis.parseDates && !categoryAxis.equalSpacing) {
                    _this.zoom(chartData[start].time, _this.getEndTime(chartData[end].time));
                } else {
                    _this.zoom(start, end);
                }
            }
        }
    },

    zoomToDates: function (start, end) {
        var _this = this;
        _this.updateScrollbar = true;
        var chartData = _this.chartData;
        if (_this.categoryAxis.equalSpacing) {
            var startIndex = _this.getClosestIndex(chartData, "time", start.getTime(), true, 0, chartData.length);
            end = AmCharts.resetDateToMin(end, _this.categoryAxis.minPeriod, 1);  // 3.4.3 to solve extra date when zooming
            var endIndex = _this.getClosestIndex(chartData, "time", end.getTime(), false, 0, chartData.length);
            _this.zoom(startIndex, endIndex);
        } else {
            _this.zoom(start.getTime(), end.getTime());
        }
    },

    zoomToCategoryValues: function (start, end) {
        var _this = this;
        _this.updateScrollbar = true;
        _this.zoom(_this.getCategoryIndexByValue(start), _this.getCategoryIndexByValue(end));
    },

    formatPeriodString: function (text, graph) {

        var _this = this;
        if (graph) {
            var keys = ["value", "open", "low", "high", "close"];
            var keysExt = ["value", "open", "low", "high", "close", "average", "sum", "count"];

            var valueAxis = graph.valueAxis;
            var chartData = _this.chartData;

            var numberFormatter = graph.numberFormatter;
            if (!numberFormatter) {
                numberFormatter = _this.nf;
            }

            for (var k = 0; k < keys.length; k++) {
                var key = keys[k];
                var sum = 0;
                var count = 0;
                var open;
                var close;
                var low;
                var high;
                var average;

                var psum = 0;
                var pcount = 0;
                var popen;
                var pclose;
                var plow;
                var phigh;
                var paverage;

                for (var i = _this.start; i <= _this.end; i++) {
                    var serialDataItem = chartData[i];
                    if (serialDataItem) {
                        var graphDataItem = serialDataItem.axes[valueAxis.id].graphs[graph.id];
                        if (graphDataItem) {
                            if (graphDataItem.values) {
                                var value = graphDataItem.values[key];

                                if (!isNaN(value)) {

                                    if (isNaN(open)) {
                                        open = value;
                                    }

                                    close = value;

                                    if (isNaN(low) || low > value) {
                                        low = value;
                                    }

                                    if (isNaN(high) || high < value) {
                                        high = value;
                                    }

                                    var decCountSum = AmCharts.getDecimals(sum);
                                    var decCountValue = AmCharts.getDecimals(value);

                                    sum += value;

                                    sum = AmCharts.roundTo(sum, Math.max(decCountSum, decCountValue));

                                    count++;

                                    average = sum / count;
                                }
                            }

                            if (graphDataItem.percents) {
                                var percents = graphDataItem.percents[key];
                                if (!isNaN(percents)) {

                                    if (isNaN(popen)) {
                                        popen = percents;
                                    }

                                    pclose = percents;

                                    if (isNaN(plow) || plow > percents) {
                                        plow = percents;
                                    }

                                    if (isNaN(phigh) || phigh < percents) {
                                        phigh = percents;
                                    }

                                    var decCountSumP = AmCharts.getDecimals(psum);
                                    var decCountValueP = AmCharts.getDecimals(percents);

                                    psum += percents;

                                    psum = AmCharts.roundTo(psum, Math.max(decCountSumP, decCountValueP));

                                    pcount++;

                                    paverage = psum / pcount;
                                }
                            }
                        }
                    }
                }


                var data = {
                    open: open,
                    close: close,
                    high: high,
                    low: low,
                    average: average,
                    sum: sum,
                    count: count
                };
                var pdata = {
                    open: popen,
                    close: pclose,
                    high: phigh,
                    low: plow,
                    average: paverage,
                    sum: psum,
                    count: pcount
                };



                text = AmCharts.formatValue(text, data, keysExt, numberFormatter, key + "\\.", _this.usePrefixes, _this.prefixesOfSmallNumbers, _this.prefixesOfBigNumbers);
                text = AmCharts.formatValue(text, pdata, keysExt, _this.pf, "percents\\." + key + "\\.");

            }
        }
        return text;
    },

    formatString: function (text, dItem, noFixBrakes) {
        var _this = this;
        var graph = dItem.graph;

        if (text.indexOf("[[category]]") != -1) {
            var category = dItem.serialDataItem.category;
            var categoryAxis = _this.categoryAxis;

            if (categoryAxis.parseDates) {
                var dateFormat = _this.balloonDateFormat;
                var chartCursor = _this.chartCursor;
                if (chartCursor) {
                    dateFormat = chartCursor.categoryBalloonDateFormat;
                }

                if (text.indexOf("[[category]]") != -1) {
                    var formattedDate = AmCharts.formatDate(category, dateFormat);

                    if (formattedDate.indexOf("fff") != -1) {
                        formattedDate = AmCharts.formatMilliseconds(formattedDate, category);
                    }
                    category = formattedDate;
                }
            }
            text = text.replace(/\[\[category\]\]/g, String(category));
        }

        var numberFormatter = graph.numberFormatter;

        if (!numberFormatter) {
            numberFormatter = _this.nf;
        }

        var valueAxis = dItem.graph.valueAxis;
        var duration = valueAxis.duration;

        if (duration && !isNaN(dItem.values.value)) {
            var fDuration = AmCharts.formatDuration(dItem.values.value, duration, "", valueAxis.durationUnits, valueAxis.maxInterval, numberFormatter);
            var regExp = new RegExp("\\[\\[value\\]\\]", "g");
            text = text.replace(regExp, fDuration);
        }

        var keys = ["value", "open", "low", "high", "close", "total"];
        var percentFormatter = _this.pf;

        text = AmCharts.formatValue(text, dItem.percents, keys, percentFormatter, "percents\\.");
        text = AmCharts.formatValue(text, dItem.values, keys, numberFormatter, "", _this.usePrefixes, _this.prefixesOfSmallNumbers, _this.prefixesOfBigNumbers);
        text = AmCharts.formatValue(text, dItem.values, ["percents"], percentFormatter);

        if (text.indexOf("[[") != -1) {
            text = AmCharts.formatDataContextValue(text, dItem.dataContext);
        }

        text = AmCharts.AmSerialChart.base.formatString.call(_this, text, dItem, noFixBrakes);

        return text;
    },

    addChartScrollbar: function (chartScrollbar) {
        var _this = this;
        AmCharts.callMethod("destroy", [_this.chartScrollbar]);

        if (chartScrollbar) {
            chartScrollbar.chart = _this;
            _this.listenTo(chartScrollbar, "zoomed", _this.handleScrollbarZoom);
        }

        if (_this.rotate) {
            if (chartScrollbar.width === undefined) {
                chartScrollbar.width = chartScrollbar.scrollbarHeight;
            }
        } else {
            if (chartScrollbar.height === undefined) {
                chartScrollbar.height = chartScrollbar.scrollbarHeight;
            }
        }
        _this.chartScrollbar = chartScrollbar;
    },

    removeChartScrollbar: function () {
        var _this = this;
        AmCharts.callMethod("destroy", [_this.chartScrollbar]);
        _this.chartScrollbar = null;
    },

    handleReleaseOutside: function (e) {
        var _this = this;
        AmCharts.AmSerialChart.base.handleReleaseOutside.call(_this, e);
        AmCharts.callMethod("handleReleaseOutside", [_this.chartScrollbar]);
    }

});// @tag amchart-static
AmCharts.AmRadarChart = AmCharts.Class({

    inherits: AmCharts.AmCoordinateChart,

    construct: function(theme) {
        var _this = this;
        _this.type = "radar";
        AmCharts.AmRadarChart.base.construct.call(_this, theme);
        _this.cname = "AmRadarChart";

        _this.marginLeft = 0;
        _this.marginTop = 0;
        _this.marginBottom = 0;
        _this.marginRight = 0;
        _this.radius = "35%";

        AmCharts.applyTheme(_this, theme, _this.cname);
    },

    initChart: function() {
        var _this = this;
        AmCharts.AmRadarChart.base.initChart.call(_this);

        if (_this.dataChanged) {
            _this.updateData();
            _this.dataChanged = false;
            _this.dispatchDataUpdated = true;
        }
        _this.drawChart();
    },

    updateData: function() {
        var _this = this;
        _this.parseData();

        var graphs = _this.graphs;
        var i;
        for (i = 0; i < graphs.length; i++) {
            var graph = graphs[i];
            graph.data = _this.chartData;
        }
    },

    updateGraphs: function() {
        var _this = this;
        var graphs = _this.graphs;
        var i;
        for (i = 0; i < graphs.length; i++) {
            var graph = graphs[i];
            graph.index = i;
            graph.width = _this.realRadius;
            graph.height = _this.realRadius;
            graph.x = _this.marginLeftReal;
            graph.y = _this.marginTopReal;
        }
    },

    parseData: function() {
        var _this = this;
        AmCharts.AmRadarChart.base.parseData.call(_this);
        _this.parseSerialData();
    },

    updateValueAxes: function() {
        var _this = this;
        var valueAxes = _this.valueAxes;
        var i;
        for (i = 0; i < valueAxes.length; i++) {
            var valueAxis = valueAxes[i];
            valueAxis.axisRenderer = AmCharts.RadAxis;
            valueAxis.guideFillRenderer = AmCharts.RadarFill;
            valueAxis.axisItemRenderer = AmCharts.RadItem;
            valueAxis.autoGridCount = false;

            valueAxis.x = _this.marginLeftReal;
            valueAxis.y = _this.marginTopReal;
            valueAxis.width = _this.realRadius;
            valueAxis.height = _this.realRadius;
        }
    },


    drawChart: function() {
        var _this = this;
        AmCharts.AmRadarChart.base.drawChart.call(_this);
        var realWidth = _this.updateWidth();
        var realHeight = _this.updateHeight();

        var marginTop = _this.marginTop + _this.getTitleHeight();
        var marginLeft = _this.marginLeft;
        var marginBottom = _this.marginBottom;
        var marginRight = _this.marginRight;
        var allowedHeight = realHeight - marginTop - marginBottom;
        _this.marginLeftReal = marginLeft + (realWidth - marginLeft - marginRight) / 2;
        _this.marginTopReal = marginTop + allowedHeight / 2;

        _this.realRadius = AmCharts.toCoordinate(_this.radius, realWidth, allowedHeight);

        _this.updateValueAxes();
        _this.updateGraphs();

        var chartData = _this.chartData;

        if (AmCharts.ifArray(chartData)) {
            if (_this.realWidth > 0 && _this.realHeight > 0) {
                var last = chartData.length - 1;
                var valueAxes = _this.valueAxes;
                var i;
                for (i = 0; i < valueAxes.length; i++) {
                    var valueAxis = valueAxes[i];
                    valueAxis.zoom(0, last);
                }

                var graphs = _this.graphs;
                for (i = 0; i < graphs.length; i++) {
                    var graph = graphs[i];
                    graph.zoom(0, last);
                }

                var legend = _this.legend;
                if (legend) {
                    legend.invalidateSize();
                }
            }
        } else {
            _this.cleanChart();
        }
        _this.dispDUpd();
        _this.chartCreated = true;
    },


    formatString: function(text, dItem, noFixBrakes) {
        var _this = this;
        var graph = dItem.graph;

        if (text.indexOf("[[category]]") != -1) {
            var category = dItem.serialDataItem.category;
            text = text.replace(/\[\[category\]\]/g, String(category));
        }

        var numberFormatter = graph.numberFormatter;
        if (!numberFormatter) {
            numberFormatter = _this.nf;
        }

        var keys = ["value"];
        text = AmCharts.formatValue(text, dItem.values, keys, numberFormatter, "", _this.usePrefixes, _this.prefixesOfSmallNumbers, _this.prefixesOfBigNumbers);

        if (text.indexOf("[[") != -1) {
            text = AmCharts.formatDataContextValue(text, dItem.dataContext);
        }

        text = AmCharts.AmRadarChart.base.formatString.call(_this, text, dItem, noFixBrakes);

        return text;
    },

    cleanChart: function() {
        var _this = this;
        AmCharts.callMethod("destroy", [_this.valueAxes, _this.graphs]);
    }

});// @tag amchart-static
AmCharts.AmAngularGauge = AmCharts.Class({

    inherits: AmCharts.AmChart,

    construct: function(theme) {
        var _this = this;
        _this.cname = "AmAngularGauge";
        AmCharts.AmAngularGauge.base.construct.call(_this, theme);

        _this.theme = theme;
        _this.type = "gauge";
        _this.marginLeft = 10;
        _this.marginTop = 10;
        _this.marginBottom = 10;
        _this.marginRight = 10;
        _this.minRadius = 10;

        _this.faceColor = "#FAFAFA";
        _this.faceAlpha = 0;
        _this.faceBorderWidth = 1;
        _this.faceBorderColor = "#555555";
        _this.faceBorderAlpha = 0;
        //_this.facePattern;

        _this.arrows = [];
        _this.axes = [];
        _this.startDuration = 1;
        _this.startEffect = 'easeOutSine';
        _this.adjustSize = true;
        _this.extraWidth = 0;
        _this.extraHeight = 0;

        // _this.gaugeX;
        // _this.gaugeY;
        AmCharts.applyTheme(_this, theme, _this.cname);
    },

    addAxis: function(axis) {
        this.axes.push(axis);
    },

    formatString: function(text, dItem) {
        var _this = this;
        text = AmCharts.formatValue(text, dItem, ["value"], _this.nf, "", _this.usePrefixes, _this.prefixesOfSmallNumbers, _this.prefixesOfBigNumbers);
        return text;
    },

    initChart: function() {

        var _this = this;
        AmCharts.AmAngularGauge.base.initChart.call(_this);

        var axis;
        if (_this.axes.length === 0) {
            axis = new AmCharts.GaugeAxis(_this.theme);
            _this.addAxis(axis);
        }

        var i;

        for (i = 0; i < _this.axes.length; i++) {
            axis = _this.axes[i];

            axis = AmCharts.processObject(axis, AmCharts.GaugeAxis, _this.theme);
            axis.chart = _this;
            _this.axes[i] = axis;
        }


        var arrow;
        var legendData = [];
        var arrows = _this.arrows;

        for (i = 0; i < arrows.length; i++) {
            arrow = arrows[i];

            arrow = AmCharts.processObject(arrow, AmCharts.GaugeArrow, _this.theme);
            arrow.chart = _this;
            arrows[i] = arrow;

            var arrowAxis = arrow.axis;
            if (AmCharts.isString(arrowAxis)) {
                arrow.axis = AmCharts.getObjById(_this.axes, arrowAxis);
            }

            if (!arrow.axis) {
                arrow.axis = _this.axes[0];
            }
            if (isNaN(arrow.value)) {
                arrow.setValue(arrow.axis.startValue);
            }
            if (isNaN(arrow.previousValue)) {
                arrow.previousValue = arrow.axis.startValue;
            }
        }
        _this.setLegendData(arrows);
        _this.drawChart();
        _this.totalFrames = _this.startDuration * 1000 / AmCharts.updateRate;
    },


    drawChart: function() {
        var _this = this;
        AmCharts.AmAngularGauge.base.drawChart.call(_this);

        var container = _this.container;
        var realWidth = _this.updateWidth();
        _this.realWidth = realWidth;

        var realHeight = _this.updateHeight();
        _this.realHeight = realHeight;

        var toCoordinate = AmCharts.toCoordinate;
        var marginLeft = toCoordinate(_this.marginLeft, realWidth);
        var marginRight = toCoordinate(_this.marginRight, realWidth);
        var marginTop = toCoordinate(_this.marginTop, realHeight) + _this.getTitleHeight();
        var marginBottom = toCoordinate(_this.marginBottom, realHeight);

        var radius = toCoordinate(_this.radius, realWidth, realHeight);
        var pureWidth = realWidth - marginLeft - marginRight;
        var pureHeight = realHeight - marginTop - marginBottom + _this.extraHeight;

        if (!radius) {
            radius = Math.min(pureWidth, pureHeight) / 2;
        }

        if (radius < _this.minRadius) {
            radius = _this.minRadius;
        }
        _this.radiusReal = radius;

        _this.centerX = (realWidth - marginLeft - marginRight) / 2 + marginLeft;
        _this.centerY = (realHeight - marginTop - marginBottom) / 2 + marginTop + _this.extraHeight / 2;

        if (!isNaN(_this.gaugeX)) {
            _this.centerX = _this.gaugeX;
        }

        if (!isNaN(_this.gaugeY)) {
            _this.centerY = _this.gaugeY;
        }

        var circleAlpha = _this.faceAlpha;
        var circleBorderAlpha = _this.faceBorderAlpha;
        var background;

        if (circleAlpha > 0 || circleBorderAlpha > 0) {
            background = AmCharts.circle(container, radius, _this.faceColor, circleAlpha, _this.faceBorderWidth, _this.faceBorderColor, circleBorderAlpha, false);
            background.translate(_this.centerX, _this.centerY);
            background.toBack();

            var facePattern = _this.facePattern;

            if(facePattern){
                background.pattern(facePattern);
            }
        }

        var maxWidth = 0;
        var maxHeight = 0;
        for (var i = 0; i < _this.axes.length; i++) {
            var axis = _this.axes[i];
            axis.radiusReal = AmCharts.toCoordinate(axis.radius, _this.radiusReal);
            axis.draw();
            if (axis.width > maxWidth) {
                maxWidth = axis.width;
            }

            if (axis.height > maxHeight) {
                maxHeight = axis.height;
            }
        }

        var legend = _this.legend;

        if (legend) {
            legend.invalidateSize();
        }

        if (_this.adjustSize && !_this.chartCreated) {
            if (background) {
                var bgBox = background.getBBox();
                if (bgBox.width > maxWidth) {
                    maxWidth = bgBox.width;
                }
                if (bgBox.height > maxHeight) {
                    maxHeight = bgBox.height;
                }
            }

            var emptySpace = 0;
            if (pureHeight > maxHeight || pureWidth > maxWidth) {
                emptySpace = Math.min(pureHeight - maxHeight, pureWidth - maxWidth);
            }
            if (emptySpace > 0) {
                //_this.extraWidth = pureWidth - maxWidth;
                _this.extraHeight = pureHeight - maxHeight;
                _this.chartCreated = true;
                _this.validateNow();
            }
        }
        _this.dispDUpd();
        _this.chartCreated = true;
    },

    validateSize: function() {
        var _this = this;
        _this.extraWidth = 0;
        _this.extraHeight = 0;
        _this.chartCreated = false;
        AmCharts.AmAngularGauge.base.validateSize.call(_this);
    },

    addArrow: function(arrow) {
        var _this = this;
        _this.arrows.push(arrow);
    },

    removeArrow: function(arrow) {
        var _this = this;

        AmCharts.removeFromArray(_this.arrows, arrow);
        _this.validateNow();
    },


    removeAxis: function(axis) {
        var _this = this;

        AmCharts.removeFromArray(_this.axes, axis);
        _this.validateNow();
    },



    drawArrow: function(arrow, angle) {
        // ARROW
        var _this = this;

        if (arrow.set) {
            arrow.set.remove();
        }
        var container = _this.container;
        arrow.set = container.set();

        if (!arrow.hidden) {
            var axis = arrow.axis;
            var radius = axis.radiusReal;

            var centerX = axis.centerXReal;
            var centerY = axis.centerYReal;
            var arrowStartWidth = arrow.startWidth;
            var arrowEndWidth = arrow.endWidth;
            var arrowInnerRadius = AmCharts.toCoordinate(arrow.innerRadius, axis.radiusReal);
            var arrowRadius = AmCharts.toCoordinate(arrow.radius, axis.radiusReal);

            if (!axis.inside) {
                arrowRadius -= 15;
            }



            var nailColor = arrow.nailColor;
            if (!nailColor) {
                nailColor = arrow.color;
            }

            var borderColor = arrow.nailColor;
            if (!borderColor) {
                borderColor = arrow.color;
            }

            var arrowNail = AmCharts.circle(container, arrow.nailRadius, nailColor, arrow.nailAlpha, arrow.nailBorderThickness, nailColor, arrow.nailBorderAlpha);
            arrow.set.push(arrowNail);
            arrowNail.translate(centerX, centerY);

            if (isNaN(arrowRadius)) {
                arrowRadius = radius - axis.tickLength;
            }

            var sin = Math.sin((angle) / (180) * Math.PI);
            var cos = Math.cos((angle) / (180) * Math.PI);

            var sin2 = Math.sin((angle + 90) / (180) * Math.PI);
            var cos2 = Math.cos((angle + 90) / (180) * Math.PI);

            var ax = [centerX - arrowStartWidth / 2 * sin2 + arrowInnerRadius * sin, centerX + arrowRadius * sin - arrowEndWidth / 2 * sin2, centerX + arrowRadius * sin + arrowEndWidth / 2 * sin2, centerX + arrowStartWidth / 2 * sin2 + arrowInnerRadius * sin];
            var ay = [centerY + arrowStartWidth / 2 * cos2 - arrowInnerRadius * cos, centerY - arrowRadius * cos + arrowEndWidth / 2 * cos2, centerY - arrowRadius * cos - arrowEndWidth / 2 * cos2, centerY - arrowStartWidth / 2 * cos2 - arrowInnerRadius * cos];
            var arrowGraphics = AmCharts.polygon(container, ax, ay, arrow.color, arrow.alpha, 1, borderColor, arrow.borderAlpha, undefined, true);
            arrow.set.push(arrowGraphics);

            _this.graphsSet.push(arrow.set);
        }
    },

    setValue: function(arrow, value) {
        var _this = this;
        if (arrow.axis) {
            var angle = arrow.axis.value2angle(value);
            arrow.frame = 0;
            arrow.previousValue = arrow.value;
        }
        arrow.value = value;

        var legend = _this.legend;
        if (legend) {
            legend.updateValues();
        }
    },

    handleLegendEvent: function(event) {
        var _this = this;
        var type = event.type;
        var dItem = event.dataItem;

        if (!_this.legend.data) {
            if (dItem) {
                var hidden = dItem.hidden;

                switch (type) {
                    case 'hideItem':
                        _this.hideArrow(dItem);
                        break;
                    case 'showItem':
                        _this.showArrow(dItem);
                        break;
                }
            }
        }
    },

    hideArrow: function(arrow) {
        arrow.set.hide();
        arrow.hidden = true;
    },

    showArrow: function(arrow) {
        arrow.set.show();
        arrow.hidden = false;
    },

    updateAnimations: function() {
        var _this = this;
        AmCharts.AmAngularGauge.base.updateAnimations.call(_this);
        var n = _this.arrows.length;
        var arrow;
        for (var i = 0; i < n; i++) {
            arrow = _this.arrows[i];
            var value;

            if (arrow.frame >= _this.totalFrames) {
                value = arrow.value;
            } else {
                arrow.frame++;

                if (arrow.clockWiseOnly) {
                    if (arrow.value < arrow.previousValue) {
                        var axis = arrow.axis;
                        arrow.previousValue = arrow.previousValue - (axis.endValue - axis.startValue);
                    }
                }
                var effect = AmCharts.getEffect(_this.startEffect);
                value = AmCharts[effect](0, arrow.frame, arrow.previousValue, arrow.value - arrow.previousValue, _this.totalFrames);

                if (isNaN(value)) {
                    value = arrow.value;
                }
            }

            var angle = arrow.axis.value2angle(value);
            _this.drawArrow(arrow, angle);
        }
    }
});// @tag amchart-static
AmCharts.AmFunnelChart = AmCharts.Class({

    inherits: AmCharts.AmSlicedChart,

    construct: function(theme) {
        var _this = this;
        _this.type = "funnel";
        AmCharts.AmFunnelChart.base.construct.call(_this, theme);

        _this.cname = "AmFunnelChart";
        _this.startY = 0;
        _this.startX = 0;

        _this.baseWidth = "100%";
        _this.neckWidth = 0;
        _this.neckHeight = 0;
        _this.rotate = false;
        _this.valueRepresents = "height";

        _this.pullDistance = 30;
        _this.labelPosition = "center";
        _this.labelText = "[[title]]: [[value]]";
        _this.balloonText = "[[title]]: [[value]]\n[[description]]";

        AmCharts.applyTheme(_this, theme, _this.cname);
    },


    drawChart: function() {
        var _this = this;
        AmCharts.AmFunnelChart.base.drawChart.call(_this);

        var chartData = _this.chartData;

        if (AmCharts.ifArray(chartData)) {
            if (_this.realWidth > 0 && _this.realHeight > 0) {

                var container = _this.container;
                var startDuration = _this.startDuration;
                var rotate = _this.rotate;
                var realWidth = _this.updateWidth();
                _this.realWidth = realWidth;

                var realHeight = _this.updateHeight();
                _this.realHeight = realHeight;

                var toCoordinate = AmCharts.toCoordinate;
                var marginLeft = toCoordinate(_this.marginLeft, realWidth);
                var marginRight = toCoordinate(_this.marginRight, realWidth);
                var marginTop = toCoordinate(_this.marginTop, realHeight) + _this.getTitleHeight();
                var marginBottom = toCoordinate(_this.marginBottom, realHeight);

                var widthWitoutMargins = realWidth - marginLeft - marginRight;
                var baseWidthReal = AmCharts.toCoordinate(_this.baseWidth, widthWitoutMargins);
                var neckWidthReal = AmCharts.toCoordinate(_this.neckWidth, widthWitoutMargins);
                var totalHeight = realHeight - marginBottom - marginTop;
                var neckHeightReal = AmCharts.toCoordinate(_this.neckHeight, totalHeight);

                var sliceY = marginTop;
                var neckStartY = sliceY + totalHeight - neckHeightReal;
                if (rotate) {
                    sliceY = realHeight - marginBottom;
                    neckStartY = sliceY - totalHeight + neckHeightReal;
                }

                _this.firstSliceY = sliceY;

                if (AmCharts.VML) {
                    _this.startAlpha = 1;
                }

                var centerX = widthWitoutMargins / 2 + marginLeft;

                var www = (baseWidthReal - neckWidthReal) / 2;
                var tgA = (totalHeight - neckHeightReal) / www;

                // in case area is not calculated, only height (standard bad practice)

                var previousWidth = baseWidthReal / 2;

                var totalSquare = (totalHeight - neckHeightReal) * (baseWidthReal + neckWidthReal) / 2 + neckWidthReal * neckHeightReal;
                var previousTextY = sliceY;
                var previousTextHeight = 0;

                for (var i = 0; i < chartData.length; i++) {

                    var dItem = chartData[i];
                    var sliceHeightTrimmed;
                    if (dItem.hidden !== true) {
                        var value = dItem.value;

                        var xx = [];
                        var yy = [];
                        var sliceHeight;

                        if (_this.valueRepresents == "height") {
                            sliceHeight = totalHeight * dItem.percents / 100;
                        } else {
                            var c = -totalSquare * dItem.percents / 100 / 2;
                            var b = previousWidth;
                            var a = -1 / (2 * tgA);
                            var d = (Math.pow(b, 2) - 4 * a * c);

                            if (d < 0) {
                                d = 0;
                            }

                            sliceHeight = (Math.sqrt(d) - b) / (2 * a);

                            if ((!rotate && sliceY >= neckStartY) || (rotate && sliceY <= neckStartY)) {
                                sliceHeight = (-c * 2) / neckWidthReal;
                            } else if ((!rotate && sliceY + sliceHeight > neckStartY) || (rotate && sliceY - sliceHeight < neckStartY)) {

                                if (rotate) {
                                    sliceHeightTrimmed = Math.round(sliceHeight + (sliceY - sliceHeight - neckStartY));
                                } else {
                                    sliceHeightTrimmed = Math.round(sliceHeight - (sliceY + sliceHeight - neckStartY));
                                }

                                d = sliceHeightTrimmed / tgA;
                                var sTrimmed = (b - d / 2) * sliceHeightTrimmed;

                                var sSquare = -c - sTrimmed;
                                var sHeight = (sSquare * 2) / neckWidthReal;

                                sliceHeight = sliceHeightTrimmed + sHeight;
                            }

                        }

                        var sliceWidth = previousWidth - sliceHeight / tgA;

                        var tickInSquare = false;
                        if ((!rotate && sliceY + sliceHeight > neckStartY) || (rotate && sliceY - sliceHeight < neckStartY)) {
                            sliceWidth = neckWidthReal / 2;


                            xx.push(centerX - previousWidth, centerX + previousWidth, centerX + sliceWidth, centerX + sliceWidth, centerX - sliceWidth, centerX - sliceWidth);
                            if (rotate) {
                                sliceHeightTrimmed = sliceHeight + (sliceY - sliceHeight - neckStartY);
                                if(sliceY < neckStartY){
                                    sliceHeightTrimmed = 0;
                                }
                                yy.push(sliceY, sliceY, sliceY - sliceHeightTrimmed, sliceY - sliceHeight, sliceY - sliceHeight, sliceY - sliceHeightTrimmed, sliceY);
                            } else {
                                sliceHeightTrimmed = sliceHeight - (sliceY + sliceHeight - neckStartY);

                                if(sliceY > neckStartY){
                                    sliceHeightTrimmed = 0;
                                }

                                yy.push(sliceY, sliceY, sliceY + sliceHeightTrimmed, sliceY + sliceHeight, sliceY + sliceHeight, sliceY + sliceHeightTrimmed, sliceY);
                            }
                            tickInSquare = true;
                        } else {
                            xx.push(centerX - previousWidth, centerX + previousWidth, centerX + sliceWidth, centerX - sliceWidth);
                            if (rotate) {
                                yy.push(sliceY, sliceY, sliceY - sliceHeight, sliceY - sliceHeight);
                            } else {
                                yy.push(sliceY, sliceY, sliceY + sliceHeight, sliceY + sliceHeight);
                            }
                        }

                        var fullSlice = container.set();
                        var wedge = container.set();
                        var wedgeGraphics = AmCharts.polygon(container, xx, yy, dItem.color, dItem.alpha, _this.outlineThickness, _this.outlineColor, _this.outlineAlpha);
                        wedge.push(wedgeGraphics);
                        _this.graphsSet.push(wedge);
                        dItem.wedge = wedge;
                        dItem.index = i;

                        var gradientRatio = _this.gradientRatio;
                        if (gradientRatio) {
                            var gradient = [];
                            var g;
                            for (g = 0; g < gradientRatio.length; g++) {
                                gradient.push(AmCharts.adjustLuminosity(dItem.color, gradientRatio[g]));
                            }
                            if (gradient.length > 0) {
                                wedgeGraphics.gradient("linearGradient", gradient);
                            }
                            if (dItem.pattern) {
                                wedgeGraphics.pattern(dItem.pattern);
                            }
                        }


                        if (startDuration > 0) {
                            if (!_this.chartCreated) {
                                wedge.setAttr('opacity', _this.startAlpha);
                            }
                        }

                        _this.addEventListeners(wedge, dItem);
                        dItem.ty0 = sliceY - sliceHeight / 2;
                        // label
                        if (_this.labelsEnabled && _this.labelText && dItem.percents >= _this.hideLabelsPercent) {

                            var text = _this.formatString(_this.labelText, dItem);

                            var labelColor = dItem.labelColor;
                            if (!labelColor) {
                                labelColor = _this.color;
                            }

                            var labelPosition = _this.labelPosition;
                            var align = "left";
                            if (labelPosition == "center") {
                                align = "middle";
                            }
                            if (labelPosition == "left") {
                                align = "right";
                            }

                            var txt = AmCharts.text(container, text, labelColor, _this.fontFamily, _this.fontSize, align);
                            wedge.push(txt);
                            var tx = centerX;

                            var ty;
                            if (rotate) {
                                ty = sliceY - sliceHeight / 2;
                                dItem.ty0 = ty;
                            } else {
                                ty = sliceY + sliceHeight / 2;
                                dItem.ty0 = ty;
                                if (ty < previousTextY + previousTextHeight + 5) {
                                    ty = previousTextY + previousTextHeight + 5;
                                }
                                if (ty > realHeight - marginBottom) {
                                    ty = realHeight - marginBottom;
                                }
                            }

                            if (labelPosition == "right") {
                                tx = widthWitoutMargins + 10 + marginLeft;
                                dItem.tx0 = centerX + (previousWidth - sliceHeight / 2 / tgA);
                                if (tickInSquare) {
                                    dItem.tx0 = centerX + sliceWidth;
                                }
                            }

                            if (labelPosition == "left") {
                                dItem.tx0 = centerX - (previousWidth - sliceHeight / 2 / tgA);
                                if (tickInSquare) {
                                    dItem.tx0 = centerX - sliceWidth;
                                }
                                tx = marginLeft;
                            }

                            dItem.label = txt;
                            dItem.labelX = tx;
                            dItem.labelY = ty;
                            dItem.labelHeight = txt.getBBox().height;

                            txt.translate(tx, ty);

                            previousTextHeight = txt.getBBox().height;
                            previousTextY = ty;
                        }

                        if (dItem.alpha === 0 || (startDuration > 0 && !_this.chartCreated)) {
                            wedge.hide();
                        }

                        if (rotate) {
                            sliceY -= sliceHeight;
                        } else {
                            sliceY += sliceHeight;
                        }

                        previousWidth = sliceWidth;

                        dItem.startX = AmCharts.toCoordinate(_this.startX, realWidth);
                        dItem.startY = AmCharts.toCoordinate(_this.startY, realHeight);
                        dItem.pullX = AmCharts.toCoordinate(_this.pullDistance, realWidth);
                        dItem.pullY = 0;
                        dItem.balloonX = centerX;
                        dItem.balloonY = dItem.ty0;
                    }
                }
                _this.arrangeLabels();

                _this.initialStart();

                var legend = _this.legend;
                if (legend) {
                    legend.invalidateSize();
                }
            } else {
                _this.cleanChart();
            }
        }
        _this.dispDUpd();
        _this.chartCreated = true;
    },

    arrangeLabels: function() {
        var _this = this;

        var rotate = _this.rotate;
        var previousY;
        if (rotate) {
            previousY = 0;
        } else {
            previousY = _this.realHeight;
        }
        var previousHeight = 0;
        var chartData = _this.chartData;

        var count = chartData.length;
        var dItem;
        for (var i = 0; i < count; i++) {
            dItem = chartData[count - i - 1];

            var label = dItem.label;

            var labelY = dItem.labelY;
            var labelX = dItem.labelX;
            var labelHeight = dItem.labelHeight;
            var newY = labelY;
            if (rotate) {
                if (previousY + previousHeight + 5 > labelY) {
                    newY = previousY + previousHeight + 5;
                }
            } else {
                if (labelY + labelHeight + 5 > previousY) {
                    newY = previousY - 5 - labelHeight;
                }
            }
            previousY = newY;
            previousHeight = labelHeight;

            if(label){
                label.translate(labelX, newY);
            }

            dItem.labelY = newY;
            dItem.tx = labelX;
            dItem.ty = newY;
            dItem.tx2 = labelX;
        }
        if (_this.labelPosition != "center") {
            _this.drawTicks();
        }
    }
});// @tag amchart
AmCharts.AxisBase = AmCharts.Class({

    construct: function (theme) {
        var _this = this;
        _this.dx = 0;
        _this.dy = 0;
        _this.x = 0;
        _this.y = 0;
        _this.viX = 0;
        _this.viY = 0;
        //_this.axisWidth;
        _this.axisThickness = 1;
        _this.axisColor = '#000000';
        _this.axisAlpha = 1;
        _this.tickLength = 5;
        _this.gridCount = 5;
        _this.gridAlpha = 0.15;
        _this.gridThickness = 1;
        _this.gridColor = '#000000';
        _this.dashLength = 0;
        _this.labelFrequency = 1;
        _this.showFirstLabel = true;
        _this.showLastLabel = true;
        _this.fillColor = '#FFFFFF';
        _this.fillAlpha = 0;
        _this.labelsEnabled = true;
        _this.labelRotation = 0;
        _this.autoGridCount = true;
        _this.valueRollOverColor = '#CC0000';
        _this.offset = 0;
        _this.guides = [];
        _this.visible = true;
        _this.counter = 0;
        _this.guides = [];
        _this.inside = false;
        _this.ignoreAxisWidth = false;
        //_this.titleColor;
        //_this.titleFontSize;
        _this.minHorizontalGap = 75;
        _this.minVerticalGap = 35;
        _this.titleBold = true;
        _this.minorGridEnabled = false;
        _this.minorGridAlpha = 0.07;
        _this.autoWrap = false;
        _this.titleAlign = 'middle';

        AmCharts.applyTheme(_this, theme, "AxisBase");
    },

    zoom: function (start, end) {
        var _this = this;
        _this.start = start;
        _this.end = end;
        _this.dataChanged = true;
        _this.draw();
    },

    fixAxisPosition: function () {
        var _this = this;
        var pos = _this.position;

        if (_this.orientation == "H") {
            if (pos == "left") {
                pos = "bottom";
            }
            if (pos == "right") {
                pos = "top";
            }
        } else {
            if (pos == "bottom") {
                pos = "left";
            }
            if (pos == "top") {
                pos = "right";
            }
        }

        _this.position = pos;
    },

    draw: function () {
        var _this = this;
        var chart = _this.chart;

        _this.allLabels = [];
        _this.counter = 0;
        _this.destroy();
        _this.fixAxisPosition();
        _this.labels = [];

        var container = chart.container;

        var set = container.set();
        chart.gridSet.push(set);
        _this.set = set;

        var labelsSet = container.set();
        chart.axesLabelsSet.push(labelsSet);
        _this.labelsSet = labelsSet;

        _this.axisLine = new _this.axisRenderer(_this);

        if (_this.autoGridCount) {
            var c;

            if (_this.orientation == "V") {
                c = _this.height / _this.minVerticalGap;
                if (c < 3) {
                    c = 3;
                }
            } else {
                c = _this.width / _this.minHorizontalGap;
            }
            _this.gridCountR = Math.max(c, 1);
        }
        else{
            _this.gridCountR = _this.gridCount;
        }
        _this.axisWidth = _this.axisLine.axisWidth;
        _this.addTitle();
    },

    setOrientation: function (rotate) {
        var _this = this;
        if (rotate) {
            _this.orientation = "H";
        } else {
            _this.orientation = "V";
        }
    },


    addTitle: function () {

        var _this = this;
        var title = _this.title;

        //_this.titleLabel = null;
        if (title) {
            var chart = _this.chart;

            var color = _this.titleColor;
            if (color === undefined) {
                color = chart.color;
            }

            var titleFontSize = _this.titleFontSize;
            if (isNaN(titleFontSize)) {
                titleFontSize = chart.fontSize + 1;
            }
            var titleLabel = AmCharts.text(chart.container, title, color, chart.fontFamily, titleFontSize, _this.titleAlign, _this.titleBold);
            _this.titleLabel = titleLabel;
        }
    },

    positionTitle: function () {
        var _this = this;
        var titleLabel = _this.titleLabel;
        if (titleLabel) {
            var tx;
            var ty;
            var labelsSet = _this.labelsSet;
            var bbox = {};
            if (labelsSet.length() > 0) {
                bbox = labelsSet.getBBox();
            } else {
                bbox.x = 0;
                bbox.y = 0;
                bbox.width = _this.viW;
                bbox.height = _this.viH;
            }
            labelsSet.push(titleLabel);

            var bx = bbox.x;
            var by = bbox.y;

            if (AmCharts.VML) {
                if (!_this.rotate) {
                    by -= _this.y;
                } else {
                    bx -= _this.x;
                }
            }

            var bw = bbox.width;
            var bh = bbox.height;

            var w = _this.viW;
            var h = _this.viH;

            var anchor = "middle";

            var r = 0;

            var fontSize = titleLabel.getBBox().height / 2;
            var inside = _this.inside;
            var titleAlign = _this.titleAlign;

            switch (_this.position) {
                case "top":
                    if(titleAlign == "left"){
                        tx = -1;
                    }
                    else if(titleAlign == "right"){
                        tx = w;
                    }
                    else{
                        tx = w / 2;
                    }

                    ty = by - 10 - fontSize;
                    break;
                case "bottom":
                    if(titleAlign == "left"){
                        tx = -1;
                    }
                    else if(titleAlign == "right"){
                        tx = w;
                    }
                    else{
                        tx = w / 2;
                    }

                    ty = by + bh + 10 + fontSize;
                    break;
                case "left":
                    tx = bx - 10 - fontSize;

                    if (inside) {
                        tx -= 5;
                    }
                    if(titleAlign == "left"){
                        ty = h + 1;
                    }
                    else if(titleAlign == "right"){
                        ty = -1;
                    }
                    else{
                        ty = h / 2;
                    }
                    r = -90;
                    break;
                case "right":
                    tx = bx + bw + 10 + fontSize - 3;
                    if (inside) {
                        tx += 7;
                    }
                    if(titleAlign == "left"){
                        ty = h + 2;
                    }
                    else if(titleAlign == "right"){
                        ty = -2;
                    }
                    else{
                        ty = h / 2;
                    }
                    r = -90;
                    break;
            }

            if (_this.marginsChanged) {
                titleLabel.translate(tx, ty);
                _this.tx = tx;
                _this.ty = ty;
            } else {
                titleLabel.translate(_this.tx, _this.ty);
            }
            _this.marginsChanged = false;

            if (r !== 0) {
                titleLabel.rotate(r);
            }
        }
    },

    pushAxisItem: function (axisItem, above) {
        var axisItemGraphics = axisItem.graphics();
        if (axisItemGraphics.length() > 0) {
            if (above) {
                this.labelsSet.push(axisItemGraphics);
            } else {
                this.set.push(axisItemGraphics);
            }
        }

        var label = axisItem.getLabel();
        if (label) {
            this.labelsSet.push(label);
        }
    },

    addGuide: function (guide) {
        var _this = this;
        var guides = _this.guides;
        if(guides.indexOf(guide) == -1){
            guides.push(guide);
        }
    },

    removeGuide: function (guide) {
        var guides = this.guides;
        var i;
        for (i = 0; i < guides.length; i++) {
            if (guides[i] == guide) {
                guides.splice(i, 1);
            }
        }
    },

    handleGuideOver: function (guide) {
        var _this = this;
        clearTimeout(_this.chart.hoverInt);
        var bbox = guide.graphics.getBBox();
        var x = bbox.x + bbox.width / 2;
        var y = bbox.y + bbox.height / 2;
        var color = guide.fillColor;
        if (color === undefined) {
            color = guide.lineColor;
        }
        _this.chart.showBalloon(guide.balloonText, color, true, x, y);
    },

    handleGuideOut: function (event) {
        this.chart.hideBalloon();
    },

    addEventListeners: function (graphics, guide) {
        var _this = this;
        graphics.mouseover(function () {
            _this.handleGuideOver(guide);
        });
        graphics.mouseout(function () {
            _this.handleGuideOut(guide);
        });
    },


    getBBox: function () {
        var _this = this;
        var bbox = _this.labelsSet.getBBox();

        if (!AmCharts.VML) {
            bbox = ({
                x: (bbox.x + _this.x),
                y: (bbox.y + _this.y),
                width: bbox.width,
                height: bbox.height
            });
        }
        return bbox;
    },

    destroy: function () {
        var _this = this;
        AmCharts.remove(_this.set);
        AmCharts.remove(_this.labelsSet);

        var axisLine = _this.axisLine;
        if (axisLine) {
            AmCharts.remove(axisLine.set);
        }
        AmCharts.remove(_this.grid0);
    }
});// @tag amchart
AmCharts.ValueAxis = AmCharts.Class({

    inherits: AmCharts.AxisBase,

    construct: function (theme) {
        var _this = this;
        _this.cname = "ValueAxis";
        _this.createEvents('axisChanged', 'logarithmicAxisFailed', 'axisSelfZoomed', 'axisZoomed');
        AmCharts.ValueAxis.base.construct.call(this, theme);
        _this.dataChanged = true;
        //_this.gridCount = 8;
        _this.stackType = "none";
        _this.position = "left";
        _this.unitPosition = "right";
        _this.integersOnly = false;
        _this.includeGuidesInMinMax = false;
        _this.includeHidden = false;
        _this.recalculateToPercents = false;
        //_this.duration;
        _this.durationUnits = {
            DD: "d. ",
            hh: ":",
            mm: ":",
            ss: ""
        };
        _this.scrollbar = false;
        //_this.maxDecCount;
        _this.baseValue = 0;
        _this.radarCategoriesEnabled = true;
        _this.gridType = "polygons";
        _this.useScientificNotation = false;
        _this.axisTitleOffset = 10;
        _this.minMaxMultiplier = 1;
        _this.logGridLimit = 2;
        // _this.labelFunction

        AmCharts.applyTheme(_this, theme, _this.cname);
    },

    updateData: function () {
        var _this = this;
        if (_this.gridCountR <= 0) {
            _this.gridCountR = 1;
        }

        _this.totals = [];
        _this.data = _this.chart.chartData;

        var chart = _this.chart;

        if (chart.type != "xy") {
            _this.stackGraphs("smoothedLine");
            _this.stackGraphs("line");
            _this.stackGraphs("column");
            _this.stackGraphs("step");
        }

        if (_this.recalculateToPercents) {
            _this.recalculate();
        }

        if (_this.synchronizationMultiplier && _this.synchronizeWith) {

            if(AmCharts.isString(_this.synchronizeWith)){
                _this.synchronizeWith = chart.getValueAxisById(_this.synchronizeWith);
            }
            if(_this.synchronizeWith){
                _this.synchronizeWithAxis(_this.synchronizeWith);
                _this.foundGraphs = true;
            }
        } else {
            _this.foundGraphs = false;
            _this.getMinMax();
        }
    },


    draw: function () {
        var _this = this;
        AmCharts.ValueAxis.base.draw.call(_this);

        var chart = _this.chart;
        var set = _this.set;

        // thsi is to handle fallback to v.1 of flash chart only
        if (_this.type == "duration") {
            _this.duration = "ss";
        }

        if (_this.dataChanged === true) {
            _this.updateData();
            _this.dataChanged = false;
        }

        if (_this.logarithmic) {
            var min = _this.getMin(0, _this.data.length - 1);

            if (min <= 0 || _this.minimum <= 0) {
                var eType = 'logarithmicAxisFailed';
                _this.fire(eType, {
                    type: eType,
                    chart: chart
                });
                return;
            }
        }

        _this.grid0 = null;

        var coord;
        var i;
        var dx = chart.dx;
        var dy = chart.dy;
        var hide = false;
        var logarithmic = _this.logarithmic;

        if (!isNaN(_this.min) && !isNaN(_this.max) && _this.foundGraphs && _this.min != Infinity && _this.max != -Infinity) {
            var labelFrequency = _this.labelFrequency;
            var showFirstLabel = _this.showFirstLabel;
            var showLastLabel = _this.showLastLabel;
            var frequency = 1;
            var startCount = 0;

            // the number of grid lines
            var gridCountReal = Math.round((_this.max - _this.min) / _this.step) + 1;

            // LOGARITHMIC
            var degrees;
            if (logarithmic === true) {
                degrees = Math.log(_this.max) * Math.LOG10E - Math.log(_this.minReal) * Math.LOG10E;

                _this.stepWidth = _this.axisWidth / degrees;
                // in case we have more degrees, draw grid every degree only
                if (degrees > _this.logGridLimit) {
                    gridCountReal = Math.ceil((Math.log(_this.max) * Math.LOG10E)) + 1;
                    startCount = Math.round((Math.log(_this.minReal) * Math.LOG10E));
                    if (gridCountReal > _this.gridCountR) {
                        frequency = Math.ceil(gridCountReal / _this.gridCountR);
                    }
                }
            }
            // LINEAR
            else {
                // the width of one value
                _this.stepWidth = _this.axisWidth / (_this.max - _this.min);
            }

            var numbersAfterDecimal = 0;
            if (_this.step < 1 && _this.step > -1) {
                numbersAfterDecimal = AmCharts.getDecimals(_this.step);
            }

            if (_this.integersOnly) {
                numbersAfterDecimal = 0;
            }

            if (numbersAfterDecimal > _this.maxDecCount) {
                numbersAfterDecimal = _this.maxDecCount;
            }

            var precision = _this.precision;
            if (!isNaN(precision)) {
                numbersAfterDecimal = precision;
            }
            _this.max = AmCharts.roundTo(_this.max, _this.maxDecCount);
            _this.min = AmCharts.roundTo(_this.min, _this.maxDecCount);

            var numberFormatter = {};
            numberFormatter.precision = numbersAfterDecimal;
            numberFormatter.decimalSeparator = chart.nf.decimalSeparator;
            numberFormatter.thousandsSeparator = chart.nf.thousandsSeparator;
            _this.numberFormatter = numberFormatter;

            var axisItem;
            // draw guides
            var guides = _this.guides;
            var count = guides.length;
            if (count > 0) {
                var fillAlphaReal = _this.fillAlpha;
                _this.fillAlpha = 0; // this may seam strange, but is for addValue method not to draw fill
                for (i = 0; i < count; i++) {
                    var guide = guides[i];
                    var guideToCoord = NaN;

                    var above = guide.above;

                    if (!isNaN(guide.toValue)) {
                        guideToCoord = _this.getCoordinate(guide.toValue);
                        axisItem = new _this.axisItemRenderer(this, guideToCoord, "", true, NaN, NaN, guide);
                        _this.pushAxisItem(axisItem, above);
                    }

                    var guideCoord = NaN;

                    if (!isNaN(guide.value)) {
                        guideCoord = _this.getCoordinate(guide.value);
                        var valueShift = (guideToCoord - guideCoord) / 2;
                        axisItem = new _this.axisItemRenderer(this, guideCoord, guide.label, true, NaN, valueShift, guide);
                        _this.pushAxisItem(axisItem, above);
                    }

                    if (!isNaN(guideToCoord - guideCoord)) {
                        var guideFill = new _this.guideFillRenderer(this, guideCoord, guideToCoord, guide);
                        _this.pushAxisItem(guideFill, above);
                        var guideFillGraphics = guideFill.graphics();
                        guide.graphics = guideFillGraphics;
                        if (guide.balloonText) {
                            _this.addEventListeners(guideFillGraphics, guide);
                        }
                    }
                }
                _this.fillAlpha = fillAlphaReal;
            }

            var exponential = false;

            var minMant = Number.MAX_VALUE;

            for (i = startCount; i < gridCountReal; i += frequency) {
                var val = AmCharts.roundTo(_this.step * i + _this.min, numbersAfterDecimal);

                if (String(val).indexOf("e") != -1) {
                    exponential = true;

                    var vStrArr = String(val).split("e");
                    var vMant = Number(vStrArr[1]);
                }
            }

            if (_this.duration) {
                _this.maxInterval = AmCharts.getMaxInterval(_this.max, _this.duration);
            }

            var step = _this.step;
            var minorGridEnabled = _this.minorGridEnabled;
            var minorGridStep;
            var minorGridAlpha = _this.minorGridAlpha;

            if (minorGridEnabled) {
                minorGridStep = _this.getMinorGridStep(step, _this.stepWidth * step);
            }

            for (i = startCount; i < gridCountReal; i += frequency) {
                var value = step * i + _this.min;

                value = AmCharts.roundTo(value, _this.maxDecCount + 1);

                if (_this.integersOnly && Math.round(value) != value) {
                    // void
                } else if (!isNaN(precision) && Number(AmCharts.toFixed(value, precision)) != value) {
                    // void
                } else {
                    if (logarithmic === true) {
                        if (value === 0) {
                            value = _this.minReal;
                        }
                        if (degrees > _this.logGridLimit) {
                            value = Math.pow(10, i);
                        }

                        if (String(value).indexOf("e") != -1) {
                            exponential = true;
                        } else {
                            exponential = false;
                        }
                    }

                    var valueText;

                    if (_this.useScientificNotation) {
                        exponential = true;
                    }

                    if (_this.usePrefixes) {
                        exponential = false;
                    }

                    if (!exponential) {
                        if (logarithmic) {
                            var temp = String(value).split(".");
                            if (temp[1]) {
                                numberFormatter.precision = temp[1].length;
                                //added in 3.4.3 to fix floating point
                                if(i < 0){
                                    numberFormatter.precision = Math.abs(i);
                                }
                                // end of 3.4.3

                            } else {
                                numberFormatter.precision = -1;
                            }
                        }

                        if (_this.usePrefixes) {
                            valueText = AmCharts.addPrefix(value, chart.prefixesOfBigNumbers, chart.prefixesOfSmallNumbers, numberFormatter, true);
                        } else {
                            valueText = AmCharts.formatNumber(value, numberFormatter, numberFormatter.precision);
                        }

                    } else {
                        if (String(value).indexOf("e") == -1) {
                            valueText = value.toExponential(15);
                        } else {
                            valueText = String(value);
                        }

                        var valStrArr = valueText.split("e");
                        var valBase = Number(valStrArr[0]);
                        var valMant = Number(valStrArr[1]);

                        valBase = AmCharts.roundTo(valBase, 14);

                        if (valBase == 10) {
                            valBase = 1;
                            valMant += 1;
                        }

                        valueText = valBase + "e" + valMant;

                        if (value === 0) {
                            valueText = "0";
                        }
                        if (value == 1) {
                            valueText = "1";
                        }
                    }

                    if (_this.duration) {
                        valueText = AmCharts.formatDuration(value, _this.duration, "", _this.durationUnits, _this.maxInterval, numberFormatter);
                    }

                    if (_this.recalculateToPercents) {
                        valueText = valueText + "%";
                    } else {
                        var unit = _this.unit;
                        if (unit) {
                            if (_this.unitPosition == "left") {
                                valueText = unit + valueText;
                            } else {
                                valueText = valueText + unit;
                            }
                        }
                    }
                    if (Math.round(i / labelFrequency) != i / labelFrequency) {
                        valueText = undefined;
                    }

                    if ((i === 0 && !showFirstLabel) || (i == (gridCountReal - 1) && !showLastLabel)) {
                        valueText = " ";
                    }

                    coord = _this.getCoordinate(value);

                    if (_this.labelFunction) {
                        valueText = _this.labelFunction(value, valueText, this).toString();
                    }

                    axisItem = new _this.axisItemRenderer(this, coord, valueText);
                    _this.pushAxisItem(axisItem);

                    if (value == _this.baseValue && chart.type != "radar") {
                        var xx;
                        var yy;

                        var ww = _this.viW;
                        var hh = _this.viH;
                        var vx = _this.viX;
                        var vy = _this.viY;

                        if (_this.orientation == "H") {
                            if (coord >= 0 && coord <= ww + 1) {
                                xx = [coord, coord, coord + dx];
                                yy = [hh, 0, dy];
                            }
                        } else {
                            if (coord >= 0 && coord <= hh + 1) {
                                xx = [0, ww, ww + dx];
                                yy = [coord, coord, coord + dy];
                            }
                        }

                        if (xx) {
                            var gridAlpha = AmCharts.fitToBounds(_this.gridAlpha * 2, 0, 1);

                            var grid0 = AmCharts.line(chart.container, xx, yy, _this.gridColor, gridAlpha, 1, _this.dashLength);
                            grid0.translate(vx, vy);
                            _this.grid0 = grid0;
                            chart.axesSet.push(grid0);
                            grid0.toBack();
                        }
                    }

                    // minor grid
                    if (!isNaN(minorGridStep) && minorGridAlpha > 0 && i < gridCountReal - 1) {
                        // change it temporary
                        var realAlpha = _this.gridAlpha;
                        _this.gridAlpha = _this.minorGridAlpha;
                        for (var m = 1; m < step / minorGridStep; m++) {
                            var minorCoord = _this.getCoordinate(value + minorGridStep * m);
                            var minorAxisItem = new _this.axisItemRenderer(this, minorCoord, "", false, 0, 0, false, false, 0, true);
                            _this.pushAxisItem(minorAxisItem);
                        }
                        _this.gridAlpha = realAlpha;
                    }
                }
            }

            // BASE VALUE
            var base = _this.baseValue;

            // if the min is > 0, then the base value is equal to min
            if (_this.min > _this.baseValue && _this.max > _this.baseValue) {
                base = _this.min;
            }

            // if both min and max are less then zero, then the base value is equal to max
            if (_this.min < _this.baseValue && _this.max < _this.baseValue) {
                base = _this.max;
            }

            if (logarithmic && base < _this.minReal) {
                base = _this.minReal;
            }

            _this.baseCoord = _this.getCoordinate(base);

            var name = "axisChanged";
            var event = {
                type: name,
                target: _this,
                chart: chart
            };

            if (logarithmic) {
                event.min = _this.minReal;
            } else {
                event.min = _this.min;
            }
            event.max = _this.max;

            _this.fire(name, event);

            _this.axisCreated = true;
        } else {
            hide = true;
        }

        var axisLineSet = _this.axisLine.set;
        var labelsSet = _this.labelsSet;

        _this.positionTitle();

        if (chart.type != "radar") {
            var viX = _this.viX;
            var viY = _this.viY;
            set.translate(viX, viY);
            labelsSet.translate(viX, viY);
        } else {
            axisLineSet.toFront();
        }

        if (!_this.visible || hide) {
            set.hide();
            axisLineSet.hide();
            labelsSet.hide();
        } else {
            set.show();
            axisLineSet.show();
            labelsSet.show();
        }

        _this.axisY = _this.y - _this.viY;
        _this.axisX = _this.x - _this.viX;
    },


    getMinorGridStep: function (step, width) {
        var gridCount = [5, 4, 2];

        if (width < 60) {
            gridCount.shift();
        }

        var stepE = Math.floor(Math.log(Math.abs(step)) * Math.LOG10E);
        for (var i = 0; i < gridCount.length; i++) {
            var minorStep = step / gridCount[i];
            var minorStepE = Math.floor(Math.log(Math.abs(minorStep)) * Math.LOG10E);

            if (Math.abs(stepE - minorStepE) > 0) {
                continue;
            }

            if (step < 1) {
                var tempStep = Math.pow(10, -minorStepE) * minorStep;

                if (tempStep == Math.round(tempStep)) {
                    return minorStep;
                }
            } else {
                if (minorStep == Math.round(minorStep)) {
                    return minorStep;
                }
            }
        }
    },

    stackGraphs: function (type) {
        var _this = this;
        var stackType = _this.stackType;
        if (stackType == "stacked") {
            stackType = "regular";
        }
        if (stackType == "line") {
            stackType = "none";
        }
        if (stackType == "100% stacked") {
            stackType = "100%";
        }
        _this.stackType = stackType;

        var previousValues = [];
        var previousNegativeValues = [];
        var previousPositiveValues = [];
        var sum = [];
        var value;
        var graphs = _this.chart.graphs;
        var previousGraph;
        var graphType;
        var graph;
        var graphDataItem;
        var j;
        var i;
        var baseValue = _this.baseValue;

        var linetype = false;
        if (type == "line" || type == "step" || type == "smoothedLine") {
            linetype = true;
        }

        // set stackGraphs (tells the graph to which graph it is stacked)
        if (linetype && (stackType == "regular" || stackType == "100%")) {
            for (j = 0; j < graphs.length; j++) {
                graph = graphs[j];

                if (!graph.hidden) {
                    graphType = graph.type;

                    if (graph.chart == _this.chart && graph.valueAxis == this && type == graphType && graph.stackable) {
                        if (previousGraph) {
                            graph.stackGraph = previousGraph;
                            previousGraph = graph;
                        } else {
                            previousGraph = graph;
                        }
                    }
                }
            }
        }



        // do the calculations
        for (i = _this.start; i <= _this.end; i++) {
            var maxDecCount = 0;
            for (j = 0; j < graphs.length; j++) {
                graph = graphs[j];
                if (!graph.hidden) {
                    graphType = graph.type;

                    if (graph.chart == _this.chart && graph.valueAxis == this && type == graphType && graph.stackable) {
                        graphDataItem = _this.data[i].axes[_this.id].graphs[graph.id];

                        value = graphDataItem.values.value;

                        if (!isNaN(value)) {
                            var numbersAfterDecimal = AmCharts.getDecimals(value);
                            if (maxDecCount < numbersAfterDecimal) {
                                maxDecCount = numbersAfterDecimal;
                            }

                            if (isNaN(sum[i])) {
                                sum[i] = Math.abs(value);
                            } else {
                                sum[i] += Math.abs(value);
                            }

                            sum[i] = AmCharts.roundTo(sum[i], maxDecCount);

                            // LINE AND STEP
                            // for the bands, if no stack set but fillToGraph is set
                            var fillToGraph = graph.fillToGraph;
                            if (linetype && fillToGraph) {
                                var fillToDataItem = _this.data[i].axes[_this.id].graphs[fillToGraph.id];
                                if (fillToDataItem) {
                                    graphDataItem.values.open = fillToDataItem.values.value;
                                }
                            }


                            if (stackType == "regular") {
                                // LINE AND STEP
                                if (linetype) {
                                    // if previous value is not present
                                    if (isNaN(previousValues[i])) {
                                        previousValues[i] = value;
                                        graphDataItem.values.close = value;
                                        graphDataItem.values.open = _this.baseValue;
                                    }
                                    // if previous value is present
                                    else {
                                        if (isNaN(value)) {
                                            graphDataItem.values.close = previousValues[i];
                                            graphDataItem.values.open = previousValues[i];
                                        } else {
                                            graphDataItem.values.close = value + previousValues[i];
                                            graphDataItem.values.open = previousValues[i];
                                        }
                                        previousValues[i] = graphDataItem.values.close;
                                    }
                                }

                                // COLUMN
                                if (type == "column") {
                                    if (!isNaN(value)) {

                                        if(graph.newStack){
                                            previousPositiveValues[i] = NaN;
                                            previousNegativeValues[i] = NaN;
                                        }

                                        graphDataItem.values.close = value;

                                        if (value < 0) {
                                            graphDataItem.values.close = value;
                                            if (!isNaN(previousNegativeValues[i])) {
                                                graphDataItem.values.close += previousNegativeValues[i];
                                                graphDataItem.values.open = previousNegativeValues[i];
                                            } else {
                                                graphDataItem.values.open = baseValue;
                                            }
                                            previousNegativeValues[i] = graphDataItem.values.close;
                                        } else {
                                            graphDataItem.values.close = value;
                                            if (!isNaN(previousPositiveValues[i])) {
                                                graphDataItem.values.close += previousPositiveValues[i];
                                                graphDataItem.values.open = previousPositiveValues[i];
                                            } else {
                                                graphDataItem.values.open = baseValue;
                                            }
                                            previousPositiveValues[i] = graphDataItem.values.close;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        for (i = _this.start; i <= _this.end; i++) {
            for (j = 0; j < graphs.length; j++) {
                graph = graphs[j];
                if (!graph.hidden) {
                    graphType = graph.type;
                    if (graph.chart == _this.chart && graph.valueAxis == this && type == graphType && graph.stackable) {
                        graphDataItem = _this.data[i].axes[_this.id].graphs[graph.id];
                        value = graphDataItem.values.value;

                        if (!isNaN(value)) {
                            var percents = value / sum[i] * 100;
                            graphDataItem.values.percents = percents;
                            graphDataItem.values.total = sum[i];

                            if (stackType == "100%") {
                                if (isNaN(previousNegativeValues[i])) {
                                    previousNegativeValues[i] = 0;
                                }

                                if (isNaN(previousPositiveValues[i])) {
                                    previousPositiveValues[i] = 0;
                                }

                                if (percents < 0) {
                                    graphDataItem.values.close = AmCharts.fitToBounds(percents + previousNegativeValues[i], -100, 100);
                                    graphDataItem.values.open = previousNegativeValues[i];
                                    previousNegativeValues[i] = graphDataItem.values.close;
                                } else {
                                    // this fixes 100.000000001 error
                                    graphDataItem.values.close = AmCharts.fitToBounds(percents + previousPositiveValues[i], -100, 100);
                                    graphDataItem.values.open = previousPositiveValues[i];
                                    previousPositiveValues[i] = graphDataItem.values.close;
                                }
                            }
                        }
                    }
                }
            }
        }
    },


    recalculate: function () {
        var _this = this;
        var graphs = _this.chart.graphs;
        var j;
        for (j = 0; j < graphs.length; j++) {
            var graph = graphs[j];

            if (graph.valueAxis == this) {
                var fieldName = "value";
                if (graph.type == "candlestick" || graph.type == "ohlc") {
                    fieldName = "open";
                }

                var baseValue;
                var graphDataItem;
                var end = _this.end + 2;
                end = AmCharts.fitToBounds(_this.end + 1, 0, _this.data.length - 1);
                var start = _this.start;

                if (start > 0) {
                    start--;
                }

                var ii;

                var thisStart = _this.start;
                if (graph.compareFromStart) {
                    thisStart = 0;
                }

                for (ii = thisStart; ii <= end; ii++) {
                    graphDataItem = _this.data[ii].axes[_this.id].graphs[graph.id];
                    baseValue = graphDataItem.values[fieldName];

                    if (!isNaN(baseValue)) {
                        break;
                    }
                }

                var i;
                for (i = start; i <= end; i++) {
                    graphDataItem = _this.data[i].axes[_this.id].graphs[graph.id];
                    graphDataItem.percents = {};
                    var values = graphDataItem.values;

                    var k;
                    for (k in values) {
                        if (k != "percents") {
                            var val = values[k];
                            var percent = val / baseValue * 100 - 100;

                            graphDataItem.percents[k] = percent;
                        } else {
                            graphDataItem.percents[k] = values[k];
                        }
                    }
                }
            }
        }
    },


    getMinMax: function () {
        var _this = this;
        var expand = false;
        var chart = _this.chart;
        var graphs = chart.graphs;
        var g;
        for (g = 0; g < graphs.length; g++) {
            var type = graphs[g].type;

            if (type == "line" || type == "step" || type == "smoothedLine") {
                if (_this.expandMinMax) {
                    expand = true;
                }
            }
        }

        if (expand) {
            if (_this.start > 0) {
                _this.start--;
            }

            if (_this.end < _this.data.length - 1) {
                _this.end++;
            }
        }

        if (chart.type == 'serial') {
            if (chart.categoryAxis.parseDates === true && !expand) {
                if (_this.end < _this.data.length - 1) {
                    _this.end++;
                }
            }
        }

        // get min and max
        var minMaxMultiplier = _this.minMaxMultiplier;
        _this.min = _this.getMin(_this.start, _this.end);
        _this.max = _this.getMax();

        var delta = (_this.max - _this.min) * (minMaxMultiplier - 1);
        _this.min -= delta;
        _this.max += delta;

        var guideCount = _this.guides.length;
        if (_this.includeGuidesInMinMax && guideCount > 0) {
            var i;
            for (i = 0; i < guideCount; i++) {
                var guide = _this.guides[i];

                if (guide.toValue < _this.min) {
                    _this.min = guide.toValue;
                }

                if (guide.value < _this.min) {
                    _this.min = guide.value;
                }

                if (guide.toValue > _this.max) {
                    _this.max = guide.toValue;
                }

                if (guide.value > _this.max) {
                    _this.max = guide.value;
                }
            }
        }

        // set defined
        if (!isNaN(_this.minimum)) {
            _this.min = _this.minimum;
        }

        if (!isNaN(_this.maximum)) {
            _this.max = _this.maximum;
        }

        if (_this.min > _this.max) {
            var maxT = _this.max;
            _this.max = _this.min;
            _this.min = maxT;
        }

        // set temp if not reseted
        if (!isNaN(_this.minTemp)) {
            _this.min = _this.minTemp;
        }

        if (!isNaN(_this.maxTemp)) {
            _this.max = _this.maxTemp;
        }

        _this.minReal = _this.min;
        _this.maxReal = _this.max;

        if (_this.min === 0 && _this.max === 0) {
            _this.max = 9;
        }

        if (_this.min > _this.max) {
            _this.min = _this.max - 1;
        }

        var initialMin = _this.min; //initial minimum
        var initialMax = _this.max; //initial maximum
        var dif = _this.max - _this.min; //difference
        var difE; //row of difference
        if (dif === 0) {
            // difference is 0 if all values of the period are equal
            // then difference will be
            difE = Math.pow(10, Math.floor(Math.log(Math.abs(_this.max)) * Math.LOG10E)) / 10;
        } else {
            difE = Math.pow(10, Math.floor(Math.log(Math.abs(dif)) * Math.LOG10E)) / 10;
        }

        // new min and max
        if (isNaN(_this.maximum) && isNaN(_this.maxTemp)) {
            _this.max = Math.ceil(_this.max / difE) * difE + difE;
        }

        if (isNaN(_this.minimum) && isNaN(_this.minTemp)) {
            _this.min = Math.floor(_this.min / difE) * difE - difE;
        }

        if (_this.min < 0 && initialMin >= 0) { //min is zero if initial min > 0
            _this.min = 0;
        }

        if (_this.max > 0 && initialMax <= 0) { //min is zero if initial min > 0
            _this.max = 0;
        }

        if (_this.stackType == "100%") {
            if (_this.min < 0) {
                _this.min = -100;
            } else {
                _this.min = 0;
            }

            if (_this.max < 0) {
                _this.max = 0;
            } else {
                _this.max = 100;
            }
        }

        // new difference
        dif = _this.max - _this.min;
        difE = Math.pow(10, Math.floor(Math.log(Math.abs(dif)) * Math.LOG10E)) / 10;

        // aprox size of the step
        _this.step = Math.ceil((dif / _this.gridCountR) / difE) * difE;

        // row of the step
        var stepE = Math.pow(10, Math.floor(Math.log(Math.abs(_this.step)) * Math.LOG10E));
        stepE = _this.fixStepE(stepE);

        var temp = Math.ceil(_this.step / stepE); //number from 1 to 10
        if (temp > 5) {
            temp = 10;
        }

        if (temp <= 5 && temp > 2) {
            temp = 5;
        }

        //real step
        _this.step = Math.ceil(_this.step / (stepE * temp)) * stepE * temp;

        if (stepE < 1) {
            _this.maxDecCount = Math.abs(Math.log(Math.abs(stepE)) * Math.LOG10E);
            _this.maxDecCount = Math.round(_this.maxDecCount);
            _this.step = AmCharts.roundTo(_this.step, _this.maxDecCount + 1);
        } else {
            _this.maxDecCount = 0;
        }

        _this.min = _this.step * Math.floor(_this.min / _this.step);
        _this.max = _this.step * Math.ceil(_this.max / _this.step);

        if (_this.min < 0 && initialMin >= 0) { //min is zero if initial min > 0
            _this.min = 0;
        }

        if (_this.max > 0 && initialMax <= 0) { //min is zero if initial min > 0
            _this.max = 0;
        }

        // tweek real min
        // round
        if (_this.minReal > 1 && _this.max - _this.minReal > 1) {
            _this.minReal = Math.floor(_this.minReal);
        }

        dif = (Math.pow(10, Math.floor(Math.log(Math.abs(_this.minReal)) * Math.LOG10E)));

        // find next after zero
        if (_this.min === 0) {
            _this.minReal = dif;
        }
        if (_this.min === 0 && _this.minReal > 1) {
            _this.minReal = 1;
        }

        if (_this.min > 0 && _this.minReal - _this.step > 0) {
            if (_this.min + _this.step < _this.minReal) {
                _this.minReal = _this.min + _this.step;
            } else {
                _this.minReal = _this.min;
            }
        }

        var degrees = Math.log(initialMax) * Math.LOG10E - Math.log(initialMin) * Math.LOG10E;

        if (_this.logarithmic) {
            if (degrees > 2) {
                _this.min = Math.pow(10, Math.floor(Math.log(Math.abs(initialMin)) * Math.LOG10E));
                _this.minReal = _this.min;
                _this.max = Math.pow(10, Math.ceil(Math.log(Math.abs(initialMax)) * Math.LOG10E));
            } else {
                var minE = Math.pow(10, Math.floor(Math.log(Math.abs(_this.min)) * Math.LOG10E)) / 10;
                var minRealE = Math.pow(10, Math.floor(Math.log(Math.abs(initialMin)) * Math.LOG10E)) / 10;

                if (minE < minRealE) {
                    _this.min = 10 * minRealE;
                    _this.minReal = _this.min;
                }
            }
        }
    },

    fixStepE: function (stepE) {
        // fix step e beacuse of roundoff problem
        var stepExp = stepE.toExponential(0);
        var stepExpArr = stepExp.split("e");
        var base = Number(stepExpArr[0]);
        var mant = Number(stepExpArr[1]);
        if (base == 9) {
            mant++;
        }
        return this.generateNumber(1, mant);
    },

    generateNumber: function (num, mant) {
        var zeroes = "";
        var n;

        if (mant < 0) {
            n = Math.abs(mant) - 1;
        } else {
            n = Math.abs(mant);
        }

        var i;
        for (i = 0; i < n; i++) {
            zeroes = zeroes + "0";
        }
        if (mant < 0) {
            return Number("0." + zeroes + String(num));
        } else {
            return Number(String(num) + zeroes);
        }
    },


    getMin: function (start, end) {
        var _this = this;
        var min;

        var i;
        for (i = start; i <= end; i++) {
            var graphs = _this.data[i].axes[_this.id].graphs;

            var j;
            for (j in graphs) {
                if (graphs.hasOwnProperty(j)) {
                    var graph = _this.chart.getGraphById(j);

                    if (graph.includeInMinMax) {
                        if (!graph.hidden || _this.includeHidden) {
                            if (isNaN(min)) {
                                min = Infinity;
                            }

                            _this.foundGraphs = true;

                            var values = graphs[j].values;
                            if (_this.recalculateToPercents) {
                                values = graphs[j].percents;
                            }

                            var val;

                            if (_this.minMaxField) {
                                val = values[_this.minMaxField];

                                if (val < min) {
                                    min = val;
                                }
                            } else {
                                var k;
                                for (k in values) {
                                    if (values.hasOwnProperty(k)) {
                                        if (k != "percents" && k != "total") {
                                            val = values[k];
                                            if (val < min) {
                                                min = val;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        return min;
    },


    getMax: function () {
        var _this = this;
        var max;
        var i;

        for (i = _this.start; i <= _this.end; i++) {
            var graphs = _this.data[i].axes[_this.id].graphs;

            var j;
            for (j in graphs) {
                if (graphs.hasOwnProperty(j)) {
                    var graph = _this.chart.getGraphById(j);
                    if (graph.includeInMinMax) {
                        if (!graph.hidden || _this.includeHidden) {
                            if (isNaN(max)) {
                                max = -Infinity;
                            }

                            _this.foundGraphs = true;

                            var values = graphs[j].values;
                            if (_this.recalculateToPercents) {
                                values = graphs[j].percents;
                            }

                            var val;

                            if (_this.minMaxField) {
                                val = values[_this.minMaxField];

                                if (val > max) {
                                    max = val;
                                }
                            } else {
                                var k;
                                for (k in values) {
                                    if (values.hasOwnProperty(k)) {
                                        if (k != "percents" && k != "total") {
                                            val = values[k];
                                            if (val > max) {
                                                max = val;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        return max;
    },


    dispatchZoomEvent: function (startValue, endValue) {
        var _this = this;
        var event = {
            type: "axisZoomed",
            startValue: startValue,
            endValue: endValue,
            target: _this,
            chart: _this.chart
        };
        _this.fire(event.type, event);
    },


    zoomToValues: function (startValue, endValue) {
        var _this = this;
        if (endValue < startValue) {
            var temp = endValue;
            endValue = startValue;
            startValue = temp;
        }

        if (startValue < _this.min) {
            startValue = _this.min;
        }

        if (endValue > _this.max) {
            endValue = _this.max;
        }

        var event = {};
        event.type = "axisSelfZoomed";
        event.chart = _this.chart;
        event.valueAxis = _this;
        event.multiplier = _this.axisWidth / Math.abs((_this.getCoordinate(endValue) - _this.getCoordinate(startValue)));

        if (_this.orientation == "V") {
            if (_this.reversed) {
                event.position = _this.getCoordinate(startValue);
            } else {
                event.position = _this.getCoordinate(endValue);
            }
        } else {
            if (_this.reversed) {
                event.position = _this.getCoordinate(endValue);
            } else {
                event.position = _this.getCoordinate(startValue);
            }
        }

        _this.fire(event.type, event);
    },


    coordinateToValue: function (coordinate) {
        var _this = this;
        if (isNaN(coordinate)) {
            return NaN;
        }

        var value;
        var axisWidth = _this.axisWidth;
        var stepWidth = _this.stepWidth;
        var reversed = _this.reversed;
        var rotate = _this.rotate;
        var min = _this.min;
        var minReal = _this.minReal;

        // LOGARITHMIC
        if (_this.logarithmic === true) {
            var degree;

            if (rotate) {
                // REVERSED
                if (reversed === true) {
                    degree = (axisWidth - coordinate) / stepWidth;
                }
                // NOT REVERSED
                else {
                    degree = coordinate / stepWidth;
                }
            } else {
                // REVERSED
                if (reversed === true) {
                    degree = coordinate / stepWidth;
                }
                // NOT REVERSED
                else {
                    degree = (axisWidth - coordinate) / stepWidth;
                }
            }
            value = Math.pow(10, degree + Math.log(minReal) * Math.LOG10E);
        }

        // LINEAR (SIMPLE)
        else {
            // REVERSED
            if (reversed === true) {
                if (rotate) {
                    value = min - (coordinate - axisWidth) / stepWidth;
                } else {
                    value = coordinate / stepWidth + min;
                }
            }
            // NOT REVERSED
            else {
                if (rotate) {
                    value = coordinate / stepWidth + min;
                } else {
                    value = min - (coordinate - axisWidth) / stepWidth;
                }
            }
        }
        return value;
    },


    getCoordinate: function (value) {
        var _this = this;
        if (isNaN(value)) {
            return NaN;
        }
        var rotate = _this.rotate;
        var reversed = _this.reversed;
        var coord;
        var axisWidth = _this.axisWidth;
        var stepWidth = _this.stepWidth;
        var min = _this.min;
        var minReal = _this.minReal;

        // LOGARITHMIC
        if (_this.logarithmic === true) {
            var degree = (Math.log(value) * Math.LOG10E) - Math.log(minReal) * Math.LOG10E;
            if (rotate) {
                // REVERSED
                if (reversed === true) {
                    coord = axisWidth - stepWidth * degree;
                }
                // NOT REVERSED
                else {
                    coord = stepWidth * degree;
                }
            } else {
                // REVERSED
                if (reversed === true) {
                    coord = stepWidth * degree;
                }
                // NOT REVERSED
                else {
                    coord = axisWidth - stepWidth * degree;
                }
            }
        }
        // LINEAR (SIMPLE)
        else {
            // REVERSED
            if (reversed === true) {
                if (rotate) {
                    coord = axisWidth - stepWidth * (value - min);
                } else {
                    coord = stepWidth * (value - min);
                }
            }
            // NOT REVERSED
            else {
                if (rotate) {
                    coord = stepWidth * (value - min);
                } else {
                    coord = axisWidth - stepWidth * (value - min);
                }
            }
        }

        if (_this.rotate) {
            coord += _this.x - _this.viX;
        } else {
            coord += _this.y - _this.viY;
        }

        return Math.round(coord);
    },

    /**
     * One value axis can be synchronized with another value axis.
     * You should set synchronizationMultiplier in order for this to work.
     */
    synchronizeWithAxis: function (value) {
        var _this = this;
        _this.synchronizeWith = value;
        _this.listenTo(_this.synchronizeWith, "axisChanged", _this.handleSynchronization);
    },


    handleSynchronization: function (event) {
        var _this = this;
        var synchronizeWith = _this.synchronizeWith;
        var syncMin = synchronizeWith.min;
        var syncMax = synchronizeWith.max;
        var syncStep = synchronizeWith.step;

        var synchronizationMultiplier = _this.synchronizationMultiplier;

        if (synchronizationMultiplier) {
            _this.min = syncMin * synchronizationMultiplier;
            _this.max = syncMax * synchronizationMultiplier;
            _this.step = syncStep * synchronizationMultiplier;

            var stepE = Math.pow(10, Math.floor(Math.log(Math.abs(_this.step)) * Math.LOG10E));

            var maxDecCount = Math.abs(Math.log(Math.abs(stepE)) * Math.LOG10E);
            maxDecCount = Math.round(maxDecCount);

            _this.maxDecCount = maxDecCount;

            _this.draw();
        }
    }

});// @tag amchart
AmCharts.CategoryAxis = AmCharts.Class({

    inherits: AmCharts.AxisBase,

    construct: function(theme) {
        var _this = this;
        _this.cname = "CategoryAxis";
        AmCharts.CategoryAxis.base.construct.call(_this, theme);
        _this.minPeriod = "DD";
        _this.parseDates = false;
        _this.equalSpacing = false;
        _this.position = "bottom";
        _this.startOnAxis = false;
        _this.firstDayOfWeek = 1;
        _this.gridPosition = "middle";
        _this.boldPeriodBeginning = true;
        _this.markPeriodChange = true;
        _this.safeDistance = 30;
        _this.centerLabelOnFullPeriod = true;
        //_this.categoryFunction;
        _this.periods = [{
            period: "ss",
            count: 1
        }, {
            period: "ss",
            count: 5
        }, {
            period: "ss",
            count: 10
        }, {
            period: "ss",
            count: 30
        }, {
            period: "mm",
            count: 1
        }, {
            period: "mm",
            count: 5
        }, {
            period: "mm",
            count: 10
        }, {
            period: "mm",
            count: 30
        }, {
            period: "hh",
            count: 1
        }, {
            period: "hh",
            count: 3
        }, {
            period: "hh",
            count: 6
        }, {
            period: "hh",
            count: 12
        }, {
            period: "DD",
            count: 1
        }, {
            period: "DD",
            count: 2
        }, {
            period: "DD",
            count: 3
        }, {
            period: "DD",
            count: 4
        }, {
            period: "DD",
            count: 5
        }, {
            period: "WW",
            count: 1
        }, {
            period: "MM",
            count: 1
        }, {
            period: "MM",
            count: 2
        }, {
            period: "MM",
            count: 3
        }, {
            period: "MM",
            count: 6
        }, {
            period: "YYYY",
            count: 1
        }, {
            period: "YYYY",
            count: 2
        }, {
            period: "YYYY",
            count: 5
        }, {
            period: "YYYY",
            count: 10
        }, {
            period: "YYYY",
            count: 50
        }, {
            period: "YYYY",
            count: 100
        }];

        _this.dateFormats = [{
            period: 'fff',
            format: 'JJ:NN:SS'
        }, {
            period: 'ss',
            format: 'JJ:NN:SS'
        }, {
            period: 'mm',
            format: 'JJ:NN'
        }, {
            period: 'hh',
            format: 'JJ:NN'
        }, {
            period: 'DD',
            format: 'MMM DD'
        }, {
            period: 'WW',
            format: 'MMM DD'
        }, {
            period: 'MM',
            format: 'MMM'
        }, {
            period: 'YYYY',
            format: 'YYYY'
        }];

        _this.nextPeriod = {};
        _this.nextPeriod.fff = "ss";
        _this.nextPeriod.ss = "mm";
        _this.nextPeriod.mm = "hh";
        _this.nextPeriod.hh = "DD";
        _this.nextPeriod.DD = "MM";
        _this.nextPeriod.MM = "YYYY";

        AmCharts.applyTheme(_this, theme, _this.cname);
    },


    draw: function() {
        var _this = this;
        AmCharts.CategoryAxis.base.draw.call(_this);

        _this.generateDFObject();

        var data = _this.chart.chartData;
        _this.data = data;

        if (AmCharts.ifArray(data)) {
            var i;
            var chart = _this.chart;
            var end = _this.end;
            var start = _this.start;
            var labelFrequency = _this.labelFrequency;
            var startFrom = 0;
            var valueCount = end - start + 1;
            var gridCount = _this.gridCountR;
            var showFirstLabel = _this.showFirstLabel;
            var showLastLabel = _this.showLastLabel;
            var coord;
            var valueText = "";
            var minPeriodObj = AmCharts.extractPeriod(_this.minPeriod);
            var minDuration = AmCharts.getPeriodDuration(minPeriodObj.period, minPeriodObj.count);
            var periodObj;
            var periodMultiplier;
            var period;
            var periodDuration;
            var periodReal;
            var previousTime;
            var previousTimeReal;
            var periodWidth;
            var periodCount;
            var time;
            var biggerPeriodChanged;
            var dateFormat;
            var realStartFrom;
            var rotate = _this.rotate;
            var firstDayOfWeek = _this.firstDayOfWeek;
            var boldPeriodBeginning = _this.boldPeriodBeginning;
            var lastTime = data[data.length - 1].time;
            var maxTime = AmCharts.resetDateToMin(new Date(lastTime + minDuration * 1.05), _this.minPeriod, 1, firstDayOfWeek).getTime();
            var bold;
            var axisItem;
            var UNDEFINED;

            if (_this.endTime > maxTime) {
                _this.endTime = maxTime;
            }

            var minorGridEnabled = _this.minorGridEnabled;
            var minorGridFrequency;
            var gridAlphaReal = _this.gridAlpha;
            var minorPeriodDuration;
            var mAxisItem;

            // PARSE DATES

            if (_this.parseDates && !_this.equalSpacing) {

                _this.timeDifference = _this.endTime - _this.startTime;

                periodObj = _this.choosePeriod(0);

                period = periodObj.period;
                periodMultiplier = periodObj.count;

                periodDuration = AmCharts.getPeriodDuration(period, periodMultiplier);

                // check if this period is not shorter then minPeriod
                if (periodDuration < minDuration) {
                    period = minPeriodObj.period;
                    periodMultiplier = minPeriodObj.count;
                    periodDuration = minDuration;
                }

                periodReal = period;
                // weeks don't have format, swith to days
                if (periodReal == "WW") {
                    periodReal = "DD";
                }
                _this.stepWidth = _this.getStepWidth(_this.timeDifference);

                gridCount = Math.ceil(_this.timeDifference / periodDuration) + 5;

                //previousTime = AmCharts.resetDateToMin(new Date(_this.startTime - periodDuration * periodMultiplier), period, periodMultiplier, firstDayOfWeek).getTime();
                // 2.10.7
                previousTime = AmCharts.resetDateToMin(new Date(_this.startTime - periodDuration), period, periodMultiplier, firstDayOfWeek).getTime();

                var startTime = previousTime;

                // if this is pure period (no numbers and not a week), place the value in the middle
                if (periodReal == period && periodMultiplier == 1 && _this.centerLabelOnFullPeriod) {
                    periodWidth = periodDuration * _this.stepWidth;
                }

                _this.cellWidth = minDuration * _this.stepWidth;


                periodCount = Math.round(previousTime / periodDuration);

                start = -1;
                if (periodCount / 2 == Math.round(periodCount / 2)) {
                    start = -2;
                    previousTime -= periodDuration;
                }

                var initialTime = chart.firstTime;
                // delta time is used to fix a problem which happens because month duration is not the same all the time
                var deltaTime = 0;

                if (minorGridEnabled && periodMultiplier > 1) {
                    minorGridFrequency = _this.chooseMinorFrequency(periodMultiplier);
                    minorPeriodDuration = AmCharts.getPeriodDuration(period, minorGridFrequency);
                }

                if (_this.gridCountR > 0) {
                    for (i = start; i <= gridCount; i++) {
                        //time = previousTime + periodDuration * 1.1;
                        time = initialTime + periodDuration * (i + Math.floor((startTime - initialTime) / periodDuration)) - deltaTime;

                        if (period == "DD") {
                            time += 3600000; // this should fix daylight saving errors - otherwise double grid appears or the gap between grid lines is bigger
                        }
                        time = AmCharts.resetDateToMin(new Date(time), period, periodMultiplier, firstDayOfWeek).getTime();

                        //if (time != previousTime) {
                            // fixing not equal month duration problem
                            if (period == "MM") {
                                var mult = (time - previousTime) / periodDuration;
                                if ((time - previousTime) / periodDuration >= 1.5) {
                                    //time = time - (mult - 1) * periodDuration; 3.3.6
                                    time = time - (mult - 1) * periodDuration + AmCharts.getPeriodDuration("DD", 3); // add extra 3 days, as month length is not equal and might remove too much sometimes
                                    time = AmCharts.resetDateToMin(new Date(time), period, 1).getTime(); // this is new (3.3.7), as we add 3 days above
                                    deltaTime += periodDuration;
                                }
                            }

                            coord = (time - _this.startTime) * _this.stepWidth;

                            biggerPeriodChanged = false;

                            if (_this.nextPeriod[periodReal]) {
                                biggerPeriodChanged = _this.checkPeriodChange(_this.nextPeriod[periodReal], 1, time, previousTime, periodReal);
                            }

                            bold = false;

                            if (biggerPeriodChanged && _this.markPeriodChange) {
                                dateFormat = _this.dateFormatsObject[_this.nextPeriod[periodReal]];

                                if(_this.twoLineMode){
                                    dateFormat =  _this.dateFormatsObject[periodReal] + "\n" + dateFormat;
                                    dateFormat = AmCharts.fixBrakes(dateFormat);
                                }
                                bold = true;
                            } else {
                                dateFormat = _this.dateFormatsObject[periodReal];
                            }

                            if (!boldPeriodBeginning) {
                                bold = false;
                            }

                            valueText = AmCharts.formatDate(new Date(time), dateFormat);

                            if ((i == start && !showFirstLabel) || (i == gridCount && !showLastLabel)) {
                                valueText = " ";
                            }

                            if (_this.labelFunction) {
                                valueText = _this.labelFunction(valueText, new Date(time), this, period, periodMultiplier, previousTimeReal).toString();
                            }

                            // draw grid
                            axisItem = new _this.axisItemRenderer(this, coord, valueText, false, periodWidth, 0, false, bold);
                            _this.pushAxisItem(axisItem);

                            previousTime = time;
                            previousTimeReal = time;

                            // minor grid
                            if (!isNaN(minorGridFrequency)) {
                                for (var g = 1; g < periodMultiplier; g = g + minorGridFrequency) {
                                    _this.gridAlpha = _this.minorGridAlpha;
                                    //var mtime = time + minorPeriodDuration * (g + 0.1 + Math.floor((startTime - initialTime) / minorPeriodDuration));
                                    var mtime = time + minorPeriodDuration * g;
                                    mtime = AmCharts.resetDateToMin(new Date(mtime), period, minorGridFrequency, firstDayOfWeek).getTime();
                                    var mcoord = (mtime - _this.startTime) * _this.stepWidth;
                                    mAxisItem = new _this.axisItemRenderer(this, mcoord);
                                    _this.pushAxisItem(mAxisItem);
                                }
                            }
                            _this.gridAlpha = gridAlphaReal;
                       // }
                    }
                }
            }
            // DO NOT PARSE DATES
            else if (!_this.parseDates) {
                _this.cellWidth = _this.getStepWidth(valueCount);

                // in case there are more values when gridlines, fix the gridCount
                if (valueCount < gridCount) {
                    gridCount = valueCount;
                }

                startFrom += _this.start;

                _this.stepWidth = _this.getStepWidth(valueCount);

                if (gridCount > 0) {
                    var gridFrequency = Math.floor(valueCount / gridCount);
                    minorGridFrequency = _this.chooseMinorFrequency(gridFrequency);

                    realStartFrom = startFrom;
                    if (realStartFrom / 2 == Math.round(realStartFrom / 2)) {
                        realStartFrom--;
                    }

                    if (realStartFrom < 0) {
                        realStartFrom = 0;
                    }

                    var realCount = 0;

                    if(_this.end - realStartFrom + 1 >= _this.autoRotateCount){
                        _this.labelRotation = _this.autoRotateAngle;
                    }

                    for (i = realStartFrom; i <= _this.end + 2; i++) {
                        var sDataItem;
                        var forceShow = false;
                        if (i >= 0 && i < _this.data.length) {
                            sDataItem = _this.data[i];
                            valueText = sDataItem.category;
                            forceShow = sDataItem.forceShow;
                        } else {
                            valueText = "";
                        }

                        if (minorGridEnabled && !isNaN(minorGridFrequency)) {
                            if (i / minorGridFrequency != Math.round(i / minorGridFrequency) && !forceShow) {
                                continue;
                            } else {
                                if (i / gridFrequency == Math.round(i / gridFrequency) || forceShow) {

                                } else {
                                    _this.gridAlpha = _this.minorGridAlpha;
                                    valueText = UNDEFINED;
                                }
                            }
                        } else {
                            if (i / gridFrequency != Math.round(i / gridFrequency) && !forceShow) {
                                continue;
                            }
                        }

                        coord = _this.getCoordinate(i - startFrom);
                        var vShift = 0;
                        if (_this.gridPosition == "start") {
                            coord = coord - _this.cellWidth / 2;
                            vShift = _this.cellWidth / 2;
                        }

                        if ((i == start && !showFirstLabel) || (i == _this.end && !showLastLabel)) {
                            valueText = UNDEFINED;
                        }

                        if (Math.round(realCount / labelFrequency) != realCount / labelFrequency) {
                            valueText = UNDEFINED;
                        }

                        realCount++;

                        var cellW = _this.cellWidth;
                        if (rotate) {
                            cellW = NaN;
                        }

                        if (_this.labelFunction && sDataItem) {
                            valueText = _this.labelFunction(valueText, sDataItem, this);
                        }
                        valueText = AmCharts.fixBrakes(valueText);

                        axisItem = new _this.axisItemRenderer(this, coord, valueText, true, cellW, vShift, UNDEFINED, false, vShift);
                        _this.pushAxisItem(axisItem);
                        _this.gridAlpha = gridAlphaReal;
                    }
                }
            }

            // PARSE, BUT EQUAL SPACING
            else if (_this.parseDates && _this.equalSpacing) {
                startFrom = _this.start;
                _this.startTime = _this.data[_this.start].time;
                _this.endTime = _this.data[_this.end].time;

                _this.timeDifference = _this.endTime - _this.startTime;

                periodObj = _this.choosePeriod(0);
                period = periodObj.period;
                periodMultiplier = periodObj.count;
                periodDuration = AmCharts.getPeriodDuration(period, periodMultiplier);

                // check if this period is not shorter then minPeriod
                if (periodDuration < minDuration) {
                    period = minPeriodObj.period;
                    periodMultiplier = minPeriodObj.count;
                    periodDuration = minDuration;
                }

                periodReal = period;
                // weeks don't have format, swith to days
                if (periodReal == "WW") {
                    periodReal = "DD";
                }

                _this.stepWidth = _this.getStepWidth(valueCount);

                gridCount = Math.ceil(_this.timeDifference / periodDuration) + 1;

                previousTime = AmCharts.resetDateToMin(new Date(_this.startTime - periodDuration), period, periodMultiplier, firstDayOfWeek).getTime();

                _this.cellWidth = _this.getStepWidth(valueCount);

                periodCount = Math.round(previousTime / periodDuration);

                start = -1;
                if (periodCount / 2 == Math.round(periodCount / 2)) {
                    start = -2;
                    previousTime -= periodDuration;
                }

                var lastIndex = _this.data.length;

                realStartFrom = _this.start;

                if (realStartFrom / 2 == Math.round(realStartFrom / 2)) {
                    realStartFrom--;
                }

                if (realStartFrom < 0) {
                    realStartFrom = 0;
                }

                var realEnd = _this.end + 2;
                if (realEnd >= _this.data.length) {
                    realEnd = _this.data.length;
                }

                // first must be skipped if more data items then gridcount
                var thisIsFirst = false;

                thisIsFirst = !showFirstLabel;

                _this.previousPos = -1000;

                if (_this.labelRotation > 20) {
                    _this.safeDistance = 5;
                }

                var realRealStartFrom = realStartFrom;
                // find second period change to avoid small gap between first label and the second
                if (_this.data[realStartFrom].time != AmCharts.resetDateToMin(new Date(_this.data[realStartFrom].time), period, periodMultiplier, firstDayOfWeek).getTime()) {
                    var cc = 0;
                    var tempPreviousTime = previousTime;
                    for (i = realStartFrom; i < realEnd; i++) {
                        time = _this.data[i].time;

                        if (_this.checkPeriodChange(period, periodMultiplier, time, tempPreviousTime)) {
                            cc++;
                            if (cc >= 2) {
                                realRealStartFrom = i;
                                i = realEnd;
                            }
                            tempPreviousTime = time;
                        }
                    }
                }

                if (minorGridEnabled && periodMultiplier > 1) {
                    minorGridFrequency = _this.chooseMinorFrequency(periodMultiplier);
                    minorPeriodDuration = AmCharts.getPeriodDuration(period, minorGridFrequency);
                }

                var previousMinorTime;

                for (i = realStartFrom; i < realEnd; i++) {
                    time = _this.data[i].time;

                    if (_this.checkPeriodChange(period, periodMultiplier, time, previousTime) && i >= realRealStartFrom) {

                        coord = _this.getCoordinate(i - _this.start);

                        biggerPeriodChanged = false;
                        if (_this.nextPeriod[periodReal]) {
                            biggerPeriodChanged = _this.checkPeriodChange(_this.nextPeriod[periodReal], 1, time, previousTime, periodReal);
                        }

                        bold = false;
                        if (biggerPeriodChanged && _this.markPeriodChange) {
                            dateFormat = _this.dateFormatsObject[_this.nextPeriod[periodReal]];
                            bold = true;
                        } else {
                            dateFormat = _this.dateFormatsObject[periodReal];
                        }

                        valueText = AmCharts.formatDate(new Date(time), dateFormat);

                        if ((i == start && !showFirstLabel) || (i == gridCount && !showLastLabel)) {
                            valueText = " ";
                        }

                        if (!thisIsFirst) {
                            if (!boldPeriodBeginning) {
                                bold = false;
                            }

                            // draw grid
                            if (coord - _this.previousPos > _this.safeDistance * Math.cos(_this.labelRotation * Math.PI / 180)) {

                                if (_this.labelFunction) {
                                    valueText = _this.labelFunction(valueText, new Date(time), this, period, periodMultiplier, previousTimeReal);
                                }

                                axisItem = new _this.axisItemRenderer(this, coord, valueText, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, bold);

                                var axisItemGraphics = axisItem.graphics();
                                _this.pushAxisItem(axisItem);
                                var graphicsWidth = axisItemGraphics.getBBox().width;
                                if (!AmCharts.isModern) {
                                    graphicsWidth -= coord;
                                }
                                _this.previousPos = coord + graphicsWidth;


                            }
                        } else {
                            thisIsFirst = false;
                        }

                        previousTime = time;
                        previousTimeReal = time;
                    } else {
                        // minor grid
                        if (!isNaN(minorGridFrequency)) {
                            if (_this.checkPeriodChange(period, minorGridFrequency, time, previousMinorTime)) {
                                _this.gridAlpha = _this.minorGridAlpha;
                                coord = _this.getCoordinate(i - _this.start);
                                mAxisItem = new _this.axisItemRenderer(this, coord);
                                _this.pushAxisItem(mAxisItem);
                                previousMinorTime = time;
                            }
                            _this.gridAlpha = gridAlphaReal;
                        }
                    }
                }
            }

            // get x's of all categories
            for (i = 0; i < _this.data.length; i++) {
                var serialDataItem = _this.data[i];
                if (serialDataItem) {
                    var xxx;
                    if (_this.parseDates && !_this.equalSpacing) {
                        var categoryTime = serialDataItem.time;
                        xxx = Math.round((categoryTime - _this.startTime) * _this.stepWidth + _this.cellWidth / 2);
                    } else {
                        xxx = _this.getCoordinate(i - startFrom);
                    }

                    serialDataItem.x[_this.id] = xxx;
                }
            }
            // guides
            var count = _this.guides.length;

            for (i = 0; i < count; i++) {
                var guide = _this.guides[i];
                var guideToCoord = NaN;
                var guideCoord = NaN;
                var valueShift = NaN;
                var toCategoryIndex = NaN;
                var categoryIndex = NaN;
                var above = guide.above;

                if (guide.toCategory) {
                    toCategoryIndex = chart.getCategoryIndexByValue(guide.toCategory);
                    if (!isNaN(toCategoryIndex)) {
                        guideToCoord = _this.getCoordinate(toCategoryIndex - startFrom);
                        axisItem = new _this.axisItemRenderer(this, guideToCoord, "", true, NaN, NaN, guide);
                        _this.pushAxisItem(axisItem, above);
                    }
                }

                if (guide.category) {
                    categoryIndex = chart.getCategoryIndexByValue(guide.category);
                    if (!isNaN(categoryIndex)) {
                        guideCoord = _this.getCoordinate(categoryIndex - startFrom);
                        valueShift = (guideToCoord - guideCoord) / 2;
                        axisItem = new _this.axisItemRenderer(this, guideCoord, guide.label, true, NaN, valueShift, guide);
                        _this.pushAxisItem(axisItem, above);
                    }
                }

                if (guide.toDate) {

                    if(!(guide.toDate instanceof Date)){
                        guide.toDate = AmCharts.stringToDate(guide.toDate, chart.dataDateFormat);
                    }

                    if (_this.equalSpacing) {
                        toCategoryIndex = chart.getClosestIndex(_this.data, "time", guide.toDate.getTime(), false, 0, _this.data.length - 1);
                        if (!isNaN(toCategoryIndex)) {
                            guideToCoord = _this.getCoordinate(toCategoryIndex - startFrom);
                        }
                    } else {
                        guideToCoord = (guide.toDate.getTime() - _this.startTime) * _this.stepWidth;
                    }
                    axisItem = new _this.axisItemRenderer(this, guideToCoord, "", true, NaN, NaN, guide);
                    _this.pushAxisItem(axisItem, above);
                }

                if (guide.date) {
                    if(!(guide.date instanceof Date)){
                        guide.date = AmCharts.stringToDate(guide.date, chart.dataDateFormat);
                    }
                    if (_this.equalSpacing) {
                        categoryIndex = chart.getClosestIndex(_this.data, "time", guide.date.getTime(), false, 0, _this.data.length - 1);
                        if (!isNaN(categoryIndex)) {
                            guideCoord = _this.getCoordinate(categoryIndex - startFrom);
                        }
                    } else {
                        guideCoord = (guide.date.getTime() - _this.startTime) * _this.stepWidth;
                    }

                    valueShift = (guideToCoord - guideCoord) / 2;

                    if (_this.orientation == "H") {
                        axisItem = new _this.axisItemRenderer(this, guideCoord, guide.label, false, valueShift * 2, NaN, guide);
                    } else {
                        axisItem = new _this.axisItemRenderer(this, guideCoord, guide.label, false, NaN, valueShift, guide);
                    }
                    _this.pushAxisItem(axisItem, above);
                }

                var guideFill = new _this.guideFillRenderer(this, guideCoord, guideToCoord, guide);
                var guideFillGraphics = guideFill.graphics();
                _this.pushAxisItem(guideFill, above);
                guide.graphics = guideFillGraphics;
                guideFillGraphics.index = i;

                if (guide.balloonText) {
                    _this.addEventListeners(guideFillGraphics, guide);
                }
            }
        }

        _this.axisCreated = true;

        var xx = _this.x;
        var yy = _this.y;
        _this.set.translate(xx, yy);
        _this.labelsSet.translate(xx, yy);
        _this.positionTitle();
        var axisLine = _this.axisLine.set;
        if (axisLine) {
            axisLine.toFront();
        }

        var currentHeight = _this.getBBox().height;
        if((currentHeight - _this.previousHeight) > 2 && _this.autoWrap && !_this.parseDates){
            _this.chart.marginsUpdated = false;
            _this.axisCreated = false;
        }
        _this.previousHeight = currentHeight;
    },

    chooseMinorFrequency: function(frequency) {
        for (var i = 10; i > 0; i--) {
            if (frequency / i == Math.round(frequency / i)) {
                return frequency / i;
            }
        }
    },


    choosePeriod: function(index) {
        var _this = this;
        var periodDuration = AmCharts.getPeriodDuration(_this.periods[index].period, _this.periods[index].count);
        var count = Math.ceil(_this.timeDifference / periodDuration);
        var periods = _this.periods;

        var gridCount = _this.gridCountR;
        if (_this.timeDifference < periodDuration && index > 0) {
            return periods[index - 1];
        }

        if (count <= gridCount) {
            return periods[index];
        } else {
            if (index + 1 < periods.length) {
                return _this.choosePeriod(index + 1);
            } else {
                return periods[index];
            }
        }
    },

    getStepWidth: function(valueCount) {
        var _this = this;
        var stepWidth;
        if (_this.startOnAxis) {
            stepWidth = _this.axisWidth / (valueCount - 1);

            if (valueCount == 1) {
                stepWidth = _this.axisWidth;
            }
        } else {
            stepWidth = _this.axisWidth / valueCount;
        }
        return stepWidth;
    },

    getCoordinate: function(index) {
        var _this = this;
        var coord = index * _this.stepWidth;

        if (!_this.startOnAxis) {
            coord += _this.stepWidth / 2;
        }

        return Math.round(coord);
    },

    timeZoom: function(startTime, endTime) {
        var _this = this;
        _this.startTime = startTime;
        _this.endTime = endTime;
    },

    minDuration: function() {
        var _this = this;
        var minPeriodObj = AmCharts.extractPeriod(_this.minPeriod);
        return AmCharts.getPeriodDuration(minPeriodObj.period, minPeriodObj.count);
    },

    checkPeriodChange: function(period, count, time, previousTime, previousPeriod) {
        var currentDate = new Date(time);
        var previousDate = new Date(previousTime);

        var firstDayOfWeek = this.firstDayOfWeek;
        var realCount = count;
        if (period == "DD") {
            count = 1;
        }

        var current = AmCharts.resetDateToMin(currentDate, period, count, firstDayOfWeek).getTime();
        var previous = AmCharts.resetDateToMin(previousDate, period, count, firstDayOfWeek).getTime();

        if (period == "DD" && previousPeriod != "hh") {
            if (current - previous <= AmCharts.getPeriodDuration(period, realCount)) {
                return false;
            }
        }

        if (current != previous) {
            return true;
        } else {
            return false;
        }
    },


    generateDFObject: function() {
        var _this = this;
        _this.dateFormatsObject = {};
        var i;
        for (i = 0; i < _this.dateFormats.length; i++) {
            var df = _this.dateFormats[i];
            _this.dateFormatsObject[df.period] = df.format;
        }
    },


    xToIndex: function(x) {
        var _this = this;
        var data = _this.data;
        var chart = _this.chart;
        var rotate = chart.rotate;
        var stepWidth = _this.stepWidth;
        var index;
        if (_this.parseDates && !_this.equalSpacing) {
            var time = _this.startTime + Math.round(x / stepWidth) - _this.minDuration() / 2;
            index = chart.getClosestIndex(data, "time", time, false, _this.start, _this.end + 1);
        } else {
            if (!_this.startOnAxis) {
                x -= stepWidth / 2;
            }
            index = _this.start + Math.round(x / stepWidth);
        }

        index = AmCharts.fitToBounds(index, 0, data.length - 1);

        var indexX;
        if (data[index]) {
            indexX = data[index].x[_this.id];
        }

        if (rotate) {
            if (indexX > _this.height + 1) {
                index--;
            }
            if (indexX < 0) {
                index++;
            }
        } else {
            if (indexX > _this.width + 1) {
                index--;
            }
            if (indexX < 0) {
                index++;
            }
        }

        index = AmCharts.fitToBounds(index, 0, data.length - 1);

        return index;
    },

    dateToCoordinate: function(date) {
        var _this = this;
        if (_this.parseDates && !_this.equalSpacing) {
            return (date.getTime() - _this.startTime) * _this.stepWidth;
        } else if (_this.parseDates && _this.equalSpacing) {
            var index = _this.chart.getClosestIndex(_this.data, "time", date.getTime(), false, 0, _this.data.length - 1);
            return _this.getCoordinate(index - _this.start);
        } else {
            return NaN;
        }
    },

    categoryToCoordinate: function(category) {
        var _this = this;
        if (_this.chart) {
            var index = _this.chart.getCategoryIndexByValue(category);
            return _this.getCoordinate(index - _this.start);
        } else {
            return NaN;
        }
    },

    coordinateToDate: function(coordinate) {
        var _this = this;
        if (_this.equalSpacing) {
            var index = _this.xToIndex(coordinate);
            return new Date(_this.data[index].time);
        } else {
            return new Date(_this.startTime + coordinate / _this.stepWidth);
        }
    }
});// @tag amchart
AmCharts.GaugeArrow = AmCharts.Class({

    construct: function (theme) {
        var _this = this;
        _this.cname = "GaugeArrow";
        _this.color = "#000000";
        _this.alpha = 1;
        _this.nailAlpha = 1;
        _this.nailRadius = 8;
        _this.startWidth = 8;
        _this.endWidth = 0;
        _this.borderAlpha = 1;
        _this.radius = "90%";
        _this.innerRadius = 0;
        _this.nailBorderAlpha = 0;
        _this.nailBorderThickness = 1;
        _this.frame = 0;

        AmCharts.applyTheme(_this, theme, "GaugeArrow");
    },

    setValue: function (value) {
        var _this = this;
        var chart = _this.chart;
        if(!chart){
            _this.value = value;
            _this.previousValue = value;
        }
        else{
            chart.setValue(this, value);
        }
    }

});

AmCharts.GaugeBand = AmCharts.Class({
    construct: function () {
        var _this = this;
        _this.cname = "GaugeBand";
    }

});// @tag amchart
AmCharts.GaugeAxis = AmCharts.Class({

    construct: function (theme) {
        var _this = this;
        _this.cname = "GaugeAxis";
        _this.radius = "95%";
        _this.startAngle = -120;
        _this.endAngle = 120;
        _this.startValue = 0;
        _this.endValue = 200;
        _this.gridCount = 5;
        //_this.valueInterval;
        //_this.minorTickInterval;
        _this.tickLength = 10;
        _this.minorTickLength = 5;
        _this.tickColor = "#555555";
        _this.tickAlpha = 1;
        _this.tickThickness = 1;
        _this.labelFrequency = 1;
        _this.inside = true;
        _this.labelOffset = 10;
        _this.showFirstLabel = true;
        _this.showLastLabel = true;
        _this.axisThickness = 1;
        _this.axisColor = '#000000';
        _this.axisAlpha = 1;
        _this.gridInside = true;
        //_this.topText = "";
        //_this.topTextFontSize;
        //_this.topTextColor;
        _this.topTextYOffset = 0;
        _this.topTextBold = true;

        //_this.bottomText = "";
        //_this.bottomTextFontSize;
        // _this.bottomTextColor
        _this.bottomTextYOffset = 0;
        _this.bottomTextBold = true;
        _this.centerX = "0%";
        _this.centerY = "0%";

        _this.bandOutlineThickness = 0;
        _this.bandOutlineAlpha = 0;
        _this.bandOutlineColor = "#000000";
        _this.bandAlpha = 1;

        AmCharts.applyTheme(_this, theme, "GaugeAxis");
    },

    value2angle: function (value) {
        var _this = this;
        return _this.startAngle + _this.singleValueAngle * value;
    },

    setTopText: function (text) {
        if(text !== undefined){
            var _this = this;
            _this.topText = text;
            var chart = _this.chart;
            if (_this.axisCreated) {

                if (_this.topTF) {
                    _this.topTF.remove();
                }

                var fontSize = _this.topTextFontSize;
                if(!fontSize){
                    fontSize = chart.fontSize;
                }

                var textColor = _this.topTextColor;
                if(!textColor){
                    textColor = chart.color;
                }

                var topTextField = AmCharts.text(chart.container, text, textColor, chart.fontFamily, fontSize, undefined, _this.topTextBold);
                topTextField.translate(_this.centerXReal, _this.centerYReal - _this.radiusReal / 2 + _this.topTextYOffset);
                _this.chart.graphsSet.push(topTextField);
                _this.topTF = topTextField;
            }
        }
    },

    setBottomText: function (text) {
        if(text !== undefined){
            var _this = this;
            _this.bottomText = text;
            var chart = _this.chart;
            if (_this.axisCreated) {

                if (_this.bottomTF) {
                    _this.bottomTF.remove();
                }

                var fontSize = _this.bottomTextFontSize;
                if(!fontSize){
                    fontSize = chart.fontSize;
                }

                var textColor = _this.bottomTextColor;
                if(!textColor){
                    textColor = chart.color;
                }

                var bottomTextField = AmCharts.text(chart.container, text, textColor, chart.fontFamily, fontSize, undefined, _this.bottomTextBold);
                bottomTextField.translate(_this.centerXReal, _this.centerYReal + _this.radiusReal / 2 + _this.bottomTextYOffset);
                _this.bottomTF = bottomTextField;
                _this.chart.graphsSet.push(bottomTextField);
            }
        }
    },

    draw: function () {
        var _this = this;

        var chart = _this.chart;
        var set = chart.graphsSet;

        var UNDEFINED;
        var startValue = _this.startValue;
        var endValue = _this.endValue;

        var valueInterval = _this.valueInterval;

        if(isNaN(valueInterval)){
            var dif = endValue - startValue;
            valueInterval = dif / _this.gridCount;
        }

        var minorTickInterval = _this.minorTickInterval;

        if(isNaN(minorTickInterval)){
            minorTickInterval = valueInterval / 5;
        }

        var startAngle = _this.startAngle;

        var endAngle = _this.endAngle;

        var tickLength = _this.tickLength;

        var majorTickCount = (endValue - startValue) / valueInterval + 1;

        var valueAngle = (endAngle - startAngle) / (majorTickCount - 1);

        var singleValueAngle = valueAngle / valueInterval;

        _this.singleValueAngle = singleValueAngle;

        var container = chart.container;
        var tickColor = _this.tickColor;
        var tickAlpha = _this.tickAlpha;
        var tickThickness = _this.tickThickness;


        var minorTickCount = valueInterval / minorTickInterval;
        var minorValueAngle = valueAngle / minorTickCount;
        var minorTickLength = _this.minorTickLength;
        var labelFrequency = _this.labelFrequency;
        var radius = _this.radiusReal;

        if (!_this.inside) {
            radius -= 15;
        }

        var centerX = chart.centerX + AmCharts.toCoordinate(_this.centerX, chart.realWidth);
        var centerY = chart.centerY + AmCharts.toCoordinate(_this.centerY, chart.realHeight);

        _this.centerXReal = centerX;
        _this.centerYReal = centerY;

        // axis

        var axisAttr = {
            'fill': _this.axisColor,
                'fill-opacity': _this.axisAlpha,
                'stroke-width': 0,
                'stroke-opacity': 0
        };

        var axisRadius;
        var minorTickRadius;
        if (_this.gridInside) {
            axisRadius = radius;
            minorTickRadius = radius;
        } else {
            axisRadius = radius - tickLength;
            minorTickRadius = axisRadius + minorTickLength;
        }

        var axisThickness = _this.axisThickness / 2;
        var axis = AmCharts.wedge(container, centerX, centerY, startAngle, endAngle - startAngle, axisRadius + axisThickness, axisRadius + axisThickness, axisRadius - axisThickness, 0, axisAttr);
        set.push(axis);

        var round = AmCharts.doNothing;
        if (!AmCharts.isModern) {
            round = Math.round;
        }

        var decCount = AmCharts.getDecimals(valueInterval);

        for (var i = 0; i < majorTickCount; i++) {
            // MAJOR TICKS
            var value = startValue + i * valueInterval;
            var angle = startAngle + i * valueAngle;

            var xx1 = round(centerX + radius * Math.sin((angle) / (180) * Math.PI));
            var yy1 = round(centerY - radius * Math.cos((angle) / (180) * Math.PI));

            var xx2 = round(centerX + (radius - tickLength) * Math.sin((angle) / (180) * Math.PI));
            var yy2 = round(centerY - (radius - tickLength) * Math.cos((angle) / (180) * Math.PI));

            var line = AmCharts.line(container, [xx1, xx2], [yy1, yy2], tickColor, tickAlpha, tickThickness, 0, false, false, true);
            set.push(line);
            var sign = -1;
            var dx = _this.labelOffset;
            if (!_this.inside) {
                dx = -dx - tickLength;
                sign = 1;
            }

            var sin = Math.sin((angle) / (180) * Math.PI);
            var cos = Math.cos((angle) / (180) * Math.PI);
            var lx = centerX + (radius - tickLength - dx) * sin;
            var ly = centerY - (radius - tickLength - dx) * cos;

            var fontSize = _this.fontSize;
            if (isNaN(fontSize)) {
                fontSize = chart.fontSize;
            }

            var lsin = Math.sin((angle - 90) / (180) * Math.PI);
            var lcos = Math.cos((angle - 90) / (180) * Math.PI);

            // LABELS
            if (labelFrequency > 0) {
                if (i / labelFrequency == Math.round(i / labelFrequency)) {
                    if ((!_this.showLastLabel && i == majorTickCount - 1) || (!_this.showFirstLabel && i === 0)) {

                    } else {
                        var valueTxt = AmCharts.formatNumber(value, chart.nf, decCount);

                        var unit = _this.unit;
                        if (unit) {
                            if (_this.unitPosition == "left") {
                                valueTxt = unit + valueTxt;
                            } else {
                                valueTxt = valueTxt + unit;
                            }
                        }

                        var label = AmCharts.text(container, valueTxt, chart.color, chart.fontFamily, fontSize);
                        var labelBBox = label.getBBox();
                        label.translate(lx + sign * labelBBox.width / 2 * lcos, ly + sign * labelBBox.height / 2 * lsin);
                        set.push(label);
                    }
                }
            }

            // MINOR TICKS
            if (i < majorTickCount - 1) {
                for (var m = 1; m < minorTickCount; m++) {
                    var mAngle = angle + minorValueAngle * m;

                    var mxx1 = round(centerX + minorTickRadius * Math.sin((mAngle) / (180) * Math.PI));
                    var myy1 = round(centerY - minorTickRadius * Math.cos((mAngle) / (180) * Math.PI));

                    var mxx2 = round(centerX + (minorTickRadius - minorTickLength) * Math.sin((mAngle) / (180) * Math.PI));
                    var myy2 = round(centerY - (minorTickRadius - minorTickLength) * Math.cos((mAngle) / (180) * Math.PI));

                    var mLine = AmCharts.line(container, [mxx1, mxx2], [myy1, myy2], tickColor, tickAlpha, tickThickness, 0, false, false, true);
                    set.push(mLine);
                }
            }
        }

        // BANDS
        var bands = _this.bands;
        if (bands) {
            for (var b = 0; b < bands.length; b++) {
                var band = bands[b];
                if (band) {
                    var bandStartValue = band.startValue;
                    var bandEndValue = band.endValue;
                    var bandRadius = AmCharts.toCoordinate(band.radius, radius);

                    if (isNaN(bandRadius)) {
                        bandRadius = minorTickRadius;
                    }

                    var bandInnerRadius = AmCharts.toCoordinate(band.innerRadius, radius);
                    if (isNaN(bandInnerRadius)) {
                        bandInnerRadius = bandRadius - minorTickLength;
                    }

                    var bandStartAngle = startAngle + singleValueAngle * (bandStartValue - _this.startValue);

                    var bandArc = singleValueAngle * (bandEndValue - bandStartValue);

                    var outlineColor = band.outlineColor;
                    if (outlineColor == UNDEFINED) {
                        outlineColor = _this.bandOutlineColor;
                    }

                    var outlineThickness = band.outlineThickness;
                    if (isNaN(outlineThickness)) {
                        outlineThickness = _this.bandOutlineThickness;
                    }

                    var outlineAlpha = band.outlineAlpha;
                    if (isNaN(outlineAlpha)) {
                        outlineAlpha = _this.bandOutlineAlpha;
                    }

                    var bandAlpha = band.alpha;
                    if (isNaN(bandAlpha)) {
                        bandAlpha = _this.bandAlpha;
                    }

                    var attr = {
                        'fill': band.color,
                            'stroke': outlineColor,
                            'stroke-width': outlineThickness,
                            'stroke-opacity': outlineAlpha
                    };

                    var bandGraphics = AmCharts.wedge(container, centerX, centerY, bandStartAngle, bandArc, bandRadius, bandRadius, bandInnerRadius, 0, attr);
                    bandGraphics.setAttr('opacity', bandAlpha);
                    chart.gridSet.push(bandGraphics);
                }
            }
        }
        _this.axisCreated = true;
        _this.setTopText(_this.topText);
        _this.setBottomText(_this.bottomText);
        var bbox = chart.graphsSet.getBBox();
        _this.width = bbox.width;
        _this.height = bbox.height;
    }
});

// @tag amchart
AmCharts.RecAxis = AmCharts.Class({

    construct: function (axis) {
        var _this = this;
        var chart = axis.chart;
        var t = axis.axisThickness;
        var c = axis.axisColor;
        var a = axis.axisAlpha;
        var l = axis.tickLength;
        var o = axis.offset;
        var dx = axis.dx;
        var dy = axis.dy;

        var vx = axis.viX;
        var vy = axis.viY;
        var vh = axis.viH;
        var vw = axis.viW;

        var x;
        var y;
        var container = chart.container;

        // POSITION CONTAINERS
        // HORIZONTAL
        var line;

        if (axis.orientation == "H") {
            line = AmCharts.line(container, [0, vw], [0, 0], c, a, t);

            _this.axisWidth = axis.width;

            // BOTTOM
            if (axis.position == "bottom") {
                y = t / 2 + o + vh + vy - 1;
                x = vx;
            }
            // TOP
            else {
                y = -t / 2 - o + vy + dy;
                x = dx + vx;
            }
        }
        // VERTICAL
        else {
            _this.axisWidth = axis.height;

            // RIGHT
            if (axis.position == "right") {
                line = AmCharts.line(container, [0, 0, -dx], [0, vh, vh - dy], c, a, t);
                y = vy + dy;
                x = t / 2 + o + dx + vw + vx - 1;
            }
            // LEFT
            else {
                line = AmCharts.line(container, [0, 0], [0, vh], c, a, t);
                y = vy;
                x = -t / 2 - o + vx;
            }
        }
        line.translate(x, y);
        chart.axesSet.push(line);
        _this.set = line;
    }

});// @tag amchart
AmCharts.RecItem = AmCharts.Class({

    construct: function (axis, coord, value, below, textWidth, valueShift, guide, bold, tickShift, minor) {
        var _this = this;

        coord = Math.round(coord);
        var UNDEFINED;

        if (value == UNDEFINED) {
            value = "";
        }

        if (!tickShift) {
            tickShift = 0;
        }

        if (below == UNDEFINED) {
            below = true;
        }
        var fontFamily = axis.chart.fontFamily;
        var textSize = axis.fontSize;

        if (textSize == UNDEFINED) {
            textSize = axis.chart.fontSize;
        }

        var color = axis.color;
        if (color == UNDEFINED) {
            color = axis.chart.color;
        }

        var container = axis.chart.container;
        var set = container.set();
        _this.set = set;

        var vCompensation = 3;
        var hCompensation = 4;
        var axisThickness = axis.axisThickness;
        var axisColor = axis.axisColor;
        var axisAlpha = axis.axisAlpha;
        var tickLength = axis.tickLength;
        var gridAlpha = axis.gridAlpha;
        var gridThickness = axis.gridThickness;
        var gridColor = axis.gridColor;
        var dashLength = axis.dashLength;
        var fillColor = axis.fillColor;
        var fillAlpha = axis.fillAlpha;
        var labelsEnabled = axis.labelsEnabled;
        var labelRotation = axis.labelRotation;
        var counter = axis.counter;
        var labelInside = axis.inside;
        var dx = axis.dx;
        var dy = axis.dy;

        var orientation = axis.orientation;
        var position = axis.position;
        var previousCoord = axis.previousCoord;
        var truncate = axis.autoTruncate;

        var vh = axis.viH;
        var vw = axis.viW;
        var offset = axis.offset;

        var tick;
        var grid;
        var MIDDLE = "middle";
        var START = "start";
        var BOTTOM = "bottom";


        if (guide) {
            labelsEnabled = true;

            if (!isNaN(guide.tickLength)) {
                tickLength = guide.tickLength;
            }

            if (guide.lineColor != UNDEFINED) {
                gridColor = guide.lineColor;
            }

            if (guide.color != UNDEFINED) {
                color = guide.color;
            }

            if (!isNaN(guide.lineAlpha)) {
                gridAlpha = guide.lineAlpha;
            }

            if (!isNaN(guide.dashLength)) {
                dashLength = guide.dashLength;
            }

            if (!isNaN(guide.lineThickness)) {
                gridThickness = guide.lineThickness;
            }
            if (guide.inside === true) {
                labelInside = true;
            }

            if (!isNaN(guide.labelRotation)) {
                labelRotation = guide.labelRotation;
            }
            if (!isNaN(guide.fontSize)) {
                textSize = guide.fontSize;
            }

            if (guide.position) {
                position = guide.position;
            }
        } else {
            if (value === "") {
                tickLength = 0;
            }
        }

        var align = START;
        if (textWidth) {
            align = MIDDLE;
        }

        var angle = labelRotation * Math.PI / 180;
        var fillWidth;
        var fillHeight;
        var lx = 0;
        var ly = 0;
        var tx = 0;
        var ty = 0;
        var labelTextWidth = 0;
        var labelTextHeight = 0;
        var fillCoord;

        if (orientation == "V") {
            labelRotation = 0;
        }

        var valueTF;
        if (labelsEnabled) {

           if(axis.autoWrap && labelRotation === 0){
                valueTF = AmCharts.wrappedText(container, value, color, fontFamily, textSize, align, bold, textWidth, 0);
            }
            else{
                valueTF = AmCharts.text(container, value, color, fontFamily, textSize, align, bold);
            }

            var bbox = valueTF.getBBox();
            labelTextWidth = bbox.width;
            labelTextHeight = bbox.height;
        }

        // horizontal AXIS
        if (orientation == "H") {
            if (coord >= 0 && coord <= vw + 1) {
                if (tickLength > 0 && axisAlpha > 0 && coord + tickShift <= vw + 1) {
                    tick = AmCharts.line(container, [coord + tickShift, coord + tickShift], [0, tickLength], axisColor, axisAlpha, gridThickness);
                    set.push(tick);
                }
                if (gridAlpha > 0) {
                    grid = AmCharts.line(container, [coord, coord + dx, coord + dx], [vh, vh + dy, dy], gridColor, gridAlpha, gridThickness, dashLength);
                    set.push(grid);
                }
            }
            ly = 0;
            lx = coord;

            if (guide && labelRotation == 90) {
                lx -= textSize;
            }

            if (below === false) {
                align = START;

                if (position == BOTTOM) {
                    if (labelInside) {
                        ly += tickLength;
                    } else {
                        ly -= tickLength;
                    }
                } else {
                    if (labelInside) {
                        ly -= tickLength;
                    } else {
                        ly += tickLength;
                    }
                }

                lx += 3;

                if (textWidth) {
                    lx += textWidth / 2;
                    align = MIDDLE;
                }

                if (labelRotation > 0) {
                    align = MIDDLE;
                }
            } else {
                align = MIDDLE;
            }


            if (counter == 1 && fillAlpha > 0 && !guide && !minor && previousCoord < vw) {
                fillCoord = AmCharts.fitToBounds(coord, 0, vw);
                previousCoord = AmCharts.fitToBounds(previousCoord, 0, vw);
                fillWidth = fillCoord - previousCoord;
                if (fillWidth > 0) {
                    fill = AmCharts.rect(container, fillWidth, axis.height, fillColor, fillAlpha);
                    fill.translate((fillCoord - fillWidth + dx), dy);
                    set.push(fill);
                }
            }

            // ADJUST POSITIONS
            // BOTTOM
            if (position == BOTTOM) {
                ly += vh + textSize / 2 + offset;

                //INSIDE
                if (labelInside) {
                    if (labelRotation > 0) {
                        ly = vh - (labelTextWidth / 2) * Math.sin(angle) - tickLength - vCompensation;
                        lx += (labelTextWidth / 2) * Math.cos(angle) - hCompensation + 2;
                    } else if(labelRotation < 0) {
                        ly = vh + labelTextWidth * Math.sin(angle) - tickLength - vCompensation + 2;
                        lx += -labelTextWidth * Math.cos(angle) - labelTextHeight * Math.sin(angle) - hCompensation;
                    }
                    else{
                        ly -= tickLength + textSize + vCompensation + vCompensation;
                    }
                }
                //OUTSIDE
                else {
                    if (labelRotation > 0) {
                        ly = vh + (labelTextWidth / 2) * Math.sin(angle) + tickLength + vCompensation;
                        lx -= (labelTextWidth / 2) * Math.cos(angle);
                    } else if(labelRotation < 0) {
                        ly = vh + tickLength + vCompensation - (labelTextWidth / 2) * Math.sin(angle) + 2;
                        lx += (labelTextWidth / 2) * Math.cos(angle);
                    }
                    else{
                        ly += tickLength + axisThickness + vCompensation + 3;
                    }
                }
            }
            // TOP
            else {
                ly += dy + textSize / 2 - offset;
                lx += dx;
                //INSIDE
                if (labelInside) {
                    if (labelRotation > 0) {
                        ly = (labelTextWidth / 2) * Math.sin(angle) + tickLength + vCompensation;
                        lx -= (labelTextWidth / 2) * Math.cos(angle);
                    } else {
                        ly += tickLength + vCompensation;
                    }
                }
                //OUTSIDE
                else {
                    if (labelRotation > 0) {
                        ly = -(labelTextWidth / 2) * Math.sin(angle) - tickLength - 2 * vCompensation;
                        lx += (labelTextWidth / 2) * Math.cos(angle);
                    } else {
                        ly -= tickLength + textSize + vCompensation + axisThickness + 3;
                    }
                }
            }

            if (position == BOTTOM) {
                //INSIDE
                if (labelInside) {
                    ty = vh - tickLength - 1;
                }
                //OUTSIDE
                else {
                    ty = vh + axisThickness - 1;
                }
                ty += offset;
            }
            // TOP
            else {
                tx = dx;
                //INSIDE
                if (labelInside) {
                    ty = dy;
                }
                //OUTSIDE
                else {
                    ty = dy - tickLength - axisThickness + 1;
                }
                ty -= offset;
            }

            if (valueShift) {
                lx += valueShift;
            }

            var llx = lx;

            if (labelRotation > 0) {
                llx += labelTextWidth / 2 * Math.cos(angle);
            }

            if (valueTF) {
                var dlx = 0;
                if (labelInside) {
                    dlx = labelTextWidth / 2 * Math.cos(angle);
                }

                if (llx + dlx > vw + 2 || llx < 0) {
                    valueTF.remove();
                    valueTF = null;
                }
            }
        }
        // VERTICAL AXIS
        else {
            if (coord >= 0 && coord <= vh + 1) {
                // ticks
                if (tickLength > 0 && axisAlpha > 0 && coord + tickShift <= vh + 1) {
                    tick = AmCharts.line(container, [0, tickLength], [coord + tickShift, coord + tickShift], axisColor, axisAlpha, gridThickness);
                    set.push(tick);
                }
                // grid
                if (gridAlpha > 0) {
                    grid = AmCharts.line(container, [0, dx, vw + dx], [coord, coord + dy, coord + dy], gridColor, gridAlpha, gridThickness, dashLength);
                    set.push(grid);
                }
            }

            // text field
            align = "end";

            if ((labelInside === true && position == "left") || (labelInside === false && position == "right")) {
                align = START;
            }
            ly = coord - textSize / 2;

            if (counter == 1 && fillAlpha > 0 && !guide && !minor) {
                fillCoord = AmCharts.fitToBounds(coord, 0, vh);
                previousCoord = AmCharts.fitToBounds(previousCoord, 0, vh);
                fillHeight = fillCoord - previousCoord;
                fill = AmCharts.polygon(container, [0, axis.width, axis.width, 0], [0, 0, fillHeight, fillHeight], fillColor, fillAlpha);
                fill.translate(dx, (fillCoord - fillHeight + dy));
                set.push(fill);
            }
            // ADJUST POSITIONS
            // RIGHT
            ly += textSize / 2;
            if (position == "right") {
                lx += dx + vw + offset;
                ly += dy;

                // INSIDE
                if (labelInside) {
                    lx -= tickLength + hCompensation;
                    if (!valueShift) {
                        ly -= textSize / 2 + 3;
                    }
                }
                //OUTSIDE
                else {
                    lx += tickLength + hCompensation + axisThickness;
                    ly -= 2;
                }
            }
            // LEFT
            else {
                // INSIDE
                if (labelInside) {
                    lx += tickLength + hCompensation - offset;
                    if (!valueShift) {
                        ly -= textSize / 2 + 3;
                    }
                    if (guide) {
                        lx += dx;
                        ly += dy;
                    }
                }
                // OUTSIDE
                else {
                    lx += -tickLength - axisThickness - hCompensation - 2 - offset;
                    ly -= 2;
                }
            }

            if (tick) {
                if (position == "right") {
                    tx += dx + offset + vw;
                    ty += dy;
                    // INSIDE
                    if (labelInside) {
                        tx -= axisThickness;
                    }
                    //OUTSIDE
                    else {
                        tx += axisThickness;
                    }
                }
                // LEFT
                else {
                    tx -= offset;
                    // INSIDE
                    if (labelInside) {
                        // void
                    }
                    // OUTSIDE
                    else {
                        tx -= tickLength + axisThickness;
                    }
                }
            }

            if (valueShift) {
                ly += valueShift;
            }

            var topY = -3;

            if (position == "right") {
                topY += dy;
            }
            if (valueTF) {
                if (ly > vh + 1 || ly < topY) {
                    valueTF.remove();
                    valueTF = null;
                }
            }
        }

        if (tick) {
            tick.translate(tx, ty);
        }

        if (axis.visible === false) {
            if (tick) {
                tick.remove();
                tick = null;
            }
            if (valueTF) {
                valueTF.remove();
                valueTF = null;
            }
        }

        if (valueTF) {
            valueTF.attr({
                'text-anchor': align
            });
            valueTF.translate(lx, ly);

            if (labelRotation !== 0) {
                valueTF.rotate(-labelRotation, axis.chart.backgroundColor);
            }
            axis.allLabels.push(valueTF);

            if (value != " ") {
                _this.label = valueTF;
            }
        }

        if (!minor) {
            if (counter === 0) {
                axis.counter = 1;
            } else {
                axis.counter = 0;
            }
            axis.previousCoord = coord;
        }

        // remove empty
        if (_this.set.node.childNodes.length === 0) {
            _this.set.remove();
        }
    },

    graphics: function () {
        return this.set;
    },

    getLabel: function () {
        return this.label;
    }
});// @tag amchart
AmCharts.RecFill = AmCharts.Class({

    construct: function (axis, guideCoord, guideToCoord, guide) {
        var _this = this;
        var dx = axis.dx;
        var dy = axis.dy;
        var orientation = axis.orientation;
        var shift = 0;

        if (guideToCoord < guideCoord) {
            var temp = guideCoord;
            guideCoord = guideToCoord;
            guideToCoord = temp;
        }

        var fillAlpha = guide.fillAlpha;
        if (isNaN(fillAlpha)) {
            fillAlpha = 0;
        }
        var container = axis.chart.container;
        var fillColor = guide.fillColor;


        if (orientation == "V") {
            guideCoord = AmCharts.fitToBounds(guideCoord, 0, axis.viH);
            guideToCoord = AmCharts.fitToBounds(guideToCoord, 0, axis.viH);
        } else {
            guideCoord = AmCharts.fitToBounds(guideCoord, 0, axis.viW);
            guideToCoord = AmCharts.fitToBounds(guideToCoord, 0, axis.viW);
        }

        var fillWidth = guideToCoord - guideCoord;

        if (isNaN(fillWidth)) {
            fillWidth = 4;
            shift = 2;
            fillAlpha = 0;
        }

        if (fillWidth < 0) {
            if (typeof (fillColor) == 'object') {
                fillColor = fillColor.join(',').split(',').reverse();
            }
        }

        var fill;

        if (orientation == "V") {
            fill = AmCharts.rect(container, axis.width, fillWidth, fillColor, fillAlpha);
            fill.translate(dx, guideCoord - shift + dy);
        } else {
            fill = AmCharts.rect(container, fillWidth, axis.height, fillColor, fillAlpha);
            fill.translate(guideCoord - shift + dx, dy);
        }
        _this.set = container.set([fill]);
    },

    graphics: function () {
        return this.set;
    },

    getLabel: function () {

    }
});// @tag amchart
AmCharts.RadAxis = AmCharts.Class({

    construct: function (axis) {
        var _this = this;
        var chart = axis.chart;
        var t = axis.axisThickness;
        var c = axis.axisColor;
        var a = axis.axisAlpha;
        var l = axis.tickLength;
        var x = axis.x;
        var y = axis.y;
        var UNDEFINED;

        _this.set = chart.container.set();
        chart.axesSet.push(_this.set);

        var labelsEnabled = axis.labelsEnabled;
        var axisTitleOffset = axis.axisTitleOffset;
        var radarCategoriesEnabled = axis.radarCategoriesEnabled;

        var fontFamily = axis.chart.fontFamily;
        var textSize = axis.fontSize;

        if (textSize === UNDEFINED) {
            textSize = axis.chart.fontSize;
        }

        var color = axis.color;
        if (color === UNDEFINED) {
            color = axis.chart.color;
        }

        if (chart) {
            _this.axisWidth = axis.height;
            var dataProvider = chart.chartData;
            var count = dataProvider.length;
            var i;

            for (i = 0; i < count; i++) {
                var angle = 180 - 360 / count * i;
                var xx = x + _this.axisWidth * Math.sin((angle) / (180) * Math.PI);
                var yy = y + _this.axisWidth * Math.cos((angle) / (180) * Math.PI);
                if (a > 0) {
                    var line = AmCharts.line(chart.container, [x, xx], [y, yy], c, a, t);
                    _this.set.push(line);
                }

                // label
                if (radarCategoriesEnabled) {
                    var align = "start";
                    var labelX = x + (_this.axisWidth + axisTitleOffset) * Math.sin((angle) / (180) * Math.PI);
                    var labelY = y + (_this.axisWidth + axisTitleOffset) * Math.cos((angle) / (180) * Math.PI);

                    if (angle == 180 || angle === 0) {
                        align = "middle";
                        labelX = labelX - 5;
                    }
                    if (angle < 0) {
                        align = "end";
                        labelX = labelX - 10;
                    }

                    if (angle == 180) {
                        labelY -= 5;
                    }

                    if (angle === 0) {
                        labelY += 5;
                    }

                    var titleTF = AmCharts.text(chart.container, dataProvider[i].category, color, fontFamily, textSize, align);
                    titleTF.translate(labelX + 5, labelY);
                    _this.set.push(titleTF);

                    var bbox = titleTF.getBBox();
                }
            }
        }
    }
});// @tag amchart
AmCharts.RadItem = AmCharts.Class({

    construct: function (axis, coord, value, below, textWidth, valueShift, guide) {
        var _this = this;
        var UNDEFINED;

        if (value === UNDEFINED) {
            value = "";
        }

        var fontFamily = axis.chart.fontFamily;
        var textSize = axis.fontSize;

        if (textSize === UNDEFINED) {
            textSize = axis.chart.fontSize;
        }

        var color = axis.color;
        if (color === UNDEFINED) {
            color = axis.chart.color;
        }

        var container = axis.chart.container;
        var set = container.set();
        _this.set = set;

        var vCompensation = 3;
        var hCompensation = 4;
        var axisThickness = axis.axisThickness;
        var axisColor = axis.axisColor;
        var axisAlpha = axis.axisAlpha;
        var tickLength = axis.tickLength;
        var gridAlpha = axis.gridAlpha;
        var gridThickness = axis.gridThickness;
        var gridColor = axis.gridColor;
        var dashLength = axis.dashLength;
        var fillColor = axis.fillColor;
        var fillAlpha = axis.fillAlpha;
        var labelsEnabled = axis.labelsEnabled;
        var labelRotation = axis.labelRotation;
        var counter = axis.counter;
        var labelInside = axis.inside;
        var position = axis.position;
        var previousCoord = axis.previousCoord;
        var gridType = axis.gridType;
        var i;
        var count;
        var angle;


        coord -= axis.height;
        var tick;
        var grid;

        var x = axis.x;
        var y = axis.y;
        var lx = 0;
        var ly = 0;

        if (guide) {
            labelsEnabled = true;

            if (!isNaN(guide.tickLength)) {
                tickLength = guide.tickLength;
            }

            if (guide.lineColor != UNDEFINED) {
                gridColor = guide.lineColor;
            }

            if (!isNaN(guide.lineAlpha)) {
                gridAlpha = guide.lineAlpha;
            }

            if (!isNaN(guide.dashLength)) {
                dashLength = guide.dashLength;
            }

            if (!isNaN(guide.lineThickness)) {
                gridThickness = guide.lineThickness;
            }
            if (guide.inside === true) {
                labelInside = true;
            }
        } else {
            if (!value) {
                gridAlpha = gridAlpha / 3;
                tickLength = tickLength / 2;
            }
        }

        var align = "end";
        var dir = -1;
        if (labelInside) {
            align = "start";
            dir = 1;
        }

        var valueTF;
        if (labelsEnabled) {
            valueTF = AmCharts.text(container, value, color, fontFamily, textSize, align);
            valueTF.translate(x + (tickLength + 3) * dir, coord);
            set.push(valueTF);

            _this.label = valueTF;

            tick = AmCharts.line(container, [x, x + tickLength * dir], [coord, coord], axisColor, axisAlpha, gridThickness);
            set.push(tick);
        }

        var radius = Math.round(axis.y - coord);

        // grid
        var xx = [];
        var yy = [];
        if (gridAlpha > 0) {
            if (gridType == "polygons") {

                count = axis.data.length;


                for (i = 0; i < count; i++) {
                    angle = 180 - 360 / count * i;
                    xx.push(radius * Math.sin((angle) / (180) * Math.PI));
                    yy.push(radius * Math.cos((angle) / (180) * Math.PI));
                }
                xx.push(xx[0]);
                yy.push(yy[0]);

                grid = AmCharts.line(container, xx, yy, gridColor, gridAlpha, gridThickness, dashLength);
            } else {
                grid = AmCharts.circle(container, radius, "#FFFFFF", 0, gridThickness, gridColor, gridAlpha);
            }
            grid.translate(x, y);
            set.push(grid);
        }

        if (counter == 1 && fillAlpha > 0 && !guide && value !== "") {
            var prevCoord = axis.previousCoord;
            var fill;

            if (gridType == "polygons") {
                for (i = count; i >= 0; i--) {
                    angle = 180 - 360 / count * i;
                    xx.push(prevCoord * Math.sin((angle) / (180) * Math.PI));
                    yy.push(prevCoord * Math.cos((angle) / (180) * Math.PI));
                }
                fill = AmCharts.polygon(container, xx, yy, fillColor, fillAlpha);
            } else {
                fill = AmCharts.wedge(container, 0, 0, 0, 360, radius, radius, prevCoord, 0, {
                    'fill': fillColor,
                        'fill-opacity': fillAlpha,
                        'stroke': "#000",
                        'stroke-opacity': 0,
                        'stroke-width': 1
                });
            }
            set.push(fill);
            fill.translate(x, y);
        }


        if (axis.visible === false) {
            if (tick) {
                tick.hide();
            }
            if (valueTF) {
                valueTF.hide();
            }
        }


        if (value !== "") {
            if (counter === 0) {
                axis.counter = 1;
            } else {
                axis.counter = 0;
            }
            axis.previousCoord = radius;
        }
    },

    graphics: function () {
        return this.set;
    },

    getLabel: function () {
        return this.label;
    }

});// @tag amchart
AmCharts.RadarFill = AmCharts.Class({

    construct: function (axis, guideCoord, guideToCoord, guide) {

        guideCoord = guideCoord - axis.axisWidth;
        guideToCoord = guideToCoord - axis.axisWidth;

        var guideToCoordReal = Math.max(guideCoord, guideToCoord);
        var guideCoordReal = Math.min(guideCoord, guideToCoord);

        guideToCoord = guideToCoordReal;
        guideCoord = guideCoordReal;

        var _this = this;
        var chart = axis.chart;
        var container = chart.container;
        var fillAlpha = guide.fillAlpha;
        var fillColor = guide.fillColor;

        var radius = Math.abs(guideToCoord - axis.y);
        var innerRadius = Math.abs(guideCoord - axis.y);

        var radiusReal = Math.max(radius, innerRadius);
        var innerRadiusReal = Math.min(radius, innerRadius);

        radius = radiusReal;
        innerRadius = innerRadiusReal;

        var angle = guide.angle + 90;
        var toAngle = guide.toAngle + 90;
        if (isNaN(angle)) {
            angle = 0;
        }
        if (isNaN(toAngle)) {
            toAngle = 360;
        }

        _this.set = container.set();

        if (fillColor === undefined) {
            fillColor = "#000000";
        }

        if (isNaN(fillAlpha)) {
            fillAlpha = 0;
        }

        if (axis.gridType == "polygons") {
            var xx = [];
            var yy = [];

            var count = axis.data.length;

            var i;
            for (i = 0; i < count; i++) {
                angle = 180 - 360 / count * i;
                xx.push(radius * Math.sin((angle) / (180) * Math.PI));
                yy.push(radius * Math.cos((angle) / (180) * Math.PI));
            }
            xx.push(xx[0]);
            yy.push(yy[0]);

            for (i = count; i >= 0; i--) {
                angle = 180 - 360 / count * i;
                xx.push(innerRadius * Math.sin((angle) / (180) * Math.PI));
                yy.push(innerRadius * Math.cos((angle) / (180) * Math.PI));
            }

            _this.fill = AmCharts.polygon(container, xx, yy, fillColor, fillAlpha);
        } else {
            _this.fill = AmCharts.wedge(container, 0, 0, angle, (toAngle - angle), radius, radius, innerRadius, 0, {
                'fill': fillColor,
                    'fill-opacity': fillAlpha,
                    'stroke': "#000",
                    'stroke-opacity': 0,
                    'stroke-width': 1
            });
        }

        _this.set.push(_this.fill);
        _this.fill.translate(axis.x, axis.y);
    },

    graphics: function () {
        return this.set;
    },

    getLabel: function () {

    }

});// @tag amchart
AmCharts.AmExport = AmCharts.Class({
	construct: function(chart, cfg) {
		var _this		= this;
		_this.DEBUG		= false;
		_this.chart		= chart;
		_this.canvas	= null;
		_this.svgs		= [];
		_this.cfg		= {
			menuTop					: 'auto',
			menuLeft				: 'auto',
			menuRight				: '0px',
			menuBottom				: '0px',
			menuItems				: [{
				textAlign				: 'center',
				icon					: _this.chart.pathToImages + 'export.png',
				iconTitle				: 'Save chart as an image',
				format					: 'png'
			}],
			menuItemStyle			: {
			backgroundColor			: 'transparent',
			rollOverBackgroundColor	: '#EFEFEF',
			color					: '#000000',
			rollOverColor			: '#CC0000',
			paddingTop				: '6px',
			paddingRight			: '6px',
			paddingBottom			: '6px',
			paddingLeft				: '6px',
			marginTop				: '0px',
			marginRight				: '0px',
			marginBottom			: '0px',
			marginLeft				: '0px',
			textAlign				: 'left',
			textDecoration			: 'none',
			fontFamily				: _this.chart.fontFamily,
			fontSize				: _this.chart.fontSize + 'px'
			},
			menuItemOutput			: {
				backgroundColor			: '#FFFFFF',
				fileName				: 'amChart',
				format					: 'png',
				output					: 'dataurlnewwindow',
				render					: 'browser',
				dpi						: 90,
				onclick					: function(instance, config, event) {
					event.preventDefault();
					// Polify SVG; needs to wait
					instance.polifySVG();
					instance.output(config);
				}
			},
			removeImagery: false
		};
		_this.processing = {
			buffer: [],
			drawn: 0,
			timer: 0
		};

		// Config dependency adaption
		if (typeof(window.canvg) != 'undefined' && typeof(window.RGBColor) != 'undefined') {
			_this.cfg.menuItemOutput.render = 'canvg';
		}
		if (typeof(window.saveAs) != 'undefined') {
			_this.cfg.menuItemOutput.output = 'save';
		}
		if (AmCharts.isIE && AmCharts.IEversion < 10) {
			_this.cfg.menuItemOutput.output = 'dataurlnewwindow';
		}

		// Merge given configs
		if (cfg) {
			cfg.menuItemOutput = AmCharts.extend(_this.cfg.menuItemOutput, cfg.menuItemOutput || {});
			cfg.menuItemStyle = AmCharts.extend(_this.cfg.menuItemStyle, cfg.menuItemStyle || {});
			_this.cfg = AmCharts.extend(_this.cfg, cfg);
		}

		// Add reference to chart
		_this.chart.AmExport = _this;

		// Listen to the drawer
		_this.chart.addListener('rendered', function() {
			_this.setup();
		});

		// DEBUG; Public reference
		if (_this.DEBUG) {
			window.AmExport = _this;
		}
	},

	/*
	Simple log function for internal purpose
	@param **args
	*/
	log: function() {
		console.log('AmExport: ', arguments);
	},

	/* PUBLIC
	Prepares everything to get exported
	@param none
	*/
	setup: function() {
		var _this = this;

		if (_this.DEBUG == 10) {
			_this.log('SETUP START');
		} // DEBUG


		if (!AmCharts.isIE || (AmCharts.isIE && AmCharts.IEversion > 9)) {
			// Build Buttons
			_this.generateButtons();
			if (_this.DEBUG == 10) {
				_this.log('SETUP END');
			} // DEBUG
		} else {
			if (_this.DEBUG == 10) {
				_this.log('< IE10 NOT SUPPORTED');
			} // DEBUG
		}
	},

	/* PUBLIC
	Decodes base64 string to binary array
	@param base64_string
	@copyright Eli Grey, http://eligrey.com and Devin Samarin, https://github.com/eboyjr
	*/
	generateBinaryArray: function(base64_string) {
		var
		len = base64_string.length,
			buffer = new Uint8Array(len / 4 * 3 | 0),
			i = 0,
			outptr = 0,
			last = [0, 0],
			state = 0,
			save = 0,
			rank, code, undef, base64_ranks = new Uint8Array([
				62, -1, -1, -1, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, 0, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51
			]);
		while (len--) {
			code = base64_string.charCodeAt(i++);
			rank = base64_ranks[code - 43];
			if (rank !== 255 && rank !== undef) {
				last[1] = last[0];
				last[0] = code;
				save = (save << 6) | rank;
				state++;
				if (state === 4) {
					buffer[outptr++] = save >>> 16;
					if (last[1] !== 61 /* padding character */ ) {
						buffer[outptr++] = save >>> 8;
					}
					if (last[0] !== 61 /* padding character */ ) {
						buffer[outptr++] = save;
					}
					state = 0;
				}
			}
		}
		// 2/3 chance there's going to be some null bytes at the end, but that
		// doesn't really matter with most image formats.
		// If it somehow matters for you, truncate the buffer up outptr.
		return buffer;
	},

	/*
	Creates blob object
	@param base64_datastring string
	@param type string
	*/
	generateBlob: function(datastring, type) {
		var _this = this,
			header_end = datastring.indexOf(',') + 1,
			header = datastring.substring(0, header_end),
			data = datastring,
			blob = new Blob();

		if (header.indexOf('base64') != -1) {
			data = _this.generateBinaryArray(datastring.substring(header_end));
		}

		// Fake blob for IE
		if (AmCharts.isIE && AmCharts.IEversion < 10) {
			blob.data = data;
			blob.size = data.length;
			blob.type = type;
			blob.encoding = 'base64';
		} else {
			blob = new Blob([data], {
				type: type
			});
		}
		return blob;
	},

	/*
	Creates PDF object
	@param config object
	*/
	generatePDF: function(cfg) {
		var _this = this,
			pdf = {
				output: function() {
					return '';
				}
			},
			data = _this.canvas.toDataURL('image/jpeg'), // JSPDF ONLY SUPPORTS JPG
			width = (_this.canvas.width * 25.4) / cfg.dpi,
			height = (_this.canvas.height * 25.4) / cfg.dpi;

		// Check
		if (window.jsPDF) {
			pdf = new jsPDF();
			if (pdf.addImage) {
				pdf.addImage(data, 'JPEG', 0, 0, width, height);
			} else {
				alert("Missing jsPDF plugin; Please add the 'addImage' plugin.");
			}
		} else {
			alert("Missing jsPDF lib; Don't forget to add the addImage plugin.");
		}

		return pdf;
	},

	/*
	Creates the CANVAS to receive the image data
	@param format void()
	@param callback; given callback function which returns the blob or datastring of the configured ouput type
	*/
	output: function(cfg, externalCallback) {
		var _this = this;
		cfg = AmCharts.extend(AmCharts.extend({}, _this.cfg.menuItemOutput), cfg || {});

		/* PRIVATE
		Callback function which gets called after the drawing process is done
		@param none
		*/
		function internalCallback() {
			var data = null;
			var blob;
			if (_this.DEBUG == 10) {
				_this.log('OUTPUT', format);
			} // DEBUG

			// SVG
			if (cfg.format == 'image/svg+xml' || cfg.format == 'svg') {
				for (var i = 0; i < _this.processing.buffer.length; i++) {
					data = new XMLSerializer().serializeToString(_this.processing.buffer[i][0]);
					blob = _this.generateBlob(data, 'image/svg+xml');

					if (cfg.output == 'save') {
						saveAs(blob, cfg.fileName + '.svg');
					} else if (cfg.output == 'datastring' || cfg.output == 'datauristring' || cfg.output == 'dataurlstring') {
						blob = 'data:image/svg+xml;base64,' + btoa(data);
					} else if (cfg.output == 'dataurlnewwindow') {
						window.open('data:image/svg+xml;base64,' + btoa(data));
					} else if (cfg.output == 'datauri' || cfg.output == 'dataurl') {
						location.href = 'data:image/svg+xml;base64,' + btoa(data);
					} else if (cfg.output == 'datastream') {
						location.href = 'data:image/octet-stream;base64,' + btoa(data);
					}

					if (externalCallback)
						externalCallback.apply(_this, [blob]);
				}
				// PDF
			} else if (cfg.format == 'application/pdf' || cfg.format == 'pdf') {
				data = _this.generatePDF(cfg).output('dataurlstring');
				blob = _this.generateBlob(data, 'application/pdf');

				if (cfg.output == 'save') {
					saveAs(blob, cfg.fileName + '.pdf');
				} else if (cfg.output == 'datastring' || cfg.output == 'datauristring' || cfg.output == 'dataurlstring') {
					blob = data;
				} else if (cfg.output == 'dataurlnewwindow') {
					window.open(data);
				} else if (cfg.output == 'datauri' || cfg.output == 'dataurl') {
					location.href = data;
				} else if (cfg.output == 'datastream') {
					location.href = data.replace('application/pdf', 'application/octet-stream');
				}

				if (externalCallback)
					externalCallback.apply(_this, [blob]);

				// PNG
			} else if (cfg.format == 'image/png' || cfg.format == 'png') {
				data = _this.canvas.toDataURL('image/png');
				blob = _this.generateBlob(data, 'image/png');

				if (cfg.output == 'save') {
					saveAs(blob, cfg.fileName + '.png');
				} else if (cfg.output == 'datastring' || cfg.output == 'datauristring' || cfg.output == 'dataurlstring') {
					blob = data;
				} else if (cfg.output == 'dataurlnewwindow') {
					window.open(data);
				} else if (cfg.output == 'datauri' || cfg.output == 'dataurl') {
					location.href = data;
				} else if (cfg.output == 'datastream') {
					location.href = data.replace('image/png', 'image/octet-stream');
				}

				if (externalCallback)
					externalCallback.apply(_this, [blob]);

				// JPG
			} else if (cfg.format == 'image/jpeg' || cfg.format == 'jpeg' || cfg.format == 'jpg') {
				data = _this.canvas.toDataURL('image/jpeg');
				blob = _this.generateBlob(data, 'image/jpeg');

				if (cfg.output == 'save') {
					saveAs(blob, cfg.fileName + '.jpg');
				} else if (cfg.output == 'datastring' || cfg.output == 'datauristring' || cfg.output == 'dataurlstring') {
					blob = data;
				} else if (cfg.output == 'dataurlnewwindow') {
					window.open(data);
				} else if (cfg.output == 'datauri' || cfg.output == 'dataurl') {
					location.href = data;
				} else if (cfg.output == 'datastream') {
					location.href = data.replace('image/jpeg', 'image/octet-stream');
				}

				if (externalCallback)
					externalCallback.apply(_this, [blob]);
			}

		}

		return _this.generateOutput(cfg, internalCallback);
	},

	/* PUBLIC
	Polifies missing attributes to the SVG and replaces images to embedded base64 images
	@param none
	*/
	polifySVG: function() {
		var _this = this;
		var svgs = _this.chart.div.getElementsByTagName('svg');

		// Recursive function to force the attributes
		function recursiveChange(svg, tag) {
			var items = svg.getElementsByTagName(tag);

			for (var i = 0; i < items.length; i++) {

				if ( _this.cfg.removeImagery ) {
					items[i].parentNode.removeChild(items[i]);

				} else {
					var image		= document.createElement('img');
					var canvas		= document.createElement('canvas');
					var ctx			= canvas.getContext('2d');

					canvas.width	= items[i].getAttribute('width');
					canvas.height	= items[i].getAttribute('height');
					image.src		= items[i].getAttribute('xlink:href');
					image.width		= items[i].getAttribute('width');
					image.height	= items[i].getAttribute('height');

					try {
						ctx.drawImage(image, 0, 0, image.width, image.height);
						datastring = canvas.toDataURL(); // image.src; // canvas.toDataURL(); //
					} catch (err) {
						datastring = image.src; // image.src; // canvas.toDataURL(); //

						_this.log('Tainted canvas, reached browser CORS security; origin from imagery must be equal to the server!');
						throw new Error(err);
					}

					items[i].setAttribute('xlink:href', datastring);
				}

				if (_this.DEBUG == 10) {
					_this.log('POLIFIED', items[i]);
				} // DEBUG
			}
		}

		// Loop through svgs to add some standardization
		for (var i = 0; i < svgs.length; i++) {
			var parent = svgs[i].parentNode;

			// Put some attrs to it; fixed 20/03/14 xmlns is required to produce a valid svg file
			if ( !AmCharts.isIE ) {
				svgs[i].setAttribute('xmlns','http://www.w3.org/2000/svg');
				//svgs[i].setAttribute('xmlns:xlink','http://www.w3.org/1999/xlink');
			}
			//svgs[i].setAttribute('width',parent.style.width);
			//svgs[i].setAttribute('height',parent.style.height);

			// DEBUG
			if (_this.DEBUG == 10) {
				_this.log('POLIFIED', svgs[i]);
			}

			// Force link adaption
			recursiveChange(svgs[i], 'pattern');
			recursiveChange(svgs[i], 'image');

			_this.svgs.push(svgs[i]);
		}

		return svgs;
	},

	/* PUBLIC
	Generates the canvas with the given SVGs and configured renderer
	@param callback; function(); gets called after drawing process on the canvas has been finished
	*/
	generateOutput: function(cfg, callback) {
		var _this = this,
			svgs = _this.chart.div.getElementsByTagName('svg'),
			canvas = document.createElement('canvas'),
			context = canvas.getContext('2d'),
			offset = {
				y: 0,
				x: 0
			},
			tmp = {};

		// Reset
		_this.processing.buffer = [];
		_this.processing.drawn = 0;
		_this.canvas = canvas;

		// Walkthroug SVGs
		if (_this.DEBUG == 10) {
			_this.log('START EXPORT');
		} // DEBUG
		if (_this.DEBUG == 10) {
			_this.log('START BUFFERING');
		} // DEBUG
		for (var i = 0; i < svgs.length; i++) {
			var parent = svgs[i].parentNode,
				svgX = Number(parent.style.left.slice(0, -2)),
				svgY = Number(parent.style.top.slice(0, -2));
			tmp = AmCharts.extend({}, offset);

			// Overtake parent position if given; fixed 20/03/14 distinguish between relativ and others
			if ( parent.style.position == 'relative' ) {
				offset.x = svgX? svgX : offset.x;
				offset.y = svgY? svgY : offset.y;
			} else {
				offset.x = svgX;
				offset.y = svgY;
			}

			_this.processing.buffer.push([svgs[i], AmCharts.extend({}, offset)]);

			// Put back from "cache"
			if (svgY && svgX) {
				offset = tmp;

				// New offset for next one
			} else {
				offset.y += svgY ? 0 : parent.offsetHeight;
			}

			if (_this.DEBUG == 10) {
				_this.log('BUFFERED', svgs[i], offset);
			} // DEBUG
		}
		if (_this.DEBUG == 10) {
			_this.log('END BUFFERING');
		} // DEBUG

		// Apply background
		if (_this.DEBUG == 10) {
			_this.log('START DRAWING', cfg.render);
		} // DEBUG
		if (_this.DEBUG == 10) {
			_this.log('FILL BACKGROUND');
		} // DEBUG
		canvas.id = AmCharts.getUniqueId();
		canvas.width = _this.chart.divRealWidth;
		canvas.height = _this.chart.divRealHeight;

		// Set given background; jpeg default
		if (cfg.backgroundColor || format == 'image/jpeg') {
			context.fillStyle = cfg.backgroundColor || '#FFFFFF';
			context.fillRect(0, 0, canvas.width, canvas.height);
		}

		/* PRIVATE
		Recursive function to draw the images to the canvas;
		@param none;
		*/
		function drawItWhenItsLoaded() {
			var img, buffer, offset, source;

			// DRAWING PROCESS DONE
			if (_this.processing.buffer.length == _this.processing.drawn) {
				if (_this.DEBUG == 10) {
					_this.log('END DRAWING');
				} // DEBUG
				return callback();

				// LOOPING LUI
			} else {
				if (_this.DEBUG == 10) {
					_this.log('DRAW', _this.processing.drawn + 1, 'OF', _this.processing.buffer.length);
				} // DEBUG

				buffer = _this.processing.buffer[_this.processing.drawn];
				source = new XMLSerializer().serializeToString(buffer[0]); //source = 'data:image/svg+xml;base64,' + btoa();
				offset = buffer[1];

				if (_this.DEBUG == 10) {
					_this.log('SOURCE', source);
				} // DEBUG

				// NATIVE
				if (cfg.render == 'browser') {
					img = new Image();
					img.id = AmCharts.getUniqueId();
					source = 'data:image/svg+xml;base64,' + btoa(source);

					//img.crossOrigin	= "Anonymous";
					img.onload = function() {
						context.drawImage(this, buffer[1].x, buffer[1].y);
						_this.processing.drawn++;

						if (_this.DEBUG == 10) {
							_this.log('ONLOAD', this);
						} // DEBUG
						drawItWhenItsLoaded();
					};
					img.onerror = function() {
						if (_this.DEBUG == 10) {
							_this.log('ONERROR', this);
						} // DEBUG
						context.drawImage(this, buffer[1].x, buffer[1].y);
						_this.processing.drawn++;
						drawItWhenItsLoaded();
					};
					img.src = source;

					if (_this.DEBUG == 10) {
						_this.log('ADD', img);
					} // DEBUG
					if (img.complete || typeof(img.complete) == 'undefined' || img.complete === undefined) {
						if (_this.DEBUG == 10) {
							_this.log('FORCE ONLOAD', img);
						} // DEBUG
						img.src = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==";
						img.src = source;
					}

					// CANVG
				} else if (cfg.render == 'canvg') {
					canvg(canvas, source, {
						offsetX: offset.x,
						offsetY: offset.y,
						ignoreMouse: true,
						ignoreAnimation: true,
						ignoreDimensions: true,
						ignoreClear: true,
						renderCallback: function() {
							_this.processing.drawn++;
							drawItWhenItsLoaded();
						}
					});
				}
			}
		}
		return drawItWhenItsLoaded();
	},

	/*
	Generates the export menu to trigger the exportation
	@param none;
	*/
	generateButtons: function() {
		var _this = this,
			div = document.createElement('div'),
			lvl = 0;

		// Push sublings
		function createList(items) {
			var ul = document.createElement('ul');

			ul.setAttribute('style', 'list-style: none; margin: 0; padding: 0;');

			// Walkthrough items
			for (var i = 0; i < items.length; i++) {
				var li = document.createElement('li'),
					img = document.createElement('img'),
					a = document.createElement('a'),
					item = items[i],
					children = null,
					itemStyle = AmCharts.extend(AmCharts.extend({}, _this.cfg.menuItemStyle), items[i]);

				// MERGE CFG
				item = AmCharts.extend(AmCharts.extend({}, _this.cfg.menuItemOutput), item);

				// ICON
				if (item['icon']) {
					img.alt = '';
					img.src = item['icon'];
					img.setAttribute('style', 'margin: 0 auto;border: none;outline: none');
					if (item['iconTitle']) {
						img.title = item['iconTitle'];
					}
					a.appendChild(img);
				}

				// TITLE; STYLING
				a.href = '#';
				if (item['title']) {
					img.setAttribute('style', 'margin-right: 5px;');
					a.innerHTML += item.title;
				}
				a.setAttribute('style', 'display: block;');
				AmCharts.extend(a.style, itemStyle);

				// ONCLICK
				a.onclick = item.onclick.bind(a, _this, item);
				li.appendChild(a);

				// APPEND SIBLINGS
				if (item.items) {
					children = createList(item.items);
					li.appendChild(children);

					li.onmouseover = function() {
						children.style.display = 'block';
					};
					li.onmouseout = function() {
						children.style.display = 'none';
					};
					children.style.display = 'none';
				}

				// Append to parent
				ul.appendChild(li);

				// Apply hover
				a.onmouseover = function() {
					this.style.backgroundColor = itemStyle.rollOverBackgroundColor;
					this.style.color = itemStyle.rollOverColor;
					this.style.borderColor = itemStyle.rollOverBorderColor;
				};
				a.onmouseout = function() {
					this.style.backgroundColor = itemStyle.backgroundColor;
					this.style.color = itemStyle.color;
					this.style.borderColor = itemStyle.borderColor;
				};
			}
			lvl++;

			if (_this.DEBUG == 10) {
				_this.log('MENU', ul);
			} // DEBUG

			return ul;
		}

		// Style wrapper; Push into chart div
		div.setAttribute('style', 'width:39px; height:28px; position: absolute;top:' + _this.cfg.menuTop + ';right:' + _this.cfg.menuRight + ';bottom:' + _this.cfg.menuBottom + ';left:' + _this.cfg.menuLeft + ';box-shadow:0px 0px 1px 0px rgba(0,0,0,0);');
		div.setAttribute('class', 'amExportButton');
		div.appendChild(createList(_this.cfg.menuItems));
		//_this.chart.div.style.position = 'relative';
		_this.chart.containerDiv.appendChild(div);
	}
});// @tag amchart
/*
 * canvg.js - Javascript SVG parser and renderer on Canvas
 * MIT Licensed 
 * Gabe Lerner (gabelerner@gmail.com)
 * http://code.google.com/p/canvg/
 *
 * Requires: rgbcolor.js - http://www.phpied.com/rgb-color-parser-in-javascript/
 */
(function(){
	// canvg(target, s)
	// empty parameters: replace all 'svg' elements on page with 'canvas' elements
	// target: canvas element or the id of a canvas element
	// s: svg string, url to svg file, or xml document
	// opts: optional hash of options
	//		 ignoreMouse: true => ignore mouse events
	//		 ignoreAnimation: true => ignore animations
	//		 ignoreDimensions: true => does not try to resize canvas
	//		 ignoreClear: true => does not clear canvas
	//		 offsetX: int => draws at a x offset
	//		 offsetY: int => draws at a y offset
	//		 scaleWidth: int => scales horizontally to width
	//		 scaleHeight: int => scales vertically to height
	//		 renderCallback: function => will call the function after the first render is completed
	//		 forceRedraw: function => will call the function on every frame, if it returns true, will redraw
	this.canvg = function (target, s, opts) {
		// no parameters
		if (target == null && s == null && opts == null) {
			var svgTags = document.getElementsByTagName('svg');
			for (var i=0; i<svgTags.length; i++) {
				var svgTag = svgTags[i];
				var c = document.createElement('canvas');
				c.width = svgTag.clientWidth;
				c.height = svgTag.clientHeight;
				svgTag.parentNode.insertBefore(c, svgTag);
				svgTag.parentNode.removeChild(svgTag);
				var div = document.createElement('div');
				div.appendChild(svgTag);
				canvg(c, div.innerHTML);
			}
			return;
		}	
		opts = opts || {};
	
		if (typeof target == 'string') {
			target = document.getElementById(target);
		}
		
		// store class on canvas
		if (target.svg != null) target.svg.stop();
		var svg = build();
		// on i.e. 8 for flash canvas, we can't assign the property so check for it
		if (!(target.childNodes.length == 1 && target.childNodes[0].nodeName == 'OBJECT')) target.svg = svg;
		svg.opts = opts;
		
		var ctx = target.getContext('2d');
		if (typeof(s.documentElement) != 'undefined') {
			// load from xml doc
			svg.loadXmlDoc(ctx, s);
		}
		else if (s.substr(0,1) == '<') {
			// load from xml string
			svg.loadXml(ctx, s);
		}
		else {
			// load from url
			svg.load(ctx, s);
		}
	}

	function build() {
		var svg = { };
		
		svg.FRAMERATE = 30;
		svg.MAX_VIRTUAL_PIXELS = 30000;
		
		// globals
		svg.init = function(ctx) {
			var uniqueId = 0;
			svg.UniqueId = function () { uniqueId++; return 'canvg' + uniqueId;	};
			svg.Definitions = {};
			svg.Styles = {};
			svg.Animations = [];
			svg.Images = [];
			svg.ctx = ctx;
			svg.ViewPort = new (function () {
				this.viewPorts = [];
				this.Clear = function() { this.viewPorts = []; }
				this.SetCurrent = function(width, height) { this.viewPorts.push({ width: width, height: height }); }
				this.RemoveCurrent = function() { this.viewPorts.pop(); }
				this.Current = function() { return this.viewPorts[this.viewPorts.length - 1]; }
				this.width = function() { return this.Current().width; }
				this.height = function() { return this.Current().height; }
				this.ComputeSize = function(d) {
					if (d != null && typeof(d) == 'number') return d;
					if (d == 'x') return this.width();
					if (d == 'y') return this.height();
					return Math.sqrt(Math.pow(this.width(), 2) + Math.pow(this.height(), 2)) / Math.sqrt(2);			
				}
			});
		}
		svg.init();
		
		// images loaded
		svg.ImagesLoaded = function() { 
			for (var i=0; i<svg.Images.length; i++) {
				if (!svg.Images[i].loaded) return false;
			}
			return true;
		}

		// trim
		svg.trim = function(s) { return s.replace(/^\s+|\s+$/g, ''); }
		
		// compress spaces
		svg.compressSpaces = function(s) { return s.replace(/[\s\r\t\n]+/gm,' '); }
		
		// ajax
		svg.ajax = function(url) {
			var AJAX;
			if(window.XMLHttpRequest){AJAX=new XMLHttpRequest();}
			else{AJAX=new ActiveXObject('Microsoft.XMLHTTP');}
			if(AJAX){
			   AJAX.open('GET',url,false);
			   AJAX.send(null);
			   return AJAX.responseText;
			}
			return null;
		} 
		
		// parse xml
		
		svg.parseXml = function(xml) {			
			if (window.DOMParser)
			{
				var parser = new DOMParser();
				return parser.parseFromString(xml, 'text/xml');
			}
			else 
			{
				xml = xml.replace(/<!DOCTYPE svg[^>]*>/, '');
				var xmlDoc = new ActiveXObject('Microsoft.XMLDOM');
				xmlDoc.async = 'false';
				xmlDoc.loadXML(xml); 
				return xmlDoc;
			}		
		}
		
		svg.Property = function(name, value) {
			this.name = name;
			this.value = value;
		}	
			svg.Property.prototype.getValue = function() {
				return this.value;
			}
		
			svg.Property.prototype.hasValue = function() {
				return (this.value != null && this.value !== '');
			}
							
			// return the numerical value of the property
			svg.Property.prototype.numValue = function() {
				if (!this.hasValue()) return 0;
				
				var n = parseFloat(this.value);
				if ((this.value + '').match(/%$/)) {
					n = n / 100.0;
				}
				return n;
			}
			
			svg.Property.prototype.valueOrDefault = function(def) {
				if (this.hasValue()) return this.value;
				return def;
			}
			
			svg.Property.prototype.numValueOrDefault = function(def) {
				if (this.hasValue()) return this.numValue();
				return def;
			}
			
			// color extensions
				// augment the current color value with the opacity
				svg.Property.prototype.addOpacity = function(opacity) {
					var newValue = this.value;
					if (opacity != null && opacity != '' && typeof(this.value)=='string') { // can only add opacity to colors, not patterns
						var color = new RGBColor(this.value);
						if (color.ok) {
							newValue = 'rgba(' + color.r + ', ' + color.g + ', ' + color.b + ', ' + opacity + ')';
						}
					}
					return new svg.Property(this.name, newValue);
				}
			
			// definition extensions
				// get the definition from the definitions table
				svg.Property.prototype.getDefinition = function() {
					var name = this.value.match(/#([^\)'"]+)/);
					if (name) { name = name[1]; }
					if (!name) { name = this.value; }
					return svg.Definitions[name];
				}
				
				svg.Property.prototype.isUrlDefinition = function() {
					return this.value.indexOf('url(') == 0
				}
				
				svg.Property.prototype.getFillStyleDefinition = function(e, opacityProp) {
					var def = this.getDefinition();
					
					// gradient
					if (def != null && def.createGradient) {
						return def.createGradient(svg.ctx, e, opacityProp);
					}
					
					// pattern
					if (def != null && def.createPattern) {
						if (def.getHrefAttribute().hasValue()) {
							var pt = def.attribute('patternTransform');
							def = def.getHrefAttribute().getDefinition();
							if (pt.hasValue()) { def.attribute('patternTransform', true).value = pt.value; }
						}
						return def.createPattern(svg.ctx, e);
					}
					
					return null;
				}
			
			// length extensions
				svg.Property.prototype.getDPI = function(viewPort) {
					return 96.0; // TODO: compute?
				}
				
				svg.Property.prototype.getEM = function(viewPort) {
					var em = 12;
					
					var fontSize = new svg.Property('fontSize', svg.Font.Parse(svg.ctx.font).fontSize);
					if (fontSize.hasValue()) em = fontSize.toPixels(viewPort);
					
					return em;
				}
				
				svg.Property.prototype.getUnits = function() {
					var s = this.value+'';
					return s.replace(/[0-9\.\-]/g,'');
				}
			
				// get the length as pixels
				svg.Property.prototype.toPixels = function(viewPort, processPercent) {
					if (!this.hasValue()) return 0;
					var s = this.value+'';
					if (s.match(/em$/)) return this.numValue() * this.getEM(viewPort);
					if (s.match(/ex$/)) return this.numValue() * this.getEM(viewPort) / 2.0;
					if (s.match(/px$/)) return this.numValue();
					if (s.match(/pt$/)) return this.numValue() * this.getDPI(viewPort) * (1.0 / 72.0);
					if (s.match(/pc$/)) return this.numValue() * 15;
					if (s.match(/cm$/)) return this.numValue() * this.getDPI(viewPort) / 2.54;
					if (s.match(/mm$/)) return this.numValue() * this.getDPI(viewPort) / 25.4;
					if (s.match(/in$/)) return this.numValue() * this.getDPI(viewPort);
					if (s.match(/%$/)) return this.numValue() * svg.ViewPort.ComputeSize(viewPort);
					var n = this.numValue();
					if (processPercent && n < 1.0) return n * svg.ViewPort.ComputeSize(viewPort);
					return n;
				}

			// time extensions
				// get the time as milliseconds
				svg.Property.prototype.toMilliseconds = function() {
					if (!this.hasValue()) return 0;
					var s = this.value+'';
					if (s.match(/s$/)) return this.numValue() * 1000;
					if (s.match(/ms$/)) return this.numValue();
					return this.numValue();
				}
			
			// angle extensions
				// get the angle as radians
				svg.Property.prototype.toRadians = function() {
					if (!this.hasValue()) return 0;
					var s = this.value+'';
					if (s.match(/deg$/)) return this.numValue() * (Math.PI / 180.0);
					if (s.match(/grad$/)) return this.numValue() * (Math.PI / 200.0);
					if (s.match(/rad$/)) return this.numValue();
					return this.numValue() * (Math.PI / 180.0);
				}
		
		// fonts
		svg.Font = new (function() {
			this.Styles = 'normal|italic|oblique|inherit';
			this.Variants = 'normal|small-caps|inherit';
			this.Weights = 'normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900|inherit';
			
			this.CreateFont = function(fontStyle, fontVariant, fontWeight, fontSize, fontFamily, inherit) { 
				var f = inherit != null ? this.Parse(inherit) : this.CreateFont('', '', '', '', '', svg.ctx.font);
				return { 
					fontFamily: fontFamily || f.fontFamily, 
					fontSize: fontSize || f.fontSize, 
					fontStyle: fontStyle || f.fontStyle, 
					fontWeight: fontWeight || f.fontWeight, 
					fontVariant: fontVariant || f.fontVariant,
					toString: function () { return [this.fontStyle, this.fontVariant, this.fontWeight, this.fontSize, this.fontFamily].join(' ') } 
				} 
			}
			
			var that = this;
			this.Parse = function(s) {
				var f = {};
				var d = svg.trim(svg.compressSpaces(s || '')).split(' ');
				var set = { fontSize: false, fontStyle: false, fontWeight: false, fontVariant: false }
				var ff = '';
				for (var i=0; i<d.length; i++) {
					if (!set.fontStyle && that.Styles.indexOf(d[i]) != -1) { if (d[i] != 'inherit') f.fontStyle = d[i]; set.fontStyle = true; }
					else if (!set.fontVariant && that.Variants.indexOf(d[i]) != -1) { if (d[i] != 'inherit') f.fontVariant = d[i]; set.fontStyle = set.fontVariant = true;	}
					else if (!set.fontWeight && that.Weights.indexOf(d[i]) != -1) {	if (d[i] != 'inherit') f.fontWeight = d[i]; set.fontStyle = set.fontVariant = set.fontWeight = true; }
					else if (!set.fontSize) { if (d[i] != 'inherit') f.fontSize = d[i].split('/')[0]; set.fontStyle = set.fontVariant = set.fontWeight = set.fontSize = true; }
					else { if (d[i] != 'inherit') ff += d[i]; }
				} if (ff != '') f.fontFamily = ff;
				return f;
			}
		});
		
		// points and paths
		svg.ToNumberArray = function(s) {
			var a = svg.trim(svg.compressSpaces((s || '').replace(/,/g, ' '))).split(' ');
			for (var i=0; i<a.length; i++) {
				a[i] = parseFloat(a[i]);
			}
			return a;
		}		
		svg.Point = function(x, y) {
			this.x = x;
			this.y = y;
		}	
			svg.Point.prototype.angleTo = function(p) {
				return Math.atan2(p.y - this.y, p.x - this.x);
			}
			
			svg.Point.prototype.applyTransform = function(v) {
				var xp = this.x * v[0] + this.y * v[2] + v[4];
				var yp = this.x * v[1] + this.y * v[3] + v[5];
				this.x = xp;
				this.y = yp;
			}

		svg.CreatePoint = function(s) {
			var a = svg.ToNumberArray(s);
			return new svg.Point(a[0], a[1]);
		}
		svg.CreatePath = function(s) {
			var a = svg.ToNumberArray(s);
			var path = [];
			for (var i=0; i<a.length; i+=2) {
				path.push(new svg.Point(a[i], a[i+1]));
			}
			return path;
		}
		
		// bounding box
		svg.BoundingBox = function(x1, y1, x2, y2) { // pass in initial points if you want
			this.x1 = Number.NaN;
			this.y1 = Number.NaN;
			this.x2 = Number.NaN;
			this.y2 = Number.NaN;
			
			this.x = function() { return this.x1; }
			this.y = function() { return this.y1; }
			this.width = function() { return this.x2 - this.x1; }
			this.height = function() { return this.y2 - this.y1; }
			
			this.addPoint = function(x, y) {	
				if (x != null) {
					if (isNaN(this.x1) || isNaN(this.x2)) {
						this.x1 = x;
						this.x2 = x;
					}
					if (x < this.x1) this.x1 = x;
					if (x > this.x2) this.x2 = x;
				}
			
				if (y != null) {
					if (isNaN(this.y1) || isNaN(this.y2)) {
						this.y1 = y;
						this.y2 = y;
					}
					if (y < this.y1) this.y1 = y;
					if (y > this.y2) this.y2 = y;
				}
			}			
			this.addX = function(x) { this.addPoint(x, null); }
			this.addY = function(y) { this.addPoint(null, y); }
			
			this.addBoundingBox = function(bb) {
				this.addPoint(bb.x1, bb.y1);
				this.addPoint(bb.x2, bb.y2);
			}
			
			this.addQuadraticCurve = function(p0x, p0y, p1x, p1y, p2x, p2y) {
				var cp1x = p0x + 2/3 * (p1x - p0x); // CP1 = QP0 + 2/3 *(QP1-QP0)
				var cp1y = p0y + 2/3 * (p1y - p0y); // CP1 = QP0 + 2/3 *(QP1-QP0)
				var cp2x = cp1x + 1/3 * (p2x - p0x); // CP2 = CP1 + 1/3 *(QP2-QP0)
				var cp2y = cp1y + 1/3 * (p2y - p0y); // CP2 = CP1 + 1/3 *(QP2-QP0)
				this.addBezierCurve(p0x, p0y, cp1x, cp2x, cp1y,	cp2y, p2x, p2y);
			}
			
			this.addBezierCurve = function(p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y) {
				// from http://blog.hackers-cafe.net/2009/06/how-to-calculate-bezier-curves-bounding.html
				var p0 = [p0x, p0y], p1 = [p1x, p1y], p2 = [p2x, p2y], p3 = [p3x, p3y];
				this.addPoint(p0[0], p0[1]);
				this.addPoint(p3[0], p3[1]);
				
				for (i=0; i<=1; i++) {
					var f = function(t) { 
						return Math.pow(1-t, 3) * p0[i]
						+ 3 * Math.pow(1-t, 2) * t * p1[i]
						+ 3 * (1-t) * Math.pow(t, 2) * p2[i]
						+ Math.pow(t, 3) * p3[i];
					}
					
					var b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];
					var a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];
					var c = 3 * p1[i] - 3 * p0[i];
					
					if (a == 0) {
						if (b == 0) continue;
						var t = -c / b;
						if (0 < t && t < 1) {
							if (i == 0) this.addX(f(t));
							if (i == 1) this.addY(f(t));
						}
						continue;
					}
					
					var b2ac = Math.pow(b, 2) - 4 * c * a;
					if (b2ac < 0) continue;
					var t1 = (-b + Math.sqrt(b2ac)) / (2 * a);
					if (0 < t1 && t1 < 1) {
						if (i == 0) this.addX(f(t1));
						if (i == 1) this.addY(f(t1));
					}
					var t2 = (-b - Math.sqrt(b2ac)) / (2 * a);
					if (0 < t2 && t2 < 1) {
						if (i == 0) this.addX(f(t2));
						if (i == 1) this.addY(f(t2));
					}
				}
			}
			
			this.isPointInBox = function(x, y) {
				return (this.x1 <= x && x <= this.x2 && this.y1 <= y && y <= this.y2);
			}
			
			this.addPoint(x1, y1);
			this.addPoint(x2, y2);
		}
		
		// transforms
		svg.Transform = function(v) {	
			var that = this;
			this.Type = {}
		
			// translate
			this.Type.translate = function(s) {
				this.p = svg.CreatePoint(s);			
				this.apply = function(ctx) {
					ctx.translate(this.p.x || 0.0, this.p.y || 0.0);
				}
				this.unapply = function(ctx) {
					ctx.translate(-1.0 * this.p.x || 0.0, -1.0 * this.p.y || 0.0);
				}
				this.applyToPoint = function(p) {
					p.applyTransform([1, 0, 0, 1, this.p.x || 0.0, this.p.y || 0.0]);
				}
			}
			
			// rotate
			this.Type.rotate = function(s) {
				var a = svg.ToNumberArray(s);
				this.angle = new svg.Property('angle', a[0]);
				this.cx = a[1] || 0;
				this.cy = a[2] || 0;
				this.apply = function(ctx) {
					ctx.translate(this.cx, this.cy);
					ctx.rotate(this.angle.toRadians());
					ctx.translate(-this.cx, -this.cy);
				}
				this.unapply = function(ctx) {
					ctx.translate(this.cx, this.cy);
					ctx.rotate(-1.0 * this.angle.toRadians());
					ctx.translate(-this.cx, -this.cy);
				}
				this.applyToPoint = function(p) {
					var a = this.angle.toRadians();
					p.applyTransform([1, 0, 0, 1, this.p.x || 0.0, this.p.y || 0.0]);
					p.applyTransform([Math.cos(a), Math.sin(a), -Math.sin(a), Math.cos(a), 0, 0]);
					p.applyTransform([1, 0, 0, 1, -this.p.x || 0.0, -this.p.y || 0.0]);
				}			
			}
			
			this.Type.scale = function(s) {
				this.p = svg.CreatePoint(s);
				this.apply = function(ctx) {
					ctx.scale(this.p.x || 1.0, this.p.y || this.p.x || 1.0);
				}
				this.unapply = function(ctx) {
					ctx.scale(1.0 / this.p.x || 1.0, 1.0 / this.p.y || this.p.x || 1.0);
				}
				this.applyToPoint = function(p) {
					p.applyTransform([this.p.x || 0.0, 0, 0, this.p.y || 0.0, 0, 0]);
				}				
			}
			
			this.Type.matrix = function(s) {
				this.m = svg.ToNumberArray(s);
				this.apply = function(ctx) {
					ctx.transform(this.m[0], this.m[1], this.m[2], this.m[3], this.m[4], this.m[5]);
				}
				this.applyToPoint = function(p) {
					p.applyTransform(this.m);
				}					
			}
			
			this.Type.SkewBase = function(s) {
				this.base = that.Type.matrix;
				this.base(s);
				this.angle = new svg.Property('angle', s);
			}
			this.Type.SkewBase.prototype = new this.Type.matrix;
			
			this.Type.skewX = function(s) {
				this.base = that.Type.SkewBase;
				this.base(s);
				this.m = [1, 0, Math.tan(this.angle.toRadians()), 1, 0, 0];
			}
			this.Type.skewX.prototype = new this.Type.SkewBase;
			
			this.Type.skewY = function(s) {
				this.base = that.Type.SkewBase;
				this.base(s);
				this.m = [1, Math.tan(this.angle.toRadians()), 0, 1, 0, 0];
			}
			this.Type.skewY.prototype = new this.Type.SkewBase;
		
			this.transforms = [];
			
			this.apply = function(ctx) {
				for (var i=0; i<this.transforms.length; i++) {
					this.transforms[i].apply(ctx);
				}
			}
			
			this.unapply = function(ctx) {
				for (var i=this.transforms.length-1; i>=0; i--) {
					this.transforms[i].unapply(ctx);
				}
			}
			
			this.applyToPoint = function(p) {
				for (var i=0; i<this.transforms.length; i++) {
					this.transforms[i].applyToPoint(p);
				}
			}
			
			var data = svg.trim(svg.compressSpaces(v)).replace(/\)(\s?,\s?)/g,') ').split(/\s(?=[a-z])/);
			for (var i=0; i<data.length; i++) {
				var type = svg.trim(data[i].split('(')[0]);
				var s = data[i].split('(')[1].replace(')','');
				var transform = new this.Type[type](s);
				transform.type = type;
				this.transforms.push(transform);
			}
		}
		
		// aspect ratio
		svg.AspectRatio = function(ctx, aspectRatio, width, desiredWidth, height, desiredHeight, minX, minY, refX, refY) {
			// aspect ratio - http://www.w3.org/TR/SVG/coords.html#PreserveAspectRatioAttribute
			aspectRatio = svg.compressSpaces(aspectRatio);
			aspectRatio = aspectRatio.replace(/^defer\s/,''); // ignore defer
			var align = aspectRatio.split(' ')[0] || 'xMidYMid';
			var meetOrSlice = aspectRatio.split(' ')[1] || 'meet';					
	
			// calculate scale
			var scaleX = width / desiredWidth;
			var scaleY = height / desiredHeight;
			var scaleMin = Math.min(scaleX, scaleY);
			var scaleMax = Math.max(scaleX, scaleY);
			if (meetOrSlice == 'meet') { desiredWidth *= scaleMin; desiredHeight *= scaleMin; }
			if (meetOrSlice == 'slice') { desiredWidth *= scaleMax; desiredHeight *= scaleMax; }	
			
			refX = new svg.Property('refX', refX);
			refY = new svg.Property('refY', refY);
			if (refX.hasValue() && refY.hasValue()) {				
				ctx.translate(-scaleMin * refX.toPixels('x'), -scaleMin * refY.toPixels('y'));
			} 
			else {					
				// align
				if (align.match(/^xMid/) && ((meetOrSlice == 'meet' && scaleMin == scaleY) || (meetOrSlice == 'slice' && scaleMax == scaleY))) ctx.translate(width / 2.0 - desiredWidth / 2.0, 0); 
				if (align.match(/YMid$/) && ((meetOrSlice == 'meet' && scaleMin == scaleX) || (meetOrSlice == 'slice' && scaleMax == scaleX))) ctx.translate(0, height / 2.0 - desiredHeight / 2.0); 
				if (align.match(/^xMax/) && ((meetOrSlice == 'meet' && scaleMin == scaleY) || (meetOrSlice == 'slice' && scaleMax == scaleY))) ctx.translate(width - desiredWidth, 0); 
				if (align.match(/YMax$/) && ((meetOrSlice == 'meet' && scaleMin == scaleX) || (meetOrSlice == 'slice' && scaleMax == scaleX))) ctx.translate(0, height - desiredHeight); 
			}
			
			// scale
			if (align == 'none') ctx.scale(scaleX, scaleY);
			else if (meetOrSlice == 'meet') ctx.scale(scaleMin, scaleMin); 
			else if (meetOrSlice == 'slice') ctx.scale(scaleMax, scaleMax); 	
			
			// translate
			ctx.translate(minX == null ? 0 : -minX, minY == null ? 0 : -minY);			
		}
		
		// elements
		svg.Element = {}
		
		svg.EmptyProperty = new svg.Property('EMPTY', '');
		
		svg.Element.ElementBase = function(node) {	
			this.attributes = {};
			this.styles = {};
			this.children = [];
			
			// get or create attribute
			this.attribute = function(name, createIfNotExists) {
				var a = this.attributes[name];
				if (a != null) return a;
							
				if (createIfNotExists == true) { a = new svg.Property(name, ''); this.attributes[name] = a; }
				return a || svg.EmptyProperty;
			}
			
			this.getHrefAttribute = function() {
				for (var a in this.attributes) { 
					if (a.match(/:href$/)) { 
						return this.attributes[a]; 
					} 
				}
				return svg.EmptyProperty;
			}
			
			// get or create style, crawls up node tree
			this.style = function(name, createIfNotExists) {
				var s = this.styles[name];
				if (s != null) return s;
				
				var a = this.attribute(name);
				if (a != null && a.hasValue()) {
					this.styles[name] = a; // move up to me to cache
					return a;
				}
				
				var p = this.parent;
				if (p != null) {
					var ps = p.style(name);
					if (ps != null && ps.hasValue()) {
						return ps;
					}
				}
					
				if (createIfNotExists == true) { s = new svg.Property(name, ''); this.styles[name] = s; }
				return s || svg.EmptyProperty;
			}
			
			// base render
			this.render = function(ctx) {
				// don't render display=none
				if (this.style('display').value == 'none') return;
				
				// don't render visibility=hidden
				if (this.attribute('visibility').value == 'hidden') return;
			
				ctx.save();
				if (this.attribute('mask').hasValue()) { // mask
					var mask = this.attribute('mask').getDefinition();
					if (mask != null) mask.apply(ctx, this);
				}
				else if (this.style('filter').hasValue()) { // filter
					var filter = this.style('filter').getDefinition();
					if (filter != null) filter.apply(ctx, this);
				}
				else {	
					this.setContext(ctx);
					this.renderChildren(ctx);	
					this.clearContext(ctx);							
				}
				ctx.restore();
			}
			
			// base set context
			this.setContext = function(ctx) {
				// OVERRIDE ME!
			}
			
			// base clear context
			this.clearContext = function(ctx) {
				// OVERRIDE ME!
			}			
			
			// base render children
			this.renderChildren = function(ctx) {
				for (var i=0; i<this.children.length; i++) {
					this.children[i].render(ctx);
				}
			}
			
			this.addChild = function(childNode, create) {
				var child = childNode;
				if (create) child = svg.CreateElement(childNode);
				child.parent = this;
				this.children.push(child);			
			}
				
			if (node != null && node.nodeType == 1) { //ELEMENT_NODE
				// add children
				for (var i=0; i<node.childNodes.length; i++) {
					var childNode = node.childNodes[i];
					if (childNode.nodeType == 1) this.addChild(childNode, true); //ELEMENT_NODE
					if (this.captureTextNodes && childNode.nodeType == 3) {
						var text = childNode.nodeValue || childNode.text || '';
						if (svg.trim(svg.compressSpaces(text)) != '') {
							this.addChild(new svg.Element.tspan(childNode), false); // TEXT_NODE
						}
					}
				}
				
				// add attributes
				for (var i=0; i<node.attributes.length; i++) {
					var attribute = node.attributes[i];
					this.attributes[attribute.nodeName] = new svg.Property(attribute.nodeName, attribute.nodeValue);
				}
										
				// add tag styles
				var styles = svg.Styles[node.nodeName];
				if (styles != null) {
					for (var name in styles) {
						this.styles[name] = styles[name];
					}
				}					
				
				// add class styles
				if (this.attribute('class').hasValue()) {
					var classes = svg.compressSpaces(this.attribute('class').value).split(' ');
					for (var j=0; j<classes.length; j++) {
						styles = svg.Styles['.'+classes[j]];
						if (styles != null) {
							for (var name in styles) {
								this.styles[name] = styles[name];
							}
						}
						styles = svg.Styles[node.nodeName+'.'+classes[j]];
						if (styles != null) {
							for (var name in styles) {
								this.styles[name] = styles[name];
							}
						}
					}
				}
				
				// add id styles
				if (this.attribute('id').hasValue()) {
					var styles = svg.Styles['#' + this.attribute('id').value];
					if (styles != null) {
						for (var name in styles) {
							this.styles[name] = styles[name];
						}
					}
				}
				
				// add inline styles
				if (this.attribute('style').hasValue()) {
					var styles = this.attribute('style').value.split(';');
					for (var i=0; i<styles.length; i++) {
						if (svg.trim(styles[i]) != '') {
							var style = styles[i].split(':');
							var name = svg.trim(style[0]);
							var value = svg.trim(style[1]);
							this.styles[name] = new svg.Property(name, value);
						}
					}
				}	

				// add id
				if (this.attribute('id').hasValue()) {
					if (svg.Definitions[this.attribute('id').value] == null) {
						svg.Definitions[this.attribute('id').value] = this;
					}
				}
			}
		}
		
		svg.Element.RenderedElementBase = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);
			
			this.setContext = function(ctx) {
				// fill
				if (this.style('fill').isUrlDefinition()) {
					var fs = this.style('fill').getFillStyleDefinition(this, this.style('fill-opacity'));
					if (fs != null) ctx.fillStyle = fs;
				}
				else if (this.style('fill').hasValue()) {
					var fillStyle = this.style('fill');
					if (fillStyle.value == 'currentColor') fillStyle.value = this.style('color').value;
					ctx.fillStyle = (fillStyle.value == 'none' ? 'rgba(0,0,0,0)' : fillStyle.value);
				}
				if (this.style('fill-opacity').hasValue()) {
					var fillStyle = new svg.Property('fill', ctx.fillStyle);
					fillStyle = fillStyle.addOpacity(this.style('fill-opacity').value);
					ctx.fillStyle = fillStyle.value;
				}
									
				// stroke
				if (this.style('stroke').isUrlDefinition()) {
					var fs = this.style('stroke').getFillStyleDefinition(this, this.style('stroke-opacity'));
					if (fs != null) ctx.strokeStyle = fs;
				}
				else if (this.style('stroke').hasValue()) {
					var strokeStyle = this.style('stroke');
					if (strokeStyle.value == 'currentColor') strokeStyle.value = this.style('color').value;
					ctx.strokeStyle = (strokeStyle.value == 'none' ? 'rgba(0,0,0,0)' : strokeStyle.value);
				}
				if (this.style('stroke-opacity').hasValue()) {
					var strokeStyle = new svg.Property('stroke', ctx.strokeStyle);
					strokeStyle = strokeStyle.addOpacity(this.style('stroke-opacity').value);
					ctx.strokeStyle = strokeStyle.value;
				}
				if (this.style('stroke-width').hasValue()) {
					var newLineWidth = this.style('stroke-width').toPixels();
					ctx.lineWidth = newLineWidth == 0 ? 0.001 : newLineWidth; // browsers don't respect 0
			    }
				if (this.style('stroke-linecap').hasValue()) ctx.lineCap = this.style('stroke-linecap').value;
				if (this.style('stroke-linejoin').hasValue()) ctx.lineJoin = this.style('stroke-linejoin').value;
				if (this.style('stroke-miterlimit').hasValue()) ctx.miterLimit = this.style('stroke-miterlimit').value;
				if (this.style('stroke-dasharray').hasValue()) {
					var gaps = svg.ToNumberArray(this.style('stroke-dasharray').value);
					if (typeof(ctx.setLineDash) != 'undefined') { ctx.setLineDash(gaps); }
					else if (typeof(ctx.webkitLineDash) != 'undefined') { ctx.webkitLineDash = gaps; }
					else if (typeof(ctx.mozDash ) != 'undefined') { ctx.mozDash  = gaps; }
					
					var offset = this.style('stroke-dashoffset').numValueOrDefault(1);
					if (typeof(ctx.lineDashOffset) != 'undefined') { ctx.lineDashOffset = offset; }
					else if (typeof(ctx.webkitLineDashOffset) != 'undefined') { ctx.webkitLineDashOffset = offset; }
					else if (typeof(ctx.mozDashOffset) != 'undefined') { ctx.mozDashOffset = offset; }
				}

				// font
				if (typeof(ctx.font) != 'undefined') {
					ctx.font = svg.Font.CreateFont( 
						this.style('font-style').value, 
						this.style('font-variant').value, 
						this.style('font-weight').value, 
						this.style('font-size').hasValue() ? this.style('font-size').toPixels() + 'px' : '', 
						this.style('font-family').value).toString();
				}
				
				// transform
				if (this.attribute('transform').hasValue()) { 
					var transform = new svg.Transform(this.attribute('transform').value);
					transform.apply(ctx);
				}
				
				// clip
				if (this.style('clip-path').hasValue()) {
					var clip = this.style('clip-path').getDefinition();
					if (clip != null) clip.apply(ctx);
				}
				
				// opacity
				if (this.style('opacity').hasValue()) {
					ctx.globalAlpha = this.style('opacity').numValue();
				}
			}		
		}
		svg.Element.RenderedElementBase.prototype = new svg.Element.ElementBase;
		
		svg.Element.PathElementBase = function(node) {
			this.base = svg.Element.RenderedElementBase;
			this.base(node);
			
			this.path = function(ctx) {
				if (ctx != null) ctx.beginPath();
				return new svg.BoundingBox();
			}
			
			this.renderChildren = function(ctx) {
				this.path(ctx);
				svg.Mouse.checkPath(this, ctx);
				if (ctx.fillStyle != '') {
					if (this.attribute('fill-rule').hasValue()) { ctx.fill(this.attribute('fill-rule').value); }
					else { ctx.fill(); }
				}
				if (ctx.strokeStyle != '') ctx.stroke();
				
				var markers = this.getMarkers();
				if (markers != null) {
					if (this.style('marker-start').isUrlDefinition()) {
						var marker = this.style('marker-start').getDefinition();
						marker.render(ctx, markers[0][0], markers[0][1]);
					}
					if (this.style('marker-mid').isUrlDefinition()) {
						var marker = this.style('marker-mid').getDefinition();
						for (var i=1;i<markers.length-1;i++) {
							marker.render(ctx, markers[i][0], markers[i][1]);
						}
					}
					if (this.style('marker-end').isUrlDefinition()) {
						var marker = this.style('marker-end').getDefinition();
						marker.render(ctx, markers[markers.length-1][0], markers[markers.length-1][1]);
					}
				}					
			}
			
			this.getBoundingBox = function() {
				return this.path();
			}
			
			this.getMarkers = function() {
				return null;
			}
		}
		svg.Element.PathElementBase.prototype = new svg.Element.RenderedElementBase;
		
		// svg element
		svg.Element.svg = function(node) {
			this.base = svg.Element.RenderedElementBase;
			this.base(node);
			
			this.baseClearContext = this.clearContext;
			this.clearContext = function(ctx) {
				this.baseClearContext(ctx);
				svg.ViewPort.RemoveCurrent();
			}
			
			this.baseSetContext = this.setContext;
			this.setContext = function(ctx) {
				// initial values
				ctx.strokeStyle = 'rgba(0,0,0,0)';
				ctx.lineCap = 'butt';
				ctx.lineJoin = 'miter';
				ctx.miterLimit = 4;			
			
				this.baseSetContext(ctx);
				
				// create new view port
				if (!this.attribute('x').hasValue()) this.attribute('x', true).value = 0;
				if (!this.attribute('y').hasValue()) this.attribute('y', true).value = 0;
				ctx.translate(this.attribute('x').toPixels('x'), this.attribute('y').toPixels('y'));
				
				var width = svg.ViewPort.width();
				var height = svg.ViewPort.height();
				
				if (!this.attribute('width').hasValue()) this.attribute('width', true).value = '100%';
				if (!this.attribute('height').hasValue()) this.attribute('height', true).value = '100%';
				if (typeof(this.root) == 'undefined') {
					width = this.attribute('width').toPixels('x');
					height = this.attribute('height').toPixels('y');
					
					var x = 0;
					var y = 0;
					if (this.attribute('refX').hasValue() && this.attribute('refY').hasValue()) {
						x = -this.attribute('refX').toPixels('x');
						y = -this.attribute('refY').toPixels('y');
					}
					
					ctx.beginPath();
					ctx.moveTo(x, y);
					ctx.lineTo(width, y);
					ctx.lineTo(width, height);
					ctx.lineTo(x, height);
					ctx.closePath();
					ctx.clip();
				}
				svg.ViewPort.SetCurrent(width, height);	
						
				// viewbox
				if (this.attribute('viewBox').hasValue()) {				
					var viewBox = svg.ToNumberArray(this.attribute('viewBox').value);
					var minX = viewBox[0];
					var minY = viewBox[1];
					width = viewBox[2];
					height = viewBox[3];
					
					svg.AspectRatio(ctx,
									this.attribute('preserveAspectRatio').value, 
									svg.ViewPort.width(), 
									width,
									svg.ViewPort.height(),
									height,
									minX,
									minY,
									this.attribute('refX').value,
									this.attribute('refY').value);
										
					svg.ViewPort.RemoveCurrent();	
					svg.ViewPort.SetCurrent(viewBox[2], viewBox[3]);						
				}				
			}
		}
		svg.Element.svg.prototype = new svg.Element.RenderedElementBase;

		// rect element
		svg.Element.rect = function(node) {
			this.base = svg.Element.PathElementBase;
			this.base(node);
			
			this.path = function(ctx) {
				var x = this.attribute('x').toPixels('x');
				var y = this.attribute('y').toPixels('y');
				var width = this.attribute('width').toPixels('x');
				var height = this.attribute('height').toPixels('y');
				var rx = this.attribute('rx').toPixels('x');
				var ry = this.attribute('ry').toPixels('y');
				if (this.attribute('rx').hasValue() && !this.attribute('ry').hasValue()) ry = rx;
				if (this.attribute('ry').hasValue() && !this.attribute('rx').hasValue()) rx = ry;
				rx = Math.min(rx, width / 2.0);
				ry = Math.min(ry, height / 2.0);
				if (ctx != null) {
					ctx.beginPath();
					ctx.moveTo(x + rx, y);
					ctx.lineTo(x + width - rx, y);
					ctx.quadraticCurveTo(x + width, y, x + width, y + ry)
					ctx.lineTo(x + width, y + height - ry);
					ctx.quadraticCurveTo(x + width, y + height, x + width - rx, y + height)
					ctx.lineTo(x + rx, y + height);
					ctx.quadraticCurveTo(x, y + height, x, y + height - ry)
					ctx.lineTo(x, y + ry);
					ctx.quadraticCurveTo(x, y, x + rx, y)
					ctx.closePath();
				}
				
				return new svg.BoundingBox(x, y, x + width, y + height);
			}
		}
		svg.Element.rect.prototype = new svg.Element.PathElementBase;
		
		// circle element
		svg.Element.circle = function(node) {
			this.base = svg.Element.PathElementBase;
			this.base(node);
			
			this.path = function(ctx) {
				var cx = this.attribute('cx').toPixels('x');
				var cy = this.attribute('cy').toPixels('y');
				var r = this.attribute('r').toPixels();
			
				if (ctx != null) {
					ctx.beginPath();
					ctx.arc(cx, cy, r, 0, Math.PI * 2, true); 
					ctx.closePath();
				}
				
				return new svg.BoundingBox(cx - r, cy - r, cx + r, cy + r);
			}
		}
		svg.Element.circle.prototype = new svg.Element.PathElementBase;	

		// ellipse element
		svg.Element.ellipse = function(node) {
			this.base = svg.Element.PathElementBase;
			this.base(node);
			
			this.path = function(ctx) {
				var KAPPA = 4 * ((Math.sqrt(2) - 1) / 3);
				var rx = this.attribute('rx').toPixels('x');
				var ry = this.attribute('ry').toPixels('y');
				var cx = this.attribute('cx').toPixels('x');
				var cy = this.attribute('cy').toPixels('y');
				
				if (ctx != null) {
					ctx.beginPath();
					ctx.moveTo(cx, cy - ry);
					ctx.bezierCurveTo(cx + (KAPPA * rx), cy - ry,  cx + rx, cy - (KAPPA * ry), cx + rx, cy);
					ctx.bezierCurveTo(cx + rx, cy + (KAPPA * ry), cx + (KAPPA * rx), cy + ry, cx, cy + ry);
					ctx.bezierCurveTo(cx - (KAPPA * rx), cy + ry, cx - rx, cy + (KAPPA * ry), cx - rx, cy);
					ctx.bezierCurveTo(cx - rx, cy - (KAPPA * ry), cx - (KAPPA * rx), cy - ry, cx, cy - ry);
					ctx.closePath();
				}
				
				return new svg.BoundingBox(cx - rx, cy - ry, cx + rx, cy + ry);
			}
		}
		svg.Element.ellipse.prototype = new svg.Element.PathElementBase;			
		
		// line element
		svg.Element.line = function(node) {
			this.base = svg.Element.PathElementBase;
			this.base(node);
			
			this.getPoints = function() {
				return [
					new svg.Point(this.attribute('x1').toPixels('x'), this.attribute('y1').toPixels('y')),
					new svg.Point(this.attribute('x2').toPixels('x'), this.attribute('y2').toPixels('y'))];
			}
								
			this.path = function(ctx) {
				var points = this.getPoints();
				
				if (ctx != null) {
					ctx.beginPath();
					ctx.moveTo(points[0].x, points[0].y);
					ctx.lineTo(points[1].x, points[1].y);
				}
				
				return new svg.BoundingBox(points[0].x, points[0].y, points[1].x, points[1].y);
			}
			
			this.getMarkers = function() {
				var points = this.getPoints();	
				var a = points[0].angleTo(points[1]);
				return [[points[0], a], [points[1], a]];
			}
		}
		svg.Element.line.prototype = new svg.Element.PathElementBase;		
				
		// polyline element
		svg.Element.polyline = function(node) {
			this.base = svg.Element.PathElementBase;
			this.base(node);
			
			this.points = svg.CreatePath(this.attribute('points').value);
			this.path = function(ctx) {
				var bb = new svg.BoundingBox(this.points[0].x, this.points[0].y);
				if (ctx != null) {
					ctx.beginPath();
					ctx.moveTo(this.points[0].x, this.points[0].y);
				}
				for (var i=1; i<this.points.length; i++) {
					bb.addPoint(this.points[i].x, this.points[i].y);
					if (ctx != null) ctx.lineTo(this.points[i].x, this.points[i].y);
				}
				return bb;
			}
			
			this.getMarkers = function() {
				var markers = [];
				for (var i=0; i<this.points.length - 1; i++) {
					markers.push([this.points[i], this.points[i].angleTo(this.points[i+1])]);
				}
				markers.push([this.points[this.points.length-1], markers[markers.length-1][1]]);
				return markers;
			}			
		}
		svg.Element.polyline.prototype = new svg.Element.PathElementBase;				
				
		// polygon element
		svg.Element.polygon = function(node) {
			this.base = svg.Element.polyline;
			this.base(node);
			
			this.basePath = this.path;
			this.path = function(ctx) {
				var bb = this.basePath(ctx);
				if (ctx != null) {
					ctx.lineTo(this.points[0].x, this.points[0].y);
					ctx.closePath();
				}
				return bb;
			}
		}
		svg.Element.polygon.prototype = new svg.Element.polyline;

		// path element
		svg.Element.path = function(node) {
			this.base = svg.Element.PathElementBase;
			this.base(node);
					
			var d = this.attribute('d').value;
			// TODO: convert to real lexer based on http://www.w3.org/TR/SVG11/paths.html#PathDataBNF
			d = d.replace(/,/gm,' '); // get rid of all commas
			d = d.replace(/([MmZzLlHhVvCcSsQqTtAa])([MmZzLlHhVvCcSsQqTtAa])/gm,'$1 $2'); // separate commands from commands
			d = d.replace(/([MmZzLlHhVvCcSsQqTtAa])([MmZzLlHhVvCcSsQqTtAa])/gm,'$1 $2'); // separate commands from commands
			d = d.replace(/([MmZzLlHhVvCcSsQqTtAa])([^\s])/gm,'$1 $2'); // separate commands from points
			d = d.replace(/([^\s])([MmZzLlHhVvCcSsQqTtAa])/gm,'$1 $2'); // separate commands from points
			d = d.replace(/([0-9])([+\-])/gm,'$1 $2'); // separate digits when no comma
			d = d.replace(/(\.[0-9]*)(\.)/gm,'$1 $2'); // separate digits when no comma
			d = d.replace(/([Aa](\s+[0-9]+){3})\s+([01])\s*([01])/gm,'$1 $3 $4 '); // shorthand elliptical arc path syntax
			d = svg.compressSpaces(d); // compress multiple spaces
			d = svg.trim(d);
			this.PathParser = new (function(d) {
				this.tokens = d.split(' ');
				
				this.reset = function() {
					this.i = -1;
					this.command = '';
					this.previousCommand = '';
					this.start = new svg.Point(0, 0);
					this.control = new svg.Point(0, 0);
					this.current = new svg.Point(0, 0);
					this.points = [];
					this.angles = [];
				}
								
				this.isEnd = function() {
					return this.i >= this.tokens.length - 1;
				}
				
				this.isCommandOrEnd = function() {
					if (this.isEnd()) return true;
					return this.tokens[this.i + 1].match(/^[A-Za-z]$/) != null;
				}
				
				this.isRelativeCommand = function() {
					switch(this.command)
					{
						case 'm':
						case 'l':
						case 'h':
						case 'v':
						case 'c':
						case 's':
						case 'q':
						case 't':
						case 'a':
						case 'z':
							return true;
							break;
					}
					return false;
				}
							
				this.getToken = function() {
					this.i++;
					return this.tokens[this.i];
				}
				
				this.getScalar = function() {
					return parseFloat(this.getToken());
				}
				
				this.nextCommand = function() {
					this.previousCommand = this.command;
					this.command = this.getToken();
				}				
				
				this.getPoint = function() {
					var p = new svg.Point(this.getScalar(), this.getScalar());
					return this.makeAbsolute(p);
				}
				
				this.getAsControlPoint = function() {
					var p = this.getPoint();
					this.control = p;
					return p;
				}
				
				this.getAsCurrentPoint = function() {
					var p = this.getPoint();
					this.current = p;
					return p;	
				}
				
				this.getReflectedControlPoint = function() {
					if (this.previousCommand.toLowerCase() != 'c' && 
					    this.previousCommand.toLowerCase() != 's' &&
						this.previousCommand.toLowerCase() != 'q' && 
						this.previousCommand.toLowerCase() != 't' ){
						return this.current;
					}
					
					// reflect point
					var p = new svg.Point(2 * this.current.x - this.control.x, 2 * this.current.y - this.control.y);					
					return p;
				}
				
				this.makeAbsolute = function(p) {
					if (this.isRelativeCommand()) {
						p.x += this.current.x;
						p.y += this.current.y;
					}
					return p;
				}
				
				this.addMarker = function(p, from, priorTo) {
					// if the last angle isn't filled in because we didn't have this point yet ...
					if (priorTo != null && this.angles.length > 0 && this.angles[this.angles.length-1] == null) {
						this.angles[this.angles.length-1] = this.points[this.points.length-1].angleTo(priorTo);
					}
					this.addMarkerAngle(p, from == null ? null : from.angleTo(p));
				}
				
				this.addMarkerAngle = function(p, a) {
					this.points.push(p);
					this.angles.push(a);
				}				
				
				this.getMarkerPoints = function() { return this.points; }
				this.getMarkerAngles = function() {
					for (var i=0; i<this.angles.length; i++) {
						if (this.angles[i] == null) {
							for (var j=i+1; j<this.angles.length; j++) {
								if (this.angles[j] != null) {
									this.angles[i] = this.angles[j];
									break;
								}
							}
						}
					}
					return this.angles;
				}
			})(d);

			this.path = function(ctx) {
				var pp = this.PathParser;
				pp.reset();

				var bb = new svg.BoundingBox();
				if (ctx != null) ctx.beginPath();
				while (!pp.isEnd()) {
					pp.nextCommand();
					switch (pp.command) {
					case 'M':
					case 'm':
						var p = pp.getAsCurrentPoint();
						pp.addMarker(p);
						bb.addPoint(p.x, p.y);
						if (ctx != null) ctx.moveTo(p.x, p.y);
						pp.start = pp.current;
						while (!pp.isCommandOrEnd()) {
							var p = pp.getAsCurrentPoint();
							pp.addMarker(p, pp.start);
							bb.addPoint(p.x, p.y);
							if (ctx != null) ctx.lineTo(p.x, p.y);
						}
						break;
					case 'L':
					case 'l':
						while (!pp.isCommandOrEnd()) {
							var c = pp.current;
							var p = pp.getAsCurrentPoint();
							pp.addMarker(p, c);
							bb.addPoint(p.x, p.y);
							if (ctx != null) ctx.lineTo(p.x, p.y);
						}
						break;
					case 'H':
					case 'h':
						while (!pp.isCommandOrEnd()) {
							var newP = new svg.Point((pp.isRelativeCommand() ? pp.current.x : 0) + pp.getScalar(), pp.current.y);
							pp.addMarker(newP, pp.current);
							pp.current = newP;
							bb.addPoint(pp.current.x, pp.current.y);
							if (ctx != null) ctx.lineTo(pp.current.x, pp.current.y);
						}
						break;
					case 'V':
					case 'v':
						while (!pp.isCommandOrEnd()) {
							var newP = new svg.Point(pp.current.x, (pp.isRelativeCommand() ? pp.current.y : 0) + pp.getScalar());
							pp.addMarker(newP, pp.current);
							pp.current = newP;
							bb.addPoint(pp.current.x, pp.current.y);
							if (ctx != null) ctx.lineTo(pp.current.x, pp.current.y);
						}
						break;
					case 'C':
					case 'c':
						while (!pp.isCommandOrEnd()) {
							var curr = pp.current;
							var p1 = pp.getPoint();
							var cntrl = pp.getAsControlPoint();
							var cp = pp.getAsCurrentPoint();
							pp.addMarker(cp, cntrl, p1);
							bb.addBezierCurve(curr.x, curr.y, p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y);
							if (ctx != null) ctx.bezierCurveTo(p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y);
						}
						break;
					case 'S':
					case 's':
						while (!pp.isCommandOrEnd()) {
							var curr = pp.current;
							var p1 = pp.getReflectedControlPoint();
							var cntrl = pp.getAsControlPoint();
							var cp = pp.getAsCurrentPoint();
							pp.addMarker(cp, cntrl, p1);
							bb.addBezierCurve(curr.x, curr.y, p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y);
							if (ctx != null) ctx.bezierCurveTo(p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y);
						}
						break;
					case 'Q':
					case 'q':
						while (!pp.isCommandOrEnd()) {
							var curr = pp.current;
							var cntrl = pp.getAsControlPoint();
							var cp = pp.getAsCurrentPoint();
							pp.addMarker(cp, cntrl, cntrl);
							bb.addQuadraticCurve(curr.x, curr.y, cntrl.x, cntrl.y, cp.x, cp.y);
							if (ctx != null) ctx.quadraticCurveTo(cntrl.x, cntrl.y, cp.x, cp.y);
						}
						break;
					case 'T':
					case 't':
						while (!pp.isCommandOrEnd()) {
							var curr = pp.current;
							var cntrl = pp.getReflectedControlPoint();
							pp.control = cntrl;
							var cp = pp.getAsCurrentPoint();
							pp.addMarker(cp, cntrl, cntrl);
							bb.addQuadraticCurve(curr.x, curr.y, cntrl.x, cntrl.y, cp.x, cp.y);
							if (ctx != null) ctx.quadraticCurveTo(cntrl.x, cntrl.y, cp.x, cp.y);
						}
						break;
					case 'A':
					case 'a':
						while (!pp.isCommandOrEnd()) {
						    var curr = pp.current;
							var rx = pp.getScalar();
							var ry = pp.getScalar();
							var xAxisRotation = pp.getScalar() * (Math.PI / 180.0);
							var largeArcFlag = pp.getScalar();
							var sweepFlag = pp.getScalar();
							var cp = pp.getAsCurrentPoint();

							// Conversion from endpoint to center parameterization
							// http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
							// x1', y1'
							var currp = new svg.Point(
								Math.cos(xAxisRotation) * (curr.x - cp.x) / 2.0 + Math.sin(xAxisRotation) * (curr.y - cp.y) / 2.0,
								-Math.sin(xAxisRotation) * (curr.x - cp.x) / 2.0 + Math.cos(xAxisRotation) * (curr.y - cp.y) / 2.0
							);
							// adjust radii
							var l = Math.pow(currp.x,2)/Math.pow(rx,2)+Math.pow(currp.y,2)/Math.pow(ry,2);
							if (l > 1) {
								rx *= Math.sqrt(l);
								ry *= Math.sqrt(l);
							}
							// cx', cy'
							var s = (largeArcFlag == sweepFlag ? -1 : 1) * Math.sqrt(
								((Math.pow(rx,2)*Math.pow(ry,2))-(Math.pow(rx,2)*Math.pow(currp.y,2))-(Math.pow(ry,2)*Math.pow(currp.x,2))) /
								(Math.pow(rx,2)*Math.pow(currp.y,2)+Math.pow(ry,2)*Math.pow(currp.x,2))
							);
							if (isNaN(s)) s = 0;
							var cpp = new svg.Point(s * rx * currp.y / ry, s * -ry * currp.x / rx);
							// cx, cy
							var centp = new svg.Point(
								(curr.x + cp.x) / 2.0 + Math.cos(xAxisRotation) * cpp.x - Math.sin(xAxisRotation) * cpp.y,
								(curr.y + cp.y) / 2.0 + Math.sin(xAxisRotation) * cpp.x + Math.cos(xAxisRotation) * cpp.y
							);
							// vector magnitude
							var m = function(v) { return Math.sqrt(Math.pow(v[0],2) + Math.pow(v[1],2)); }
							// ratio between two vectors
							var r = function(u, v) { return (u[0]*v[0]+u[1]*v[1]) / (m(u)*m(v)) }
							// angle between two vectors
							var a = function(u, v) { return (u[0]*v[1] < u[1]*v[0] ? -1 : 1) * Math.acos(r(u,v)); }
							// initial angle
							var a1 = a([1,0], [(currp.x-cpp.x)/rx,(currp.y-cpp.y)/ry]);
							// angle delta
							var u = [(currp.x-cpp.x)/rx,(currp.y-cpp.y)/ry];
							var v = [(-currp.x-cpp.x)/rx,(-currp.y-cpp.y)/ry];
							var ad = a(u, v);
							if (r(u,v) <= -1) ad = Math.PI;
							if (r(u,v) >= 1) ad = 0;

							// for markers
							var dir = 1 - sweepFlag ? 1.0 : -1.0;
							var ah = a1 + dir * (ad / 2.0);
							var halfWay = new svg.Point(
								centp.x + rx * Math.cos(ah),
								centp.y + ry * Math.sin(ah)
							);
							pp.addMarkerAngle(halfWay, ah - dir * Math.PI / 2);
							pp.addMarkerAngle(cp, ah - dir * Math.PI);

							bb.addPoint(cp.x, cp.y); // TODO: this is too naive, make it better
							if (ctx != null) {
								var r = rx > ry ? rx : ry;
								var sx = rx > ry ? 1 : rx / ry;
								var sy = rx > ry ? ry / rx : 1;

								ctx.translate(centp.x, centp.y);
								ctx.rotate(xAxisRotation);
								ctx.scale(sx, sy);
								ctx.arc(0, 0, r, a1, a1 + ad, 1 - sweepFlag);
								ctx.scale(1/sx, 1/sy);
								ctx.rotate(-xAxisRotation);
								ctx.translate(-centp.x, -centp.y);
							}
						}
						break;
					case 'Z':
					case 'z':
						if (ctx != null) ctx.closePath();
						pp.current = pp.start;
					}
				}

				return bb;
			}

			this.getMarkers = function() {
				var points = this.PathParser.getMarkerPoints();
				var angles = this.PathParser.getMarkerAngles();
				
				var markers = [];
				for (var i=0; i<points.length; i++) {
					markers.push([points[i], angles[i]]);
				}
				return markers;
			}
		}
		svg.Element.path.prototype = new svg.Element.PathElementBase;
		
		// pattern element
		svg.Element.pattern = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);
			
			this.createPattern = function(ctx, element) {
				var width = this.attribute('width').toPixels('x', true);
				var height = this.attribute('height').toPixels('y', true);
			
				// render me using a temporary svg element
				var tempSvg = new svg.Element.svg();
				tempSvg.attributes['viewBox'] = new svg.Property('viewBox', this.attribute('viewBox').value);
				tempSvg.attributes['width'] = new svg.Property('width', width + 'px');
				tempSvg.attributes['height'] = new svg.Property('height', height + 'px');
				tempSvg.attributes['transform'] = new svg.Property('transform', this.attribute('patternTransform').value);
				tempSvg.children = this.children;
				
				var c = document.createElement('canvas');
				c.width = width;
				c.height = height;
				var cctx = c.getContext('2d');
				if (this.attribute('x').hasValue() && this.attribute('y').hasValue()) {
					cctx.translate(this.attribute('x').toPixels('x', true), this.attribute('y').toPixels('y', true));
				}
				// render 3x3 grid so when we transform there's no white space on edges
				for (var x=-1; x<=1; x++) {
					for (var y=-1; y<=1; y++) {
						cctx.save();
						cctx.translate(x * c.width, y * c.height);
						tempSvg.render(cctx);
						cctx.restore();
					}
				}
				var pattern = ctx.createPattern(c, 'repeat');
				return pattern;
			}
		}
		svg.Element.pattern.prototype = new svg.Element.ElementBase;
		
		// marker element
		svg.Element.marker = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);
			
			this.baseRender = this.render;
			this.render = function(ctx, point, angle) {
				ctx.translate(point.x, point.y);
				if (this.attribute('orient').valueOrDefault('auto') == 'auto') ctx.rotate(angle);
				if (this.attribute('markerUnits').valueOrDefault('strokeWidth') == 'strokeWidth') ctx.scale(ctx.lineWidth, ctx.lineWidth);
				ctx.save();
							
				// render me using a temporary svg element
				var tempSvg = new svg.Element.svg();
				tempSvg.attributes['viewBox'] = new svg.Property('viewBox', this.attribute('viewBox').value);
				tempSvg.attributes['refX'] = new svg.Property('refX', this.attribute('refX').value);
				tempSvg.attributes['refY'] = new svg.Property('refY', this.attribute('refY').value);
				tempSvg.attributes['width'] = new svg.Property('width', this.attribute('markerWidth').value);
				tempSvg.attributes['height'] = new svg.Property('height', this.attribute('markerHeight').value);
				tempSvg.attributes['fill'] = new svg.Property('fill', this.attribute('fill').valueOrDefault('black'));
				tempSvg.attributes['stroke'] = new svg.Property('stroke', this.attribute('stroke').valueOrDefault('none'));
				tempSvg.children = this.children;
				tempSvg.render(ctx);
				
				ctx.restore();
				if (this.attribute('markerUnits').valueOrDefault('strokeWidth') == 'strokeWidth') ctx.scale(1/ctx.lineWidth, 1/ctx.lineWidth);
				if (this.attribute('orient').valueOrDefault('auto') == 'auto') ctx.rotate(-angle);
				ctx.translate(-point.x, -point.y);
			}
		}
		svg.Element.marker.prototype = new svg.Element.ElementBase;
		
		// definitions element
		svg.Element.defs = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);	
			
			this.render = function(ctx) {
				// NOOP
			}
		}
		svg.Element.defs.prototype = new svg.Element.ElementBase;
		
		// base for gradients
		svg.Element.GradientBase = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);
			
			this.gradientUnits = this.attribute('gradientUnits').valueOrDefault('objectBoundingBox');
			
			this.stops = [];			
			for (var i=0; i<this.children.length; i++) {
				var child = this.children[i];
				if (child.type == 'stop') this.stops.push(child);
			}	
			
			this.getGradient = function() {
				// OVERRIDE ME!
			}			

			this.createGradient = function(ctx, element, parentOpacityProp) {
				var stopsContainer = this;
				if (this.getHrefAttribute().hasValue()) {
					stopsContainer = this.getHrefAttribute().getDefinition();
				}
				
				var addParentOpacity = function (color) {
					if (parentOpacityProp.hasValue()) {
						var p = new svg.Property('color', color);
						return p.addOpacity(parentOpacityProp.value).value;
					}
					return color;
				};
			
				var g = this.getGradient(ctx, element);
				if (g == null) return addParentOpacity(stopsContainer.stops[stopsContainer.stops.length - 1].color);
				for (var i=0; i<stopsContainer.stops.length; i++) {
					g.addColorStop(stopsContainer.stops[i].offset, addParentOpacity(stopsContainer.stops[i].color));
				}
				
				if (this.attribute('gradientTransform').hasValue()) {
					// render as transformed pattern on temporary canvas
					var rootView = svg.ViewPort.viewPorts[0];
					
					var rect = new svg.Element.rect();
					rect.attributes['x'] = new svg.Property('x', -svg.MAX_VIRTUAL_PIXELS/3.0);
					rect.attributes['y'] = new svg.Property('y', -svg.MAX_VIRTUAL_PIXELS/3.0);
					rect.attributes['width'] = new svg.Property('width', svg.MAX_VIRTUAL_PIXELS);
					rect.attributes['height'] = new svg.Property('height', svg.MAX_VIRTUAL_PIXELS);
					
					var group = new svg.Element.g();
					group.attributes['transform'] = new svg.Property('transform', this.attribute('gradientTransform').value);
					group.children = [ rect ];
					
					var tempSvg = new svg.Element.svg();
					tempSvg.attributes['x'] = new svg.Property('x', 0);
					tempSvg.attributes['y'] = new svg.Property('y', 0);
					tempSvg.attributes['width'] = new svg.Property('width', rootView.width);
					tempSvg.attributes['height'] = new svg.Property('height', rootView.height);
					tempSvg.children = [ group ];
					
					var c = document.createElement('canvas');
					c.width = rootView.width;
					c.height = rootView.height;
					var tempCtx = c.getContext('2d');
					tempCtx.fillStyle = g;
					tempSvg.render(tempCtx);		
					return tempCtx.createPattern(c, 'no-repeat');
				}
				
				return g;				
			}
		}
		svg.Element.GradientBase.prototype = new svg.Element.ElementBase;
		
		// linear gradient element
		svg.Element.linearGradient = function(node) {
			this.base = svg.Element.GradientBase;
			this.base(node);
			
			this.getGradient = function(ctx, element) {
				var bb = element.getBoundingBox();
				
				if (!this.attribute('x1').hasValue()
				 && !this.attribute('y1').hasValue()
				 && !this.attribute('x2').hasValue()
				 && !this.attribute('y2').hasValue()) {
					this.attribute('x1', true).value = 0;
					this.attribute('y1', true).value = 0;
					this.attribute('x2', true).value = 1;
					this.attribute('y2', true).value = 0;
				 }
				
				var x1 = (this.gradientUnits == 'objectBoundingBox' 
					? bb.x() + bb.width() * this.attribute('x1').numValue() 
					: this.attribute('x1').toPixels('x'));
				var y1 = (this.gradientUnits == 'objectBoundingBox' 
					? bb.y() + bb.height() * this.attribute('y1').numValue()
					: this.attribute('y1').toPixels('y'));
				var x2 = (this.gradientUnits == 'objectBoundingBox' 
					? bb.x() + bb.width() * this.attribute('x2').numValue()
					: this.attribute('x2').toPixels('x'));
				var y2 = (this.gradientUnits == 'objectBoundingBox' 
					? bb.y() + bb.height() * this.attribute('y2').numValue()
					: this.attribute('y2').toPixels('y'));

				if (x1 == x2 && y1 == y2) return null;
				return ctx.createLinearGradient(x1, y1, x2, y2);
			}
		}
		svg.Element.linearGradient.prototype = new svg.Element.GradientBase;
		
		// radial gradient element
		svg.Element.radialGradient = function(node) {
			this.base = svg.Element.GradientBase;
			this.base(node);
			
			this.getGradient = function(ctx, element) {
				var bb = element.getBoundingBox();
				
				if (!this.attribute('cx').hasValue()) this.attribute('cx', true).value = '50%';
				if (!this.attribute('cy').hasValue()) this.attribute('cy', true).value = '50%';
				if (!this.attribute('r').hasValue()) this.attribute('r', true).value = '50%';
				
				var cx = (this.gradientUnits == 'objectBoundingBox' 
					? bb.x() + bb.width() * this.attribute('cx').numValue() 
					: this.attribute('cx').toPixels('x'));
				var cy = (this.gradientUnits == 'objectBoundingBox' 
					? bb.y() + bb.height() * this.attribute('cy').numValue() 
					: this.attribute('cy').toPixels('y'));
				
				var fx = cx;
				var fy = cy;
				if (this.attribute('fx').hasValue()) {
					fx = (this.gradientUnits == 'objectBoundingBox' 
					? bb.x() + bb.width() * this.attribute('fx').numValue() 
					: this.attribute('fx').toPixels('x'));
				}
				if (this.attribute('fy').hasValue()) {
					fy = (this.gradientUnits == 'objectBoundingBox' 
					? bb.y() + bb.height() * this.attribute('fy').numValue() 
					: this.attribute('fy').toPixels('y'));
				}
				
				var r = (this.gradientUnits == 'objectBoundingBox' 
					? (bb.width() + bb.height()) / 2.0 * this.attribute('r').numValue()
					: this.attribute('r').toPixels());
				
				return ctx.createRadialGradient(fx, fy, 0, cx, cy, r);
			}
		}
		svg.Element.radialGradient.prototype = new svg.Element.GradientBase;
		
		// gradient stop element
		svg.Element.stop = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);
			
			this.offset = this.attribute('offset').numValue();
			if (this.offset < 0) this.offset = 0;
			if (this.offset > 1) this.offset = 1;
			
			var stopColor = this.style('stop-color');
			if (this.style('stop-opacity').hasValue()) stopColor = stopColor.addOpacity(this.style('stop-opacity').value);
			this.color = stopColor.value;
		}
		svg.Element.stop.prototype = new svg.Element.ElementBase;
		
		// animation base element
		svg.Element.AnimateBase = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);
			
			svg.Animations.push(this);
			
			this.duration = 0.0;
			this.begin = this.attribute('begin').toMilliseconds();
			this.maxDuration = this.begin + this.attribute('dur').toMilliseconds();
			
			this.getProperty = function() {
				var attributeType = this.attribute('attributeType').value;
				var attributeName = this.attribute('attributeName').value;
				
				if (attributeType == 'CSS') {
					return this.parent.style(attributeName, true);
				}
				return this.parent.attribute(attributeName, true);			
			};
			
			this.initialValue = null;
			this.initialUnits = '';
			this.removed = false;			

			this.calcValue = function() {
				// OVERRIDE ME!
				return '';
			}
					
			this.update = function(delta) {	
				// set initial value
				if (this.initialValue == null) {
					this.initialValue = this.getProperty().value;
					this.initialUnits = this.getProperty().getUnits();
				}
			
				// if we're past the end time
				if (this.duration > this.maxDuration) {
					// loop for indefinitely repeating animations
					if (this.attribute('repeatCount').value == 'indefinite'
					 || this.attribute('repeatDur').value == 'indefinite') {
						this.duration = 0.0
					}
					else if (this.attribute('fill').valueOrDefault('remove') == 'remove' && !this.removed) {
						this.removed = true;
						this.getProperty().value = this.initialValue;
						return true;
					}
					else {
						return false; // no updates made
					}
				}			
				this.duration = this.duration + delta;
			
				// if we're past the begin time
				var updated = false;
				if (this.begin < this.duration) {
					var newValue = this.calcValue(); // tween
					
					if (this.attribute('type').hasValue()) {
						// for transform, etc.
						var type = this.attribute('type').value;
						newValue = type + '(' + newValue + ')';
					}
					
					this.getProperty().value = newValue;
					updated = true;
				}
				
				return updated;
			}
			
			this.from = this.attribute('from');
			this.to = this.attribute('to');
			this.values = this.attribute('values');
			if (this.values.hasValue()) this.values.value = this.values.value.split(';');
			
			// fraction of duration we've covered
			this.progress = function() {
				var ret = { progress: (this.duration - this.begin) / (this.maxDuration - this.begin) };
				if (this.values.hasValue()) {
					var p = ret.progress * (this.values.value.length - 1);
					var lb = Math.floor(p), ub = Math.ceil(p);
					ret.from = new svg.Property('from', parseFloat(this.values.value[lb]));
					ret.to = new svg.Property('to', parseFloat(this.values.value[ub]));
					ret.progress = (p - lb) / (ub - lb);
				}
				else {
					ret.from = this.from;
					ret.to = this.to;
				}
				return ret;
			}			
		}
		svg.Element.AnimateBase.prototype = new svg.Element.ElementBase;
		
		// animate element
		svg.Element.animate = function(node) {
			this.base = svg.Element.AnimateBase;
			this.base(node);
			
			this.calcValue = function() {
				var p = this.progress();
				
				// tween value linearly
				var newValue = p.from.numValue() + (p.to.numValue() - p.from.numValue()) * p.progress; 
				return newValue + this.initialUnits;
			};
		}
		svg.Element.animate.prototype = new svg.Element.AnimateBase;
			
		// animate color element
		svg.Element.animateColor = function(node) {
			this.base = svg.Element.AnimateBase;
			this.base(node);

			this.calcValue = function() {
				var p = this.progress();
				var from = new RGBColor(p.from.value);
				var to = new RGBColor(p.to.value);
				
				if (from.ok && to.ok) {
					// tween color linearly
					var r = from.r + (to.r - from.r) * p.progress;
					var g = from.g + (to.g - from.g) * p.progress;
					var b = from.b + (to.b - from.b) * p.progress;
					return 'rgb('+parseInt(r,10)+','+parseInt(g,10)+','+parseInt(b,10)+')';
				}
				return this.attribute('from').value;
			};
		}
		svg.Element.animateColor.prototype = new svg.Element.AnimateBase;
		
		// animate transform element
		svg.Element.animateTransform = function(node) {
			this.base = svg.Element.AnimateBase;
			this.base(node);
			
			this.calcValue = function() {
				var p = this.progress();
				
				// tween value linearly
				var from = svg.ToNumberArray(p.from.value);
				var to = svg.ToNumberArray(p.to.value);
				var newValue = '';
				for (var i=0; i<from.length; i++) {
					newValue += from[i] + (to[i] - from[i]) * p.progress + ' ';
				}
				return newValue;
			};
		}
		svg.Element.animateTransform.prototype = new svg.Element.animate;
		
		// font element
		svg.Element.font = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			this.horizAdvX = this.attribute('horiz-adv-x').numValue();			
			
			this.isRTL = false;
			this.isArabic = false;
			this.fontFace = null;
			this.missingGlyph = null;
			this.glyphs = [];			
			for (var i=0; i<this.children.length; i++) {
				var child = this.children[i];
				if (child.type == 'font-face') {
					this.fontFace = child;
					if (child.style('font-family').hasValue()) {
						svg.Definitions[child.style('font-family').value] = this;
					}
				}
				else if (child.type == 'missing-glyph') this.missingGlyph = child;
				else if (child.type == 'glyph') {
					if (child.arabicForm != '') {
						this.isRTL = true;
						this.isArabic = true;
						if (typeof(this.glyphs[child.unicode]) == 'undefined') this.glyphs[child.unicode] = [];
						this.glyphs[child.unicode][child.arabicForm] = child;
					}
					else {
						this.glyphs[child.unicode] = child;
					}
				}
			}	
		}
		svg.Element.font.prototype = new svg.Element.ElementBase;
		
		// font-face element
		svg.Element.fontface = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);	
			
			this.ascent = this.attribute('ascent').value;
			this.descent = this.attribute('descent').value;
			this.unitsPerEm = this.attribute('units-per-em').numValue();				
		}
		svg.Element.fontface.prototype = new svg.Element.ElementBase;
		
		// missing-glyph element
		svg.Element.missingglyph = function(node) {
			this.base = svg.Element.path;
			this.base(node);	
			
			this.horizAdvX = 0;
		}
		svg.Element.missingglyph.prototype = new svg.Element.path;
		
		// glyph element
		svg.Element.glyph = function(node) {
			this.base = svg.Element.path;
			this.base(node);	
			
			this.horizAdvX = this.attribute('horiz-adv-x').numValue();
			this.unicode = this.attribute('unicode').value;
			this.arabicForm = this.attribute('arabic-form').value;
		}
		svg.Element.glyph.prototype = new svg.Element.path;
		
		// text element
		svg.Element.text = function(node) {
			this.captureTextNodes = true;
			this.base = svg.Element.RenderedElementBase;
			this.base(node);
			
			this.baseSetContext = this.setContext;
			this.setContext = function(ctx) {
				this.baseSetContext(ctx);
				if (this.style('dominant-baseline').hasValue()) ctx.textBaseline = this.style('dominant-baseline').value;
				if (this.style('alignment-baseline').hasValue()) ctx.textBaseline = this.style('alignment-baseline').value;
			}
			
			this.getBoundingBox = function () {
				// TODO: implement
				return new svg.BoundingBox(this.attribute('x').toPixels('x'), this.attribute('y').toPixels('y'), 0, 0);
			}
			
			this.renderChildren = function(ctx) {
				this.x = this.attribute('x').toPixels('x');
				this.y = this.attribute('y').toPixels('y');
				this.x += this.getAnchorDelta(ctx, this, 0);
				for (var i=0; i<this.children.length; i++) {
					this.renderChild(ctx, this, i);
				}
			}
			
			this.getAnchorDelta = function (ctx, parent, startI) {
				var textAnchor = this.style('text-anchor').valueOrDefault('start');
				if (textAnchor != 'start') {
					var width = 0;
					for (var i=startI; i<parent.children.length; i++) {
						var child = parent.children[i];
						if (i > startI && child.attribute('x').hasValue()) break; // new group
						width += child.measureTextRecursive(ctx);
					}
					return -1 * (textAnchor == 'end' ? width : width / 2.0);
				}
				return 0;
			}
			
			this.renderChild = function(ctx, parent, i) {
				var child = parent.children[i];
				if (child.attribute('x').hasValue()) {
					child.x = child.attribute('x').toPixels('x') + this.getAnchorDelta(ctx, parent, i);
				}
				else {
					if (this.attribute('dx').hasValue()) this.x += this.attribute('dx').toPixels('x');
					if (child.attribute('dx').hasValue()) this.x += child.attribute('dx').toPixels('x');
					child.x = this.x;
				}
				this.x = child.x + child.measureText(ctx);
				
				if (child.attribute('y').hasValue()) {
					child.y = child.attribute('y').toPixels('y');
				}
				else {
					if (this.attribute('dy').hasValue()) this.y += this.attribute('dy').toPixels('y');
					if (child.attribute('dy').hasValue()) this.y += child.attribute('dy').toPixels('y');
					child.y = this.y;
				}
				this.y = child.y;
				
				child.render(ctx);
				
				for (var i=0; i<child.children.length; i++) {
					this.renderChild(ctx, child, i);
				}
			}
		}
		svg.Element.text.prototype = new svg.Element.RenderedElementBase;
		
		// text base
		svg.Element.TextElementBase = function(node) {
			this.base = svg.Element.RenderedElementBase;
			this.base(node);
			
			this.getGlyph = function(font, text, i) {
				var c = text[i];
				var glyph = null;
				if (font.isArabic) {
					var arabicForm = 'isolated';
					if ((i==0 || text[i-1]==' ') && i<text.length-2 && text[i+1]!=' ') arabicForm = 'terminal'; 
					if (i>0 && text[i-1]!=' ' && i<text.length-2 && text[i+1]!=' ') arabicForm = 'medial';
					if (i>0 && text[i-1]!=' ' && (i == text.length-1 || text[i+1]==' ')) arabicForm = 'initial';
					if (typeof(font.glyphs[c]) != 'undefined') {
						glyph = font.glyphs[c][arabicForm];
						if (glyph == null && font.glyphs[c].type == 'glyph') glyph = font.glyphs[c];
					}
				}
				else {
					glyph = font.glyphs[c];
				}
				if (glyph == null) glyph = font.missingGlyph;
				return glyph;
			}
			
			this.renderChildren = function(ctx) {
				var customFont = this.parent.style('font-family').getDefinition();
				if (customFont != null) {
					var fontSize = this.parent.style('font-size').numValueOrDefault(svg.Font.Parse(svg.ctx.font).fontSize);
					var fontStyle = this.parent.style('font-style').valueOrDefault(svg.Font.Parse(svg.ctx.font).fontStyle);
					var text = this.getText();
					if (customFont.isRTL) text = text.split("").reverse().join("");
					
					var dx = svg.ToNumberArray(this.parent.attribute('dx').value);
					for (var i=0; i<text.length; i++) {
						var glyph = this.getGlyph(customFont, text, i);
						var scale = fontSize / customFont.fontFace.unitsPerEm;
						ctx.translate(this.x, this.y);
						ctx.scale(scale, -scale);
						var lw = ctx.lineWidth;
						ctx.lineWidth = ctx.lineWidth * customFont.fontFace.unitsPerEm / fontSize;
						if (fontStyle == 'italic') ctx.transform(1, 0, .4, 1, 0, 0);
						glyph.render(ctx);
						if (fontStyle == 'italic') ctx.transform(1, 0, -.4, 1, 0, 0);
						ctx.lineWidth = lw;
						ctx.scale(1/scale, -1/scale);
						ctx.translate(-this.x, -this.y);	
						
						this.x += fontSize * (glyph.horizAdvX || customFont.horizAdvX) / customFont.fontFace.unitsPerEm;
						if (typeof(dx[i]) != 'undefined' && !isNaN(dx[i])) {
							this.x += dx[i];
						}
					}
					return;
				}
			
				if (ctx.fillStyle != '') ctx.fillText(svg.compressSpaces(this.getText()), this.x, this.y);
				if (ctx.strokeStyle != '') ctx.strokeText(svg.compressSpaces(this.getText()), this.x, this.y);
			}
			
			this.getText = function() {
				// OVERRIDE ME
			}
			
			this.measureTextRecursive = function(ctx) {
				var width = this.measureText(ctx);
				for (var i=0; i<this.children.length; i++) {
					width += this.children[i].measureTextRecursive(ctx);
				}
				return width;
			}
			
			this.measureText = function(ctx) {
				var customFont = this.parent.style('font-family').getDefinition();
				if (customFont != null) {
					var fontSize = this.parent.style('font-size').numValueOrDefault(svg.Font.Parse(svg.ctx.font).fontSize);
					var measure = 0;
					var text = this.getText();
					if (customFont.isRTL) text = text.split("").reverse().join("");
					var dx = svg.ToNumberArray(this.parent.attribute('dx').value);
					for (var i=0; i<text.length; i++) {
						var glyph = this.getGlyph(customFont, text, i);
						measure += (glyph.horizAdvX || customFont.horizAdvX) * fontSize / customFont.fontFace.unitsPerEm;
						if (typeof(dx[i]) != 'undefined' && !isNaN(dx[i])) {
							measure += dx[i];
						}
					}
					return measure;
				}
			
				var textToMeasure = svg.compressSpaces(this.getText());
				if (!ctx.measureText) return textToMeasure.length * 10;
				
				ctx.save();
				this.setContext(ctx);
				var width = ctx.measureText(textToMeasure).width;
				ctx.restore();
				return width;
			}
		}
		svg.Element.TextElementBase.prototype = new svg.Element.RenderedElementBase;
		
		// tspan 
		svg.Element.tspan = function(node) {
			this.captureTextNodes = true;
			this.base = svg.Element.TextElementBase;
			this.base(node);
			
			this.text = node.nodeValue || node.text || '';
			this.getText = function() {
				return this.text;
			}
		}
		svg.Element.tspan.prototype = new svg.Element.TextElementBase;
		
		// tref
		svg.Element.tref = function(node) {
			this.base = svg.Element.TextElementBase;
			this.base(node);
			
			this.getText = function() {
				var element = this.getHrefAttribute().getDefinition();
				if (element != null) return element.children[0].getText();
			}
		}
		svg.Element.tref.prototype = new svg.Element.TextElementBase;		
		
		// a element
		svg.Element.a = function(node) {
			this.base = svg.Element.TextElementBase;
			this.base(node);
			
			this.hasText = true;
			for (var i=0; i<node.childNodes.length; i++) {
				if (node.childNodes[i].nodeType != 3) this.hasText = false;
			}
			
			// this might contain text
			this.text = this.hasText ? node.childNodes[0].nodeValue : '';
			this.getText = function() {
				return this.text;
			}		

			this.baseRenderChildren = this.renderChildren;
			this.renderChildren = function(ctx) {
				if (this.hasText) {
					// render as text element
					this.baseRenderChildren(ctx);
					var fontSize = new svg.Property('fontSize', svg.Font.Parse(svg.ctx.font).fontSize);
					svg.Mouse.checkBoundingBox(this, new svg.BoundingBox(this.x, this.y - fontSize.toPixels('y'), this.x + this.measureText(ctx), this.y));					
				}
				else {
					// render as temporary group
					var g = new svg.Element.g();
					g.children = this.children;
					g.parent = this;
					g.render(ctx);
				}
			}
			
			this.onclick = function() {
				window.open(this.getHrefAttribute().value);
			}
			
			this.onmousemove = function() {
				svg.ctx.canvas.style.cursor = 'pointer';
			}
		}
		svg.Element.a.prototype = new svg.Element.TextElementBase;		
		
		// image element
		svg.Element.image = function(node) {
			this.base = svg.Element.RenderedElementBase;
			this.base(node);
			
			var href = this.getHrefAttribute().value;
			var isSvg = href.match(/\.svg$/)
			
			svg.Images.push(this);
			this.loaded = false;
			if (!isSvg) {
				this.img = document.createElement('img');
				var self = this;
				this.img.onload = function() { self.loaded = true; }
				this.img.onerror = function() { if (typeof(console) != 'undefined') { console.log('ERROR: image "' + href + '" not found'); self.loaded = true; } }
				this.img.src = href;
			}
			else {
				this.img = svg.ajax(href);
				this.loaded = true;
			}
			
			this.renderChildren = function(ctx) {
				var x = this.attribute('x').toPixels('x');
				var y = this.attribute('y').toPixels('y');
				
				var width = this.attribute('width').toPixels('x');
				var height = this.attribute('height').toPixels('y');			
				if (width == 0 || height == 0) return;
			
				ctx.save();
				if (isSvg) {
					ctx.drawSvg(this.img, x, y, width, height);
				}
				else {
					ctx.translate(x, y);
					svg.AspectRatio(ctx,
									this.attribute('preserveAspectRatio').value,
									width,
									this.img.width,
									height,
									this.img.height,
									0,
									0);	
					ctx.drawImage(this.img, 0, 0);		
				}
				ctx.restore();
			}
			
			this.getBoundingBox = function() {
				var x = this.attribute('x').toPixels('x');
				var y = this.attribute('y').toPixels('y');
				var width = this.attribute('width').toPixels('x');
				var height = this.attribute('height').toPixels('y');
				return new svg.BoundingBox(x, y, x + width, y + height);
			}
		}
		svg.Element.image.prototype = new svg.Element.RenderedElementBase;
		
		// group element
		svg.Element.g = function(node) {
			this.base = svg.Element.RenderedElementBase;
			this.base(node);
			
			this.getBoundingBox = function() {
				var bb = new svg.BoundingBox();
				for (var i=0; i<this.children.length; i++) {
					bb.addBoundingBox(this.children[i].getBoundingBox());
				}
				return bb;
			};
		}
		svg.Element.g.prototype = new svg.Element.RenderedElementBase;

		// symbol element
		svg.Element.symbol = function(node) {
			this.base = svg.Element.RenderedElementBase;
			this.base(node);
			
			this.baseSetContext = this.setContext;
			this.setContext = function(ctx) {		
				this.baseSetContext(ctx);
				
				// viewbox
				if (this.attribute('viewBox').hasValue()) {				
					var viewBox = svg.ToNumberArray(this.attribute('viewBox').value);
					var minX = viewBox[0];
					var minY = viewBox[1];
					width = viewBox[2];
					height = viewBox[3];
					
					svg.AspectRatio(ctx,
									this.attribute('preserveAspectRatio').value, 
									this.attribute('width').toPixels('x'),
									width,
									this.attribute('height').toPixels('y'),
									height,
									minX,
									minY);

					svg.ViewPort.SetCurrent(viewBox[2], viewBox[3]);						
				}
			}			
		}
		svg.Element.symbol.prototype = new svg.Element.RenderedElementBase;		
			
		// style element
		svg.Element.style = function(node) { 
			this.base = svg.Element.ElementBase;
			this.base(node);
			
			// text, or spaces then CDATA
			var css = ''
			for (var i=0; i<node.childNodes.length; i++) {
			  css += node.childNodes[i].nodeValue;
			}
			css = css.replace(/(\/\*([^*]|[\r\n]|(\*+([^*\/]|[\r\n])))*\*+\/)|(^[\s]*\/\/.*)/gm, ''); // remove comments
			css = svg.compressSpaces(css); // replace whitespace
			var cssDefs = css.split('}');
			for (var i=0; i<cssDefs.length; i++) {
				if (svg.trim(cssDefs[i]) != '') {
					var cssDef = cssDefs[i].split('{');
					var cssClasses = cssDef[0].split(',');
					var cssProps = cssDef[1].split(';');
					for (var j=0; j<cssClasses.length; j++) {
						var cssClass = svg.trim(cssClasses[j]);
						if (cssClass != '') {
							var props = {};
							for (var k=0; k<cssProps.length; k++) {
								var prop = cssProps[k].indexOf(':');
								var name = cssProps[k].substr(0, prop);
								var value = cssProps[k].substr(prop + 1, cssProps[k].length - prop);
								if (name != null && value != null) {
									props[svg.trim(name)] = new svg.Property(svg.trim(name), svg.trim(value));
								}
							}
							svg.Styles[cssClass] = props;
							if (cssClass == '@font-face') {
								var fontFamily = props['font-family'].value.replace(/"/g,'');
								var srcs = props['src'].value.split(',');
								for (var s=0; s<srcs.length; s++) {
									if (srcs[s].indexOf('format("svg")') > 0) {
										var urlStart = srcs[s].indexOf('url');
										var urlEnd = srcs[s].indexOf(')', urlStart);
										var url = srcs[s].substr(urlStart + 5, urlEnd - urlStart - 6);
										var doc = svg.parseXml(svg.ajax(url));
										var fonts = doc.getElementsByTagName('font');
										for (var f=0; f<fonts.length; f++) {
											var font = svg.CreateElement(fonts[f]);
											svg.Definitions[fontFamily] = font;
										}
									}
								}
							}
						}
					}
				}
			}
		}
		svg.Element.style.prototype = new svg.Element.ElementBase;
		
		// use element 
		svg.Element.use = function(node) {
			this.base = svg.Element.RenderedElementBase;
			this.base(node);
			
			this.baseSetContext = this.setContext;
			this.setContext = function(ctx) {
				this.baseSetContext(ctx);
				if (this.attribute('x').hasValue()) ctx.translate(this.attribute('x').toPixels('x'), 0);
				if (this.attribute('y').hasValue()) ctx.translate(0, this.attribute('y').toPixels('y'));
			}
			
			this.getDefinition = function() {
				var element = this.getHrefAttribute().getDefinition();
				if (this.attribute('width').hasValue()) element.attribute('width', true).value = this.attribute('width').value;
				if (this.attribute('height').hasValue()) element.attribute('height', true).value = this.attribute('height').value;
				return element;
			}
			
			this.path = function(ctx) {
				var element = this.getDefinition();
				if (element != null) element.path(ctx);
			}
			
			this.getBoundingBox = function() {
				var element = this.getDefinition();
				if (element != null) return element.getBoundingBox();
			}
			
			this.renderChildren = function(ctx) {
				var element = this.getDefinition();
				if (element != null) {
					// temporarily detach from parent and render
					var oldParent = element.parent;
					element.parent = null;
					element.render(ctx);
					element.parent = oldParent;
				}
			}
		}
		svg.Element.use.prototype = new svg.Element.RenderedElementBase;
		
		// mask element
		svg.Element.mask = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);
						
			this.apply = function(ctx, element) {
				// render as temp svg	
				var x = this.attribute('x').toPixels('x');
				var y = this.attribute('y').toPixels('y');
				var width = this.attribute('width').toPixels('x');
				var height = this.attribute('height').toPixels('y');
				
				if (width == 0 && height == 0) {
					var bb = new svg.BoundingBox();
					for (var i=0; i<this.children.length; i++) {
						bb.addBoundingBox(this.children[i].getBoundingBox());
					}
					var x = Math.floor(bb.x1);
					var y = Math.floor(bb.y1);
					var width = Math.floor(bb.width());
					var	height = Math.floor(bb.height());
				}
				
				// temporarily remove mask to avoid recursion
				var mask = element.attribute('mask').value;
				element.attribute('mask').value = '';
				
					var cMask = document.createElement('canvas');
					cMask.width = x + width;
					cMask.height = y + height;
					var maskCtx = cMask.getContext('2d');
					this.renderChildren(maskCtx);
				
					var c = document.createElement('canvas');
					c.width = x + width;
					c.height = y + height;
					var tempCtx = c.getContext('2d');
					element.render(tempCtx);
					tempCtx.globalCompositeOperation = 'destination-in';
					tempCtx.fillStyle = maskCtx.createPattern(cMask, 'no-repeat');
					tempCtx.fillRect(0, 0, x + width, y + height);
					
					ctx.fillStyle = tempCtx.createPattern(c, 'no-repeat');
					ctx.fillRect(0, 0, x + width, y + height);
					
				// reassign mask
				element.attribute('mask').value = mask;	
			}
			
			this.render = function(ctx) {
				// NO RENDER
			}
		}
		svg.Element.mask.prototype = new svg.Element.ElementBase;
		
		// clip element
		svg.Element.clipPath = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);
			
			this.apply = function(ctx) {
				for (var i=0; i<this.children.length; i++) {
					var child = this.children[i];
					if (typeof(child.path) != 'undefined') {
						var transform = null;
						if (child.attribute('transform').hasValue()) { 
							transform = new svg.Transform(child.attribute('transform').value);
							transform.apply(ctx);
						}
						child.path(ctx);
						ctx.clip();
						if (transform) { transform.unapply(ctx); }
					}
				}
			}
			
			this.render = function(ctx) {
				// NO RENDER
			}
		}
		svg.Element.clipPath.prototype = new svg.Element.ElementBase;

		// filters
		svg.Element.filter = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);
						
			this.apply = function(ctx, element) {
				// render as temp svg	
				var bb = element.getBoundingBox();
				var x = Math.floor(bb.x1);
				var y = Math.floor(bb.y1);
				var width = Math.floor(bb.width());
				var	height = Math.floor(bb.height());

				// temporarily remove filter to avoid recursion
				var filter = element.style('filter').value;
				element.style('filter').value = '';
				
				var px = 0, py = 0;
				for (var i=0; i<this.children.length; i++) {
					var efd = this.children[i].extraFilterDistance || 0;
					px = Math.max(px, efd);
					py = Math.max(py, efd);
				}
				
				var c = document.createElement('canvas');
				c.width = width + 2*px;
				c.height = height + 2*py;
				var tempCtx = c.getContext('2d');
				tempCtx.translate(-x + px, -y + py);
				element.render(tempCtx);
			
				// apply filters
				for (var i=0; i<this.children.length; i++) {
					this.children[i].apply(tempCtx, 0, 0, width + 2*px, height + 2*py);
				}
				
				// render on me
				ctx.drawImage(c, 0, 0, width + 2*px, height + 2*py, x - px, y - py, width + 2*px, height + 2*py);
				
				// reassign filter
				element.style('filter', true).value = filter;	
			}
			
			this.render = function(ctx) {
				// NO RENDER
			}		
		}
		svg.Element.filter.prototype = new svg.Element.ElementBase;
		
		svg.Element.feMorphology = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);
			
			this.apply = function(ctx, x, y, width, height) {
				// TODO: implement
			}
		}
		svg.Element.feMorphology.prototype = new svg.Element.ElementBase;
		
		svg.Element.feColorMatrix = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);
			
			function imGet(img, x, y, width, height, rgba) {
				return img[y*width*4 + x*4 + rgba];
			}
			
			function imSet(img, x, y, width, height, rgba, val) {
				img[y*width*4 + x*4 + rgba] = val;
			}
			
			this.apply = function(ctx, x, y, width, height) {
				// only supporting grayscale for now per Issue 195, need to extend to all matrix
				// assuming x==0 && y==0 for now
				var srcData = ctx.getImageData(0, 0, width, height);
				for (var y = 0; y < height; y++) {
					for (var x = 0; x < width; x++) {
						var r = imGet(srcData.data, x, y, width, height, 0);
						var g = imGet(srcData.data, x, y, width, height, 1);
						var b = imGet(srcData.data, x, y, width, height, 2);
						var gray = (r + g + b) / 3;
						imSet(srcData.data, x, y, width, height, 0, gray);
						imSet(srcData.data, x, y, width, height, 1, gray);
						imSet(srcData.data, x, y, width, height, 2, gray);
					}
				}
				ctx.clearRect(0, 0, width, height);
				ctx.putImageData(srcData, 0, 0);
			}
		}
		svg.Element.feColorMatrix.prototype = new svg.Element.ElementBase;
		
		svg.Element.feGaussianBlur = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			this.blurRadius = Math.floor(this.attribute('stdDeviation').numValue());
			this.extraFilterDistance = this.blurRadius;
			
			this.apply = function(ctx, x, y, width, height) {
				if (typeof(stackBlurCanvasRGBA) == 'undefined') {
					if (typeof(console) != 'undefined') { console.log('ERROR: StackBlur.js must be included for blur to work'); }
					return;
				}
				
				// StackBlur requires canvas be on document
				ctx.canvas.id = svg.UniqueId();
				ctx.canvas.style.display = 'none';
				document.body.appendChild(ctx.canvas);
				stackBlurCanvasRGBA(ctx.canvas.id, x, y, width, height, this.blurRadius);
				document.body.removeChild(ctx.canvas);
			}
		}
		svg.Element.feGaussianBlur.prototype = new svg.Element.ElementBase;
		
		// title element, do nothing
		svg.Element.title = function(node) {
		}
		svg.Element.title.prototype = new svg.Element.ElementBase;

		// desc element, do nothing
		svg.Element.desc = function(node) {
		}
		svg.Element.desc.prototype = new svg.Element.ElementBase;		
		
		svg.Element.MISSING = function(node) {
			if (typeof(console) != 'undefined') { console.log('ERROR: Element \'' + node.nodeName + '\' not yet implemented.'); }
		}
		svg.Element.MISSING.prototype = new svg.Element.ElementBase;
		
		// element factory
		svg.CreateElement = function(node) {	
			var className = node.nodeName.replace(/^[^:]+:/,''); // remove namespace
			className = className.replace(/\-/g,''); // remove dashes
			var e = null;
			if (typeof(svg.Element[className]) != 'undefined') {
				e = new svg.Element[className](node);
			}
			else {
				e = new svg.Element.MISSING(node);
			}

			e.type = node.nodeName;
			return e;
		}
				
		// load from url
		svg.load = function(ctx, url) {
			svg.loadXml(ctx, svg.ajax(url));
		}
		
		// load from xml
		svg.loadXml = function(ctx, xml) {
			svg.loadXmlDoc(ctx, svg.parseXml(xml));
		}
		
		svg.loadXmlDoc = function(ctx, dom) {
			svg.init(ctx);
			
			var mapXY = function(p) {
				var e = ctx.canvas;
				while (e) {
					p.x -= e.offsetLeft;
					p.y -= e.offsetTop;
					e = e.offsetParent;
				}
				if (window.scrollX) p.x += window.scrollX;
				if (window.scrollY) p.y += window.scrollY;
				return p;
			}
			
			// bind mouse
			if (svg.opts['ignoreMouse'] != true) {
				ctx.canvas.onclick = function(e) {
					var p = mapXY(new svg.Point(e != null ? e.clientX : event.clientX, e != null ? e.clientY : event.clientY));
					svg.Mouse.onclick(p.x, p.y);
				};
				ctx.canvas.onmousemove = function(e) {
					var p = mapXY(new svg.Point(e != null ? e.clientX : event.clientX, e != null ? e.clientY : event.clientY));
					svg.Mouse.onmousemove(p.x, p.y);
				};
			}
		
			var e = svg.CreateElement(dom.documentElement);
			e.root = true;
					
			// render loop
			var isFirstRender = true;
			var draw = function() {
				svg.ViewPort.Clear();
				if (ctx.canvas.parentNode) svg.ViewPort.SetCurrent(ctx.canvas.parentNode.clientWidth, ctx.canvas.parentNode.clientHeight);
			
				if (svg.opts['ignoreDimensions'] != true) {
					// set canvas size
					if (e.style('width').hasValue()) {
						ctx.canvas.width = e.style('width').toPixels('x');
						ctx.canvas.style.width = ctx.canvas.width + 'px';
					}
					if (e.style('height').hasValue()) {
						ctx.canvas.height = e.style('height').toPixels('y');
						ctx.canvas.style.height = ctx.canvas.height + 'px';
					}
				}
				var cWidth = ctx.canvas.clientWidth || ctx.canvas.width;
				var cHeight = ctx.canvas.clientHeight || ctx.canvas.height;
				if (svg.opts['ignoreDimensions'] == true && e.style('width').hasValue() && e.style('height').hasValue()) {
					cWidth = e.style('width').toPixels('x');
					cHeight = e.style('height').toPixels('y');
				}
				svg.ViewPort.SetCurrent(cWidth, cHeight);		
				
				if (svg.opts['offsetX'] != null) e.attribute('x', true).value = svg.opts['offsetX'];
				if (svg.opts['offsetY'] != null) e.attribute('y', true).value = svg.opts['offsetY'];
				if (svg.opts['scaleWidth'] != null && svg.opts['scaleHeight'] != null) {
					var xRatio = 1, yRatio = 1, viewBox = svg.ToNumberArray(e.attribute('viewBox').value);
					if (e.attribute('width').hasValue()) xRatio = e.attribute('width').toPixels('x') / svg.opts['scaleWidth'];
					else if (!isNaN(viewBox[2])) xRatio = viewBox[2] / svg.opts['scaleWidth'];
					if (e.attribute('height').hasValue()) yRatio = e.attribute('height').toPixels('y') / svg.opts['scaleHeight'];
					else if (!isNaN(viewBox[3])) yRatio = viewBox[3] / svg.opts['scaleHeight'];
					
					e.attribute('width', true).value = svg.opts['scaleWidth'];
					e.attribute('height', true).value = svg.opts['scaleHeight'];			
					e.attribute('viewBox', true).value = '0 0 ' + (cWidth * xRatio) + ' ' + (cHeight * yRatio);
					e.attribute('preserveAspectRatio', true).value = 'none';
				}
			
				// clear and render
				if (svg.opts['ignoreClear'] != true) {
					ctx.clearRect(0, 0, cWidth, cHeight);
				}
				e.render(ctx);
				if (isFirstRender) {
					isFirstRender = false;
					if (typeof(svg.opts['renderCallback']) == 'function') svg.opts['renderCallback'](dom);
				}			
			}
			
			var waitingForImages = true;
			if (svg.ImagesLoaded()) {
				waitingForImages = false;
				draw();
			}
			svg.intervalID = setInterval(function() { 
				var needUpdate = false;
				
				if (waitingForImages && svg.ImagesLoaded()) {
					waitingForImages = false;
					needUpdate = true;
				}
			
				// need update from mouse events?
				if (svg.opts['ignoreMouse'] != true) {
					needUpdate = needUpdate | svg.Mouse.hasEvents();
				}
			
				// need update from animations?
				if (svg.opts['ignoreAnimation'] != true) {
					for (var i=0; i<svg.Animations.length; i++) {
						needUpdate = needUpdate | svg.Animations[i].update(1000 / svg.FRAMERATE);
					}
				}
				
				// need update from redraw?
				if (typeof(svg.opts['forceRedraw']) == 'function') {
					if (svg.opts['forceRedraw']() == true) needUpdate = true;
				}
				
				// render if needed
				if (needUpdate) {
					draw();				
					svg.Mouse.runEvents(); // run and clear our events
				}
			}, 1000 / svg.FRAMERATE);
		}
		
		svg.stop = function() {
			if (svg.intervalID) {
				clearInterval(svg.intervalID);
			}
		}
		
		svg.Mouse = new (function() {
			this.events = [];
			this.hasEvents = function() { return this.events.length != 0; }
		
			this.onclick = function(x, y) {
				this.events.push({ type: 'onclick', x: x, y: y, 
					run: function(e) { if (e.onclick) e.onclick(); }
				});
			}
			
			this.onmousemove = function(x, y) {
				this.events.push({ type: 'onmousemove', x: x, y: y,
					run: function(e) { if (e.onmousemove) e.onmousemove(); }
				});
			}			
			
			this.eventElements = [];
			
			this.checkPath = function(element, ctx) {
				for (var i=0; i<this.events.length; i++) {
					var e = this.events[i];
					if (ctx.isPointInPath && ctx.isPointInPath(e.x, e.y)) this.eventElements[i] = element;
				}
			}
			
			this.checkBoundingBox = function(element, bb) {
				for (var i=0; i<this.events.length; i++) {
					var e = this.events[i];
					if (bb.isPointInBox(e.x, e.y)) this.eventElements[i] = element;
				}			
			}
			
			this.runEvents = function() {
				svg.ctx.canvas.style.cursor = '';
				
				for (var i=0; i<this.events.length; i++) {
					var e = this.events[i];
					var element = this.eventElements[i];
					while (element) {
						e.run(element);
						element = element.parent;
					}
				}		
			
				// done running, clear
				this.events = []; 
				this.eventElements = [];
			}
		});
		
		return svg;
	}
})();

if (typeof(CanvasRenderingContext2D) != 'undefined') {
	CanvasRenderingContext2D.prototype.drawSvg = function(s, dx, dy, dw, dh) {
		canvg(this.canvas, s, { 
			ignoreMouse: true, 
			ignoreAnimation: true, 
			ignoreDimensions: true, 
			ignoreClear: true, 
			offsetX: dx, 
			offsetY: dy, 
			scaleWidth: dw, 
			scaleHeight: dh
		});
	}
}// @tag amchart
/* FileSaver.js
 * A saveAs() FileSaver implementation.
 * 2013-10-21
 *
 * By Eli Grey, http://eligrey.com
 * License: X11/MIT
 *   See LICENSE.md
 */

/*global self */
/*jslint bitwise: true, regexp: true, confusion: true, es5: true, vars: true, white: true,
  plusplus: true */

/*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js */
if(AmCharts.isModern){ /// added by AmCharts to avoid old IE problems if this file is included
var saveAs = saveAs
  || (typeof navigator !== 'undefined' && navigator.msSaveOrOpenBlob && navigator.msSaveOrOpenBlob.bind(navigator))
  || (function(view) {
	"use strict";
	var
		  doc = view.document
		  // only get URL when necessary in case BlobBuilder.js hasn't overridden it yet
		, get_URL = function() {
			return view.URL || view.webkitURL || view;
		}
		, URL = view.URL || view.webkitURL || view
		, save_link = doc.createElementNS("http://www.w3.org/1999/xhtml", "a")
		, can_use_save_link =  !view.externalHost && "download" in save_link
		, click = function(node) {
			var event = doc.createEvent("MouseEvents");
			event.initMouseEvent(
				"click", true, false, view, 0, 0, 0, 0, 0
				, false, false, false, false, 0, null
			);
			node.dispatchEvent(event);
		}
		, webkit_req_fs = view.webkitRequestFileSystem
		, req_fs = view.requestFileSystem || webkit_req_fs || view.mozRequestFileSystem
		, throw_outside = function (ex) {
			(view.setImmediate || view.setTimeout)(function() {
				throw ex;
			}, 0);
		}
		, force_saveable_type = "application/octet-stream"
		, fs_min_size = 0
		, deletion_queue = []
		, process_deletion_queue = function() {
			var i = deletion_queue.length;
			while (i--) {
				var file = deletion_queue[i];
				if (typeof file === "string") { // file is an object URL
					URL.revokeObjectURL(file);
				} else { // file is a File
					file.remove();
				}
			}
			deletion_queue.length = 0; // clear queue
		}
		, dispatch = function(filesaver, event_types, event) {
			event_types = [].concat(event_types);
			var i = event_types.length;
			while (i--) {
				var listener = filesaver["on" + event_types[i]];
				if (typeof listener === "function") {
					try {
						listener.call(filesaver, event || filesaver);
					} catch (ex) {
						throw_outside(ex);
					}
				}
			}
		}
		, FileSaver = function(blob, name) {
			// First try a.download, then web filesystem, then object URLs
			var
				  filesaver = this
				, type = blob.type
				, blob_changed = false
				, object_url
				, target_view
				, get_object_url = function() {
					var object_url = get_URL().createObjectURL(blob);
					deletion_queue.push(object_url);
					return object_url;
				}
				, dispatch_all = function() {
					dispatch(filesaver, "writestart progress write writeend".split(" "));
				}
				// on any filesys errors revert to saving with object URLs
				, fs_error = function() {
					// don't create more object URLs than needed
					if (blob_changed || !object_url) {
						object_url = get_object_url(blob);
					}
					if (target_view) {
						target_view.location.href = object_url;
					} else {
                        window.open(object_url, "_blank");
                    }
					filesaver.readyState = filesaver.DONE;
					dispatch_all();
				}
				, abortable = function(func) {
					return function() {
						if (filesaver.readyState !== filesaver.DONE) {
							return func.apply(this, arguments);
						}
					};
				}
				, create_if_not_found = {create: true, exclusive: false}
				, slice
			;
			filesaver.readyState = filesaver.INIT;
			if (!name) {
				name = "download";
			}
			if (can_use_save_link) {
				object_url = get_object_url(blob);
				// FF for Android has a nasty garbage collection mechanism
				// that turns all objects that are not pure javascript into 'deadObject'
				// this means `doc` and `save_link` are unusable and need to be recreated
				// `view` is usable though:
				doc = view.document;
				save_link = doc.createElementNS("http://www.w3.org/1999/xhtml", "a");
				save_link.href = object_url;
				save_link.download = name;
				var event = doc.createEvent("MouseEvents");
				event.initMouseEvent(
					"click", true, false, view, 0, 0, 0, 0, 0
					, false, false, false, false, 0, null
				);
				save_link.dispatchEvent(event);
				filesaver.readyState = filesaver.DONE;
				dispatch_all();
				return;
			}
			// Object and web filesystem URLs have a problem saving in Google Chrome when
			// viewed in a tab, so I force save with application/octet-stream
			// http://code.google.com/p/chromium/issues/detail?id=91158
			if (view.chrome && type && type !== force_saveable_type) {
				slice = blob.slice || blob.webkitSlice;
				blob = slice.call(blob, 0, blob.size, force_saveable_type);
				blob_changed = true;
			}
			// Since I can't be sure that the guessed media type will trigger a download
			// in WebKit, I append .download to the filename.
			// https://bugs.webkit.org/show_bug.cgi?id=65440
			if (webkit_req_fs && name !== "download") {
				name += ".download";
			}
			if (type === force_saveable_type || webkit_req_fs) {
				target_view = view;
			}
			if (!req_fs) {
				fs_error();
				return;
			}
			fs_min_size += blob.size;
			req_fs(view.TEMPORARY, fs_min_size, abortable(function(fs) {
				fs.root.getDirectory("saved", create_if_not_found, abortable(function(dir) {
					var save = function() {
						dir.getFile(name, create_if_not_found, abortable(function(file) {
							file.createWriter(abortable(function(writer) {
								writer.onwriteend = function(event) {
									target_view.location.href = file.toURL();
									deletion_queue.push(file);
									filesaver.readyState = filesaver.DONE;
									dispatch(filesaver, "writeend", event);
								};
								writer.onerror = function() {
									var error = writer.error;
									if (error.code !== error.ABORT_ERR) {
										fs_error();
									}
								};
								"writestart progress write abort".split(" ").forEach(function(event) {
									writer["on" + event] = filesaver["on" + event];
								});
								writer.write(blob);
								filesaver.abort = function() {
									writer.abort();
									filesaver.readyState = filesaver.DONE;
								};
								filesaver.readyState = filesaver.WRITING;
							}), fs_error);
						}), fs_error);
					};
					dir.getFile(name, {create: false}, abortable(function(file) {
						// delete file if it already exists
						file.remove();
						save();
					}), abortable(function(ex) {
						if (ex.code === ex.NOT_FOUND_ERR) {
							save();
						} else {
							fs_error();
						}
					}));
				}), fs_error);
			}), fs_error);
		}
		, FS_proto = FileSaver.prototype
		, saveAs = function(blob, name) {
			return new FileSaver(blob, name);
		}
	;
	FS_proto.abort = function() {
		var filesaver = this;
		filesaver.readyState = filesaver.DONE;
		dispatch(filesaver, "abort");
	};
	FS_proto.readyState = FS_proto.INIT = 0;
	FS_proto.WRITING = 1;
	FS_proto.DONE = 2;

	FS_proto.error =
	FS_proto.onwritestart =
	FS_proto.onprogress =
	FS_proto.onwrite =
	FS_proto.onabort =
	FS_proto.onerror =
	FS_proto.onwriteend =
		null;

	view.addEventListener("unload", process_deletion_queue, false);
	return saveAs;
}(this.self || this.window || this.content));
// `self` is undefined in Firefox for Android content script context
// while `this` is nsIContentFrameMessageManager
// with an attribute `content` that corresponds to the window

if (typeof module !== 'undefined') module.exports = saveAs;
}/// added by AmCharts to avoid old IE problems if this file is included// @tag amchart
/** @preserve jsPDF 0.9.0rc2 ( ${buildDate} ${commitID} )
Copyright (c) 2010-2012 James Hall, james@snapshotmedia.co.uk, https://github.com/MrRio/jsPDF
Copyright (c) 2012 Willow Systems Corporation, willow-systems.com
MIT license.
*/

/*
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * ====================================================================
 */


/**
Creates new jsPDF document object instance
@class
@param orientation One of "portrait" or "landscape" (or shortcuts "p" (Default), "l")
@param unit Measurement unit to be used when coordinates are specified. One of "pt" (points), "mm" (Default), "cm", "in"
@param format One of 'a0', 'a1', 'a2', 'a3', 'a4' (Default) etc to 'a10', 'b0' to 'b10', 'c0' to 'c10', 'letter', 'government-letter', 'legal', 'junior-legal', 'ledger' or 'tabloid'
@returns {jsPDF}
@name jsPDF
*/
var jsPDF = (function () {
    'use strict';
    /*jslint browser:true, plusplus: true, bitwise: true, nomen: true */
    /*global document: false, btoa, atob, zpipe, Uint8Array, ArrayBuffer, Blob, saveAs, adler32cs, Deflater */

// this will run on <=IE9, possibly some niche browsers
// new webkit-based, FireFox, IE10 already have native version of this.
    if (typeof btoa === 'undefined') {
        window.btoa = function (data) {
        // DO NOT ADD UTF8 ENCODING CODE HERE!!!!

        // UTF8 encoding encodes bytes over char code 128
        // and, essentially, turns an 8-bit binary streams
        // (that base64 can deal with) into 7-bit binary streams.
        // (by default server does not know that and does not recode the data back to 8bit)
        // You destroy your data.

        // binary streams like jpeg image data etc, while stored in JavaScript strings,
        // (which are 16bit arrays) are in 8bit format already.
        // You do NOT need to char-encode that before base64 encoding.

        // if you, by act of fate
        // have string which has individual characters with code
        // above 255 (pure unicode chars), encode that BEFORE you base64 here.
        // you can use absolutely any approch there, as long as in the end,
        // base64 gets an 8bit (char codes 0 - 255) stream.
        // when you get it on the server after un-base64, you must
        // UNencode it too, to get back to 16, 32bit or whatever original bin stream.

        // Note, Yes, JavaScript strings are, in most cases UCS-2 -
        // 16-bit character arrays. This does not mean, however,
        // that you always have to UTF8 it before base64.
        // it means that if you have actual characters anywhere in
        // that string that have char code above 255, you need to
        // recode *entire* string from 16-bit (or 32bit) to 8-bit array.
        // You can do binary split to UTF16 (BE or LE)
        // you can do utf8, you can split the thing by hand and prepend BOM to it,
        // but whatever you do, make sure you mirror the opposite on
        // the server. If server does not expect to post-process un-base64
        // 8-bit binary stream, think very very hard about messing around with encoding.

        // so, long story short:
        // DO NOT ADD UTF8 ENCODING CODE HERE!!!!

        /* @preserve
        ====================================================================
        base64 encoder
        MIT, GPL

        version: 1109.2015
        discuss at: http://phpjs.org/functions/base64_encode
        +   original by: Tyler Akins (http://rumkin.com)
        +   improved by: Bayron Guevara
        +   improved by: Thunder.m
        +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
        +   bugfixed by: Pellentesque Malesuada
        +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
        +   improved by: Rafal Kukawski (http://kukawski.pl)
        +                Daniel Dotsenko, Willow Systems Corp, willow-systems.com
        ====================================================================
        */

            var b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
                b64a = b64.split(''),
                o1,
                o2,
                o3,
                h1,
                h2,
                h3,
                h4,
                bits,
                i = 0,
                ac = 0,
                enc = "",
                tmp_arr = [],
                r;

            do { // pack three octets into four hexets
                o1 = data.charCodeAt(i++);
                o2 = data.charCodeAt(i++);
                o3 = data.charCodeAt(i++);

                bits = o1 << 16 | o2 << 8 | o3;

                h1 = bits >> 18 & 0x3f;
                h2 = bits >> 12 & 0x3f;
                h3 = bits >> 6 & 0x3f;
                h4 = bits & 0x3f;

                // use hexets to index into b64, and append result to encoded string
                tmp_arr[ac++] = b64a[h1] + b64a[h2] + b64a[h3] + b64a[h4];
            } while (i < data.length);

            enc = tmp_arr.join('');
            r = data.length % 3;
            return (r ? enc.slice(0, r - 3) : enc) + '==='.slice(r || 3);
            // end of base64 encoder MIT, GPL
        };
    }

    if (typeof atob === 'undefined') {
        window.atob = function (data) {
        // http://kevin.vanzonneveld.net
        // +   original by: Tyler Akins (http://rumkin.com)
        // +   improved by: Thunder.m
        // +      input by: Aman Gupta
        // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
        // +   bugfixed by: Onno Marsman
        // +   bugfixed by: Pellentesque Malesuada
        // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
        // +      input by: Brett Zamir (http://brett-zamir.me)
        // +   bugfixed by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
        // *     example 1: base64_decode('S2V2aW4gdmFuIFpvbm5ldmVsZA==');
        // *     returns 1: 'Kevin van Zonneveld'
        // mozilla has this native
        // - but breaks in 2.0.0.12!
        //if (typeof this.window['atob'] == 'function') {
        //    return atob(data);
        //}
            var b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
                o1,
                o2,
                o3,
                h1,
                h2,
                h3,
                h4,
                bits,
                i = 0,
                ac = 0,
                dec = "",
                tmp_arr = [];

            if (!data) {
                return data;
            }

            data += '';

            do { // unpack four hexets into three octets using index points in b64
                h1 = b64.indexOf(data.charAt(i++));
                h2 = b64.indexOf(data.charAt(i++));
                h3 = b64.indexOf(data.charAt(i++));
                h4 = b64.indexOf(data.charAt(i++));

                bits = h1 << 18 | h2 << 12 | h3 << 6 | h4;

                o1 = bits >> 16 & 0xff;
                o2 = bits >> 8 & 0xff;
                o3 = bits & 0xff;

                if (h3 === 64) {
                    tmp_arr[ac++] = String.fromCharCode(o1);
                } else if (h4 === 64) {
                    tmp_arr[ac++] = String.fromCharCode(o1, o2);
                } else {
                    tmp_arr[ac++] = String.fromCharCode(o1, o2, o3);
                }
            } while (i < data.length);
            dec = tmp_arr.join('');
            return dec;
        };
    }

    var getObjectLength = typeof Object.keys === 'function' ?
                function (object) {
                    return Object.keys(object).length;
                } :
                function (object) {
                    var i = 0, e;
                    for (e in object) {
                        if (object.hasOwnProperty(e)) {
                            i++;
                        }
                    }
                    return i;
                },

/**
PubSub implementation

@class
@name PubSub
*/
        PubSub = function (context) {
            /**  @preserve
            -----------------------------------------------------------------------------------------------
            JavaScript PubSub library
            2012 (c) ddotsenko@willowsystems.com
            based on Peter Higgins (dante@dojotoolkit.org)
            Loosely based on Dojo publish/subscribe API, limited in scope. Rewritten blindly.
            Original is (c) Dojo Foundation 2004-2010. Released under either AFL or new BSD, see:
            http://dojofoundation.org/license for more information.
            -----------------------------------------------------------------------------------------------
            */
            /**
            @private
            @fieldOf PubSub
            */
            this.topics = {};
            /**
            Stores what will be `this` within the callback functions.

            @private
            @fieldOf PubSub#
            */
            this.context = context;
            /**
            Allows caller to emit an event and pass arguments to event listeners.
            @public
            @function
            @param topic {String} Name of the channel on which to voice this event
            @param args Any number of arguments you want to pass to the listeners of this event.
            @methodOf PubSub#
            @name publish
            */
            this.publish = function (topic, args) {
                if (this.topics[topic]) {
                    var currentTopic = this.topics[topic],
                        toremove = [],
                        fn,
                        i,
                        l,
                        pair,
                        emptyFunc = function () {};
                    args = Array.prototype.slice.call(arguments, 1);
                    for (i = 0, l = currentTopic.length; i < l; i++) {
                        pair = currentTopic[i]; // this is a [function, once_flag] array
                        fn = pair[0];
                        if (pair[1]) { /* 'run once' flag set */
                            pair[0] = emptyFunc;
                            toremove.push(i);
                        }
                        fn.apply(this.context, args);
                    }
                    for (i = 0, l = toremove.length; i < l; i++) {
                        currentTopic.splice(toremove[i], 1);
                    }
                }
            };
            /**
            Allows listener code to subscribe to channel and be called when data is available
            @public
            @function
            @param topic {String} Name of the channel on which to voice this event
            @param callback {Function} Executable (function pointer) that will be ran when event is voiced on this channel.
            @param once {Boolean} (optional. False by default) Flag indicating if the function is to be triggered only once.
            @returns {Object} A token object that cen be used for unsubscribing.
            @methodOf PubSub#
            @name subscribe
            */
            this.subscribe = function (topic, callback, once) {
                if (!this.topics[topic]) {
                    this.topics[topic] = [[callback, once]];
                } else {
                    this.topics[topic].push([callback, once]);
                }
                return {
                    "topic": topic,
                    "callback": callback
                };
            };
            /**
            Allows listener code to unsubscribe from a channel
            @public
            @function
            @param token {Object} A token object that was returned by `subscribe` method
            @methodOf PubSub#
            @name unsubscribe
            */
            this.unsubscribe = function (token) {
                if (this.topics[token.topic]) {
                    var currentTopic = this.topics[token.topic], i, l;

                    for (i = 0, l = currentTopic.length; i < l; i++) {
                        if (currentTopic[i][0] === token.callback) {
                            currentTopic.splice(i, 1);
                        }
                    }
                }
            };
        };


/**
@constructor
@private
*/
    function jsPDF(orientation, unit, format, compressPdf) { /** String orientation, String unit, String format, Boolean compressed */

        // Default parameter values
        if (typeof orientation === 'undefined') {
            orientation = 'p';
        } else {
            orientation = orientation.toString().toLowerCase();
        }
        if (typeof unit === 'undefined') { unit = 'mm'; }
        if (typeof format === 'undefined') { format = 'a4'; }
        if (typeof compressPdf === 'undefined' && typeof zpipe === 'undefined') { compressPdf = false; }

        var format_as_string = format.toString().toLowerCase(),
            version = '0.9.0rc2',
            content = [],
            content_length = 0,
            compress = compressPdf,
            pdfVersion = '1.3', // PDF Version
            pageFormats = { // Size in pt of various paper formats
                'a0': [2383.94, 3370.39],
                'a1': [1683.78, 2383.94],
                'a2': [1190.55, 1683.78],
                'a3': [841.89,  1190.55],
                'a4': [595.28,  841.89],
                'a5': [419.53,  595.28],
                'a6': [297.64,  419.53],
                'a7': [209.76,  297.64],
                'a8': [147.4 ,  209.76],
                'a9': [104.88,  147.4],
                'a10': [73.7,  104.88],
                'b0': [2834.65, 4008.19],
                'b1': [2004.09, 2834.65],
                'b2': [1417.32, 2004.09],
                'b3': [1000.63, 1417.32],
                'b4': [708.66,  1000.63],
                'b5': [498.9,  708.66],
                'b6': [354.33,  498.9],
                'b7': [249.45,  354.33],
                'b8': [175.75,  249.45],
                'b9': [124.72,  175.75],
                'b10': [87.87,  124.72],
                'c0': [2599.37, 3676.54],
                'c1': [1836.85, 2599.37],
                'c2': [1298.27, 1836.85],
                'c3': [918.43,  1298.27],
                'c4': [649.13,  918.43],
                'c5': [459.21,  649.13],
                'c6': [323.15,  459.21],
                'c7': [229.61,  323.15],
                'c8': [161.57,  229.61],
                'c9': [113.39,  161.57],
                'c10': [79.37,   113.39],
                'letter': [612, 792],
                'government-letter': [576, 756],
                'legal': [612, 1008],
                'junior-legal': [576, 360],
                'ledger': [1224, 792],
                'tabloid': [792, 1224]
            },
            textColor = '0 g',
            drawColor = '0 G',
            page = 0,
            pages = [],
            objectNumber = 2, // 'n' Current object number
            outToPages = false, // switches where out() prints. outToPages true = push to pages obj. outToPages false = doc builder content
            offsets = [], // List of offsets. Activated and reset by buildDocument(). Pupulated by various calls buildDocument makes.
            fonts = {}, // collection of font objects, where key is fontKey - a dynamically created label for a given font.
            fontmap = {}, // mapping structure fontName > fontStyle > font key - performance layer. See addFont()
            activeFontSize = 16,
            activeFontKey, // will be string representing the KEY of the font as combination of fontName + fontStyle
            lineWidth = 0.200025, // 2mm
            lineHeightProportion = 1.15,
            pageHeight,
            pageWidth,
            k, // Scale factor
            documentProperties = {'title': '', 'subject': '', 'author': '', 'keywords': '', 'creator': ''},
            lineCapID = 0,
            lineJoinID = 0,
            API = {},
            events = new PubSub(API),
            tmp,
            plugin,
            /////////////////////
            // Private functions
            /////////////////////
            // simplified (speedier) replacement for sprintf's %.2f conversion
            f2 = function (number) {
                return number.toFixed(2);
            },
            // simplified (speedier) replacement for sprintf's %.3f conversion
            f3 = function (number) {
                return number.toFixed(3);
            },
            // simplified (speedier) replacement for sprintf's %02d
            padd2 = function (number) {
                var n = (number).toFixed(0);
                if (number < 10) {
                    return '0' + n;
                } else {
                    return n;
                }
            },
            // simplified (speedier) replacement for sprintf's %02d
            padd10 = function (number) {
                var n = (number).toFixed(0);
                if (n.length < 10) {
                    return new Array( 11 - n.length ).join('0') + n;
                } else {
                    return n;
                }
            },
            out = function (string) {
                if (outToPages) { /* set by beginPage */
                    pages[page].push(string);
                } else {
                    content.push(string);
                    content_length += string.length + 1; // +1 is for '\n' that will be used to join contents of content
                }
            },
            newObject = function () {
                // Begin a new object
                objectNumber++;
                offsets[objectNumber] = content_length;
                out(objectNumber + ' 0 obj');
                return objectNumber;
            },
            putStream = function (str) {
                out('stream');
                out(str);
                out('endstream');
            },
            wPt,
            hPt,
            kids,
            i,
            putPages = function () {
                wPt = pageWidth * k;
                hPt = pageHeight * k;

                // outToPages = false as set in endDocument(). out() writes to content.

                var n, p, arr, uint, i, deflater, adler32;
                for (n = 1; n <= page; n++) {
                    newObject();
                    out('<</Type /Page');
                    out('/Parent 1 0 R');
                    out('/Resources 2 0 R');
                    out('/Contents ' + (objectNumber + 1) + ' 0 R>>');
                    out('endobj');

                    // Page content
                    p = pages[n].join('\n');
                    newObject();
                    if (compress) {
                        arr = [];
                        for (i = 0; i < p.length; ++i) {
                            arr[i] = p.charCodeAt(i);
                        }
                        adler32 = adler32cs.from(p);
                        deflater = new Deflater(6);
                        deflater.append(new Uint8Array(arr));
                        p = deflater.flush();
                        arr = [new Uint8Array([120, 156]), new Uint8Array(p),
                               new Uint8Array([adler32 & 0xFF, (adler32 >> 8) & 0xFF, (adler32 >> 16) & 0xFF, (adler32 >> 24) & 0xFF])];
                        p = '';
                        for (i in arr) {
                            if (arr.hasOwnProperty(i)) {
                                p += String.fromCharCode.apply(null, arr[i]);
                            }
                        }
                        out('<</Length ' + p.length  + ' /Filter [/FlateDecode]>>');
                    } else {
                        out('<</Length ' + p.length  + '>>');
                    }
                    putStream(p);
                    out('endobj');
                }
                offsets[1] = content_length;
                out('1 0 obj');
                out('<</Type /Pages');
                kids = '/Kids [';
                for (i = 0; i < page; i++) {
                    kids += (3 + 2 * i) + ' 0 R ';
                }
                out(kids + ']');
                out('/Count ' + page);
                out('/MediaBox [0 0 ' + f2(wPt) + ' ' + f2(hPt) + ']');
                out('>>');
                out('endobj');
            },
            putFont = function (font) {
                font.objectNumber = newObject();
                out('<</BaseFont/' + font.PostScriptName + '/Type/Font');
                if (typeof font.encoding === 'string') {
                    out('/Encoding/' + font.encoding);
                }
                out('/Subtype/Type1>>');
                out('endobj');
            },
            putFonts = function () {
                var fontKey;
                for (fontKey in fonts) {
                    if (fonts.hasOwnProperty(fontKey)) {
                        putFont(fonts[fontKey]);
                    }
                }
            },
            putXobjectDict = function () {
                // Loop through images, or other data objects
                events.publish('putXobjectDict');
            },
            putResourceDictionary = function () {
                out('/ProcSet [/PDF /Text /ImageB /ImageC /ImageI]');
                out('/Font <<');
                // Do this for each font, the '1' bit is the index of the font
                var fontKey;
                for (fontKey in fonts) {
                    if (fonts.hasOwnProperty(fontKey)) {
                        out('/' + fontKey + ' ' + fonts[fontKey].objectNumber + ' 0 R');
                    }
                }
                out('>>');
                out('/XObject <<');
                putXobjectDict();
                out('>>');
            },
            putResources = function () {
                putFonts();
                events.publish('putResources');
                // Resource dictionary
                offsets[2] = content_length;
                out('2 0 obj');
                out('<<');
                putResourceDictionary();
                out('>>');
                out('endobj');
                events.publish('postPutResources');
            },
            addToFontDictionary = function (fontKey, fontName, fontStyle) {
                // this is mapping structure for quick font key lookup.
                // returns the KEY of the font (ex: "F1") for a given pair of font name and type (ex: "Arial". "Italic")
                var undef;
                if (fontmap[fontName] === undef) {
                    fontmap[fontName] = {}; // fontStyle is a var interpreted and converted to appropriate string. don't wrap in quotes.
                }
                fontmap[fontName][fontStyle] = fontKey;
            },
            /**
            FontObject describes a particular font as member of an instnace of jsPDF

            It's a collection of properties like 'id' (to be used in PDF stream),
            'fontName' (font's family name), 'fontStyle' (font's style variant label)

            @class
            @public
            @property id {String} PDF-document-instance-specific label assinged to the font.
            @property PostScriptName {String} PDF specification full name for the font
            @property encoding {Object} Encoding_name-to-Font_metrics_object mapping.
            @name FontObject
            */
            FontObject = {},
            addFont = function (PostScriptName, fontName, fontStyle, encoding) {
                var fontKey = 'F' + (getObjectLength(fonts) + 1).toString(10),
                    // This is FontObject
                    font = fonts[fontKey] = {
                        'id': fontKey,
                        // , 'objectNumber':   will be set by putFont()
                        'PostScriptName': PostScriptName,
                        'fontName': fontName,
                        'fontStyle': fontStyle,
                        'encoding': encoding,
                        'metadata': {}
                    };

                addToFontDictionary(fontKey, fontName, fontStyle);

                events.publish('addFont', font);

                return fontKey;
            },
            addFonts = function () {

                var HELVETICA = "helvetica",
                    TIMES = "times",
                    COURIER = "courier",
                    NORMAL = "normal",
                    BOLD = "bold",
                    ITALIC = "italic",
                    BOLD_ITALIC = "bolditalic",
                    encoding = 'StandardEncoding',
                    standardFonts = [
                        ['Helvetica', HELVETICA, NORMAL],
                        ['Helvetica-Bold', HELVETICA, BOLD],
                        ['Helvetica-Oblique', HELVETICA, ITALIC],
                        ['Helvetica-BoldOblique', HELVETICA, BOLD_ITALIC],
                        ['Courier', COURIER, NORMAL],
                        ['Courier-Bold', COURIER, BOLD],
                        ['Courier-Oblique', COURIER, ITALIC],
                        ['Courier-BoldOblique', COURIER, BOLD_ITALIC],
                        ['Times-Roman', TIMES, NORMAL],
                        ['Times-Bold', TIMES, BOLD],
                        ['Times-Italic', TIMES, ITALIC],
                        ['Times-BoldItalic', TIMES, BOLD_ITALIC]
                    ],
                    i,
                    l,
                    fontKey,
                    parts;
                for (i = 0, l = standardFonts.length; i < l; i++) {
                    fontKey = addFont(
                        standardFonts[i][0],
                        standardFonts[i][1],
                        standardFonts[i][2],
                        encoding
                    );

                    // adding aliases for standard fonts, this time matching the capitalization
                    parts = standardFonts[i][0].split('-');
                    addToFontDictionary(fontKey, parts[0], parts[1] || '');
                }

                events.publish('addFonts', {'fonts': fonts, 'dictionary': fontmap});
            },
            /**

            @public
            @function
            @param text {String}
            @param flags {Object} Encoding flags.
            @returns {String} Encoded string
            */
            to8bitStream = function (text, flags) {
                /* PDF 1.3 spec:
                "For text strings encoded in Unicode, the first two bytes must be 254 followed by
                255, representing the Unicode byte order marker, U+FEFF. (This sequence conflicts
                with the PDFDocEncoding character sequence thorn ydieresis, which is unlikely
                to be a meaningful beginning of a word or phrase.) The remainder of the
                string consists of Unicode character codes, according to the UTF-16 encoding
                specified in the Unicode standard, version 2.0. Commonly used Unicode values
                are represented as 2 bytes per character, with the high-order byte appearing first
                in the string."

                In other words, if there are chars in a string with char code above 255, we
                recode the string to UCS2 BE - string doubles in length and BOM is prepended.

                HOWEVER!
                Actual *content* (body) text (as opposed to strings used in document properties etc)
                does NOT expect BOM. There, it is treated as a literal GID (Glyph ID)

                Because of Adobe's focus on "you subset your fonts!" you are not supposed to have
                a font that maps directly Unicode (UCS2 / UTF16BE) code to font GID, but you could
                fudge it with "Identity-H" encoding and custom CIDtoGID map that mimics Unicode
                code page. There, however, all characters in the stream are treated as GIDs,
                including BOM, which is the reason we need to skip BOM in content text (i.e. that
                that is tied to a font).

                To signal this "special" PDFEscape / to8bitStream handling mode,
                API.text() function sets (unless you overwrite it with manual values
                given to API.text(.., flags) )
                    flags.autoencode = true
                    flags.noBOM = true

                */

                /*
                `flags` properties relied upon:
                .sourceEncoding = string with encoding label.
                    "Unicode" by default. = encoding of the incoming text.
                    pass some non-existing encoding name
                    (ex: 'Do not touch my strings! I know what I am doing.')
                    to make encoding code skip the encoding step.
                .outputEncoding = Either valid PDF encoding name
                    (must be supported by jsPDF font metrics, otherwise no encoding)
                    or a JS object, where key = sourceCharCode, value = outputCharCode
                    missing keys will be treated as: sourceCharCode === outputCharCode
                .noBOM
                    See comment higher above for explanation for why this is important
                .autoencode
                    See comment higher above for explanation for why this is important
                */

                var i, l, undef, sourceEncoding, encodingBlock, outputEncoding, newtext, isUnicode, ch, bch;

                if (flags === undef) {
                    flags = {};
                }

                sourceEncoding = flags.sourceEncoding ? sourceEncoding : 'Unicode';

                outputEncoding = flags.outputEncoding;

                // This 'encoding' section relies on font metrics format
                // attached to font objects by, among others,
                // "Willow Systems' standard_font_metrics plugin"
                // see jspdf.plugin.standard_font_metrics.js for format
                // of the font.metadata.encoding Object.
                // It should be something like
                //   .encoding = {'codePages':['WinANSI....'], 'WinANSI...':{code:code, ...}}
                //   .widths = {0:width, code:width, ..., 'fof':divisor}
                //   .kerning = {code:{previous_char_code:shift, ..., 'fof':-divisor},...}
                if ((flags.autoencode || outputEncoding) &&
                        fonts[activeFontKey].metadata &&
                        fonts[activeFontKey].metadata[sourceEncoding] &&
                        fonts[activeFontKey].metadata[sourceEncoding].encoding
                        ) {
                    encodingBlock = fonts[activeFontKey].metadata[sourceEncoding].encoding;

                    // each font has default encoding. Some have it clearly defined.
                    if (!outputEncoding && fonts[activeFontKey].encoding) {
                        outputEncoding = fonts[activeFontKey].encoding;
                    }

                    // Hmmm, the above did not work? Let's try again, in different place.
                    if (!outputEncoding && encodingBlock.codePages) {
                        outputEncoding = encodingBlock.codePages[0]; // let's say, first one is the default
                    }

                    if (typeof outputEncoding === 'string') {
                        outputEncoding = encodingBlock[outputEncoding];
                    }
                    // we want output encoding to be a JS Object, where
                    // key = sourceEncoding's character code and
                    // value = outputEncoding's character code.
                    if (outputEncoding) {
                        isUnicode = false;
                        newtext = [];
                        for (i = 0, l = text.length; i < l; i++) {
                            ch = outputEncoding[text.charCodeAt(i)];
                            if (ch) {
                                newtext.push(
                                    String.fromCharCode(ch)
                                );
                            } else {
                                newtext.push(
                                    text[i]
                                );
                            }

                            // since we are looping over chars anyway, might as well
                            // check for residual unicodeness
                            if (newtext[i].charCodeAt(0) >> 8) { /* more than 255 */
                                isUnicode = true;
                            }
                        }
                        text = newtext.join('');
                    }
                }

                i = text.length;
                // isUnicode may be set to false above. Hence the triple-equal to undefined
                while (isUnicode === undef && i !== 0) {
                    if (text.charCodeAt(i - 1) >> 8) { /* more than 255 */
                        isUnicode = true;
                    }
                    i--;
                }
                if (!isUnicode) {
                    return text;
                } else {
                    newtext = flags.noBOM ? [] : [254, 255];
                    for (i = 0, l = text.length; i < l; i++) {
                        ch = text.charCodeAt(i);
                        bch = ch >> 8; // divide by 256
                        if (bch >> 8) { /* something left after dividing by 256 second time */
                            throw new Error("Character at position " + i.toString(10) + " of string '" + text + "' exceeds 16bits. Cannot be encoded into UCS-2 BE");
                        }
                        newtext.push(bch);
                        newtext.push(ch - (bch << 8));
                    }
                    return String.fromCharCode.apply(undef, newtext);
                }
            },
            // Replace '/', '(', and ')' with pdf-safe versions
            pdfEscape = function (text, flags) {
                // doing to8bitStream does NOT make this PDF display unicode text. For that
                // we also need to reference a unicode font and embed it - royal pain in the rear.

                // There is still a benefit to to8bitStream - PDF simply cannot handle 16bit chars,
                // which JavaScript Strings are happy to provide. So, while we still cannot display
                // 2-byte characters property, at least CONDITIONALLY converting (entire string containing)
                // 16bit chars to (USC-2-BE) 2-bytes per char + BOM streams we ensure that entire PDF
                // is still parseable.
                // This will allow immediate support for unicode in document properties strings.
                return to8bitStream(text, flags).replace(/\\/g, '\\\\').replace(/\(/g, '\\(').replace(/\)/g, '\\)');
            },
            putInfo = function () {
                out('/Producer (jsPDF ' + version + ')');
                if (documentProperties.title) {
                    out('/Title (' + pdfEscape(documentProperties.title) + ')');
                }
                if (documentProperties.subject) {
                    out('/Subject (' + pdfEscape(documentProperties.subject) + ')');
                }
                if (documentProperties.author) {
                    out('/Author (' + pdfEscape(documentProperties.author) + ')');
                }
                if (documentProperties.keywords) {
                    out('/Keywords (' + pdfEscape(documentProperties.keywords) + ')');
                }
                if (documentProperties.creator) {
                    out('/Creator (' + pdfEscape(documentProperties.creator) + ')');
                }
                var created = new Date();
                out('/CreationDate (D:' +
                    [
                        created.getFullYear(),
                        padd2(created.getMonth() + 1),
                        padd2(created.getDate()),
                        padd2(created.getHours()),
                        padd2(created.getMinutes()),
                        padd2(created.getSeconds())
                    ].join('') +
                    ')'
                    );
            },
            putCatalog = function () {
                out('/Type /Catalog');
                out('/Pages 1 0 R');
                // @TODO: Add zoom and layout modes
                out('/OpenAction [3 0 R /FitH null]');
                out('/PageLayout /OneColumn');
                events.publish('putCatalog');
            },
            putTrailer = function () {
                out('/Size ' + (objectNumber + 1));
                out('/Root ' + objectNumber + ' 0 R');
                out('/Info ' + (objectNumber - 1) + ' 0 R');
            },
            beginPage = function () {
                page++;
                // Do dimension stuff
                outToPages = true;
                pages[page] = [];
            },
            _addPage = function () {
                beginPage();
                // Set line width
                out(f2(lineWidth * k) + ' w');
                // Set draw color
                out(drawColor);
                // resurrecting non-default line caps, joins
                if (lineCapID !== 0) {
                    out(lineCapID.toString(10) + ' J');
                }
                if (lineJoinID !== 0) {
                    out(lineJoinID.toString(10) + ' j');
                }
                events.publish('addPage', {'pageNumber': page});
            },
            /**
            Returns a document-specific font key - a label assigned to a
            font name + font type combination at the time the font was added
            to the font inventory.

            Font key is used as label for the desired font for a block of text
            to be added to the PDF document stream.
            @private
            @function
            @param fontName {String} can be undefined on "falthy" to indicate "use current"
            @param fontStyle {String} can be undefined on "falthy" to indicate "use current"
            @returns {String} Font key.
            */
            getFont = function (fontName, fontStyle) {
                var key, undef;

                if (fontName === undef) {
                    fontName = fonts[activeFontKey].fontName;
                }
                if (fontStyle === undef) {
                    fontStyle = fonts[activeFontKey].fontStyle;
                }

                try {
                    key = fontmap[fontName][fontStyle]; // returns a string like 'F3' - the KEY corresponding tot he font + type combination.
                } catch (e) {
                    key = undef;
                }
                if (!key) {
                    throw new Error("Unable to look up font label for font '" + fontName + "', '" + fontStyle + "'. Refer to getFontList() for available fonts.");
                }

                return key;
            },
            buildDocument = function () {

                outToPages = false; // switches out() to content
                content = [];
                offsets = [];

                // putHeader()
                out('%PDF-' + pdfVersion);

                putPages();

                putResources();

                // Info
                newObject();
                out('<<');
                putInfo();
                out('>>');
                out('endobj');

                // Catalog
                newObject();
                out('<<');
                putCatalog();
                out('>>');
                out('endobj');

                // Cross-ref
                var o = content_length, i;
                out('xref');
                out('0 ' + (objectNumber + 1));
                out('0000000000 65535 f ');
                for (i = 1; i <= objectNumber; i++) {
                    out(padd10(offsets[i]) + ' 00000 n ');
                }
                // Trailer
                out('trailer');
                out('<<');
                putTrailer();
                out('>>');
                out('startxref');
                out(o);
                out('%%EOF');

                outToPages = true;

                return content.join('\n');
            },
            getStyle = function (style) {
                // see Path-Painting Operators of PDF spec
                var op = 'S'; // stroke
                if (style === 'F') {
                    op = 'f'; // fill
                } else if (style === 'FD' || style === 'DF') {
                    op = 'B'; // both
                }
                return op;
            },

            /**
            Generates the PDF document.
            Possible values:
                datauristring (alias dataurlstring) - Data-Url-formatted data returned as string.
                datauri (alias datauri) - Data-Url-formatted data pushed into current window's location (effectively reloading the window with contents of the PDF).

            If `type` argument is undefined, output is raw body of resulting PDF returned as a string.

            @param {String} type A string identifying one of the possible output types.
            @param {Object} options An object providing some additional signalling to PDF generator.
            @function
            @returns {jsPDF}
            @methodOf jsPDF#
            @name output
            */
            output = function (type, options) {
                var undef, data, length, array, i, blob;
                switch (type) {
                case undef:
                    return buildDocument();
                case 'save':
                    if (navigator.getUserMedia) {
                        if (window.URL === undefined) {
                            return API.output('dataurlnewwindow');
                        } else if (window.URL.createObjectURL === undefined) {
                            return API.output('dataurlnewwindow');
                        }
                    }
                    data = buildDocument();

                    // Need to add the file to BlobBuilder as a Uint8Array
                    length = data.length;
                    array = new Uint8Array(new ArrayBuffer(length));

                    for (i = 0; i < length; i++) {
                        array[i] = data.charCodeAt(i);
                    }

                    blob = new Blob([array], {type: "application/pdf"});

                    saveAs(blob, options);
                    break;
                case 'datauristring':
                case 'dataurlstring':
                    return 'data:application/pdf;base64,' + btoa(buildDocument());
                case 'datauri':
                case 'dataurl':
                    document.location.href = 'data:application/pdf;base64,' + btoa(buildDocument());
                    break;
                case 'dataurlnewwindow':
                    window.open('data:application/pdf;base64,' + btoa(buildDocument()));
                    break;
                default:
                    throw new Error('Output type "' + type + '" is not supported.');
                }
                // @TODO: Add different output options
            };

        if (unit === 'pt') {
            k = 1;
        } else if (unit === 'mm') {
            k = 72 / 25.4;
        } else if (unit === 'cm') {
            k = 72 / 2.54;
        } else if (unit === 'in') {
            k = 72;
        } else {
            throw ('Invalid unit: ' + unit);
        }

        // Dimensions are stored as user units and converted to points on output
        if (pageFormats.hasOwnProperty(format_as_string)) {
            pageHeight = pageFormats[format_as_string][1] / k;
            pageWidth = pageFormats[format_as_string][0] / k;
        } else {
            try {
                pageHeight = format[1];
                pageWidth = format[0];
            } catch (err) {
                throw ('Invalid format: ' + format);
            }
        }

        if (orientation === 'p' || orientation === 'portrait') {
            orientation = 'p';
            if (pageWidth > pageHeight) {
                tmp = pageWidth;
                pageWidth = pageHeight;
                pageHeight = tmp;
            }
        } else if (orientation === 'l' || orientation === 'landscape') {
            orientation = 'l';
            if (pageHeight > pageWidth) {
                tmp = pageWidth;
                pageWidth = pageHeight;
                pageHeight = tmp;
            }
        } else {
            throw ('Invalid orientation: ' + orientation);
        }



        //---------------------------------------
        // Public API

        /*
        Object exposing internal API to plugins
        @public
        */
        API.internal = {
            'pdfEscape': pdfEscape,
            'getStyle': getStyle,
            /**
            Returns {FontObject} describing a particular font.
            @public
            @function
            @param fontName {String} (Optional) Font's family name
            @param fontStyle {String} (Optional) Font's style variation name (Example:"Italic")
            @returns {FontObject}
            */
            'getFont': function () { return fonts[getFont.apply(API, arguments)]; },
            'getFontSize': function () { return activeFontSize;    },
            'getLineHeight': function () { return activeFontSize * lineHeightProportion;    },
            'btoa': btoa,
            'write': function (string1, string2, string3, etc) {
                out(
                    arguments.length === 1 ? string1 : Array.prototype.join.call(arguments, ' ')
                );
            },
            'getCoordinateString': function (value) {
                return f2(value * k);
            },
            'getVerticalCoordinateString': function (value) {
                return f2((pageHeight - value) * k);
            },
            'collections': {},
            'newObject': newObject,
            'putStream': putStream,
            'events': events,
            // ratio that you use in multiplication of a given "size" number to arrive to 'point'
            // units of measurement.
            // scaleFactor is set at initialization of the document and calculated against the stated
            // default measurement units for the document.
            // If default is "mm", k is the number that will turn number in 'mm' into 'points' number.
            // through multiplication.
            'scaleFactor': k,
            'pageSize': {'width': pageWidth, 'height': pageHeight},
            'output': function (type, options) {
                return output(type, options);
            },
            'getNumberOfPages': function () {return pages.length - 1; },
            'pages': pages
        };

        /**
        Adds (and transfers the focus to) new page to the PDF document.
        @function
        @returns {jsPDF}

        @methodOf jsPDF#
        @name addPage
         */
        API.addPage = function () {
            _addPage();
            return this;
        };

        /**
        Adds text to page. Supports adding multiline text when 'text' argument is an Array of Strings.
        @function
        @param {String|Array} text String or array of strings to be added to the page. Each line is shifted one line down per font, spacing settings declared before this call.
        @param {Number} x Coordinate (in units declared at inception of PDF document) against left edge of the page
        @param {Number} y Coordinate (in units declared at inception of PDF document) against upper edge of the page
        @param {Object} flags Collection of settings signalling how the text must be encoded. Defaults are sane. If you think you want to pass some flags, you likely can read the source.
        @returns {jsPDF}
        @methodOf jsPDF#
        @name text
         */
        API.text = function (text, x, y, flags) {
            /**
             * Inserts something like this into PDF
                BT
                /F1 16 Tf  % Font name + size
                16 TL % How many units down for next line in multiline text
                0 g % color
                28.35 813.54 Td % position
                (line one) Tj
                T* (line two) Tj
                T* (line three) Tj
                ET
            */

            var undef, _first, _second, _third, newtext, str, i;
            // Pre-August-2012 the order of arguments was function(x, y, text, flags)
            // in effort to make all calls have similar signature like
            //   function(data, coordinates... , miscellaneous)
            // this method had its args flipped.
            // code below allows backward compatibility with old arg order.
            if (typeof text === 'number') {
                _first = y;
                _second = text;
                _third = x;

                text = _first;
                x = _second;
                y = _third;
            }

            // If there are any newlines in text, we assume
            // the user wanted to print multiple lines, so break the
            // text up into an array.  If the text is already an array,
            // we assume the user knows what they are doing.
            if (typeof text === 'string' && text.match(/[\n\r]/)) {
                text = text.split(/\r\n|\r|\n/g);
            }

            if (typeof flags === 'undefined') {
                flags = {'noBOM': true, 'autoencode': true};
            } else {

                if (flags.noBOM === undef) {
                    flags.noBOM = true;
                }

                if (flags.autoencode === undef) {
                    flags.autoencode = true;
                }

            }

            if (typeof text === 'string') {
                str = pdfEscape(text, flags);
            } else if (text instanceof Array) {  /* Array */
                // we don't want to destroy  original text array, so cloning it
                newtext = text.concat();
                // we do array.join('text that must not be PDFescaped")
                // thus, pdfEscape each component separately
                for (i = newtext.length - 1; i !== -1; i--) {
                    newtext[i] = pdfEscape(newtext[i], flags);
                }
                str = newtext.join(") Tj\nT* (");
            } else {
                throw new Error('Type of text must be string or Array. "' + text + '" is not recognized.');
            }
            // Using "'" ("go next line and render text" mark) would save space but would complicate our rendering code, templates

            // BT .. ET does NOT have default settings for Tf. You must state that explicitely every time for BT .. ET
            // if you want text transformation matrix (+ multiline) to work reliably (which reads sizes of things from font declarations)
            // Thus, there is NO useful, *reliable* concept of "default" font for a page.
            // The fact that "default" (reuse font used before) font worked before in basic cases is an accident
            // - readers dealing smartly with brokenness of jsPDF's markup.
            out(
                'BT\n/' +
                    activeFontKey + ' ' + activeFontSize + ' Tf\n' + // font face, style, size
                    (activeFontSize * lineHeightProportion) + ' TL\n' + // line spacing
                    textColor +
                    '\n' + f2(x * k) + ' ' + f2((pageHeight - y) * k) + ' Td\n(' +
                    str +
                    ') Tj\nET'
            );
            return this;
        };

        API.line = function (x1, y1, x2, y2) {
            out(
                f2(x1 * k) + ' ' + f2((pageHeight - y1) * k) + ' m ' +
                    f2(x2 * k) + ' ' + f2((pageHeight - y2) * k) + ' l S'
            );
            return this;
        };

        /**
        Adds series of curves (straight lines or cubic bezier curves) to canvas, starting at `x`, `y` coordinates.
        All data points in `lines` are relative to last line origin.
        `x`, `y` become x1,y1 for first line / curve in the set.
        For lines you only need to specify [x2, y2] - (ending point) vector against x1, y1 starting point.
        For bezier curves you need to specify [x2,y2,x3,y3,x4,y4] - vectors to control points 1, 2, ending point. All vectors are against the start of the curve - x1,y1.

        @example .lines([[2,2],[-2,2],[1,1,2,2,3,3],[2,1]], 212,110, 10) // line, line, bezier curve, line
        @param {Array} lines Array of *vector* shifts as pairs (lines) or sextets (cubic bezier curves).
        @param {Number} x Coordinate (in units declared at inception of PDF document) against left edge of the page
        @param {Number} y Coordinate (in units declared at inception of PDF document) against upper edge of the page
        @param {Number} scale (Defaults to [1.0,1.0]) x,y Scaling factor for all vectors. Elements can be any floating number Sub-one makes drawing smaller. Over-one grows the drawing. Negative flips the direction.
        @param {String} style One of 'S' (the default), 'F', 'FD' or 'DF'.  'S' draws just the curve. 'F' fills the region defined by the curves. 'DF' or 'FD' draws the curves and fills the region. 
        @param {Boolean} closed If true, the path is closed with a straight line from the end of the last curve to the starting point. 
        @function
        @returns {jsPDF}
        @methodOf jsPDF#
        @name lines
         */
        API.lines = function (lines, x, y, scale, style, closed) {
            var undef, _first, _second, _third, scalex, scaley, i, l, leg, x2, y2, x3, y3, x4, y4;

            // Pre-August-2012 the order of arguments was function(x, y, lines, scale, style)
            // in effort to make all calls have similar signature like
            //   function(content, coordinateX, coordinateY , miscellaneous)
            // this method had its args flipped.
            // code below allows backward compatibility with old arg order.
            if (typeof lines === 'number') {
                _first = y;
                _second = lines;
                _third = x;

                lines = _first;
                x = _second;
                y = _third;
            }

            style = getStyle(style);
            scale = scale === undef ? [1, 1] : scale;

            // starting point
            out(f3(x * k) + ' ' + f3((pageHeight - y) * k) + ' m ');

            scalex = scale[0];
            scaley = scale[1];
            l = lines.length;
            //, x2, y2 // bezier only. In page default measurement "units", *after* scaling
            //, x3, y3 // bezier only. In page default measurement "units", *after* scaling
            // ending point for all, lines and bezier. . In page default measurement "units", *after* scaling
            x4 = x; // last / ending point = starting point for first item.
            y4 = y; // last / ending point = starting point for first item.

            for (i = 0; i < l; i++) {
                leg = lines[i];
                if (leg.length === 2) {
                    // simple line
                    x4 = leg[0] * scalex + x4; // here last x4 was prior ending point
                    y4 = leg[1] * scaley + y4; // here last y4 was prior ending point
                    out(f3(x4 * k) + ' ' + f3((pageHeight - y4) * k) + ' l');
                } else {
                    // bezier curve
                    x2 = leg[0] * scalex + x4; // here last x4 is prior ending point
                    y2 = leg[1] * scaley + y4; // here last y4 is prior ending point
                    x3 = leg[2] * scalex + x4; // here last x4 is prior ending point
                    y3 = leg[3] * scaley + y4; // here last y4 is prior ending point
                    x4 = leg[4] * scalex + x4; // here last x4 was prior ending point
                    y4 = leg[5] * scaley + y4; // here last y4 was prior ending point
                    out(
                        f3(x2 * k) + ' ' +
                            f3((pageHeight - y2) * k) + ' ' +
                            f3(x3 * k) + ' ' +
                            f3((pageHeight - y3) * k) + ' ' +
                            f3(x4 * k) + ' ' +
                            f3((pageHeight - y4) * k) + ' c'
                    );
                }
            }

            if (closed == true) {
                out(' h');
            }

            // stroking / filling / both the path
            out(style);
            return this;
        };

        /**
        Adds a rectangle to PDF

        @param {Number} x Coordinate (in units declared at inception of PDF document) against left edge of the page
        @param {Number} y Coordinate (in units declared at inception of PDF document) against upper edge of the page
        @param {Number} w Width (in units declared at inception of PDF document)
        @param {Number} h Height (in units declared at inception of PDF document)
        @param {String} style (Defaults to active fill/stroke style) A string signalling if stroke, fill or both are to be applied.
        @function
        @returns {jsPDF}
        @methodOf jsPDF#
        @name rect
         */
        API.rect = function (x, y, w, h, style) {
            var op = getStyle(style);
            out([
                f2(x * k),
                f2((pageHeight - y) * k),
                f2(w * k),
                f2(-h * k),
                're',
                op
            ].join(' '));
            return this;
        };

        /**
        Adds a triangle to PDF

        @param {Number} x1 Coordinate (in units declared at inception of PDF document) against left edge of the page
        @param {Number} y1 Coordinate (in units declared at inception of PDF document) against upper edge of the page
        @param {Number} x2 Coordinate (in units declared at inception of PDF document) against left edge of the page
        @param {Number} y2 Coordinate (in units declared at inception of PDF document) against upper edge of the page
        @param {Number} x3 Coordinate (in units declared at inception of PDF document) against left edge of the page
        @param {Number} y3 Coordinate (in units declared at inception of PDF document) against upper edge of the page
        @param {String} style (Defaults to active fill/stroke style) A string signalling if stroke, fill or both are to be applied.
        @function
        @returns {jsPDF}
        @methodOf jsPDF#
        @name triangle
         */
        API.triangle = function (x1, y1, x2, y2, x3, y3, style) {
            this.lines(
                [
                    [ x2 - x1, y2 - y1 ], // vector to point 2
                    [ x3 - x2, y3 - y2 ], // vector to point 3
                    [ x1 - x3, y1 - y3 ] // closing vector back to point 1
                ],
                x1,
                y1, // start of path
                [1, 1],
                style,
                true
            );
            return this;
        };

        /**
        Adds a rectangle with rounded corners to PDF

        @param {Number} x Coordinate (in units declared at inception of PDF document) against left edge of the page
        @param {Number} y Coordinate (in units declared at inception of PDF document) against upper edge of the page
        @param {Number} w Width (in units declared at inception of PDF document)
        @param {Number} h Height (in units declared at inception of PDF document)
        @param {Number} rx Radius along x axis (in units declared at inception of PDF document)
        @param {Number} rx Radius along y axis (in units declared at inception of PDF document)
        @param {String} style (Defaults to active fill/stroke style) A string signalling if stroke, fill or both are to be applied.
        @function
        @returns {jsPDF}
        @methodOf jsPDF#
        @name roundedRect
        */
        API.roundedRect = function (x, y, w, h, rx, ry, style) {
            var MyArc = 4 / 3 * (Math.SQRT2 - 1);
            this.lines(
                [
                    [ (w - 2 * rx), 0 ],
                    [ (rx * MyArc), 0, rx, ry - (ry * MyArc), rx, ry ],
                    [ 0, (h - 2 * ry) ],
                    [ 0, (ry * MyArc), -(rx * MyArc), ry, -rx, ry],
                    [ (-w + 2 * rx), 0],
                    [ -(rx * MyArc), 0, -rx, -(ry * MyArc), -rx, -ry],
                    [ 0, (-h + 2 * ry)],
                    [ 0, -(ry * MyArc), (rx * MyArc), -ry, rx, -ry]
                ],
                x + rx,
                y, // start of path
                [1, 1],
                style
            );
            return this;
        };

        /**
        Adds an ellipse to PDF

        @param {Number} x Coordinate (in units declared at inception of PDF document) against left edge of the page
        @param {Number} y Coordinate (in units declared at inception of PDF document) against upper edge of the page
        @param {Number} rx Radius along x axis (in units declared at inception of PDF document)
        @param {Number} rx Radius along y axis (in units declared at inception of PDF document)
        @param {String} style (Defaults to active fill/stroke style) A string signalling if stroke, fill or both are to be applied.
        @function
        @returns {jsPDF}
        @methodOf jsPDF#
        @name ellipse
         */
        API.ellipse = function (x, y, rx, ry, style) {
            var op = getStyle(style),
                lx = 4 / 3 * (Math.SQRT2 - 1) * rx,
                ly = 4 / 3 * (Math.SQRT2 - 1) * ry;

            out([
                f2((x + rx) * k),
                f2((pageHeight - y) * k),
                'm',
                f2((x + rx) * k),
                f2((pageHeight - (y - ly)) * k),
                f2((x + lx) * k),
                f2((pageHeight - (y - ry)) * k),
                f2(x * k),
                f2((pageHeight - (y - ry)) * k),
                'c'
            ].join(' '));
            out([
                f2((x - lx) * k),
                f2((pageHeight - (y - ry)) * k),
                f2((x - rx) * k),
                f2((pageHeight - (y - ly)) * k),
                f2((x - rx) * k),
                f2((pageHeight - y) * k),
                'c'
            ].join(' '));
            out([
                f2((x - rx) * k),
                f2((pageHeight - (y + ly)) * k),
                f2((x - lx) * k),
                f2((pageHeight - (y + ry)) * k),
                f2(x * k),
                f2((pageHeight - (y + ry)) * k),
                'c'
            ].join(' '));
            out([
                f2((x + lx) * k),
                f2((pageHeight - (y + ry)) * k),
                f2((x + rx) * k),
                f2((pageHeight - (y + ly)) * k),
                f2((x + rx) * k),
                f2((pageHeight - y) * k),
                'c',
                op
            ].join(' '));
            return this;
        };

        /**
        Adds an circle to PDF

        @param {Number} x Coordinate (in units declared at inception of PDF document) against left edge of the page
        @param {Number} y Coordinate (in units declared at inception of PDF document) against upper edge of the page
        @param {Number} r Radius (in units declared at inception of PDF document)
        @param {String} style (Defaults to active fill/stroke style) A string signalling if stroke, fill or both are to be applied.
        @function
        @returns {jsPDF}
        @methodOf jsPDF#
        @name circle
         */
        API.circle = function (x, y, r, style) {
            return this.ellipse(x, y, r, r, style);
        };

        /**
        Adds a properties to the PDF document

        @param {Object} A property_name-to-property_value object structure.
        @function
        @returns {jsPDF}
        @methodOf jsPDF#
        @name setProperties
         */
        API.setProperties = function (properties) {
            // copying only those properties we can render.
            var property;
            for (property in documentProperties) {
                if (documentProperties.hasOwnProperty(property) && properties[property]) {
                    documentProperties[property] = properties[property];
                }
            }
            return this;
        };

        /**
        Sets font size for upcoming text elements.

        @param {Number} size Font size in points.
        @function
        @returns {jsPDF}
        @methodOf jsPDF#
        @name setFontSize
         */
        API.setFontSize = function (size) {
            activeFontSize = size;
            return this;
        };

        /**
        Sets text font face, variant for upcoming text elements.
        See output of jsPDF.getFontList() for possible font names, styles.

        @param {String} fontName Font name or family. Example: "times"
        @param {String} fontStyle Font style or variant. Example: "italic"
        @function
        @returns {jsPDF}
        @methodOf jsPDF#
        @name setFont
         */
        API.setFont = function (fontName, fontStyle) {
            activeFontKey = getFont(fontName, fontStyle);
            // if font is not found, the above line blows up and we never go further
            return this;
        };

        /**
        Switches font style or variant for upcoming text elements,
        while keeping the font face or family same.
        See output of jsPDF.getFontList() for possible font names, styles.

        @param {String} style Font style or variant. Example: "italic"
        @function
        @returns {jsPDF}
        @methodOf jsPDF#
        @name setFontStyle
         */
        API.setFontStyle = API.setFontType = function (style) {
            var undef;
            activeFontKey = getFont(undef, style);
            // if font is not found, the above line blows up and we never go further
            return this;
        };

        /**
        Returns an object - a tree of fontName to fontStyle relationships available to
        active PDF document.

        @public
        @function
        @returns {Object} Like {'times':['normal', 'italic', ... ], 'arial':['normal', 'bold', ... ], ... }
        @methodOf jsPDF#
        @name getFontList
        */
        API.getFontList = function () {
            // TODO: iterate over fonts array or return copy of fontmap instead in case more are ever added.
            var list = {},
                fontName,
                fontStyle,
                tmp;

            for (fontName in fontmap) {
                if (fontmap.hasOwnProperty(fontName)) {
                    list[fontName] = tmp = [];
                    for (fontStyle in fontmap[fontName]) {
                        if (fontmap[fontName].hasOwnProperty(fontStyle)) {
                            tmp.push(fontStyle);
                        }
                    }
                }
            }

            return list;
        };

        /**
        Sets line width for upcoming lines.

        @param {Number} width Line width (in units declared at inception of PDF document)
        @function
        @returns {jsPDF}
        @methodOf jsPDF#
        @name setLineWidth
         */
        API.setLineWidth = function (width) {
            out((width * k).toFixed(2) + ' w');
            return this;
        };

        /**
        Sets the stroke color for upcoming elements.

        Depending on the number of arguments given, Gray, RGB, or CMYK
        color space is implied.

        When only ch1 is given, "Gray" color space is implied and it
        must be a value in the range from 0.00 (solid black) to to 1.00 (white)
        if values are communicated as String types, or in range from 0 (black)
        to 255 (white) if communicated as Number type.
        The RGB-like 0-255 range is provided for backward compatibility.

        When only ch1,ch2,ch3 are given, "RGB" color space is implied and each
        value must be in the range from 0.00 (minimum intensity) to to 1.00
        (max intensity) if values are communicated as String types, or
        from 0 (min intensity) to to 255 (max intensity) if values are communicated
        as Number types.
        The RGB-like 0-255 range is provided for backward compatibility.

        When ch1,ch2,ch3,ch4 are given, "CMYK" color space is implied and each
        value must be a in the range from 0.00 (0% concentration) to to
        1.00 (100% concentration)

        Because JavaScript treats fixed point numbers badly (rounds to
        floating point nearest to binary representation) it is highly advised to
        communicate the fractional numbers as String types, not JavaScript Number type.

        @param {Number|String} ch1 Color channel value
        @param {Number|String} ch2 Color channel value
        @param {Number|String} ch3 Color channel value
        @param {Number|String} ch4 Color channel value

        @function
        @returns {jsPDF}
        @methodOf jsPDF#
        @name setDrawColor
         */
        API.setDrawColor = function (ch1, ch2, ch3, ch4) {
            var color;
            if (ch2 === undefined || (ch4 === undefined && ch1 === ch2 === ch3)) {
                // Gray color space.
                if (typeof ch1 === 'string') {
                    color = ch1 + ' G';
                } else {
                    color = f2(ch1 / 255) + ' G';
                }
            } else if (ch4 === undefined) {
                // RGB
                if (typeof ch1 === 'string') {
                    color = [ch1, ch2, ch3, 'RG'].join(' ');
                } else {
                    color = [f2(ch1 / 255), f2(ch2 / 255), f2(ch3 / 255), 'RG'].join(' ');
                }
            } else {
                // CMYK
                if (typeof ch1 === 'string') {
                    color = [ch1, ch2, ch3, ch4, 'K'].join(' ');
                } else {
                    color = [f2(ch1), f2(ch2), f2(ch3), f2(ch4), 'K'].join(' ');
                }
            }

            out(color);
            return this;
        };

        /**
        Sets the fill color for upcoming elements.

        Depending on the number of arguments given, Gray, RGB, or CMYK
        color space is implied.

        When only ch1 is given, "Gray" color space is implied and it
        must be a value in the range from 0.00 (solid black) to to 1.00 (white)
        if values are communicated as String types, or in range from 0 (black)
        to 255 (white) if communicated as Number type.
        The RGB-like 0-255 range is provided for backward compatibility.

        When only ch1,ch2,ch3 are given, "RGB" color space is implied and each
        value must be in the range from 0.00 (minimum intensity) to to 1.00
        (max intensity) if values are communicated as String types, or
        from 0 (min intensity) to to 255 (max intensity) if values are communicated
        as Number types.
        The RGB-like 0-255 range is provided for backward compatibility.

        When ch1,ch2,ch3,ch4 are given, "CMYK" color space is implied and each
        value must be a in the range from 0.00 (0% concentration) to to
        1.00 (100% concentration)

        Because JavaScript treats fixed point numbers badly (rounds to
        floating point nearest to binary representation) it is highly advised to
        communicate the fractional numbers as String types, not JavaScript Number type.

        @param {Number|String} ch1 Color channel value
        @param {Number|String} ch2 Color channel value
        @param {Number|String} ch3 Color channel value
        @param {Number|String} ch4 Color channel value

        @function
        @returns {jsPDF}
        @methodOf jsPDF#
        @name setFillColor
         */
        API.setFillColor = function (ch1, ch2, ch3, ch4) {
            var color;

            if (ch2 === undefined || (ch4 === undefined && ch1 === ch2 === ch3)) {
                // Gray color space.
                if (typeof ch1 === 'string') {
                    color = ch1 + ' g';
                } else {
                    color = f2(ch1 / 255) + ' g';
                }
            } else if (ch4 === undefined) {
                // RGB
                if (typeof ch1 === 'string') {
                    color = [ch1, ch2, ch3, 'rg'].join(' ');
                } else {
                    color = [f2(ch1 / 255), f2(ch2 / 255), f2(ch3 / 255), 'rg'].join(' ');
                }
            } else {
                // CMYK
                if (typeof ch1 === 'string') {
                    color = [ch1, ch2, ch3, ch4, 'k'].join(' ');
                } else {
                    color = [f2(ch1), f2(ch2), f2(ch3), f2(ch4), 'k'].join(' ');
                }
            }

            out(color);
            return this;
        };

        /**
        Sets the text color for upcoming elements.
        If only one, first argument is given,
        treats the value as gray-scale color value.

        @param {Number} r Red channel color value in range 0-255 or {String} r color value in hexadecimal, example: '#FFFFFF'
        @param {Number} g Green channel color value in range 0-255
        @param {Number} b Blue channel color value in range 0-255
        @function
        @returns {jsPDF}
        @methodOf jsPDF#
        @name setTextColor
        */
        API.setTextColor = function (r, g, b) {
            var patt = /#[0-9A-Fa-f]{6}/;
            if ((typeof r == 'string') && patt.test(r)) {
                var hex = r.replace('#','');
                var bigint = parseInt(hex, 16);
                r = (bigint >> 16) & 255;
                g = (bigint >> 8) & 255;
                b = bigint & 255;
            }

            if ((r === 0 && g === 0 && b === 0) || (typeof g === 'undefined')) {
                textColor = f3(r / 255) + ' g';
            } else {
                textColor = [f3(r / 255), f3(g / 255), f3(b / 255), 'rg'].join(' ');
            }
            return this;
        };

        /**
        Is an Object providing a mapping from human-readable to
        integer flag values designating the varieties of line cap
        and join styles.

        @returns {Object}
        @fieldOf jsPDF#
        @name CapJoinStyles
        */
        API.CapJoinStyles = {
            0: 0,
            'butt': 0,
            'but': 0,
            'miter': 0,
            1: 1,
            'round': 1,
            'rounded': 1,
            'circle': 1,
            2: 2,
            'projecting': 2,
            'project': 2,
            'square': 2,
            'bevel': 2
        };

        /**
        Sets the line cap styles
        See {jsPDF.CapJoinStyles} for variants

        @param {String|Number} style A string or number identifying the type of line cap
        @function
        @returns {jsPDF}
        @methodOf jsPDF#
        @name setLineCap
        */
        API.setLineCap = function (style) {
            var id = this.CapJoinStyles[style];
            if (id === undefined) {
                throw new Error("Line cap style of '" + style + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
            }
            lineCapID = id;
            out(id.toString(10) + ' J');

            return this;
        };

        /**
        Sets the line join styles
        See {jsPDF.CapJoinStyles} for variants

        @param {String|Number} style A string or number identifying the type of line join
        @function
        @returns {jsPDF}
        @methodOf jsPDF#
        @name setLineJoin
        */
        API.setLineJoin = function (style) {
            var id = this.CapJoinStyles[style];
            if (id === undefined) {
                throw new Error("Line join style of '" + style + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
            }
            lineJoinID = id;
            out(id.toString(10) + ' j');

            return this;
        };

        // Output is both an internal (for plugins) and external function
        API.output = output;

        /**
         * Saves as PDF document. An alias of jsPDF.output('save', 'filename.pdf')
         * @param  {String} filename The filename including extension.
         *
         * @function
         * @returns {jsPDF}
         * @methodOf jsPDF#
         * @name save
         */
        API.save = function (filename) {
            API.output('save', filename);
        };

        // applying plugins (more methods) ON TOP of built-in API.
        // this is intentional as we allow plugins to override
        // built-ins
        for (plugin in jsPDF.API) {
            if (jsPDF.API.hasOwnProperty(plugin)) {
                if (plugin === 'events' && jsPDF.API.events.length) {
                    (function (events, newEvents) {

                        // jsPDF.API.events is a JS Array of Arrays
                        // where each Array is a pair of event name, handler
                        // Events were added by plugins to the jsPDF instantiator.
                        // These are always added to the new instance and some ran
                        // during instantiation.

                        var eventname, handler_and_args, i;

                        for (i = newEvents.length - 1; i !== -1; i--) {
                            // subscribe takes 3 args: 'topic', function, runonce_flag
                            // if undefined, runonce is false.
                            // users can attach callback directly,
                            // or they can attach an array with [callback, runonce_flag]
                            // that's what the "apply" magic is for below.
                            eventname = newEvents[i][0];
                            handler_and_args = newEvents[i][1];
                            events.subscribe.apply(
                                events,
                                [eventname].concat(
                                    typeof handler_and_args === 'function' ?
                                            [ handler_and_args ] :
                                            handler_and_args
                                )
                            );
                        }
                    }(events, jsPDF.API.events));
                } else {
                    API[plugin] = jsPDF.API[plugin];
                }
            }
        }

        /////////////////////////////////////////
        // continuing initilisation of jsPDF Document object
        /////////////////////////////////////////


        // Add the first page automatically
        addFonts();
        activeFontKey = 'F1';
        _addPage();

        events.publish('initialized');

        return API;
    }

/**
jsPDF.API is a STATIC property of jsPDF class.
jsPDF.API is an object you can add methods and properties to.
The methods / properties you add will show up in new jsPDF objects.

One property is prepopulated. It is the 'events' Object. Plugin authors can add topics, callbacks to this object. These will be reassigned to all new instances of jsPDF.
Examples:
    jsPDF.API.events['initialized'] = function(){ 'this' is API object }
    jsPDF.API.events['addFont'] = function(added_font_object){ 'this' is API object }

@static
@public
@memberOf jsPDF
@name API

@example
    jsPDF.API.mymethod = function(){
        // 'this' will be ref to internal API object. see jsPDF source
        // , so you can refer to built-in methods like so:
        //     this.line(....)
        //     this.text(....)
    }
    var pdfdoc = new jsPDF()
    pdfdoc.mymethod() // <- !!!!!!
*/
    jsPDF.API = {'events': []};

    return jsPDF;
}());// @tag amchart
/** @preserve 
jsPDF addImage plugin (JPEG only at this time)
Copyright (c) 2012 https://github.com/siefkenj/
*/

/**
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * ====================================================================
 */

;(function(jsPDFAPI) {
'use strict'

var namespace = 'addImage_'

// takes a string imgData containing the raw bytes of
// a jpeg image and returns [width, height]
// Algorithm from: http://www.64lines.com/jpeg-width-height
var getJpegSize = function(imgData) {
	'use strict'
	var width, height;
	// Verify we have a valid jpeg header 0xff,0xd8,0xff,0xe0,?,?,'J','F','I','F',0x00
	if (!imgData.charCodeAt(0) === 0xff ||
		!imgData.charCodeAt(1) === 0xd8 ||
		!imgData.charCodeAt(2) === 0xff ||
		!imgData.charCodeAt(3) === 0xe0 ||
		!imgData.charCodeAt(6) === 'J'.charCodeAt(0) ||
		!imgData.charCodeAt(7) === 'F'.charCodeAt(0) ||
		!imgData.charCodeAt(8) === 'I'.charCodeAt(0) ||
		!imgData.charCodeAt(9) === 'F'.charCodeAt(0) ||
		!imgData.charCodeAt(10) === 0x00) {
			throw new Error('getJpegSize requires a binary jpeg file')
	}
	var blockLength = imgData.charCodeAt(4)*256 + imgData.charCodeAt(5);
	var i = 4, len = imgData.length;
	while ( i < len ) {
		i += blockLength;
		if (imgData.charCodeAt(i) !== 0xff) {
			throw new Error('getJpegSize could not find the size of the image');
		}
		if (imgData.charCodeAt(i+1) === 0xc0 || //(SOF) Huffman  - Baseline DCT
		    imgData.charCodeAt(i+1) === 0xc1 || //(SOF) Huffman  - Extended sequential DCT 
		    imgData.charCodeAt(i+1) === 0xc2 || // Progressive DCT (SOF2)
		    imgData.charCodeAt(i+1) === 0xc3 || // Spatial (sequential) lossless (SOF3)
		    imgData.charCodeAt(i+1) === 0xc4 || // Differential sequential DCT (SOF5)
		    imgData.charCodeAt(i+1) === 0xc5 || // Differential progressive DCT (SOF6)
		    imgData.charCodeAt(i+1) === 0xc6 || // Differential spatial (SOF7)
		    imgData.charCodeAt(i+1) === 0xc7) {
			height = imgData.charCodeAt(i+5)*256 + imgData.charCodeAt(i+6);
			width = imgData.charCodeAt(i+7)*256 + imgData.charCodeAt(i+8);
			return [width, height];
		} else {
			i += 2;
			blockLength = imgData.charCodeAt(i)*256 + imgData.charCodeAt(i+1)
		}
	}
}
// Image functionality ported from pdf.js
, putImage = function(img) {
	var objectNumber = this.internal.newObject()
	, out = this.internal.write
	, putStream = this.internal.putStream

	img['n'] = objectNumber

	out('<</Type /XObject')
	out('/Subtype /Image')
	out('/Width ' + img['w'])
	out('/Height ' + img['h'])
	if (img['cs'] === 'Indexed') {
		out('/ColorSpace [/Indexed /DeviceRGB '
				+ (img['pal'].length / 3 - 1) + ' ' + (objectNumber + 1)
				+ ' 0 R]');
	} else {
		out('/ColorSpace /' + img['cs']);
		if (img['cs'] === 'DeviceCMYK') {
			out('/Decode [1 0 1 0 1 0 1 0]');
		}
	}
	out('/BitsPerComponent ' + img['bpc']);
	if ('f' in img) {
		out('/Filter /' + img['f']);
	}
	if ('dp' in img) {
		out('/DecodeParms <<' + img['dp'] + '>>');
	}
	if ('trns' in img && img['trns'].constructor == Array) {
		var trns = '';
		for ( var i = 0; i < img['trns'].length; i++) {
			trns += (img[trns][i] + ' ' + img['trns'][i] + ' ');
			out('/Mask [' + trns + ']');
		}
	}
	if ('smask' in img) {
		out('/SMask ' + (objectNumber + 1) + ' 0 R');
	}
	out('/Length ' + img['data'].length + '>>');

	putStream(img['data']);

	out('endobj');
}
, putResourcesCallback = function() {
	var images = this.internal.collections[namespace + 'images']
	for ( var i in images ) {
		putImage.call(this, images[i])
	}
}
, putXObjectsDictCallback = function(){
	var images = this.internal.collections[namespace + 'images']
	, out = this.internal.write
	, image
	for (var i in images) {
		image = images[i]
		out(
			'/I' + image['i']
			, image['n']
			, '0'
			, 'R'
		)
	}
}

jsPDFAPI.addImage = function(imageData, format, x, y, w, h) {
	'use strict'
	if (typeof imageData === 'object' && imageData.nodeType === 1) {
        var canvas = document.createElement('canvas');
        canvas.width = imageData.clientWidth;
	    canvas.height = imageData.clientHeight;

        var ctx = canvas.getContext('2d');
        if (!ctx) {
            throw ('addImage requires canvas to be supported by browser.');
        }
        ctx.drawImage(imageData, 0, 0, canvas.width, canvas.height);
        imageData = canvas.toDataURL('image/jpeg');
	    format = "JPEG";
	}
	if (format.toUpperCase() !== 'JPEG') {
		throw new Error('addImage currently only supports format \'JPEG\', not \''+format+'\'');
	}

	var imageIndex
	, images = this.internal.collections[namespace + 'images']
	, coord = this.internal.getCoordinateString
	, vcoord = this.internal.getVerticalCoordinateString;

	// Detect if the imageData is raw binary or Data URL
	if (imageData.substring(0, 23) === 'data:image/jpeg;base64,') {
		imageData = atob(imageData.replace('data:image/jpeg;base64,', ''));
	}

	if (images){
		// this is NOT the first time this method is ran on this instance of jsPDF object.
		imageIndex = Object.keys ? 
		Object.keys(images).length :
		(function(o){
			var i = 0
			for (var e in o){if(o.hasOwnProperty(e)){ i++ }}
			return i
		})(images)
	} else {
		// this is the first time this method is ran on this instance of jsPDF object.
		imageIndex = 0
		this.internal.collections[namespace + 'images'] = images = {}
		this.internal.events.subscribe('putResources', putResourcesCallback)
		this.internal.events.subscribe('putXobjectDict', putXObjectsDictCallback)
	}

	var dims = getJpegSize(imageData);
	var info = {
		w : dims[0],
		h : dims[1],
		cs : 'DeviceRGB',
		bpc : 8,
		f : 'DCTDecode',
		i : imageIndex,
		data : imageData
		// n: objectNumber will be added by putImage code

	};
	images[imageIndex] = info
	if (!w && !h) {
		w = -96;
		h = -96;
	}
	if (w < 0) {
		w = (-1) * info['w'] * 72 / w / this.internal.scaleFactor;
	}
	if (h < 0) {
		h = (-1) * info['h'] * 72 / h / this.internal.scaleFactor;
	}
	if (w === 0) {
		w = h * info['w'] / info['h'];
	}
	if (h === 0) {
		h = w * info['h'] / info['w'];
	}

	this.internal.write(
		'q'
		, coord(w)
		, '0 0'
		, coord(h) // TODO: check if this should be shifted by vcoord
		, coord(x)
		, vcoord(y + h)
		, 'cm /I'+info['i']
		, 'Do Q'
	)

	return this 
}
})(jsPDF.API)// @tag amchart
/**
 * A class to parse color values
 * @author Stoyan Stefanov <sstoo@gmail.com>
 * @link   http://www.phpied.com/rgb-color-parser-in-javascript/
 * @license Use it if you like it
 */
function RGBColor(color_string)
{
    this.ok = false;

    // strip any leading #
    if (color_string.charAt(0) == '#') { // remove # if any
        color_string = color_string.substr(1,6);
    }

    color_string = color_string.replace(/ /g,'');
    color_string = color_string.toLowerCase();

    // before getting into regexps, try simple matches
    // and overwrite the input
    var simple_colors = {
        aliceblue: 'f0f8ff',
        antiquewhite: 'faebd7',
        aqua: '00ffff',
        aquamarine: '7fffd4',
        azure: 'f0ffff',
        beige: 'f5f5dc',
        bisque: 'ffe4c4',
        black: '000000',
        blanchedalmond: 'ffebcd',
        blue: '0000ff',
        blueviolet: '8a2be2',
        brown: 'a52a2a',
        burlywood: 'deb887',
        cadetblue: '5f9ea0',
        chartreuse: '7fff00',
        chocolate: 'd2691e',
        coral: 'ff7f50',
        cornflowerblue: '6495ed',
        cornsilk: 'fff8dc',
        crimson: 'dc143c',
        cyan: '00ffff',
        darkblue: '00008b',
        darkcyan: '008b8b',
        darkgoldenrod: 'b8860b',
        darkgray: 'a9a9a9',
        darkgreen: '006400',
        darkkhaki: 'bdb76b',
        darkmagenta: '8b008b',
        darkolivegreen: '556b2f',
        darkorange: 'ff8c00',
        darkorchid: '9932cc',
        darkred: '8b0000',
        darksalmon: 'e9967a',
        darkseagreen: '8fbc8f',
        darkslateblue: '483d8b',
        darkslategray: '2f4f4f',
        darkturquoise: '00ced1',
        darkviolet: '9400d3',
        deeppink: 'ff1493',
        deepskyblue: '00bfff',
        dimgray: '696969',
        dodgerblue: '1e90ff',
        feldspar: 'd19275',
        firebrick: 'b22222',
        floralwhite: 'fffaf0',
        forestgreen: '228b22',
        fuchsia: 'ff00ff',
        gainsboro: 'dcdcdc',
        ghostwhite: 'f8f8ff',
        gold: 'ffd700',
        goldenrod: 'daa520',
        gray: '808080',
        green: '008000',
        greenyellow: 'adff2f',
        honeydew: 'f0fff0',
        hotpink: 'ff69b4',
        indianred : 'cd5c5c',
        indigo : '4b0082',
        ivory: 'fffff0',
        khaki: 'f0e68c',
        lavender: 'e6e6fa',
        lavenderblush: 'fff0f5',
        lawngreen: '7cfc00',
        lemonchiffon: 'fffacd',
        lightblue: 'add8e6',
        lightcoral: 'f08080',
        lightcyan: 'e0ffff',
        lightgoldenrodyellow: 'fafad2',
        lightgrey: 'd3d3d3',
        lightgreen: '90ee90',
        lightpink: 'ffb6c1',
        lightsalmon: 'ffa07a',
        lightseagreen: '20b2aa',
        lightskyblue: '87cefa',
        lightslateblue: '8470ff',
        lightslategray: '778899',
        lightsteelblue: 'b0c4de',
        lightyellow: 'ffffe0',
        lime: '00ff00',
        limegreen: '32cd32',
        linen: 'faf0e6',
        magenta: 'ff00ff',
        maroon: '800000',
        mediumaquamarine: '66cdaa',
        mediumblue: '0000cd',
        mediumorchid: 'ba55d3',
        mediumpurple: '9370d8',
        mediumseagreen: '3cb371',
        mediumslateblue: '7b68ee',
        mediumspringgreen: '00fa9a',
        mediumturquoise: '48d1cc',
        mediumvioletred: 'c71585',
        midnightblue: '191970',
        mintcream: 'f5fffa',
        mistyrose: 'ffe4e1',
        moccasin: 'ffe4b5',
        navajowhite: 'ffdead',
        navy: '000080',
        oldlace: 'fdf5e6',
        olive: '808000',
        olivedrab: '6b8e23',
        orange: 'ffa500',
        orangered: 'ff4500',
        orchid: 'da70d6',
        palegoldenrod: 'eee8aa',
        palegreen: '98fb98',
        paleturquoise: 'afeeee',
        palevioletred: 'd87093',
        papayawhip: 'ffefd5',
        peachpuff: 'ffdab9',
        peru: 'cd853f',
        pink: 'ffc0cb',
        plum: 'dda0dd',
        powderblue: 'b0e0e6',
        purple: '800080',
        red: 'ff0000',
        rosybrown: 'bc8f8f',
        royalblue: '4169e1',
        saddlebrown: '8b4513',
        salmon: 'fa8072',
        sandybrown: 'f4a460',
        seagreen: '2e8b57',
        seashell: 'fff5ee',
        sienna: 'a0522d',
        silver: 'c0c0c0',
        skyblue: '87ceeb',
        slateblue: '6a5acd',
        slategray: '708090',
        snow: 'fffafa',
        springgreen: '00ff7f',
        steelblue: '4682b4',
        tan: 'd2b48c',
        teal: '008080',
        thistle: 'd8bfd8',
        tomato: 'ff6347',
        turquoise: '40e0d0',
        violet: 'ee82ee',
        violetred: 'd02090',
        wheat: 'f5deb3',
        white: 'ffffff',
        whitesmoke: 'f5f5f5',
        yellow: 'ffff00',
        yellowgreen: '9acd32'
    };
    for (var key in simple_colors) {
        if (color_string == key) {
            color_string = simple_colors[key];
        }
    }
    // emd of simple type-in colors

    // array of color definition objects
    var color_defs = [
        {
            re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
            example: ['rgb(123, 234, 45)', 'rgb(255,234,245)'],
            process: function (bits){
                return [
                    parseInt(bits[1]),
                    parseInt(bits[2]),
                    parseInt(bits[3])
                ];
            }
        },
        {
            re: /^(\w{2})(\w{2})(\w{2})$/,
            example: ['#00ff00', '336699'],
            process: function (bits){
                return [
                    parseInt(bits[1], 16),
                    parseInt(bits[2], 16),
                    parseInt(bits[3], 16)
                ];
            }
        },
        {
            re: /^(\w{1})(\w{1})(\w{1})$/,
            example: ['#fb0', 'f0f'],
            process: function (bits){
                return [
                    parseInt(bits[1] + bits[1], 16),
                    parseInt(bits[2] + bits[2], 16),
                    parseInt(bits[3] + bits[3], 16)
                ];
            }
        }
    ];

    // search through the definitions to find a match
    for (var i = 0; i < color_defs.length; i++) {
        var re = color_defs[i].re;
        var processor = color_defs[i].process;
        var bits = re.exec(color_string);
        if (bits) {
            channels = processor(bits);
            this.r = channels[0];
            this.g = channels[1];
            this.b = channels[2];
            this.ok = true;
        }

    }

    // validate/cleanup values
    this.r = (this.r < 0 || isNaN(this.r)) ? 0 : ((this.r > 255) ? 255 : this.r);
    this.g = (this.g < 0 || isNaN(this.g)) ? 0 : ((this.g > 255) ? 255 : this.g);
    this.b = (this.b < 0 || isNaN(this.b)) ? 0 : ((this.b > 255) ? 255 : this.b);

    // some getters
    this.toRGB = function () {
        return 'rgb(' + this.r + ', ' + this.g + ', ' + this.b + ')';
    }
    this.toHex = function () {
        var r = this.r.toString(16);
        var g = this.g.toString(16);
        var b = this.b.toString(16);
        if (r.length == 1) r = '0' + r;
        if (g.length == 1) g = '0' + g;
        if (b.length == 1) b = '0' + b;
        return '#' + r + g + b;
    }

    // help
    this.getHelpXML = function () {

        var examples = new Array();
        // add regexps
        for (var i = 0; i < color_defs.length; i++) {
            var example = color_defs[i].example;
            for (var j = 0; j < example.length; j++) {
                examples[examples.length] = example[j];
            }
        }
        // add type-in colors
        for (var sc in simple_colors) {
            examples[examples.length] = sc;
        }

        var xml = document.createElement('ul');
        xml.setAttribute('id', 'rgbcolor-examples');
        for (var i = 0; i < examples.length; i++) {
            try {
                var list_item = document.createElement('li');
                var list_color = new RGBColor(examples[i]);
                var example_div = document.createElement('div');
                example_div.style.cssText =
                        'margin: 3px; '
                        + 'border: 1px solid black; '
                        + 'background:' + list_color.toHex() + '; '
                        + 'color:' + list_color.toHex()
                ;
                example_div.appendChild(document.createTextNode('test'));
                var list_item_value = document.createTextNode(
                    ' ' + examples[i] + ' -> ' + list_color.toRGB() + ' -> ' + list_color.toHex()
                );
                list_item.appendChild(example_div);
                list_item.appendChild(list_item_value);
                xml.appendChild(list_item);

            } catch(e){}
        }
        return xml;

    }

}

// @tag amchart
AmCharts.themes.black = {

	themeName: "black",

	AmChart: {
		color: "#e7e7e7", backgroundColor: "#222222"
	},

	AmCoordinateChart: {
		colors: ["#de4c4f", "#d8854f", "#eea638", "#a7a737", "#86a965", "#8aabb0", "#69c8ff", "#cfd27e", "#9d9888", "#916b8a", "#724887", "#7256bc"]
	},

	AmStockChart: {
		colors: ["#de4c4f", "#d8854f", "#eea638", "#a7a737", "#86a965", "#8aabb0", "#69c8ff", "#cfd27e", "#9d9888", "#916b8a", "#724887", "#7256bc"]
	},

	AmSlicedChart: {
		outlineAlpha: 1,
		outlineThickness: 2,
		labelTickColor: "#FFFFFF",
		labelTickAlpha: 0.3,
		colors: ["#de4c4f", "#d8854f", "#eea638", "#a7a737", "#86a965", "#8aabb0", "#69c8ff", "#cfd27e", "#9d9888", "#916b8a", "#724887", "#7256bc"]
	},

	AmRectangularChart: {
		zoomOutButtonColor: '#FFFFFF',
		zoomOutButtonRollOverAlpha: 0.15,
		zoomOutButtonImage: "lensWhite.png"
	},

	AxisBase: {
		axisColor: "#FFFFFF",
		axisAlpha: 0.3,
		gridAlpha: 0.1,
		gridColor: "#FFFFFF",
		dashLength: 3
	},

	ChartScrollbar: {
		backgroundColor: "#000000",
		backgroundAlpha: 0.2,
		graphFillAlpha: 0.2,
		graphLineAlpha: 0,
		graphFillColor: "#FFFFFF",
		selectedGraphFillColor: "#FFFFFF",
		selectedGraphFillAlpha: 0.4,
		selectedGraphLineColor: "#FFFFFF",
		selectedBackgroundColor: "#FFFFFF",
		selectedBackgroundAlpha: 0.09,
		gridAlpha: 0.15
	},

	ChartCursor: {
		cursorColor: "#FFFFFF",
		color: "#000000",
		cursorAlpha: 0.5
	},

	AmLegend: {
		color: "#e7e7e7"
	},

	AmGraph: {
		lineAlpha: 0.9
	},


	GaugeArrow: {
		color: "#FFFFFF",
		alpha: 0.8,
		nailAlpha: 0,
		innerRadius: "40%",
		nailRadius: 15,
		startWidth: 15,
		borderAlpha: 0.8,
		nailBorderAlpha: 0
	},

	GaugeAxis: {
		tickColor: "#FFFFFF",
		tickAlpha: 1,
		tickLength: 15,
		minorTickLength: 8,
		axisThickness: 3,
		axisColor: '#FFFFFF',
		axisAlpha: 1,
		bandAlpha: 0.8
	},

	TrendLine: {
		lineColor: "#c03246",
		lineAlpha: 0.8
	},

	// ammap
	AreasSettings: {
		alpha: 0.8,
		color: "#FFFFFF",
		colorSolid: "#000000",
		unlistedAreasAlpha: 0.4,
		unlistedAreasColor: "#FFFFFF",
		outlineColor: "#000000",
		outlineAlpha: 0.5,
		outlineThickness: 0.5,
		rollOverColor: "#3c5bdc",
		rollOverOutlineColor: "#000000",
		selectedOutlineColor: "#000000",
		selectedColor: "#f15135",
		unlistedAreasOutlineColor: "#000000",
		unlistedAreasOutlineAlpha: 0.5
	},

	LinesSettings: {
		color: "#FFFFFF",
		alpha: 0.8
	},

	ImagesSettings: {
		alpha: 0.8,
		labelColor: "#FFFFFF",
		color: "#FFFFFF",
		labelRollOverColor: "#3c5bdc"
	},

	ZoomControl: {
		buttonRollOverColor: "#3c5bdc",
		buttonFillColor: "#738f58",
		buttonBorderColor: "#738f58",
		buttonFillAlpha: 0.8,
		gridBackgroundColor: "#FFFFFF",
		buttonBorderAlpha:0,
		buttonCornerRadius:2,
		gridAlpha:0.5,
		gridBackgroundColor:"#FFFFFF",
		homeIconFile:"homeIconWhite.gif",
		buttonIconAlpha:0.6,
		gridAlpha: 0.2,
		buttonSize:20
	},

	SmallMap: {
		mapColor: "#FFFFFF",
		rectangleColor: "#FFFFFF",
		backgroundColor: "#000000",
		backgroundAlpha: 0.7,
		borderThickness: 1,
		borderAlpha: 0.8
	},

	// the defaults below are set using CSS syntax, you can use any existing css property
	// if you don't use Stock chart, you can delete lines below
	PeriodSelector: {
		color: "#e7e7e7"
	},

	PeriodButton: {
		color: "#e7e7e7",
		background: "transparent",
		opacity: 0.7,
		border: "1px solid rgba(255, 255, 255, .15)",
		MozBorderRadius: "5px",
		borderRadius: "5px",
		margin: "1px",
		outline: "none",
		boxSizing: "border-box"
	},

	PeriodButtonSelected: {
		color: "#e7e7e7",
		backgroundColor: "rgba(255, 255, 255, 0.1)",
		border: "1px solid rgba(255, 255, 255, .3)",
		MozBorderRadius: "5px",
		borderRadius: "5px",
		margin: "1px",
		outline: "none",
		opacity: 1,
		boxSizing: "border-box"
	},

	PeriodInputField: {
		color: "#e7e7e7",
		background: "transparent",
		border: "1px solid rgba(255, 255, 255, .15)",
		outline: "none"
	},

	DataSetSelector: {
		color: "#e7e7e7",
		selectedBackgroundColor: "rgba(255, 255, 255, .25)",
		rollOverBackgroundColor: "rgba(255, 255, 255, .15)"
	},

	DataSetCompareList: {
		color: "#e7e7e7",
		lineHeight: "100%",
		boxSizing: "initial",
		webkitBoxSizing: "initial",
		border: "1px solid rgba(255, 255, 255, .15)"
	},

	DataSetSelect: {
		border: "1px solid rgba(255, 255, 255, .15)",
		outline: "none"
	}

};// @tag amchart
AmCharts.themes.chalk = {

	themeName: "chalk",

	AmChart: {
		color: "#e7e7e7",
		fontFamily: "Covered By Your Grace",
		fontSize: 18,
		handDrawn: true,
		backgroundColor: "#282828"
	},

	AmCoordinateChart: {
		colors: ["#FFFFFF", "#e384a6", "#f4d499", "#4d90d6", "#c7e38c", "#9986c8", "#edf28c", "#ffd1d4", "#5ee1dc", "#b0eead", "#fef85a", "#8badd2"]
	},

	AmSlicedChart: {
		outlineAlpha: 1,
		labelTickColor: "#FFFFFF",
		labelTickAlpha: 0.3,
		colors: ["#FFFFFF", "#e384a6", "#f4d499", "#4d90d6", "#c7e38c", "#9986c8", "#edf28c", "#ffd1d4", "#5ee1dc", "#b0eead", "#fef85a", "#8badd2"]
	},

	AmStockChart: {
		colors: ["#FFFFFF", "#e384a6", "#f4d499", "#4d90d6", "#c7e38c", "#9986c8", "#edf28c", "#ffd1d4", "#5ee1dc", "#b0eead", "#fef85a", "#8badd2"]
	},

	AmRectangularChart: {

		zoomOutButtonColor: '#FFFFFF',
		zoomOutButtonRollOverAlpha: 0.15,
		zoomOutButtonImage: "lensWhite.png"
	},

	AxisBase: {
		axisColor: "#FFFFFF",
		gridColor: "#FFFFFF"
	},

	ChartScrollbar: {
		backgroundColor: "#FFFFFF",
		backgroundAlpha: 0.2,
		graphFillAlpha: 0.5,
		graphLineAlpha: 0,
		selectedBackgroundColor: "#000000",
		selectedBackgroundAlpha: 0.25,
		fontSize: 15,
		gridAlpha: 0.15
	},

	ChartCursor: {
		cursorColor: "#FFFFFF",
		color: "#000000"
	},

	AmLegend: {
		color: "#e7e7e7",
		markerSize: 20
	},

	AmGraph: {
		lineAlpha: 0.8
	},


	GaugeArrow: {
		color: "#FFFFFF",
		alpha: 0.1,
		nailAlpha: 0,
		innerRadius: "40%",
		nailRadius: 15,
		startWidth: 15,
		borderAlpha: 0.8,
		nailBorderAlpha: 0
	},

	GaugeAxis: {
		tickColor: "#FFFFFF",
		tickAlpha: 0.8,
		tickLength: 15,
		minorTickLength: 8,
		axisThickness: 3,
		axisColor: '#FFFFFF',
		axisAlpha: 0.8,
		bandAlpha: 0.4
	},

	TrendLine: {
		lineColor: "#c03246",
		lineAlpha: 0.8
	},

	// ammap
	AmMap: {
		handDrawn: false
	},

	AreasSettings: {
		alpha: 0.8,
		color: "#FFFFFF",
		colorSolid: "#000000",
		unlistedAreasAlpha: 0.4,
		unlistedAreasColor: "#FFFFFF",
		outlineColor: "#000000",
		outlineAlpha: 0.5,
		outlineThickness: 0.5,
		rollOverColor: "#4d90d6",
		rollOverOutlineColor: "#000000",
		selectedOutlineColor: "#000000",
		selectedColor: "#e384a6",
		unlistedAreasOutlineColor: "#000000",
		unlistedAreasOutlineAlpha: 0.5
	},

	LinesSettings: {
		color: "#FFFFFF",
		alpha: 0.8
	},

	ImagesSettings: {
		alpha: 0.8,
		labelFontSize: 16,
		labelColor: "#FFFFFF",
		color: "#FFFFFF",
		labelRollOverColor: "#4d90d6"
	},

	ZoomControl: {
		buttonRollOverColor: "#4d90d6",
		buttonFillColor: "#e384a6",
		buttonFillAlpha: 0.8,
		buttonBorderColor: "#FFFFFF",
		gridBackgroundColor: "#FFFFFF",
		gridAlpha: 0.8
	},

	SmallMap: {
		mapColor: "#FFFFFF",
		rectangleColor: "#FFFFFF",
		backgroundColor: "#000000",
		backgroundAlpha: 0.7,
		borderThickness: 1,
		borderAlpha: 0.8
	},


	// the defaults below are set using CSS syntax, you can use any existing css property
	// if you don't use Stock chart, you can delete lines below
	PeriodSelector: {
		fontFamily: "Covered By Your Grace",
		fontSize:"16px",
		color: "#e7e7e7"
	},

	PeriodButton: {
		fontFamily: "Covered By Your Grace",
		fontSize:"16px",
		color: "#e7e7e7",
		background: "transparent",
		opacity: 0.7,
		border: "1px solid rgba(255, 255, 255, .15)",
		MozBorderRadius: "5px",
		borderRadius: "5px",
		margin: "1px",
		outline: "none",
		boxSizing: "border-box"
	},

	PeriodButtonSelected: {
		fontFamily: "Covered By Your Grace",
		fontSize:"16px",
		color: "#e7e7e7",
		backgroundColor: "rgba(255, 255, 255, 0.1)",
		border: "1px solid rgba(255, 255, 255, .3)",
		MozBorderRadius: "5px",
		borderRadius: "5px",
		margin: "1px",
		outline: "none",
		opacity: 1,
		boxSizing: "border-box"
	},

	PeriodInputField: {
		fontFamily: "Covered By Your Grace",
		fontSize:"16px",
		color: "#e7e7e7",
		background: "transparent",
		border: "1px solid rgba(255, 255, 255, .15)",
		outline: "none"
	},

	DataSetSelector: {
		fontFamily: "Covered By Your Grace",
		fontSize:"16px",
		color: "#e7e7e7",
		selectedBackgroundColor: "rgba(255, 255, 255, .25)",
		rollOverBackgroundColor: "rgba(255, 255, 255, .15)"
	},

	DataSetCompareList: {
		fontFamily: "Covered By Your Grace",
		fontSize:"16px",
		color: "#e7e7e7",
		lineHeight: "100%",
		boxSizing: "initial",
		webkitBoxSizing: "initial",
		border: "1px solid rgba(255, 255, 255, .15)"
	},

	DataSetSelect: {
		fontFamily: "Covered By Your Grace",
		fontSize:"16px",
		border: "1px solid rgba(255, 255, 255, .15)",
		outline: "none"
	}

};// @tag amchart
AmCharts.themes.dark = {

	themeName: "dark",

	AmChart: {
		color: "#e7e7e7", backgroundColor: "#282828"
	},

	AmCoordinateChart: {
		colors: ["#ae85c9", "#aab9f7", "#b6d2ff", "#c9e6f2", "#c9f0e1", "#e8d685", "#e0ad63", "#d48652", "#d27362", "#495fba", "#7a629b", "#8881cc"]
	},

	AmStockChart: {
		colors: ["#639dbd", "#e8d685", "#ae85c9", "#c9f0e1", "#d48652", "#629b6d", "#719dc3", "#719dc3"]
	},

	AmSlicedChart: {
		outlineAlpha: 1,
		outlineThickness: 2,
		labelTickColor: "#FFFFFF",
		labelTickAlpha: 0.3,
		colors: ["#495fba", "#e8d685", "#ae85c9", "#c9f0e1", "#d48652", "#629b6d", "#719dc3", "#719dc3"]
	},

	AmRectangularChart: {
		zoomOutButtonColor: '#FFFFFF',
		zoomOutButtonRollOverAlpha: 0.15,
		zoomOutButtonImage: "lensWhite.png"
	},

	AxisBase: {
		axisColor: "#FFFFFF",
		axisAlpha: 0.3,
		gridAlpha: 0.1,
		gridColor: "#FFFFFF",
		dashLength: 3
	},

	ChartScrollbar: {
		backgroundColor: "#000000",
		backgroundAlpha: 0.2,
		graphFillAlpha: 0.2,
		graphLineAlpha: 0,
		graphFillColor: "#FFFFFF",
		selectedGraphFillColor: "#FFFFFF",
		selectedGraphFillAlpha: 0.4,
		selectedGraphLineColor: "#FFFFFF",
		selectedBackgroundColor: "#FFFFFF",
		selectedBackgroundAlpha: 0.09,
		gridAlpha: 0.15
	},

	ChartCursor: {
		cursorColor: "#FFFFFF",
		color: "#000000",
		cursorAlpha: 0.5
	},

	AmLegend: {
		color: "#e7e7e7"
	},

	AmGraph: {
		lineAlpha: 0.9
	},


	GaugeArrow: {
		color: "#FFFFFF",
		alpha: 0.8,
		nailAlpha: 0,
		innerRadius: "40%",
		nailRadius: 15,
		startWidth: 15,
		borderAlpha: 0.8,
		nailBorderAlpha: 0
	},

	GaugeAxis: {
		tickColor: "#FFFFFF",
		tickAlpha: 1,
		tickLength: 15,
		minorTickLength: 8,
		axisThickness: 3,
		axisColor: '#FFFFFF',
		axisAlpha: 1,
		bandAlpha: 0.8
	},

	TrendLine: {
		lineColor: "#c03246",
		lineAlpha: 0.8
	},

	// ammap
	AreasSettings: {
		alpha: 0.8,
		color: "#FFFFFF",
		colorSolid: "#000000",
		unlistedAreasAlpha: 0.4,
		unlistedAreasColor: "#FFFFFF",
		outlineColor: "#000000",
		outlineAlpha: 0.5,
		outlineThickness: 0.5,
		rollOverColor: "#3c5bdc",
		rollOverOutlineColor: "#000000",
		selectedOutlineColor: "#000000",
		selectedColor: "#f15135",
		unlistedAreasOutlineColor: "#000000",
		unlistedAreasOutlineAlpha: 0.5
	},

	LinesSettings: {
		color: "#FFFFFF",
		alpha: 0.8
	},

	ImagesSettings: {
		alpha: 0.8,
		labelColor: "#FFFFFF",
		color: "#FFFFFF",
		labelRollOverColor: "#3c5bdc"
	},

	ZoomControl: {
		buttonRollOverColor: "#3c5bdc",
		buttonFillColor: "#f15135",
		buttonFillAlpha: 0.8,
		gridBackgroundColor: "#FFFFFF",
		buttonBorderAlpha:0,
		buttonCornerRadius:2,
		gridAlpha:0.5,
		gridBackgroundColor:"#FFFFFF",
		homeIconFile:"homeIconWhite.gif",
		buttonIconAlpha:0.6,
		gridAlpha: 0.2,
		buttonSize:20
	},

	SmallMap: {
		mapColor: "#FFFFFF",
		rectangleColor: "#FFFFFF",
		backgroundColor: "#000000",
		backgroundAlpha: 0.7,
		borderThickness: 1,
		borderAlpha: 0.8
	},

	// the defaults below are set using CSS syntax, you can use any existing css property
	// if you don't use Stock chart, you can delete lines below
	PeriodSelector: {
		color: "#e7e7e7"
	},

	PeriodButton: {
		color: "#e7e7e7",
		background: "transparent",
		opacity: 0.7,
		border: "1px solid rgba(255, 255, 255, .15)",
		MozBorderRadius: "5px",
		borderRadius: "5px",
		margin: "1px",
		outline: "none",
		boxSizing: "border-box"
	},

	PeriodButtonSelected: {
		color: "#e7e7e7",
		backgroundColor: "rgba(255, 255, 255, 0.1)",
		border: "1px solid rgba(255, 255, 255, .3)",
		MozBorderRadius: "5px",
		borderRadius: "5px",
		margin: "1px",
		outline: "none",
		opacity: 1,
		boxSizing: "border-box"
	},

	PeriodInputField: {
		color: "#e7e7e7",
		background: "transparent",
		border: "1px solid rgba(255, 255, 255, .15)",
		outline: "none"
	},

	DataSetSelector: {
		color: "#e7e7e7",
		selectedBackgroundColor: "rgba(255, 255, 255, .25)",
		rollOverBackgroundColor: "rgba(255, 255, 255, .15)"
	},

	DataSetCompareList: {
		color: "#e7e7e7",
		lineHeight: "100%",
		boxSizing: "initial",
		webkitBoxSizing: "initial",
		border: "1px solid rgba(255, 255, 255, .15)"
	},

	DataSetSelect: {
		border: "1px solid rgba(255, 255, 255, .15)",
		outline: "none"
	}

};// @tag amchart
AmCharts.themes.light = {

	themeName:"light",

	AmChart: {
		color: "#000000", backgroundColor: "#FFFFFF"
	},

	AmCoordinateChart: {
		colors: ["#67b7dc", "#fdd400", "#84b761", "#cc4748", "#cd82ad", "#2f4074", "#448e4d", "#b7b83f", "#b9783f", "#b93e3d", "#913167"]
	},

	AmStockChart: {
		colors: ["#67b7dc", "#fdd400", "#84b761", "#cc4748", "#cd82ad", "#2f4074", "#448e4d", "#b7b83f", "#b9783f", "#b93e3d", "#913167"]
	},

	AmSlicedChart: {
		colors: ["#67b7dc", "#fdd400", "#84b761", "#cc4748", "#cd82ad", "#2f4074", "#448e4d", "#b7b83f", "#b9783f", "#b93e3d", "#913167"],
		outlineAlpha: 1,
		outlineThickness: 2,
		labelTickColor: "#000000",
		labelTickAlpha: 0.3
	},

	AmRectangularChart: {
		zoomOutButtonColor: '#000000',
		zoomOutButtonRollOverAlpha: 0.15,
		zoomOutButtonImage: "lens.png"
	},

	AxisBase: {
		axisColor: "#000000",
		axisAlpha: 0.3,
		gridAlpha: 0.1,
		gridColor: "#000000"
	},

	ChartScrollbar: {
		backgroundColor: "#000000",
		backgroundAlpha: 0.12,
		graphFillAlpha: 0.5,
		graphLineAlpha: 0,
		selectedBackgroundColor: "#FFFFFF",
		selectedBackgroundAlpha: 0.4,
		gridAlpha: 0.15
	},

	ChartCursor: {
		cursorColor: "#000000",
		color: "#FFFFFF",
		cursorAlpha: 0.5
	},

	AmLegend: {
		color: "#000000"
	},

	AmGraph: {
		lineAlpha: 0.9
	},
	GaugeArrow: {
		color: "#000000",
		alpha: 0.8,
		nailAlpha: 0,
		innerRadius: "40%",
		nailRadius: 15,
		startWidth: 15,
		borderAlpha: 0.8,
		nailBorderAlpha: 0
	},

	GaugeAxis: {
		tickColor: "#000000",
		tickAlpha: 1,
		tickLength: 15,
		minorTickLength: 8,
		axisThickness: 3,
		axisColor: '#000000',
		axisAlpha: 1,
		bandAlpha: 0.8
	},

	TrendLine: {
		lineColor: "#c03246",
		lineAlpha: 0.8
	},

	// ammap
	AreasSettings: {
		alpha: 0.8,
		color: "#67b7dc",
		colorSolid: "#003767",
		unlistedAreasAlpha: 0.4,
		unlistedAreasColor: "#000000",
		outlineColor: "#FFFFFF",
		outlineAlpha: 0.5,
		outlineThickness: 0.5,
		rollOverColor: "#3c5bdc",
		rollOverOutlineColor: "#FFFFFF",
		selectedOutlineColor: "#FFFFFF",
		selectedColor: "#f15135",
		unlistedAreasOutlineColor: "#FFFFFF",
		unlistedAreasOutlineAlpha: 0.5
	},

	LinesSettings: {
		color: "#000000",
		alpha: 0.8
	},

	ImagesSettings: {
		alpha: 0.8,
		labelColor: "#000000",
		color: "#000000",
		labelRollOverColor: "#3c5bdc"
	},

	ZoomControl: {
		buttonRollOverColor: "#3c5bdc",
		buttonFillColor: "#3994e2",
		buttonBorderColor: "#3994e2",
		buttonFillAlpha: 0.8,
		gridBackgroundColor: "#FFFFFF",
		buttonBorderAlpha:0,
		buttonCornerRadius:2,
		gridColor:"#FFFFFF",
		gridBackgroundColor:"#000000",
		buttonIconAlpha:0.6,
		gridAlpha: 0.6,
		buttonSize:20
	},

	SmallMap: {
		mapColor: "#000000",
		rectangleColor: "#f15135",
		backgroundColor: "#FFFFFF",
		backgroundAlpha: 0.7,
		borderThickness: 1,
		borderAlpha: 0.8
	},

	// the defaults below are set using CSS syntax, you can use any existing css property
	// if you don't use Stock chart, you can delete lines below
	PeriodSelector: {
		color: "#000000"
	},

	PeriodButton: {
		color: "#000000",
		background: "transparent",
		opacity: 0.7,
		border: "1px solid rgba(0, 0, 0, .3)",
		MozBorderRadius: "5px",
		borderRadius: "5px",
		margin: "1px",
		outline: "none",
		boxSizing: "border-box"
	},

	PeriodButtonSelected: {
		color: "#000000",
		backgroundColor: "#b9cdf5",
		border: "1px solid rgba(0, 0, 0, .3)",
		MozBorderRadius: "5px",
		borderRadius: "5px",
		margin: "1px",
		outline: "none",
		opacity: 1,
		boxSizing: "border-box"
	},

	PeriodInputField: {
		color: "#000000",
		background: "transparent",
		border: "1px solid rgba(0, 0, 0, .3)",
		outline: "none"
	},

	DataSetSelector: {

		color: "#000000",
		selectedBackgroundColor: "#b9cdf5",
		rollOverBackgroundColor: "#a8b0e4"
	},

	DataSetCompareList: {
		color: "#000000",
		lineHeight: "100%",
		boxSizing: "initial",
		webkitBoxSizing: "initial",
		border: "1px solid rgba(0, 0, 0, .3)"
	},

	DataSetSelect: {
		border: "1px solid rgba(0, 0, 0, .3)",
		outline: "none"
	}

};// @tag amchart
AmCharts.themes.patterns = {

	themeName:"patterns",

	AmChart: {
		color: "#000000", backgroundColor: "#FFFFFF"
	},

	AmCoordinateChart: {
		colors:["#000000","#000000","#000000","#000000","#000000","#000000","#000000","#000000","#000000","#000000","#000000","#000000","#000000","#000000","#000000","#000000","#000000","#000000","#000000","#000000","#000000"],
		patterns:[
		{"url":"../amcharts/patterns/black/pattern1.png", "width":4, "height":4},
		{"url":"../amcharts/patterns/black/pattern2.png", "width":4, "height":4},
		{"url":"../amcharts/patterns/black/pattern3.png", "width":4, "height":4},
		{"url":"../amcharts/patterns/black/pattern4.png", "width":4, "height":4},
		{"url":"../amcharts/patterns/black/pattern5.png", "width":4, "height":4},
		{"url":"../amcharts/patterns/black/pattern6.png", "width":4, "height":4},
		{"url":"../amcharts/patterns/black/pattern7.png", "width":4, "height":4},
		{"url":"../amcharts/patterns/black/pattern8.png", "width":4, "height":4},
		{"url":"../amcharts/patterns/black/pattern9.png", "width":4, "height":4},
		{"url":"../amcharts/patterns/black/pattern10.png", "width":4, "height":4},
		{"url":"../amcharts/patterns/black/pattern11.png", "width":4, "height":4},
		{"url":"../amcharts/patterns/black/pattern12.png", "width":4, "height":4},
		{"url":"../amcharts/patterns/black/pattern13.png", "width":4, "height":4},
		{"url":"../amcharts/patterns/black/pattern14.png", "width":4, "height":4},
		{"url":"../amcharts/patterns/black/pattern15.png", "width":4, "height":4},
		{"url":"../amcharts/patterns/black/pattern16.png", "width":4, "height":4},
		{"url":"../amcharts/patterns/black/pattern17.png", "width":4, "height":4},
		{"url":"../amcharts/patterns/black/pattern18.png", "width":4, "height":4},
		{"url":"../amcharts/patterns/black/pattern19.png", "width":4, "height":4},
		{"url":"../amcharts/patterns/black/pattern20.png", "width":4, "height":4},
		{"url":"../amcharts/patterns/black/pattern21.png", "width":4, "height":4}]
	},


	AmStockChart: {
		colors:["#000000","#000000","#000000","#000000","#000000","#000000","#000000","#000000","#000000","#000000","#000000","#000000","#000000","#000000","#000000","#000000","#000000","#000000","#000000","#000000","#000000"]
	},

	AmPieChart: {
		depth3D:0,
		angle:0,
		labelRadius:10
	},

	AmSlicedChart: {
		outlineAlpha: 0.3,
		colors:["#000000","#000000","#000000","#000000","#000000","#000000","#000000","#000000","#000000","#000000","#000000","#000000","#000000","#000000","#000000","#000000","#000000","#000000","#000000","#000000","#000000"],
		outlineThickness: 1,
		outlineColor:"#000000",
		labelTickColor: "#000000",
		labelTickAlpha: 0.3,
		patterns:[
		{"url":"../amcharts/patterns/black/pattern1.png", "width":4, "height":4},
		{"url":"../amcharts/patterns/black/pattern2.png", "width":4, "height":4},
		{"url":"../amcharts/patterns/black/pattern3.png", "width":4, "height":4},
		{"url":"../amcharts/patterns/black/pattern4.png", "width":4, "height":4},
		{"url":"../amcharts/patterns/black/pattern5.png", "width":4, "height":4},
		{"url":"../amcharts/patterns/black/pattern6.png", "width":4, "height":4},
		{"url":"../amcharts/patterns/black/pattern7.png", "width":4, "height":4},
		{"url":"../amcharts/patterns/black/pattern8.png", "width":4, "height":4},
		{"url":"../amcharts/patterns/black/pattern9.png", "width":4, "height":4},
		{"url":"../amcharts/patterns/black/pattern10.png", "width":4, "height":4},
		{"url":"../amcharts/patterns/black/pattern11.png", "width":4, "height":4},
		{"url":"../amcharts/patterns/black/pattern12.png", "width":4, "height":4},
		{"url":"../amcharts/patterns/black/pattern13.png", "width":4, "height":4},
		{"url":"../amcharts/patterns/black/pattern14.png", "width":4, "height":4},
		{"url":"../amcharts/patterns/black/pattern15.png", "width":4, "height":4},
		{"url":"../amcharts/patterns/black/pattern16.png", "width":4, "height":4},
		{"url":"../amcharts/patterns/black/pattern17.png", "width":4, "height":4},
		{"url":"../amcharts/patterns/black/pattern18.png", "width":4, "height":4},
		{"url":"../amcharts/patterns/black/pattern19.png", "width":4, "height":4},
		{"url":"../amcharts/patterns/black/pattern20.png", "width":4, "height":4},
		{"url":"../amcharts/patterns/black/pattern21.png", "width":4, "height":4}]
	},

	AmRectangularChart: {
		zoomOutButtonColor: '#000000',
		zoomOutButtonRollOverAlpha: 0.15,
		zoomOutButtonImage: "lens.png"
	},



	AxisBase: {
		axisColor: "#000000",
		axisAlpha: 0.3,
		gridAlpha: 0.05,
		gridColor: "#000000"
	},

	ChartScrollbar: {
		backgroundColor: "#000000",
		backgroundAlpha: 0.13,
		graphFillAlpha: 0.4,
		selectedGraphFillAlpha: 0.7,
		graphLineAlpha: 0,
		selectedBackgroundColor: "#FFFFFF",
		selectedBackgroundAlpha: 0.9,
		gridAlpha: 0.15
	},

	ChartCursor: {
		cursorColor: "#000000",
		color: "#FFFFFF",
		cursorAlpha: 0.5
	},

	AmLegend: {
		color: "#000000",
		markerBorderAlpha:0.1,
		markerSize:20,
		switchColor:"#000000"
	},

	AmGraph: {
		lineAlpha: 0.4,
		fillAlphas:0.5
	},

	AmAngularGauge:{
		faceAlpha:0.5,
		facePattern:{"url":"../amcharts/patterns/black/pattern1.png", "width":4, "height":4}
	},


	GaugeArrow: {
		color: "#000000",
		alpha: 1,
		nailAlpha: 1,
		innerRadius: "0%",
		nailRadius: 15,
		startWidth: 15,
		borderAlpha: 1,
		radius:"70%",
		nailBorderAlpha: 1
	},

	GaugeAxis: {
		tickColor: "#000000",
		tickAlpha: 1,
		tickLength: 15,
		minorTickLength: 8,
		axisThickness: 1,
		axisColor: '#000000',
		axisAlpha: 1,
		bandAlpha: 1
	},

	TrendLine: {
		lineColor: "#c03246",
		lineAlpha: 0.8
	},

	// ammap
	AreasSettings: {
		alpha: 0.8,
		color: "#000000",
		colorSolid: "#000000",
		unlistedAreasAlpha: 0.4,
		unlistedAreasColor: "#000000",
		outlineColor: "#FFFFFF",
		outlineAlpha: 0.5,
		outlineThickness: 0.5,
		rollOverColor: "#3c5bdc",
		rollOverOutlineColor: "#FFFFFF",
		selectedOutlineColor: "#FFFFFF",
		selectedColor: "#f15135",
		unlistedAreasOutlineColor: "#FFFFFF",
		unlistedAreasOutlineAlpha: 0.5
	},

	LinesSettings: {
		color: "#000000",
		alpha: 0.8
	},

	ImagesSettings: {
		alpha: 0.8,
		labelColor: "#000000",
		color: "#000000",
		labelRollOverColor: "#3c5bdc"
	},

	ZoomControl: {
		buttonRollOverColor: "#3c5bdc",
		buttonFillColor: "#f15135",
		buttonFillAlpha: 0.8,
		buttonBorderColor: "#000000",
		gridBackgroundColor: "#000000",
		gridAlpha: 0.8
	},

	SmallMap: {
		mapColor: "#000000",
		rectangleColor: "#FFFFFF",
		backgroundColor: "#FFFFFF",
		backgroundAlpha: 0.7,
		borderThickness: 1,
		borderAlpha: 0.8
	},

	// the defaults below are set using CSS syntax, you can use any existing css property
	// if you don't use Stock chart, you can delete lines below
	PeriodSelector: {
		color: "#000000"
	},

	PeriodButton: {
		color: "#000000",
		background: "transparent",
		opacity: 0.7,
		border: "1px solid rgba(0, 0, 0, .3)",
		MozBorderRadius: "5px",
		borderRadius: "5px",
		margin: "1px",
		outline: "none",
		boxSizing: "border-box"
	},

	PeriodButtonSelected: {
		color: "#000000",
		backgroundColor: "rgba(0, 0, 0, 0.1)",
		border: "1px solid rgba(0, 0, 0, .3)",
		MozBorderRadius: "5px",
		borderRadius: "5px",
		margin: "1px",
		outline: "none",
		opacity: 1,
		boxSizing: "border-box"
	},

	PeriodInputField: {
		color: "#000000",
		background: "transparent",
		border: "1px solid rgba(0, 0, 0, .3)",
		outline: "none"
	},

	DataSetSelector: {
		color: "#000000",
		selectedBackgroundColor: "rgba(0, 0, 0, .25)",
		rollOverBackgroundColor: "rgba(0, 0, 0, .15)"
	},

	DataSetCompareList: {
		color: "#000000",
		lineHeight: "100%",
		boxSizing: "initial",
		webkitBoxSizing: "initial",
		border: "1px solid rgba(0, 0, 0, .3)"
	},

	DataSetSelect: {
		border: "1px solid rgba(0, 0, 0, .3)",
		outline: "none"
	}

};
// @tag amchart
AmCharts.AxisBase = AmCharts.Class({

    construct: function (theme) {
        var _this = this;
        _this.dx = 0;
        _this.dy = 0;
        _this.x = 0;
        _this.y = 0;
        _this.viX = 0;
        _this.viY = 0;
        //_this.axisWidth;
        _this.axisThickness = 1;
        _this.axisColor = '#000000';
        _this.axisAlpha = 1;
        _this.tickLength = 5;
        _this.gridCount = 5;
        _this.gridAlpha = 0.15;
        _this.gridThickness = 1;
        _this.gridColor = '#000000';
        _this.dashLength = 0;
        _this.labelFrequency = 1;
        _this.showFirstLabel = true;
        _this.showLastLabel = true;
        _this.fillColor = '#FFFFFF';
        _this.fillAlpha = 0;
        _this.labelsEnabled = true;
        _this.labelRotation = 0;
        _this.autoGridCount = true;
        _this.valueRollOverColor = '#CC0000';
        _this.offset = 0;
        _this.guides = [];
        _this.visible = true;
        _this.counter = 0;
        _this.guides = [];
        _this.inside = false;
        _this.ignoreAxisWidth = false;
        //_this.titleColor;
        //_this.titleFontSize;
        _this.minHorizontalGap = 75;
        _this.minVerticalGap = 35;
        _this.titleBold = true;
        _this.minorGridEnabled = false;
        _this.minorGridAlpha = 0.07;
        _this.autoWrap = false;
        _this.titleAlign = 'middle';

        AmCharts.applyTheme(_this, theme, "AxisBase");
    },

    zoom: function (start, end) {
        var _this = this;
        _this.start = start;
        _this.end = end;
        _this.dataChanged = true;
        _this.draw();
    },

    fixAxisPosition: function () {
        var _this = this;
        var pos = _this.position;

        if (_this.orientation == "H") {
            if (pos == "left") {
                pos = "bottom";
            }
            if (pos == "right") {
                pos = "top";
            }
        } else {
            if (pos == "bottom") {
                pos = "left";
            }
            if (pos == "top") {
                pos = "right";
            }
        }

        _this.position = pos;
    },

    draw: function () {
        var _this = this;
        var chart = _this.chart;

        _this.allLabels = [];
        _this.counter = 0;
        _this.destroy();
        _this.fixAxisPosition();
        _this.labels = [];

        var container = chart.container;

        var set = container.set();
        chart.gridSet.push(set);
        _this.set = set;

        var labelsSet = container.set();
        chart.axesLabelsSet.push(labelsSet);
        _this.labelsSet = labelsSet;

        _this.axisLine = new _this.axisRenderer(_this);

        if (_this.autoGridCount) {
            var c;

            if (_this.orientation == "V") {
                c = _this.height / _this.minVerticalGap;
                if (c < 3) {
                    c = 3;
                }
            } else {
                c = _this.width / _this.minHorizontalGap;
            }
            _this.gridCountR = Math.max(c, 1);
        }
        else{
            _this.gridCountR = _this.gridCount;
        }
        _this.axisWidth = _this.axisLine.axisWidth;
        _this.addTitle();
    },

    setOrientation: function (rotate) {
        var _this = this;
        if (rotate) {
            _this.orientation = "H";
        } else {
            _this.orientation = "V";
        }
    },


    addTitle: function () {

        var _this = this;
        var title = _this.title;

        //_this.titleLabel = null;
        if (title) {
            var chart = _this.chart;

            var color = _this.titleColor;
            if (color === undefined) {
                color = chart.color;
            }

            var titleFontSize = _this.titleFontSize;
            if (isNaN(titleFontSize)) {
                titleFontSize = chart.fontSize + 1;
            }
            var titleLabel = AmCharts.text(chart.container, title, color, chart.fontFamily, titleFontSize, _this.titleAlign, _this.titleBold);
            _this.titleLabel = titleLabel;
        }
    },

    positionTitle: function () {
        var _this = this;
        var titleLabel = _this.titleLabel;
        if (titleLabel) {
            var tx;
            var ty;
            var labelsSet = _this.labelsSet;
            var bbox = {};
            if (labelsSet.length() > 0) {
                bbox = labelsSet.getBBox();
            } else {
                bbox.x = 0;
                bbox.y = 0;
                bbox.width = _this.viW;
                bbox.height = _this.viH;
            }
            labelsSet.push(titleLabel);

            var bx = bbox.x;
            var by = bbox.y;

            if (AmCharts.VML) {
                if (!_this.rotate) {
                    by -= _this.y;
                } else {
                    bx -= _this.x;
                }
            }

            var bw = bbox.width;
            var bh = bbox.height;

            var w = _this.viW;
            var h = _this.viH;

            var anchor = "middle";

            var r = 0;

            var fontSize = titleLabel.getBBox().height / 2;
            var inside = _this.inside;
            var titleAlign = _this.titleAlign;

            switch (_this.position) {
                case "top":
                    if(titleAlign == "left"){
                        tx = -1;
                    }
                    else if(titleAlign == "right"){
                        tx = w;
                    }
                    else{
                        tx = w / 2;
                    }

                    ty = by - 10 - fontSize;
                    break;
                case "bottom":
                    if(titleAlign == "left"){
                        tx = -1;
                    }
                    else if(titleAlign == "right"){
                        tx = w;
                    }
                    else{
                        tx = w / 2;
                    }

                    ty = by + bh + 10 + fontSize;
                    break;
                case "left":
                    tx = bx - 10 - fontSize;

                    if (inside) {
                        tx -= 5;
                    }
                    if(titleAlign == "left"){
                        ty = h + 1;
                    }
                    else if(titleAlign == "right"){
                        ty = -1;
                    }
                    else{
                        ty = h / 2;
                    }
                    r = -90;
                    break;
                case "right":
                    tx = bx + bw + 10 + fontSize - 3;
                    if (inside) {
                        tx += 7;
                    }
                    if(titleAlign == "left"){
                        ty = h + 2;
                    }
                    else if(titleAlign == "right"){
                        ty = -2;
                    }
                    else{
                        ty = h / 2;
                    }
                    r = -90;
                    break;
            }

            if (_this.marginsChanged) {
                titleLabel.translate(tx, ty);
                _this.tx = tx;
                _this.ty = ty;
            } else {
                titleLabel.translate(_this.tx, _this.ty);
            }
            _this.marginsChanged = false;

            if (r !== 0) {
                titleLabel.rotate(r);
            }
        }
    },

    pushAxisItem: function (axisItem, above) {
        var axisItemGraphics = axisItem.graphics();
        if (axisItemGraphics.length() > 0) {
            if (above) {
                this.labelsSet.push(axisItemGraphics);
            } else {
                this.set.push(axisItemGraphics);
            }
        }

        var label = axisItem.getLabel();
        if (label) {
            this.labelsSet.push(label);
        }
    },

    addGuide: function (guide) {
        var _this = this;
        var guides = _this.guides;
        if(guides.indexOf(guide) == -1){
            guides.push(guide);
        }
    },

    removeGuide: function (guide) {
        var guides = this.guides;
        var i;
        for (i = 0; i < guides.length; i++) {
            if (guides[i] == guide) {
                guides.splice(i, 1);
            }
        }
    },

    handleGuideOver: function (guide) {
        var _this = this;
        clearTimeout(_this.chart.hoverInt);
        var bbox = guide.graphics.getBBox();
        var x = bbox.x + bbox.width / 2;
        var y = bbox.y + bbox.height / 2;
        var color = guide.fillColor;
        if (color === undefined) {
            color = guide.lineColor;
        }
        _this.chart.showBalloon(guide.balloonText, color, true, x, y);
    },

    handleGuideOut: function (event) {
        this.chart.hideBalloon();
    },

    addEventListeners: function (graphics, guide) {
        var _this = this;
        graphics.mouseover(function () {
            _this.handleGuideOver(guide);
        });
        graphics.mouseout(function () {
            _this.handleGuideOut(guide);
        });
    },


    getBBox: function () {
        var _this = this;
        var bbox = _this.labelsSet.getBBox();

        if (!AmCharts.VML) {
            bbox = ({
                x: (bbox.x + _this.x),
                y: (bbox.y + _this.y),
                width: bbox.width,
                height: bbox.height
            });
        }
        return bbox;
    },

    destroy: function () {
        var _this = this;
        AmCharts.remove(_this.set);
        AmCharts.remove(_this.labelsSet);

        var axisLine = _this.axisLine;
        if (axisLine) {
            AmCharts.remove(axisLine.set);
        }
        AmCharts.remove(_this.grid0);
    }
});

// @tag amchart
AmCharts.CategoryAxis = AmCharts.Class({

    inherits: AmCharts.AxisBase,

    construct: function(theme) {
        var _this = this;
        _this.cname = "CategoryAxis";
        AmCharts.CategoryAxis.base.construct.call(_this, theme);
        _this.minPeriod = "DD";
        _this.parseDates = false;
        _this.equalSpacing = false;
        _this.position = "bottom";
        _this.startOnAxis = false;
        _this.firstDayOfWeek = 1;
        _this.gridPosition = "middle";
        _this.boldPeriodBeginning = true;
        _this.markPeriodChange = true;
        _this.safeDistance = 30;
        _this.centerLabelOnFullPeriod = true;
        //_this.categoryFunction;
        _this.periods = [{
            period: "ss",
            count: 1
        }, {
            period: "ss",
            count: 5
        }, {
            period: "ss",
            count: 10
        }, {
            period: "ss",
            count: 30
        }, {
            period: "mm",
            count: 1
        }, {
            period: "mm",
            count: 5
        }, {
            period: "mm",
            count: 10
        }, {
            period: "mm",
            count: 30
        }, {
            period: "hh",
            count: 1
        }, {
            period: "hh",
            count: 3
        }, {
            period: "hh",
            count: 6
        }, {
            period: "hh",
            count: 12
        }, {
            period: "DD",
            count: 1
        }, {
            period: "DD",
            count: 2
        }, {
            period: "DD",
            count: 3
        }, {
            period: "DD",
            count: 4
        }, {
            period: "DD",
            count: 5
        }, {
            period: "WW",
            count: 1
        }, {
            period: "MM",
            count: 1
        }, {
            period: "MM",
            count: 2
        }, {
            period: "MM",
            count: 3
        }, {
            period: "MM",
            count: 6
        }, {
            period: "YYYY",
            count: 1
        }, {
            period: "YYYY",
            count: 2
        }, {
            period: "YYYY",
            count: 5
        }, {
            period: "YYYY",
            count: 10
        }, {
            period: "YYYY",
            count: 50
        }, {
            period: "YYYY",
            count: 100
        }];

        _this.dateFormats = [{
            period: 'fff',
            format: 'JJ:NN:SS'
        }, {
            period: 'ss',
            format: 'JJ:NN:SS'
        }, {
            period: 'mm',
            format: 'JJ:NN'
        }, {
            period: 'hh',
            format: 'JJ:NN'
        }, {
            period: 'DD',
            format: 'MMM DD'
        }, {
            period: 'WW',
            format: 'MMM DD'
        }, {
            period: 'MM',
            format: 'MMM'
        }, {
            period: 'YYYY',
            format: 'YYYY'
        }];

        _this.nextPeriod = {};
        _this.nextPeriod.fff = "ss";
        _this.nextPeriod.ss = "mm";
        _this.nextPeriod.mm = "hh";
        _this.nextPeriod.hh = "DD";
        _this.nextPeriod.DD = "MM";
        _this.nextPeriod.MM = "YYYY";

        AmCharts.applyTheme(_this, theme, _this.cname);
    },


    draw: function() {
        var _this = this;
        AmCharts.CategoryAxis.base.draw.call(_this);

        _this.generateDFObject();

        var data = _this.chart.chartData;
        _this.data = data;

        if (AmCharts.ifArray(data)) {
            var i;
            var chart = _this.chart;
            var end = _this.end;
            var start = _this.start;
            var labelFrequency = _this.labelFrequency;
            var startFrom = 0;
            var valueCount = end - start + 1;
            var gridCount = _this.gridCountR;
            var showFirstLabel = _this.showFirstLabel;
            var showLastLabel = _this.showLastLabel;
            var coord;
            var valueText = "";
            var minPeriodObj = AmCharts.extractPeriod(_this.minPeriod);
            var minDuration = AmCharts.getPeriodDuration(minPeriodObj.period, minPeriodObj.count);
            var periodObj;
            var periodMultiplier;
            var period;
            var periodDuration;
            var periodReal;
            var previousTime;
            var previousTimeReal;
            var periodWidth;
            var periodCount;
            var time;
            var biggerPeriodChanged;
            var dateFormat;
            var realStartFrom;
            var rotate = _this.rotate;
            var firstDayOfWeek = _this.firstDayOfWeek;
            var boldPeriodBeginning = _this.boldPeriodBeginning;
            var lastTime = data[data.length - 1].time;
            var maxTime = AmCharts.resetDateToMin(new Date(lastTime + minDuration * 1.05), _this.minPeriod, 1, firstDayOfWeek).getTime();
            var bold;
            var axisItem;
            var UNDEFINED;

            if (_this.endTime > maxTime) {
                _this.endTime = maxTime;
            }

            var minorGridEnabled = _this.minorGridEnabled;
            var minorGridFrequency;
            var gridAlphaReal = _this.gridAlpha;
            var minorPeriodDuration;
            var mAxisItem;

            // PARSE DATES

            if (_this.parseDates && !_this.equalSpacing) {

                _this.timeDifference = _this.endTime - _this.startTime;

                periodObj = _this.choosePeriod(0);

                period = periodObj.period;
                periodMultiplier = periodObj.count;

                periodDuration = AmCharts.getPeriodDuration(period, periodMultiplier);

                // check if this period is not shorter then minPeriod
                if (periodDuration < minDuration) {
                    period = minPeriodObj.period;
                    periodMultiplier = minPeriodObj.count;
                    periodDuration = minDuration;
                }

                periodReal = period;
                // weeks don't have format, swith to days
                if (periodReal == "WW") {
                    periodReal = "DD";
                }
                _this.stepWidth = _this.getStepWidth(_this.timeDifference);

                gridCount = Math.ceil(_this.timeDifference / periodDuration) + 5;

                //previousTime = AmCharts.resetDateToMin(new Date(_this.startTime - periodDuration * periodMultiplier), period, periodMultiplier, firstDayOfWeek).getTime();
                // 2.10.7
                previousTime = AmCharts.resetDateToMin(new Date(_this.startTime - periodDuration), period, periodMultiplier, firstDayOfWeek).getTime();

                var startTime = previousTime;

                // if this is pure period (no numbers and not a week), place the value in the middle
                if (periodReal == period && periodMultiplier == 1 && _this.centerLabelOnFullPeriod) {
                    periodWidth = periodDuration * _this.stepWidth;
                }

                _this.cellWidth = minDuration * _this.stepWidth;


                periodCount = Math.round(previousTime / periodDuration);

                start = -1;
                if (periodCount / 2 == Math.round(periodCount / 2)) {
                    start = -2;
                    previousTime -= periodDuration;
                }

                var initialTime = chart.firstTime;
                // delta time is used to fix a problem which happens because month duration is not the same all the time
                var deltaTime = 0;

                if (minorGridEnabled && periodMultiplier > 1) {
                    minorGridFrequency = _this.chooseMinorFrequency(periodMultiplier);
                    minorPeriodDuration = AmCharts.getPeriodDuration(period, minorGridFrequency);
                }

                if (_this.gridCountR > 0) {
                    for (i = start; i <= gridCount; i++) {
                        //time = previousTime + periodDuration * 1.1;
                        time = initialTime + periodDuration * (i + Math.floor((startTime - initialTime) / periodDuration)) - deltaTime;

                        if (period == "DD") {
                            time += 3600000; // this should fix daylight saving errors - otherwise double grid appears or the gap between grid lines is bigger
                        }
                        time = AmCharts.resetDateToMin(new Date(time), period, periodMultiplier, firstDayOfWeek).getTime();

                        //if (time != previousTime) {
                            // fixing not equal month duration problem
                            if (period == "MM") {
                                var mult = (time - previousTime) / periodDuration;
                                if ((time - previousTime) / periodDuration >= 1.5) {
                                    //time = time - (mult - 1) * periodDuration; 3.3.6
                                    time = time - (mult - 1) * periodDuration + AmCharts.getPeriodDuration("DD", 3); // add extra 3 days, as month length is not equal and might remove too much sometimes
                                    time = AmCharts.resetDateToMin(new Date(time), period, 1).getTime(); // this is new (3.3.7), as we add 3 days above
                                    deltaTime += periodDuration;
                                }
                            }

                            coord = (time - _this.startTime) * _this.stepWidth;

                            biggerPeriodChanged = false;

                            if (_this.nextPeriod[periodReal]) {
                                biggerPeriodChanged = _this.checkPeriodChange(_this.nextPeriod[periodReal], 1, time, previousTime, periodReal);
                            }

                            bold = false;

                            if (biggerPeriodChanged && _this.markPeriodChange) {
                                dateFormat = _this.dateFormatsObject[_this.nextPeriod[periodReal]];

                                if(_this.twoLineMode){
                                    dateFormat =  _this.dateFormatsObject[periodReal] + "\n" + dateFormat;
                                    dateFormat = AmCharts.fixBrakes(dateFormat);
                                }
                                bold = true;
                            } else {
                                dateFormat = _this.dateFormatsObject[periodReal];
                            }

                            if (!boldPeriodBeginning) {
                                bold = false;
                            }

                            valueText = AmCharts.formatDate(new Date(time), dateFormat);

                            if ((i == start && !showFirstLabel) || (i == gridCount && !showLastLabel)) {
                                valueText = " ";
                            }

                            if (_this.labelFunction) {
                                valueText = _this.labelFunction(valueText, new Date(time), this, period, periodMultiplier, previousTimeReal).toString();
                            }

                            // draw grid
                            axisItem = new _this.axisItemRenderer(this, coord, valueText, false, periodWidth, 0, false, bold);
                            _this.pushAxisItem(axisItem);

                            previousTime = time;
                            previousTimeReal = time;

                            // minor grid
                            if (!isNaN(minorGridFrequency)) {
                                for (var g = 1; g < periodMultiplier; g = g + minorGridFrequency) {
                                    _this.gridAlpha = _this.minorGridAlpha;
                                    //var mtime = time + minorPeriodDuration * (g + 0.1 + Math.floor((startTime - initialTime) / minorPeriodDuration));
                                    var mtime = time + minorPeriodDuration * g;
                                    mtime = AmCharts.resetDateToMin(new Date(mtime), period, minorGridFrequency, firstDayOfWeek).getTime();
                                    var mcoord = (mtime - _this.startTime) * _this.stepWidth;
                                    mAxisItem = new _this.axisItemRenderer(this, mcoord);
                                    _this.pushAxisItem(mAxisItem);
                                }
                            }
                            _this.gridAlpha = gridAlphaReal;
                       // }
                    }
                }
            }
            // DO NOT PARSE DATES
            else if (!_this.parseDates) {
                _this.cellWidth = _this.getStepWidth(valueCount);

                // in case there are more values when gridlines, fix the gridCount
                if (valueCount < gridCount) {
                    gridCount = valueCount;
                }

                startFrom += _this.start;

                _this.stepWidth = _this.getStepWidth(valueCount);

                if (gridCount > 0) {
                    var gridFrequency = Math.floor(valueCount / gridCount);
                    minorGridFrequency = _this.chooseMinorFrequency(gridFrequency);

                    realStartFrom = startFrom;
                    if (realStartFrom / 2 == Math.round(realStartFrom / 2)) {
                        realStartFrom--;
                    }

                    if (realStartFrom < 0) {
                        realStartFrom = 0;
                    }

                    var realCount = 0;

                    if(_this.end - realStartFrom + 1 >= _this.autoRotateCount){
                        _this.labelRotation = _this.autoRotateAngle;
                    }

                    for (i = realStartFrom; i <= _this.end + 2; i++) {
                        var sDataItem;
                        var forceShow = false;
                        if (i >= 0 && i < _this.data.length) {
                            sDataItem = _this.data[i];
                            valueText = sDataItem.category;
                            forceShow = sDataItem.forceShow;
                        } else {
                            valueText = "";
                        }

                        if (minorGridEnabled && !isNaN(minorGridFrequency)) {
                            if (i / minorGridFrequency != Math.round(i / minorGridFrequency) && !forceShow) {
                                continue;
                            } else {
                                if (i / gridFrequency == Math.round(i / gridFrequency) || forceShow) {

                                } else {
                                    _this.gridAlpha = _this.minorGridAlpha;
                                    valueText = UNDEFINED;
                                }
                            }
                        } else {
                            if (i / gridFrequency != Math.round(i / gridFrequency) && !forceShow) {
                                continue;
                            }
                        }

                        coord = _this.getCoordinate(i - startFrom);
                        var vShift = 0;
                        if (_this.gridPosition == "start") {
                            coord = coord - _this.cellWidth / 2;
                            vShift = _this.cellWidth / 2;
                        }

                        if ((i == start && !showFirstLabel) || (i == _this.end && !showLastLabel)) {
                            valueText = UNDEFINED;
                        }

                        if (Math.round(realCount / labelFrequency) != realCount / labelFrequency) {
                            valueText = UNDEFINED;
                        }

                        realCount++;

                        var cellW = _this.cellWidth;
                        if (rotate) {
                            cellW = NaN;
                        }

                        if (_this.labelFunction && sDataItem) {
                            valueText = _this.labelFunction(valueText, sDataItem, this);
                        }
                        valueText = AmCharts.fixBrakes(valueText);

                        axisItem = new _this.axisItemRenderer(this, coord, valueText, true, cellW, vShift, UNDEFINED, false, vShift);
                        _this.pushAxisItem(axisItem);
                        _this.gridAlpha = gridAlphaReal;
                    }
                }
            }

            // PARSE, BUT EQUAL SPACING
            else if (_this.parseDates && _this.equalSpacing) {
                startFrom = _this.start;
                _this.startTime = _this.data[_this.start].time;
                _this.endTime = _this.data[_this.end].time;

                _this.timeDifference = _this.endTime - _this.startTime;

                periodObj = _this.choosePeriod(0);
                period = periodObj.period;
                periodMultiplier = periodObj.count;
                periodDuration = AmCharts.getPeriodDuration(period, periodMultiplier);

                // check if this period is not shorter then minPeriod
                if (periodDuration < minDuration) {
                    period = minPeriodObj.period;
                    periodMultiplier = minPeriodObj.count;
                    periodDuration = minDuration;
                }

                periodReal = period;
                // weeks don't have format, swith to days
                if (periodReal == "WW") {
                    periodReal = "DD";
                }

                _this.stepWidth = _this.getStepWidth(valueCount);

                gridCount = Math.ceil(_this.timeDifference / periodDuration) + 1;

                previousTime = AmCharts.resetDateToMin(new Date(_this.startTime - periodDuration), period, periodMultiplier, firstDayOfWeek).getTime();

                _this.cellWidth = _this.getStepWidth(valueCount);

                periodCount = Math.round(previousTime / periodDuration);

                start = -1;
                if (periodCount / 2 == Math.round(periodCount / 2)) {
                    start = -2;
                    previousTime -= periodDuration;
                }

                var lastIndex = _this.data.length;

                realStartFrom = _this.start;

                if (realStartFrom / 2 == Math.round(realStartFrom / 2)) {
                    realStartFrom--;
                }

                if (realStartFrom < 0) {
                    realStartFrom = 0;
                }

                var realEnd = _this.end + 2;
                if (realEnd >= _this.data.length) {
                    realEnd = _this.data.length;
                }

                // first must be skipped if more data items then gridcount
                var thisIsFirst = false;

                thisIsFirst = !showFirstLabel;

                _this.previousPos = -1000;

                if (_this.labelRotation > 20) {
                    _this.safeDistance = 5;
                }

                var realRealStartFrom = realStartFrom;
                // find second period change to avoid small gap between first label and the second
                if (_this.data[realStartFrom].time != AmCharts.resetDateToMin(new Date(_this.data[realStartFrom].time), period, periodMultiplier, firstDayOfWeek).getTime()) {
                    var cc = 0;
                    var tempPreviousTime = previousTime;
                    for (i = realStartFrom; i < realEnd; i++) {
                        time = _this.data[i].time;

                        if (_this.checkPeriodChange(period, periodMultiplier, time, tempPreviousTime)) {
                            cc++;
                            if (cc >= 2) {
                                realRealStartFrom = i;
                                i = realEnd;
                            }
                            tempPreviousTime = time;
                        }
                    }
                }

                if (minorGridEnabled && periodMultiplier > 1) {
                    minorGridFrequency = _this.chooseMinorFrequency(periodMultiplier);
                    minorPeriodDuration = AmCharts.getPeriodDuration(period, minorGridFrequency);
                }

                var previousMinorTime;

                for (i = realStartFrom; i < realEnd; i++) {
                    time = _this.data[i].time;

                    if (_this.checkPeriodChange(period, periodMultiplier, time, previousTime) && i >= realRealStartFrom) {

                        coord = _this.getCoordinate(i - _this.start);

                        biggerPeriodChanged = false;
                        if (_this.nextPeriod[periodReal]) {
                            biggerPeriodChanged = _this.checkPeriodChange(_this.nextPeriod[periodReal], 1, time, previousTime, periodReal);
                        }

                        bold = false;
                        if (biggerPeriodChanged && _this.markPeriodChange) {
                            dateFormat = _this.dateFormatsObject[_this.nextPeriod[periodReal]];
                            bold = true;
                        } else {
                            dateFormat = _this.dateFormatsObject[periodReal];
                        }

                        valueText = AmCharts.formatDate(new Date(time), dateFormat);

                        if ((i == start && !showFirstLabel) || (i == gridCount && !showLastLabel)) {
                            valueText = " ";
                        }

                        if (!thisIsFirst) {
                            if (!boldPeriodBeginning) {
                                bold = false;
                            }

                            // draw grid
                            if (coord - _this.previousPos > _this.safeDistance * Math.cos(_this.labelRotation * Math.PI / 180)) {

                                if (_this.labelFunction) {
                                    valueText = _this.labelFunction(valueText, new Date(time), this, period, periodMultiplier, previousTimeReal);
                                }

                                axisItem = new _this.axisItemRenderer(this, coord, valueText, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, bold);

                                var axisItemGraphics = axisItem.graphics();
                                _this.pushAxisItem(axisItem);
                                var graphicsWidth = axisItemGraphics.getBBox().width;
                                if (!AmCharts.isModern) {
                                    graphicsWidth -= coord;
                                }
                                _this.previousPos = coord + graphicsWidth;


                            }
                        } else {
                            thisIsFirst = false;
                        }

                        previousTime = time;
                        previousTimeReal = time;
                    } else {
                        // minor grid
                        if (!isNaN(minorGridFrequency)) {
                            if (_this.checkPeriodChange(period, minorGridFrequency, time, previousMinorTime)) {
                                _this.gridAlpha = _this.minorGridAlpha;
                                coord = _this.getCoordinate(i - _this.start);
                                mAxisItem = new _this.axisItemRenderer(this, coord);
                                _this.pushAxisItem(mAxisItem);
                                previousMinorTime = time;
                            }
                            _this.gridAlpha = gridAlphaReal;
                        }
                    }
                }
            }

            // get x's of all categories
            for (i = 0; i < _this.data.length; i++) {
                var serialDataItem = _this.data[i];
                if (serialDataItem) {
                    var xxx;
                    if (_this.parseDates && !_this.equalSpacing) {
                        var categoryTime = serialDataItem.time;
                        xxx = Math.round((categoryTime - _this.startTime) * _this.stepWidth + _this.cellWidth / 2);
                    } else {
                        xxx = _this.getCoordinate(i - startFrom);
                    }

                    serialDataItem.x[_this.id] = xxx;
                }
            }
            // guides
            var count = _this.guides.length;

            for (i = 0; i < count; i++) {
                var guide = _this.guides[i];
                var guideToCoord = NaN;
                var guideCoord = NaN;
                var valueShift = NaN;
                var toCategoryIndex = NaN;
                var categoryIndex = NaN;
                var above = guide.above;

                if (guide.toCategory) {
                    toCategoryIndex = chart.getCategoryIndexByValue(guide.toCategory);
                    if (!isNaN(toCategoryIndex)) {
                        guideToCoord = _this.getCoordinate(toCategoryIndex - startFrom);
                        axisItem = new _this.axisItemRenderer(this, guideToCoord, "", true, NaN, NaN, guide);
                        _this.pushAxisItem(axisItem, above);
                    }
                }

                if (guide.category) {
                    categoryIndex = chart.getCategoryIndexByValue(guide.category);
                    if (!isNaN(categoryIndex)) {
                        guideCoord = _this.getCoordinate(categoryIndex - startFrom);
                        valueShift = (guideToCoord - guideCoord) / 2;
                        axisItem = new _this.axisItemRenderer(this, guideCoord, guide.label, true, NaN, valueShift, guide);
                        _this.pushAxisItem(axisItem, above);
                    }
                }

                if (guide.toDate) {

                    if(!(guide.toDate instanceof Date)){
                        guide.toDate = AmCharts.stringToDate(guide.toDate, chart.dataDateFormat);
                    }

                    if (_this.equalSpacing) {
                        toCategoryIndex = chart.getClosestIndex(_this.data, "time", guide.toDate.getTime(), false, 0, _this.data.length - 1);
                        if (!isNaN(toCategoryIndex)) {
                            guideToCoord = _this.getCoordinate(toCategoryIndex - startFrom);
                        }
                    } else {
                        guideToCoord = (guide.toDate.getTime() - _this.startTime) * _this.stepWidth;
                    }
                    axisItem = new _this.axisItemRenderer(this, guideToCoord, "", true, NaN, NaN, guide);
                    _this.pushAxisItem(axisItem, above);
                }

                if (guide.date) {
                    if(!(guide.date instanceof Date)){
                        guide.date = AmCharts.stringToDate(guide.date, chart.dataDateFormat);
                    }
                    if (_this.equalSpacing) {
                        categoryIndex = chart.getClosestIndex(_this.data, "time", guide.date.getTime(), false, 0, _this.data.length - 1);
                        if (!isNaN(categoryIndex)) {
                            guideCoord = _this.getCoordinate(categoryIndex - startFrom);
                        }
                    } else {
                        guideCoord = (guide.date.getTime() - _this.startTime) * _this.stepWidth;
                    }

                    valueShift = (guideToCoord - guideCoord) / 2;

                    if (_this.orientation == "H") {
                        axisItem = new _this.axisItemRenderer(this, guideCoord, guide.label, false, valueShift * 2, NaN, guide);
                    } else {
                        axisItem = new _this.axisItemRenderer(this, guideCoord, guide.label, false, NaN, valueShift, guide);
                    }
                    _this.pushAxisItem(axisItem, above);
                }

                var guideFill = new _this.guideFillRenderer(this, guideCoord, guideToCoord, guide);
                var guideFillGraphics = guideFill.graphics();
                _this.pushAxisItem(guideFill, above);
                guide.graphics = guideFillGraphics;
                guideFillGraphics.index = i;

                if (guide.balloonText) {
                    _this.addEventListeners(guideFillGraphics, guide);
                }
            }
        }

        _this.axisCreated = true;

        var xx = _this.x;
        var yy = _this.y;
        _this.set.translate(xx, yy);
        _this.labelsSet.translate(xx, yy);
        _this.positionTitle();
        var axisLine = _this.axisLine.set;
        if (axisLine) {
            axisLine.toFront();
        }

        var currentHeight = _this.getBBox().height;
        if((currentHeight - _this.previousHeight) > 2 && _this.autoWrap && !_this.parseDates){
            _this.chart.marginsUpdated = false;
            _this.axisCreated = false;
        }
        _this.previousHeight = currentHeight;
    },

    chooseMinorFrequency: function(frequency) {
        for (var i = 10; i > 0; i--) {
            if (frequency / i == Math.round(frequency / i)) {
                return frequency / i;
            }
        }
    },


    choosePeriod: function(index) {
        var _this = this;
        var periodDuration = AmCharts.getPeriodDuration(_this.periods[index].period, _this.periods[index].count);
        var count = Math.ceil(_this.timeDifference / periodDuration);
        var periods = _this.periods;

        var gridCount = _this.gridCountR;
        if (_this.timeDifference < periodDuration && index > 0) {
            return periods[index - 1];
        }

        if (count <= gridCount) {
            return periods[index];
        } else {
            if (index + 1 < periods.length) {
                return _this.choosePeriod(index + 1);
            } else {
                return periods[index];
            }
        }
    },

    getStepWidth: function(valueCount) {
        var _this = this;
        var stepWidth;
        if (_this.startOnAxis) {
            stepWidth = _this.axisWidth / (valueCount - 1);

            if (valueCount == 1) {
                stepWidth = _this.axisWidth;
            }
        } else {
            stepWidth = _this.axisWidth / valueCount;
        }
        return stepWidth;
    },

    getCoordinate: function(index) {
        var _this = this;
        var coord = index * _this.stepWidth;

        if (!_this.startOnAxis) {
            coord += _this.stepWidth / 2;
        }

        return Math.round(coord);
    },

    timeZoom: function(startTime, endTime) {
        var _this = this;
        _this.startTime = startTime;
        _this.endTime = endTime;
    },

    minDuration: function() {
        var _this = this;
        var minPeriodObj = AmCharts.extractPeriod(_this.minPeriod);
        return AmCharts.getPeriodDuration(minPeriodObj.period, minPeriodObj.count);
    },

    checkPeriodChange: function(period, count, time, previousTime, previousPeriod) {
        var currentDate = new Date(time);
        var previousDate = new Date(previousTime);

        var firstDayOfWeek = this.firstDayOfWeek;
        var realCount = count;
        if (period == "DD") {
            count = 1;
        }

        var current = AmCharts.resetDateToMin(currentDate, period, count, firstDayOfWeek).getTime();
        var previous = AmCharts.resetDateToMin(previousDate, period, count, firstDayOfWeek).getTime();

        if (period == "DD" && previousPeriod != "hh") {
            if (current - previous <= AmCharts.getPeriodDuration(period, realCount)) {
                return false;
            }
        }

        if (current != previous) {
            return true;
        } else {
            return false;
        }
    },


    generateDFObject: function() {
        var _this = this;
        _this.dateFormatsObject = {};
        var i;
        for (i = 0; i < _this.dateFormats.length; i++) {
            var df = _this.dateFormats[i];
            _this.dateFormatsObject[df.period] = df.format;
        }
    },


    xToIndex: function(x) {
        var _this = this;
        var data = _this.data;
        var chart = _this.chart;
        var rotate = chart.rotate;
        var stepWidth = _this.stepWidth;
        var index;
        if (_this.parseDates && !_this.equalSpacing) {
            var time = _this.startTime + Math.round(x / stepWidth) - _this.minDuration() / 2;
            index = chart.getClosestIndex(data, "time", time, false, _this.start, _this.end + 1);
        } else {
            if (!_this.startOnAxis) {
                x -= stepWidth / 2;
            }
            index = _this.start + Math.round(x / stepWidth);
        }

        index = AmCharts.fitToBounds(index, 0, data.length - 1);

        var indexX;
        if (data[index]) {
            indexX = data[index].x[_this.id];
        }

        if (rotate) {
            if (indexX > _this.height + 1) {
                index--;
            }
            if (indexX < 0) {
                index++;
            }
        } else {
            if (indexX > _this.width + 1) {
                index--;
            }
            if (indexX < 0) {
                index++;
            }
        }

        index = AmCharts.fitToBounds(index, 0, data.length - 1);

        return index;
    },

    dateToCoordinate: function(date) {
        var _this = this;
        if (_this.parseDates && !_this.equalSpacing) {
            return (date.getTime() - _this.startTime) * _this.stepWidth;
        } else if (_this.parseDates && _this.equalSpacing) {
            var index = _this.chart.getClosestIndex(_this.data, "time", date.getTime(), false, 0, _this.data.length - 1);
            return _this.getCoordinate(index - _this.start);
        } else {
            return NaN;
        }
    },

    categoryToCoordinate: function(category) {
        var _this = this;
        if (_this.chart) {
            var index = _this.chart.getCategoryIndexByValue(category);
            return _this.getCoordinate(index - _this.start);
        } else {
            return NaN;
        }
    },

    coordinateToDate: function(coordinate) {
        var _this = this;
        if (_this.equalSpacing) {
            var index = _this.xToIndex(coordinate);
            return new Date(_this.data[index].time);
        } else {
            return new Date(_this.startTime + coordinate / _this.stepWidth);
        }
    }
});

// @tag amchart
AmCharts.GaugeArrow = AmCharts.Class({

    construct: function (theme) {
        var _this = this;
        _this.cname = "GaugeArrow";
        _this.color = "#000000";
        _this.alpha = 1;
        _this.nailAlpha = 1;
        _this.nailRadius = 8;
        _this.startWidth = 8;
        _this.endWidth = 0;
        _this.borderAlpha = 1;
        _this.radius = "90%";
        _this.innerRadius = 0;
        _this.nailBorderAlpha = 0;
        _this.nailBorderThickness = 1;
        _this.frame = 0;

        AmCharts.applyTheme(_this, theme, "GaugeArrow");
    },

    setValue: function (value) {
        var _this = this;
        var chart = _this.chart;
        if(!chart){
            _this.value = value;
            _this.previousValue = value;
        }
        else{
            chart.setValue(this, value);
        }
    }

});

AmCharts.GaugeBand = AmCharts.Class({
    construct: function () {
        var _this = this;
        _this.cname = "GaugeBand";
    }

});

// @tag amchart
AmCharts.GaugeAxis = AmCharts.Class({

    construct: function (theme) {
        var _this = this;
        _this.cname = "GaugeAxis";
        _this.radius = "95%";
        _this.startAngle = -120;
        _this.endAngle = 120;
        _this.startValue = 0;
        _this.endValue = 200;
        _this.gridCount = 5;
        //_this.valueInterval;
        //_this.minorTickInterval;
        _this.tickLength = 10;
        _this.minorTickLength = 5;
        _this.tickColor = "#555555";
        _this.tickAlpha = 1;
        _this.tickThickness = 1;
        _this.labelFrequency = 1;
        _this.inside = true;
        _this.labelOffset = 10;
        _this.showFirstLabel = true;
        _this.showLastLabel = true;
        _this.axisThickness = 1;
        _this.axisColor = '#000000';
        _this.axisAlpha = 1;
        _this.gridInside = true;
        //_this.topText = "";
        //_this.topTextFontSize;
        //_this.topTextColor;
        _this.topTextYOffset = 0;
        _this.topTextBold = true;

        //_this.bottomText = "";
        //_this.bottomTextFontSize;
        // _this.bottomTextColor
        _this.bottomTextYOffset = 0;
        _this.bottomTextBold = true;
        _this.centerX = "0%";
        _this.centerY = "0%";

        _this.bandOutlineThickness = 0;
        _this.bandOutlineAlpha = 0;
        _this.bandOutlineColor = "#000000";
        _this.bandAlpha = 1;

        AmCharts.applyTheme(_this, theme, "GaugeAxis");
    },

    value2angle: function (value) {
        var _this = this;
        return _this.startAngle + _this.singleValueAngle * value;
    },

    setTopText: function (text) {
        if(text !== undefined){
            var _this = this;
            _this.topText = text;
            var chart = _this.chart;
            if (_this.axisCreated) {

                if (_this.topTF) {
                    _this.topTF.remove();
                }

                var fontSize = _this.topTextFontSize;
                if(!fontSize){
                    fontSize = chart.fontSize;
                }

                var textColor = _this.topTextColor;
                if(!textColor){
                    textColor = chart.color;
                }

                var topTextField = AmCharts.text(chart.container, text, textColor, chart.fontFamily, fontSize, undefined, _this.topTextBold);
                topTextField.translate(_this.centerXReal, _this.centerYReal - _this.radiusReal / 2 + _this.topTextYOffset);
                _this.chart.graphsSet.push(topTextField);
                _this.topTF = topTextField;
            }
        }
    },

    setBottomText: function (text) {
        if(text !== undefined){
            var _this = this;
            _this.bottomText = text;
            var chart = _this.chart;
            if (_this.axisCreated) {

                if (_this.bottomTF) {
                    _this.bottomTF.remove();
                }

                var fontSize = _this.bottomTextFontSize;
                if(!fontSize){
                    fontSize = chart.fontSize;
                }

                var textColor = _this.bottomTextColor;
                if(!textColor){
                    textColor = chart.color;
                }

                var bottomTextField = AmCharts.text(chart.container, text, textColor, chart.fontFamily, fontSize, undefined, _this.bottomTextBold);
                bottomTextField.translate(_this.centerXReal, _this.centerYReal + _this.radiusReal / 2 + _this.bottomTextYOffset);
                _this.bottomTF = bottomTextField;
                _this.chart.graphsSet.push(bottomTextField);
            }
        }
    },

    draw: function () {
        var _this = this;

        var chart = _this.chart;
        var set = chart.graphsSet;

        var UNDEFINED;
        var startValue = _this.startValue;
        var endValue = _this.endValue;

        var valueInterval = _this.valueInterval;

        if(isNaN(valueInterval)){
            var dif = endValue - startValue;
            valueInterval = dif / _this.gridCount;
        }

        var minorTickInterval = _this.minorTickInterval;

        if(isNaN(minorTickInterval)){
            minorTickInterval = valueInterval / 5;
        }

        var startAngle = _this.startAngle;

        var endAngle = _this.endAngle;

        var tickLength = _this.tickLength;

        var majorTickCount = (endValue - startValue) / valueInterval + 1;

        var valueAngle = (endAngle - startAngle) / (majorTickCount - 1);

        var singleValueAngle = valueAngle / valueInterval;

        _this.singleValueAngle = singleValueAngle;

        var container = chart.container;
        var tickColor = _this.tickColor;
        var tickAlpha = _this.tickAlpha;
        var tickThickness = _this.tickThickness;


        var minorTickCount = valueInterval / minorTickInterval;
        var minorValueAngle = valueAngle / minorTickCount;
        var minorTickLength = _this.minorTickLength;
        var labelFrequency = _this.labelFrequency;
        var radius = _this.radiusReal;

        if (!_this.inside) {
            radius -= 15;
        }

        var centerX = chart.centerX + AmCharts.toCoordinate(_this.centerX, chart.realWidth);
        var centerY = chart.centerY + AmCharts.toCoordinate(_this.centerY, chart.realHeight);

        _this.centerXReal = centerX;
        _this.centerYReal = centerY;

        // axis

        var axisAttr = {
            'fill': _this.axisColor,
                'fill-opacity': _this.axisAlpha,
                'stroke-width': 0,
                'stroke-opacity': 0
        };

        var axisRadius;
        var minorTickRadius;
        if (_this.gridInside) {
            axisRadius = radius;
            minorTickRadius = radius;
        } else {
            axisRadius = radius - tickLength;
            minorTickRadius = axisRadius + minorTickLength;
        }

        var axisThickness = _this.axisThickness / 2;
        var axis = AmCharts.wedge(container, centerX, centerY, startAngle, endAngle - startAngle, axisRadius + axisThickness, axisRadius + axisThickness, axisRadius - axisThickness, 0, axisAttr);
        set.push(axis);

        var round = AmCharts.doNothing;
        if (!AmCharts.isModern) {
            round = Math.round;
        }

        var decCount = AmCharts.getDecimals(valueInterval);

        for (var i = 0; i < majorTickCount; i++) {
            // MAJOR TICKS
            var value = startValue + i * valueInterval;
            var angle = startAngle + i * valueAngle;

            var xx1 = round(centerX + radius * Math.sin((angle) / (180) * Math.PI));
            var yy1 = round(centerY - radius * Math.cos((angle) / (180) * Math.PI));

            var xx2 = round(centerX + (radius - tickLength) * Math.sin((angle) / (180) * Math.PI));
            var yy2 = round(centerY - (radius - tickLength) * Math.cos((angle) / (180) * Math.PI));

            var line = AmCharts.line(container, [xx1, xx2], [yy1, yy2], tickColor, tickAlpha, tickThickness, 0, false, false, true);
            set.push(line);
            var sign = -1;
            var dx = _this.labelOffset;
            if (!_this.inside) {
                dx = -dx - tickLength;
                sign = 1;
            }

            var sin = Math.sin((angle) / (180) * Math.PI);
            var cos = Math.cos((angle) / (180) * Math.PI);
            var lx = centerX + (radius - tickLength - dx) * sin;
            var ly = centerY - (radius - tickLength - dx) * cos;

            var fontSize = _this.fontSize;
            if (isNaN(fontSize)) {
                fontSize = chart.fontSize;
            }

            var lsin = Math.sin((angle - 90) / (180) * Math.PI);
            var lcos = Math.cos((angle - 90) / (180) * Math.PI);

            // LABELS
            if (labelFrequency > 0) {
                if (i / labelFrequency == Math.round(i / labelFrequency)) {
                    if ((!_this.showLastLabel && i == majorTickCount - 1) || (!_this.showFirstLabel && i === 0)) {

                    } else {
                        var valueTxt = AmCharts.formatNumber(value, chart.nf, decCount);

                        var unit = _this.unit;
                        if (unit) {
                            if (_this.unitPosition == "left") {
                                valueTxt = unit + valueTxt;
                            } else {
                                valueTxt = valueTxt + unit;
                            }
                        }

                        var label = AmCharts.text(container, valueTxt, chart.color, chart.fontFamily, fontSize);
                        var labelBBox = label.getBBox();
                        label.translate(lx + sign * labelBBox.width / 2 * lcos, ly + sign * labelBBox.height / 2 * lsin);
                        set.push(label);
                    }
                }
            }

            // MINOR TICKS
            if (i < majorTickCount - 1) {
                for (var m = 1; m < minorTickCount; m++) {
                    var mAngle = angle + minorValueAngle * m;

                    var mxx1 = round(centerX + minorTickRadius * Math.sin((mAngle) / (180) * Math.PI));
                    var myy1 = round(centerY - minorTickRadius * Math.cos((mAngle) / (180) * Math.PI));

                    var mxx2 = round(centerX + (minorTickRadius - minorTickLength) * Math.sin((mAngle) / (180) * Math.PI));
                    var myy2 = round(centerY - (minorTickRadius - minorTickLength) * Math.cos((mAngle) / (180) * Math.PI));

                    var mLine = AmCharts.line(container, [mxx1, mxx2], [myy1, myy2], tickColor, tickAlpha, tickThickness, 0, false, false, true);
                    set.push(mLine);
                }
            }
        }

        // BANDS
        var bands = _this.bands;
        if (bands) {
            for (var b = 0; b < bands.length; b++) {
                var band = bands[b];
                if (band) {
                    var bandStartValue = band.startValue;
                    var bandEndValue = band.endValue;
                    var bandRadius = AmCharts.toCoordinate(band.radius, radius);

                    if (isNaN(bandRadius)) {
                        bandRadius = minorTickRadius;
                    }

                    var bandInnerRadius = AmCharts.toCoordinate(band.innerRadius, radius);
                    if (isNaN(bandInnerRadius)) {
                        bandInnerRadius = bandRadius - minorTickLength;
                    }

                    var bandStartAngle = startAngle + singleValueAngle * (bandStartValue - _this.startValue);

                    var bandArc = singleValueAngle * (bandEndValue - bandStartValue);

                    var outlineColor = band.outlineColor;
                    if (outlineColor == UNDEFINED) {
                        outlineColor = _this.bandOutlineColor;
                    }

                    var outlineThickness = band.outlineThickness;
                    if (isNaN(outlineThickness)) {
                        outlineThickness = _this.bandOutlineThickness;
                    }

                    var outlineAlpha = band.outlineAlpha;
                    if (isNaN(outlineAlpha)) {
                        outlineAlpha = _this.bandOutlineAlpha;
                    }

                    var bandAlpha = band.alpha;
                    if (isNaN(bandAlpha)) {
                        bandAlpha = _this.bandAlpha;
                    }

                    var attr = {
                        'fill': band.color,
                            'stroke': outlineColor,
                            'stroke-width': outlineThickness,
                            'stroke-opacity': outlineAlpha
                    };

                    var bandGraphics = AmCharts.wedge(container, centerX, centerY, bandStartAngle, bandArc, bandRadius, bandRadius, bandInnerRadius, 0, attr);
                    bandGraphics.setAttr('opacity', bandAlpha);
                    chart.gridSet.push(bandGraphics);
                }
            }
        }
        _this.axisCreated = true;
        _this.setTopText(_this.topText);
        _this.setBottomText(_this.bottomText);
        var bbox = chart.graphsSet.getBBox();
        _this.width = bbox.width;
        _this.height = bbox.height;
    }
});


// @tag amchart
AmCharts.RadAxis = AmCharts.Class({

    construct: function (axis) {
        var _this = this;
        var chart = axis.chart;
        var t = axis.axisThickness;
        var c = axis.axisColor;
        var a = axis.axisAlpha;
        var l = axis.tickLength;
        var x = axis.x;
        var y = axis.y;
        var UNDEFINED;

        _this.set = chart.container.set();
        chart.axesSet.push(_this.set);

        var labelsEnabled = axis.labelsEnabled;
        var axisTitleOffset = axis.axisTitleOffset;
        var radarCategoriesEnabled = axis.radarCategoriesEnabled;

        var fontFamily = axis.chart.fontFamily;
        var textSize = axis.fontSize;

        if (textSize === UNDEFINED) {
            textSize = axis.chart.fontSize;
        }

        var color = axis.color;
        if (color === UNDEFINED) {
            color = axis.chart.color;
        }

        if (chart) {
            _this.axisWidth = axis.height;
            var dataProvider = chart.chartData;
            var count = dataProvider.length;
            var i;

            for (i = 0; i < count; i++) {
                var angle = 180 - 360 / count * i;
                var xx = x + _this.axisWidth * Math.sin((angle) / (180) * Math.PI);
                var yy = y + _this.axisWidth * Math.cos((angle) / (180) * Math.PI);
                if (a > 0) {
                    var line = AmCharts.line(chart.container, [x, xx], [y, yy], c, a, t);
                    _this.set.push(line);
                }

                // label
                if (radarCategoriesEnabled) {
                    var align = "start";
                    var labelX = x + (_this.axisWidth + axisTitleOffset) * Math.sin((angle) / (180) * Math.PI);
                    var labelY = y + (_this.axisWidth + axisTitleOffset) * Math.cos((angle) / (180) * Math.PI);

                    if (angle == 180 || angle === 0) {
                        align = "middle";
                        labelX = labelX - 5;
                    }
                    if (angle < 0) {
                        align = "end";
                        labelX = labelX - 10;
                    }

                    if (angle == 180) {
                        labelY -= 5;
                    }

                    if (angle === 0) {
                        labelY += 5;
                    }

                    var titleTF = AmCharts.text(chart.container, dataProvider[i].category, color, fontFamily, textSize, align);
                    titleTF.translate(labelX + 5, labelY);
                    _this.set.push(titleTF);

                    var bbox = titleTF.getBBox();
                }
            }
        }
    }
});

// @tag amchart
AmCharts.RadarFill = AmCharts.Class({

    construct: function (axis, guideCoord, guideToCoord, guide) {

        guideCoord = guideCoord - axis.axisWidth;
        guideToCoord = guideToCoord - axis.axisWidth;

        var guideToCoordReal = Math.max(guideCoord, guideToCoord);
        var guideCoordReal = Math.min(guideCoord, guideToCoord);

        guideToCoord = guideToCoordReal;
        guideCoord = guideCoordReal;

        var _this = this;
        var chart = axis.chart;
        var container = chart.container;
        var fillAlpha = guide.fillAlpha;
        var fillColor = guide.fillColor;

        var radius = Math.abs(guideToCoord - axis.y);
        var innerRadius = Math.abs(guideCoord - axis.y);

        var radiusReal = Math.max(radius, innerRadius);
        var innerRadiusReal = Math.min(radius, innerRadius);

        radius = radiusReal;
        innerRadius = innerRadiusReal;

        var angle = guide.angle + 90;
        var toAngle = guide.toAngle + 90;
        if (isNaN(angle)) {
            angle = 0;
        }
        if (isNaN(toAngle)) {
            toAngle = 360;
        }

        _this.set = container.set();

        if (fillColor === undefined) {
            fillColor = "#000000";
        }

        if (isNaN(fillAlpha)) {
            fillAlpha = 0;
        }

        if (axis.gridType == "polygons") {
            var xx = [];
            var yy = [];

            var count = axis.data.length;

            var i;
            for (i = 0; i < count; i++) {
                angle = 180 - 360 / count * i;
                xx.push(radius * Math.sin((angle) / (180) * Math.PI));
                yy.push(radius * Math.cos((angle) / (180) * Math.PI));
            }
            xx.push(xx[0]);
            yy.push(yy[0]);

            for (i = count; i >= 0; i--) {
                angle = 180 - 360 / count * i;
                xx.push(innerRadius * Math.sin((angle) / (180) * Math.PI));
                yy.push(innerRadius * Math.cos((angle) / (180) * Math.PI));
            }

            _this.fill = AmCharts.polygon(container, xx, yy, fillColor, fillAlpha);
        } else {
            _this.fill = AmCharts.wedge(container, 0, 0, angle, (toAngle - angle), radius, radius, innerRadius, 0, {
                'fill': fillColor,
                    'fill-opacity': fillAlpha,
                    'stroke': "#000",
                    'stroke-opacity': 0,
                    'stroke-width': 1
            });
        }

        _this.set.push(_this.fill);
        _this.fill.translate(axis.x, axis.y);
    },

    graphics: function () {
        return this.set;
    },

    getLabel: function () {

    }

});

// @tag amchart
AmCharts.RadItem = AmCharts.Class({

    construct: function (axis, coord, value, below, textWidth, valueShift, guide) {
        var _this = this;
        var UNDEFINED;

        if (value === UNDEFINED) {
            value = "";
        }

        var fontFamily = axis.chart.fontFamily;
        var textSize = axis.fontSize;

        if (textSize === UNDEFINED) {
            textSize = axis.chart.fontSize;
        }

        var color = axis.color;
        if (color === UNDEFINED) {
            color = axis.chart.color;
        }

        var container = axis.chart.container;
        var set = container.set();
        _this.set = set;

        var vCompensation = 3;
        var hCompensation = 4;
        var axisThickness = axis.axisThickness;
        var axisColor = axis.axisColor;
        var axisAlpha = axis.axisAlpha;
        var tickLength = axis.tickLength;
        var gridAlpha = axis.gridAlpha;
        var gridThickness = axis.gridThickness;
        var gridColor = axis.gridColor;
        var dashLength = axis.dashLength;
        var fillColor = axis.fillColor;
        var fillAlpha = axis.fillAlpha;
        var labelsEnabled = axis.labelsEnabled;
        var labelRotation = axis.labelRotation;
        var counter = axis.counter;
        var labelInside = axis.inside;
        var position = axis.position;
        var previousCoord = axis.previousCoord;
        var gridType = axis.gridType;
        var i;
        var count;
        var angle;


        coord -= axis.height;
        var tick;
        var grid;

        var x = axis.x;
        var y = axis.y;
        var lx = 0;
        var ly = 0;

        if (guide) {
            labelsEnabled = true;

            if (!isNaN(guide.tickLength)) {
                tickLength = guide.tickLength;
            }

            if (guide.lineColor != UNDEFINED) {
                gridColor = guide.lineColor;
            }

            if (!isNaN(guide.lineAlpha)) {
                gridAlpha = guide.lineAlpha;
            }

            if (!isNaN(guide.dashLength)) {
                dashLength = guide.dashLength;
            }

            if (!isNaN(guide.lineThickness)) {
                gridThickness = guide.lineThickness;
            }
            if (guide.inside === true) {
                labelInside = true;
            }
        } else {
            if (!value) {
                gridAlpha = gridAlpha / 3;
                tickLength = tickLength / 2;
            }
        }

        var align = "end";
        var dir = -1;
        if (labelInside) {
            align = "start";
            dir = 1;
        }

        var valueTF;
        if (labelsEnabled) {
            valueTF = AmCharts.text(container, value, color, fontFamily, textSize, align);
            valueTF.translate(x + (tickLength + 3) * dir, coord);
            set.push(valueTF);

            _this.label = valueTF;

            tick = AmCharts.line(container, [x, x + tickLength * dir], [coord, coord], axisColor, axisAlpha, gridThickness);
            set.push(tick);
        }

        var radius = Math.round(axis.y - coord);

        // grid
        var xx = [];
        var yy = [];
        if (gridAlpha > 0) {
            if (gridType == "polygons") {

                count = axis.data.length;


                for (i = 0; i < count; i++) {
                    angle = 180 - 360 / count * i;
                    xx.push(radius * Math.sin((angle) / (180) * Math.PI));
                    yy.push(radius * Math.cos((angle) / (180) * Math.PI));
                }
                xx.push(xx[0]);
                yy.push(yy[0]);

                grid = AmCharts.line(container, xx, yy, gridColor, gridAlpha, gridThickness, dashLength);
            } else {
                grid = AmCharts.circle(container, radius, "#FFFFFF", 0, gridThickness, gridColor, gridAlpha);
            }
            grid.translate(x, y);
            set.push(grid);
        }

        if (counter == 1 && fillAlpha > 0 && !guide && value !== "") {
            var prevCoord = axis.previousCoord;
            var fill;

            if (gridType == "polygons") {
                for (i = count; i >= 0; i--) {
                    angle = 180 - 360 / count * i;
                    xx.push(prevCoord * Math.sin((angle) / (180) * Math.PI));
                    yy.push(prevCoord * Math.cos((angle) / (180) * Math.PI));
                }
                fill = AmCharts.polygon(container, xx, yy, fillColor, fillAlpha);
            } else {
                fill = AmCharts.wedge(container, 0, 0, 0, 360, radius, radius, prevCoord, 0, {
                    'fill': fillColor,
                        'fill-opacity': fillAlpha,
                        'stroke': "#000",
                        'stroke-opacity': 0,
                        'stroke-width': 1
                });
            }
            set.push(fill);
            fill.translate(x, y);
        }


        if (axis.visible === false) {
            if (tick) {
                tick.hide();
            }
            if (valueTF) {
                valueTF.hide();
            }
        }


        if (value !== "") {
            if (counter === 0) {
                axis.counter = 1;
            } else {
                axis.counter = 0;
            }
            axis.previousCoord = radius;
        }
    },

    graphics: function () {
        return this.set;
    },

    getLabel: function () {
        return this.label;
    }

});

// @tag amchart
AmCharts.RecAxis = AmCharts.Class({

    construct: function (axis) {
        var _this = this;
        var chart = axis.chart;
        var t = axis.axisThickness;
        var c = axis.axisColor;
        var a = axis.axisAlpha;
        var l = axis.tickLength;
        var o = axis.offset;
        var dx = axis.dx;
        var dy = axis.dy;

        var vx = axis.viX;
        var vy = axis.viY;
        var vh = axis.viH;
        var vw = axis.viW;

        var x;
        var y;
        var container = chart.container;

        // POSITION CONTAINERS
        // HORIZONTAL
        var line;

        if (axis.orientation == "H") {
            line = AmCharts.line(container, [0, vw], [0, 0], c, a, t);

            _this.axisWidth = axis.width;

            // BOTTOM
            if (axis.position == "bottom") {
                y = t / 2 + o + vh + vy - 1;
                x = vx;
            }
            // TOP
            else {
                y = -t / 2 - o + vy + dy;
                x = dx + vx;
            }
        }
        // VERTICAL
        else {
            _this.axisWidth = axis.height;

            // RIGHT
            if (axis.position == "right") {
                line = AmCharts.line(container, [0, 0, -dx], [0, vh, vh - dy], c, a, t);
                y = vy + dy;
                x = t / 2 + o + dx + vw + vx - 1;
            }
            // LEFT
            else {
                line = AmCharts.line(container, [0, 0], [0, vh], c, a, t);
                y = vy;
                x = -t / 2 - o + vx;
            }
        }
        line.translate(x, y);
        chart.axesSet.push(line);
        _this.set = line;
    }

});

// @tag amchart
AmCharts.RecFill = AmCharts.Class({

    construct: function (axis, guideCoord, guideToCoord, guide) {
        var _this = this;
        var dx = axis.dx;
        var dy = axis.dy;
        var orientation = axis.orientation;
        var shift = 0;

        if (guideToCoord < guideCoord) {
            var temp = guideCoord;
            guideCoord = guideToCoord;
            guideToCoord = temp;
        }

        var fillAlpha = guide.fillAlpha;
        if (isNaN(fillAlpha)) {
            fillAlpha = 0;
        }
        var container = axis.chart.container;
        var fillColor = guide.fillColor;


        if (orientation == "V") {
            guideCoord = AmCharts.fitToBounds(guideCoord, 0, axis.viH);
            guideToCoord = AmCharts.fitToBounds(guideToCoord, 0, axis.viH);
        } else {
            guideCoord = AmCharts.fitToBounds(guideCoord, 0, axis.viW);
            guideToCoord = AmCharts.fitToBounds(guideToCoord, 0, axis.viW);
        }

        var fillWidth = guideToCoord - guideCoord;

        if (isNaN(fillWidth)) {
            fillWidth = 4;
            shift = 2;
            fillAlpha = 0;
        }

        if (fillWidth < 0) {
            if (typeof (fillColor) == 'object') {
                fillColor = fillColor.join(',').split(',').reverse();
            }
        }

        var fill;

        if (orientation == "V") {
            fill = AmCharts.rect(container, axis.width, fillWidth, fillColor, fillAlpha);
            fill.translate(dx, guideCoord - shift + dy);
        } else {
            fill = AmCharts.rect(container, fillWidth, axis.height, fillColor, fillAlpha);
            fill.translate(guideCoord - shift + dx, dy);
        }
        _this.set = container.set([fill]);
    },

    graphics: function () {
        return this.set;
    },

    getLabel: function () {

    }
});

// @tag amchart
AmCharts.RecItem = AmCharts.Class({

    construct: function (axis, coord, value, below, textWidth, valueShift, guide, bold, tickShift, minor) {
        var _this = this;

        coord = Math.round(coord);
        var UNDEFINED;

        if (value == UNDEFINED) {
            value = "";
        }

        if (!tickShift) {
            tickShift = 0;
        }

        if (below == UNDEFINED) {
            below = true;
        }
        var fontFamily = axis.chart.fontFamily;
        var textSize = axis.fontSize;

        if (textSize == UNDEFINED) {
            textSize = axis.chart.fontSize;
        }

        var color = axis.color;
        if (color == UNDEFINED) {
            color = axis.chart.color;
        }

        var container = axis.chart.container;
        var set = container.set();
        _this.set = set;

        var vCompensation = 3;
        var hCompensation = 4;
        var axisThickness = axis.axisThickness;
        var axisColor = axis.axisColor;
        var axisAlpha = axis.axisAlpha;
        var tickLength = axis.tickLength;
        var gridAlpha = axis.gridAlpha;
        var gridThickness = axis.gridThickness;
        var gridColor = axis.gridColor;
        var dashLength = axis.dashLength;
        var fillColor = axis.fillColor;
        var fillAlpha = axis.fillAlpha;
        var labelsEnabled = axis.labelsEnabled;
        var labelRotation = axis.labelRotation;
        var counter = axis.counter;
        var labelInside = axis.inside;
        var dx = axis.dx;
        var dy = axis.dy;

        var orientation = axis.orientation;
        var position = axis.position;
        var previousCoord = axis.previousCoord;
        var truncate = axis.autoTruncate;

        var vh = axis.viH;
        var vw = axis.viW;
        var offset = axis.offset;

        var tick;
        var grid;
        var MIDDLE = "middle";
        var START = "start";
        var BOTTOM = "bottom";


        if (guide) {
            labelsEnabled = true;

            if (!isNaN(guide.tickLength)) {
                tickLength = guide.tickLength;
            }

            if (guide.lineColor != UNDEFINED) {
                gridColor = guide.lineColor;
            }

            if (guide.color != UNDEFINED) {
                color = guide.color;
            }

            if (!isNaN(guide.lineAlpha)) {
                gridAlpha = guide.lineAlpha;
            }

            if (!isNaN(guide.dashLength)) {
                dashLength = guide.dashLength;
            }

            if (!isNaN(guide.lineThickness)) {
                gridThickness = guide.lineThickness;
            }
            if (guide.inside === true) {
                labelInside = true;
            }

            if (!isNaN(guide.labelRotation)) {
                labelRotation = guide.labelRotation;
            }
            if (!isNaN(guide.fontSize)) {
                textSize = guide.fontSize;
            }

            if (guide.position) {
                position = guide.position;
            }
        } else {
            if (value === "") {
                tickLength = 0;
            }
        }

        var align = START;
        if (textWidth) {
            align = MIDDLE;
        }

        var angle = labelRotation * Math.PI / 180;
        var fillWidth;
        var fillHeight;
        var lx = 0;
        var ly = 0;
        var tx = 0;
        var ty = 0;
        var labelTextWidth = 0;
        var labelTextHeight = 0;
        var fillCoord;

        if (orientation == "V") {
            labelRotation = 0;
        }

        var valueTF;
        if (labelsEnabled) {

           if(axis.autoWrap && labelRotation === 0){
                valueTF = AmCharts.wrappedText(container, value, color, fontFamily, textSize, align, bold, textWidth, 0);
            }
            else{
                valueTF = AmCharts.text(container, value, color, fontFamily, textSize, align, bold);
            }

            var bbox = valueTF.getBBox();
            labelTextWidth = bbox.width;
            labelTextHeight = bbox.height;
        }

        // horizontal AXIS
        if (orientation == "H") {
            if (coord >= 0 && coord <= vw + 1) {
                if (tickLength > 0 && axisAlpha > 0 && coord + tickShift <= vw + 1) {
                    tick = AmCharts.line(container, [coord + tickShift, coord + tickShift], [0, tickLength], axisColor, axisAlpha, gridThickness);
                    set.push(tick);
                }
                if (gridAlpha > 0) {
                    grid = AmCharts.line(container, [coord, coord + dx, coord + dx], [vh, vh + dy, dy], gridColor, gridAlpha, gridThickness, dashLength);
                    set.push(grid);
                }
            }
            ly = 0;
            lx = coord;

            if (guide && labelRotation == 90) {
                lx -= textSize;
            }

            if (below === false) {
                align = START;

                if (position == BOTTOM) {
                    if (labelInside) {
                        ly += tickLength;
                    } else {
                        ly -= tickLength;
                    }
                } else {
                    if (labelInside) {
                        ly -= tickLength;
                    } else {
                        ly += tickLength;
                    }
                }

                lx += 3;

                if (textWidth) {
                    lx += textWidth / 2;
                    align = MIDDLE;
                }

                if (labelRotation > 0) {
                    align = MIDDLE;
                }
            } else {
                align = MIDDLE;
            }


            if (counter == 1 && fillAlpha > 0 && !guide && !minor && previousCoord < vw) {
                fillCoord = AmCharts.fitToBounds(coord, 0, vw);
                previousCoord = AmCharts.fitToBounds(previousCoord, 0, vw);
                fillWidth = fillCoord - previousCoord;
                if (fillWidth > 0) {
                    fill = AmCharts.rect(container, fillWidth, axis.height, fillColor, fillAlpha);
                    fill.translate((fillCoord - fillWidth + dx), dy);
                    set.push(fill);
                }
            }

            // ADJUST POSITIONS
            // BOTTOM
            if (position == BOTTOM) {
                ly += vh + textSize / 2 + offset;

                //INSIDE
                if (labelInside) {
                    if (labelRotation > 0) {
                        ly = vh - (labelTextWidth / 2) * Math.sin(angle) - tickLength - vCompensation;
                        lx += (labelTextWidth / 2) * Math.cos(angle) - hCompensation + 2;
                    } else if(labelRotation < 0) {
                        ly = vh + labelTextWidth * Math.sin(angle) - tickLength - vCompensation + 2;
                        lx += -labelTextWidth * Math.cos(angle) - labelTextHeight * Math.sin(angle) - hCompensation;
                    }
                    else{
                        ly -= tickLength + textSize + vCompensation + vCompensation;
                    }
                }
                //OUTSIDE
                else {
                    if (labelRotation > 0) {
                        ly = vh + (labelTextWidth / 2) * Math.sin(angle) + tickLength + vCompensation;
                        lx -= (labelTextWidth / 2) * Math.cos(angle);
                    } else if(labelRotation < 0) {
                        ly = vh + tickLength + vCompensation - (labelTextWidth / 2) * Math.sin(angle) + 2;
                        lx += (labelTextWidth / 2) * Math.cos(angle);
                    }
                    else{
                        ly += tickLength + axisThickness + vCompensation + 3;
                    }
                }
            }
            // TOP
            else {
                ly += dy + textSize / 2 - offset;
                lx += dx;
                //INSIDE
                if (labelInside) {
                    if (labelRotation > 0) {
                        ly = (labelTextWidth / 2) * Math.sin(angle) + tickLength + vCompensation;
                        lx -= (labelTextWidth / 2) * Math.cos(angle);
                    } else {
                        ly += tickLength + vCompensation;
                    }
                }
                //OUTSIDE
                else {
                    if (labelRotation > 0) {
                        ly = -(labelTextWidth / 2) * Math.sin(angle) - tickLength - 2 * vCompensation;
                        lx += (labelTextWidth / 2) * Math.cos(angle);
                    } else {
                        ly -= tickLength + textSize + vCompensation + axisThickness + 3;
                    }
                }
            }

            if (position == BOTTOM) {
                //INSIDE
                if (labelInside) {
                    ty = vh - tickLength - 1;
                }
                //OUTSIDE
                else {
                    ty = vh + axisThickness - 1;
                }
                ty += offset;
            }
            // TOP
            else {
                tx = dx;
                //INSIDE
                if (labelInside) {
                    ty = dy;
                }
                //OUTSIDE
                else {
                    ty = dy - tickLength - axisThickness + 1;
                }
                ty -= offset;
            }

            if (valueShift) {
                lx += valueShift;
            }

            var llx = lx;

            if (labelRotation > 0) {
                llx += labelTextWidth / 2 * Math.cos(angle);
            }

            if (valueTF) {
                var dlx = 0;
                if (labelInside) {
                    dlx = labelTextWidth / 2 * Math.cos(angle);
                }

                if (llx + dlx > vw + 2 || llx < 0) {
                    valueTF.remove();
                    valueTF = null;
                }
            }
        }
        // VERTICAL AXIS
        else {
            if (coord >= 0 && coord <= vh + 1) {
                // ticks
                if (tickLength > 0 && axisAlpha > 0 && coord + tickShift <= vh + 1) {
                    tick = AmCharts.line(container, [0, tickLength], [coord + tickShift, coord + tickShift], axisColor, axisAlpha, gridThickness);
                    set.push(tick);
                }
                // grid
                if (gridAlpha > 0) {
                    grid = AmCharts.line(container, [0, dx, vw + dx], [coord, coord + dy, coord + dy], gridColor, gridAlpha, gridThickness, dashLength);
                    set.push(grid);
                }
            }

            // text field
            align = "end";

            if ((labelInside === true && position == "left") || (labelInside === false && position == "right")) {
                align = START;
            }
            ly = coord - textSize / 2;

            if (counter == 1 && fillAlpha > 0 && !guide && !minor) {
                fillCoord = AmCharts.fitToBounds(coord, 0, vh);
                previousCoord = AmCharts.fitToBounds(previousCoord, 0, vh);
                fillHeight = fillCoord - previousCoord;
                fill = AmCharts.polygon(container, [0, axis.width, axis.width, 0], [0, 0, fillHeight, fillHeight], fillColor, fillAlpha);
                fill.translate(dx, (fillCoord - fillHeight + dy));
                set.push(fill);
            }
            // ADJUST POSITIONS
            // RIGHT
            ly += textSize / 2;
            if (position == "right") {
                lx += dx + vw + offset;
                ly += dy;

                // INSIDE
                if (labelInside) {
                    lx -= tickLength + hCompensation;
                    if (!valueShift) {
                        ly -= textSize / 2 + 3;
                    }
                }
                //OUTSIDE
                else {
                    lx += tickLength + hCompensation + axisThickness;
                    ly -= 2;
                }
            }
            // LEFT
            else {
                // INSIDE
                if (labelInside) {
                    lx += tickLength + hCompensation - offset;
                    if (!valueShift) {
                        ly -= textSize / 2 + 3;
                    }
                    if (guide) {
                        lx += dx;
                        ly += dy;
                    }
                }
                // OUTSIDE
                else {
                    lx += -tickLength - axisThickness - hCompensation - 2 - offset;
                    ly -= 2;
                }
            }

            if (tick) {
                if (position == "right") {
                    tx += dx + offset + vw;
                    ty += dy;
                    // INSIDE
                    if (labelInside) {
                        tx -= axisThickness;
                    }
                    //OUTSIDE
                    else {
                        tx += axisThickness;
                    }
                }
                // LEFT
                else {
                    tx -= offset;
                    // INSIDE
                    if (labelInside) {
                        // void
                    }
                    // OUTSIDE
                    else {
                        tx -= tickLength + axisThickness;
                    }
                }
            }

            if (valueShift) {
                ly += valueShift;
            }

            var topY = -3;

            if (position == "right") {
                topY += dy;
            }
            if (valueTF) {
                if (ly > vh + 1 || ly < topY) {
                    valueTF.remove();
                    valueTF = null;
                }
            }
        }

        if (tick) {
            tick.translate(tx, ty);
        }

        if (axis.visible === false) {
            if (tick) {
                tick.remove();
                tick = null;
            }
            if (valueTF) {
                valueTF.remove();
                valueTF = null;
            }
        }

        if (valueTF) {
            valueTF.attr({
                'text-anchor': align
            });
            valueTF.translate(lx, ly);

            if (labelRotation !== 0) {
                valueTF.rotate(-labelRotation, axis.chart.backgroundColor);
            }
            axis.allLabels.push(valueTF);

            if (value != " ") {
                _this.label = valueTF;
            }
        }

        if (!minor) {
            if (counter === 0) {
                axis.counter = 1;
            } else {
                axis.counter = 0;
            }
            axis.previousCoord = coord;
        }

        // remove empty
        if (_this.set.node.childNodes.length === 0) {
            _this.set.remove();
        }
    },

    graphics: function () {
        return this.set;
    },

    getLabel: function () {
        return this.label;
    }
});

// @tag amchart
AmCharts.ValueAxis = AmCharts.Class({

    inherits: AmCharts.AxisBase,

    construct: function (theme) {
        var _this = this;
        _this.cname = "ValueAxis";
        _this.createEvents('axisChanged', 'logarithmicAxisFailed', 'axisSelfZoomed', 'axisZoomed');
        AmCharts.ValueAxis.base.construct.call(this, theme);
        _this.dataChanged = true;
        //_this.gridCount = 8;
        _this.stackType = "none";
        _this.position = "left";
        _this.unitPosition = "right";
        _this.integersOnly = false;
        _this.includeGuidesInMinMax = false;
        _this.includeHidden = false;
        _this.recalculateToPercents = false;
        //_this.duration;
        _this.durationUnits = {
            DD: "d. ",
            hh: ":",
            mm: ":",
            ss: ""
        };
        _this.scrollbar = false;
        //_this.maxDecCount;
        _this.baseValue = 0;
        _this.radarCategoriesEnabled = true;
        _this.gridType = "polygons";
        _this.useScientificNotation = false;
        _this.axisTitleOffset = 10;
        _this.minMaxMultiplier = 1;
        _this.logGridLimit = 2;
        // _this.labelFunction

        AmCharts.applyTheme(_this, theme, _this.cname);
    },

    updateData: function () {
        var _this = this;
        if (_this.gridCountR <= 0) {
            _this.gridCountR = 1;
        }

        _this.totals = [];
        _this.data = _this.chart.chartData;

        var chart = _this.chart;

        if (chart.type != "xy") {
            _this.stackGraphs("smoothedLine");
            _this.stackGraphs("line");
            _this.stackGraphs("column");
            _this.stackGraphs("step");
        }

        if (_this.recalculateToPercents) {
            _this.recalculate();
        }

        if (_this.synchronizationMultiplier && _this.synchronizeWith) {

            if(AmCharts.isString(_this.synchronizeWith)){
                _this.synchronizeWith = chart.getValueAxisById(_this.synchronizeWith);
            }
            if(_this.synchronizeWith){
                _this.synchronizeWithAxis(_this.synchronizeWith);
                _this.foundGraphs = true;
            }
        } else {
            _this.foundGraphs = false;
            _this.getMinMax();
        }
    },


    draw: function () {
        var _this = this;
        AmCharts.ValueAxis.base.draw.call(_this);

        var chart = _this.chart;
        var set = _this.set;

        // thsi is to handle fallback to v.1 of flash chart only
        if (_this.type == "duration") {
            _this.duration = "ss";
        }

        if (_this.dataChanged === true) {
            _this.updateData();
            _this.dataChanged = false;
        }

        if (_this.logarithmic) {
            var min = _this.getMin(0, _this.data.length - 1);

            if (min <= 0 || _this.minimum <= 0) {
                var eType = 'logarithmicAxisFailed';
                _this.fire(eType, {
                    type: eType,
                    chart: chart
                });
                return;
            }
        }

        _this.grid0 = null;

        var coord;
        var i;
        var dx = chart.dx;
        var dy = chart.dy;
        var hide = false;
        var logarithmic = _this.logarithmic;

        if (!isNaN(_this.min) && !isNaN(_this.max) && _this.foundGraphs && _this.min != Infinity && _this.max != -Infinity) {
            var labelFrequency = _this.labelFrequency;
            var showFirstLabel = _this.showFirstLabel;
            var showLastLabel = _this.showLastLabel;
            var frequency = 1;
            var startCount = 0;

            // the number of grid lines
            var gridCountReal = Math.round((_this.max - _this.min) / _this.step) + 1;

            // LOGARITHMIC
            var degrees;
            if (logarithmic === true) {
                degrees = Math.log(_this.max) * Math.LOG10E - Math.log(_this.minReal) * Math.LOG10E;

                _this.stepWidth = _this.axisWidth / degrees;
                // in case we have more degrees, draw grid every degree only
                if (degrees > _this.logGridLimit) {
                    gridCountReal = Math.ceil((Math.log(_this.max) * Math.LOG10E)) + 1;
                    startCount = Math.round((Math.log(_this.minReal) * Math.LOG10E));
                    if (gridCountReal > _this.gridCountR) {
                        frequency = Math.ceil(gridCountReal / _this.gridCountR);
                    }
                }
            }
            // LINEAR
            else {
                // the width of one value
                _this.stepWidth = _this.axisWidth / (_this.max - _this.min);
            }

            var numbersAfterDecimal = 0;
            if (_this.step < 1 && _this.step > -1) {
                numbersAfterDecimal = AmCharts.getDecimals(_this.step);
            }

            if (_this.integersOnly) {
                numbersAfterDecimal = 0;
            }

            if (numbersAfterDecimal > _this.maxDecCount) {
                numbersAfterDecimal = _this.maxDecCount;
            }

            var precision = _this.precision;
            if (!isNaN(precision)) {
                numbersAfterDecimal = precision;
            }
            _this.max = AmCharts.roundTo(_this.max, _this.maxDecCount);
            _this.min = AmCharts.roundTo(_this.min, _this.maxDecCount);

            var numberFormatter = {};
            numberFormatter.precision = numbersAfterDecimal;
            numberFormatter.decimalSeparator = chart.nf.decimalSeparator;
            numberFormatter.thousandsSeparator = chart.nf.thousandsSeparator;
            _this.numberFormatter = numberFormatter;

            var axisItem;
            // draw guides
            var guides = _this.guides;
            var count = guides.length;
            if (count > 0) {
                var fillAlphaReal = _this.fillAlpha;
                _this.fillAlpha = 0; // this may seam strange, but is for addValue method not to draw fill
                for (i = 0; i < count; i++) {
                    var guide = guides[i];
                    var guideToCoord = NaN;

                    var above = guide.above;

                    if (!isNaN(guide.toValue)) {
                        guideToCoord = _this.getCoordinate(guide.toValue);
                        axisItem = new _this.axisItemRenderer(this, guideToCoord, "", true, NaN, NaN, guide);
                        _this.pushAxisItem(axisItem, above);
                    }

                    var guideCoord = NaN;

                    if (!isNaN(guide.value)) {
                        guideCoord = _this.getCoordinate(guide.value);
                        var valueShift = (guideToCoord - guideCoord) / 2;
                        axisItem = new _this.axisItemRenderer(this, guideCoord, guide.label, true, NaN, valueShift, guide);
                        _this.pushAxisItem(axisItem, above);
                    }

                    if (!isNaN(guideToCoord - guideCoord)) {
                        var guideFill = new _this.guideFillRenderer(this, guideCoord, guideToCoord, guide);
                        _this.pushAxisItem(guideFill, above);
                        var guideFillGraphics = guideFill.graphics();
                        guide.graphics = guideFillGraphics;
                        if (guide.balloonText) {
                            _this.addEventListeners(guideFillGraphics, guide);
                        }
                    }
                }
                _this.fillAlpha = fillAlphaReal;
            }

            var exponential = false;

            var minMant = Number.MAX_VALUE;

            for (i = startCount; i < gridCountReal; i += frequency) {
                var val = AmCharts.roundTo(_this.step * i + _this.min, numbersAfterDecimal);

                if (String(val).indexOf("e") != -1) {
                    exponential = true;

                    var vStrArr = String(val).split("e");
                    var vMant = Number(vStrArr[1]);
                }
            }

            if (_this.duration) {
                _this.maxInterval = AmCharts.getMaxInterval(_this.max, _this.duration);
            }

            var step = _this.step;
            var minorGridEnabled = _this.minorGridEnabled;
            var minorGridStep;
            var minorGridAlpha = _this.minorGridAlpha;

            if (minorGridEnabled) {
                minorGridStep = _this.getMinorGridStep(step, _this.stepWidth * step);
            }

            for (i = startCount; i < gridCountReal; i += frequency) {
                var value = step * i + _this.min;

                value = AmCharts.roundTo(value, _this.maxDecCount + 1);

                if (_this.integersOnly && Math.round(value) != value) {
                    // void
                } else if (!isNaN(precision) && Number(AmCharts.toFixed(value, precision)) != value) {
                    // void
                } else {
                    if (logarithmic === true) {
                        if (value === 0) {
                            value = _this.minReal;
                        }
                        if (degrees > _this.logGridLimit) {
                            value = Math.pow(10, i);
                        }

                        if (String(value).indexOf("e") != -1) {
                            exponential = true;
                        } else {
                            exponential = false;
                        }
                    }

                    var valueText;

                    if (_this.useScientificNotation) {
                        exponential = true;
                    }

                    if (_this.usePrefixes) {
                        exponential = false;
                    }

                    if (!exponential) {
                        if (logarithmic) {
                            var temp = String(value).split(".");
                            if (temp[1]) {
                                numberFormatter.precision = temp[1].length;
                                //added in 3.4.3 to fix floating point
                                if(i < 0){
                                    numberFormatter.precision = Math.abs(i);
                                }
                                // end of 3.4.3

                            } else {
                                numberFormatter.precision = -1;
                            }
                        }

                        if (_this.usePrefixes) {
                            valueText = AmCharts.addPrefix(value, chart.prefixesOfBigNumbers, chart.prefixesOfSmallNumbers, numberFormatter, true);
                        } else {
                            valueText = AmCharts.formatNumber(value, numberFormatter, numberFormatter.precision);
                        }

                    } else {
                        if (String(value).indexOf("e") == -1) {
                            valueText = value.toExponential(15);
                        } else {
                            valueText = String(value);
                        }

                        var valStrArr = valueText.split("e");
                        var valBase = Number(valStrArr[0]);
                        var valMant = Number(valStrArr[1]);

                        valBase = AmCharts.roundTo(valBase, 14);

                        if (valBase == 10) {
                            valBase = 1;
                            valMant += 1;
                        }

                        valueText = valBase + "e" + valMant;

                        if (value === 0) {
                            valueText = "0";
                        }
                        if (value == 1) {
                            valueText = "1";
                        }
                    }

                    if (_this.duration) {
                        valueText = AmCharts.formatDuration(value, _this.duration, "", _this.durationUnits, _this.maxInterval, numberFormatter);
                    }

                    if (_this.recalculateToPercents) {
                        valueText = valueText + "%";
                    } else {
                        var unit = _this.unit;
                        if (unit) {
                            if (_this.unitPosition == "left") {
                                valueText = unit + valueText;
                            } else {
                                valueText = valueText + unit;
                            }
                        }
                    }
                    if (Math.round(i / labelFrequency) != i / labelFrequency) {
                        valueText = undefined;
                    }

                    if ((i === 0 && !showFirstLabel) || (i == (gridCountReal - 1) && !showLastLabel)) {
                        valueText = " ";
                    }

                    coord = _this.getCoordinate(value);

                    if (_this.labelFunction) {
                        valueText = _this.labelFunction(value, valueText, this).toString();
                    }

                    axisItem = new _this.axisItemRenderer(this, coord, valueText);
                    _this.pushAxisItem(axisItem);

                    if (value == _this.baseValue && chart.type != "radar") {
                        var xx;
                        var yy;

                        var ww = _this.viW;
                        var hh = _this.viH;
                        var vx = _this.viX;
                        var vy = _this.viY;

                        if (_this.orientation == "H") {
                            if (coord >= 0 && coord <= ww + 1) {
                                xx = [coord, coord, coord + dx];
                                yy = [hh, 0, dy];
                            }
                        } else {
                            if (coord >= 0 && coord <= hh + 1) {
                                xx = [0, ww, ww + dx];
                                yy = [coord, coord, coord + dy];
                            }
                        }

                        if (xx) {
                            var gridAlpha = AmCharts.fitToBounds(_this.gridAlpha * 2, 0, 1);

                            var grid0 = AmCharts.line(chart.container, xx, yy, _this.gridColor, gridAlpha, 1, _this.dashLength);
                            grid0.translate(vx, vy);
                            _this.grid0 = grid0;
                            chart.axesSet.push(grid0);
                            grid0.toBack();
                        }
                    }

                    // minor grid
                    if (!isNaN(minorGridStep) && minorGridAlpha > 0 && i < gridCountReal - 1) {
                        // change it temporary
                        var realAlpha = _this.gridAlpha;
                        _this.gridAlpha = _this.minorGridAlpha;
                        for (var m = 1; m < step / minorGridStep; m++) {
                            var minorCoord = _this.getCoordinate(value + minorGridStep * m);
                            var minorAxisItem = new _this.axisItemRenderer(this, minorCoord, "", false, 0, 0, false, false, 0, true);
                            _this.pushAxisItem(minorAxisItem);
                        }
                        _this.gridAlpha = realAlpha;
                    }
                }
            }

            // BASE VALUE
            var base = _this.baseValue;

            // if the min is > 0, then the base value is equal to min
            if (_this.min > _this.baseValue && _this.max > _this.baseValue) {
                base = _this.min;
            }

            // if both min and max are less then zero, then the base value is equal to max
            if (_this.min < _this.baseValue && _this.max < _this.baseValue) {
                base = _this.max;
            }

            if (logarithmic && base < _this.minReal) {
                base = _this.minReal;
            }

            _this.baseCoord = _this.getCoordinate(base);

            var name = "axisChanged";
            var event = {
                type: name,
                target: _this,
                chart: chart
            };

            if (logarithmic) {
                event.min = _this.minReal;
            } else {
                event.min = _this.min;
            }
            event.max = _this.max;

            _this.fire(name, event);

            _this.axisCreated = true;
        } else {
            hide = true;
        }

        var axisLineSet = _this.axisLine.set;
        var labelsSet = _this.labelsSet;

        _this.positionTitle();

        if (chart.type != "radar") {
            var viX = _this.viX;
            var viY = _this.viY;
            set.translate(viX, viY);
            labelsSet.translate(viX, viY);
        } else {
            axisLineSet.toFront();
        }

        if (!_this.visible || hide) {
            set.hide();
            axisLineSet.hide();
            labelsSet.hide();
        } else {
            set.show();
            axisLineSet.show();
            labelsSet.show();
        }

        _this.axisY = _this.y - _this.viY;
        _this.axisX = _this.x - _this.viX;
    },


    getMinorGridStep: function (step, width) {
        var gridCount = [5, 4, 2];

        if (width < 60) {
            gridCount.shift();
        }

        var stepE = Math.floor(Math.log(Math.abs(step)) * Math.LOG10E);
        for (var i = 0; i < gridCount.length; i++) {
            var minorStep = step / gridCount[i];
            var minorStepE = Math.floor(Math.log(Math.abs(minorStep)) * Math.LOG10E);

            if (Math.abs(stepE - minorStepE) > 0) {
                continue;
            }

            if (step < 1) {
                var tempStep = Math.pow(10, -minorStepE) * minorStep;

                if (tempStep == Math.round(tempStep)) {
                    return minorStep;
                }
            } else {
                if (minorStep == Math.round(minorStep)) {
                    return minorStep;
                }
            }
        }
    },

    stackGraphs: function (type) {
        var _this = this;
        var stackType = _this.stackType;
        if (stackType == "stacked") {
            stackType = "regular";
        }
        if (stackType == "line") {
            stackType = "none";
        }
        if (stackType == "100% stacked") {
            stackType = "100%";
        }
        _this.stackType = stackType;

        var previousValues = [];
        var previousNegativeValues = [];
        var previousPositiveValues = [];
        var sum = [];
        var value;
        var graphs = _this.chart.graphs;
        var previousGraph;
        var graphType;
        var graph;
        var graphDataItem;
        var j;
        var i;
        var baseValue = _this.baseValue;

        var linetype = false;
        if (type == "line" || type == "step" || type == "smoothedLine") {
            linetype = true;
        }

        // set stackGraphs (tells the graph to which graph it is stacked)
        if (linetype && (stackType == "regular" || stackType == "100%")) {
            for (j = 0; j < graphs.length; j++) {
                graph = graphs[j];

                if (!graph.hidden) {
                    graphType = graph.type;

                    if (graph.chart == _this.chart && graph.valueAxis == this && type == graphType && graph.stackable) {
                        if (previousGraph) {
                            graph.stackGraph = previousGraph;
                            previousGraph = graph;
                        } else {
                            previousGraph = graph;
                        }
                    }
                }
            }
        }



        // do the calculations
        for (i = _this.start; i <= _this.end; i++) {
            var maxDecCount = 0;
            for (j = 0; j < graphs.length; j++) {
                graph = graphs[j];
                if (!graph.hidden) {
                    graphType = graph.type;

                    if (graph.chart == _this.chart && graph.valueAxis == this && type == graphType && graph.stackable) {
                        graphDataItem = _this.data[i].axes[_this.id].graphs[graph.id];

                        value = graphDataItem.values.value;

                        if (!isNaN(value)) {
                            var numbersAfterDecimal = AmCharts.getDecimals(value);
                            if (maxDecCount < numbersAfterDecimal) {
                                maxDecCount = numbersAfterDecimal;
                            }

                            if (isNaN(sum[i])) {
                                sum[i] = Math.abs(value);
                            } else {
                                sum[i] += Math.abs(value);
                            }

                            sum[i] = AmCharts.roundTo(sum[i], maxDecCount);

                            // LINE AND STEP
                            // for the bands, if no stack set but fillToGraph is set
                            var fillToGraph = graph.fillToGraph;
                            if (linetype && fillToGraph) {
                                var fillToDataItem = _this.data[i].axes[_this.id].graphs[fillToGraph.id];
                                if (fillToDataItem) {
                                    graphDataItem.values.open = fillToDataItem.values.value;
                                }
                            }


                            if (stackType == "regular") {
                                // LINE AND STEP
                                if (linetype) {
                                    // if previous value is not present
                                    if (isNaN(previousValues[i])) {
                                        previousValues[i] = value;
                                        graphDataItem.values.close = value;
                                        graphDataItem.values.open = _this.baseValue;
                                    }
                                    // if previous value is present
                                    else {
                                        if (isNaN(value)) {
                                            graphDataItem.values.close = previousValues[i];
                                            graphDataItem.values.open = previousValues[i];
                                        } else {
                                            graphDataItem.values.close = value + previousValues[i];
                                            graphDataItem.values.open = previousValues[i];
                                        }
                                        previousValues[i] = graphDataItem.values.close;
                                    }
                                }

                                // COLUMN
                                if (type == "column") {
                                    if (!isNaN(value)) {

                                        if(graph.newStack){
                                            previousPositiveValues[i] = NaN;
                                            previousNegativeValues[i] = NaN;
                                        }

                                        graphDataItem.values.close = value;

                                        if (value < 0) {
                                            graphDataItem.values.close = value;
                                            if (!isNaN(previousNegativeValues[i])) {
                                                graphDataItem.values.close += previousNegativeValues[i];
                                                graphDataItem.values.open = previousNegativeValues[i];
                                            } else {
                                                graphDataItem.values.open = baseValue;
                                            }
                                            previousNegativeValues[i] = graphDataItem.values.close;
                                        } else {
                                            graphDataItem.values.close = value;
                                            if (!isNaN(previousPositiveValues[i])) {
                                                graphDataItem.values.close += previousPositiveValues[i];
                                                graphDataItem.values.open = previousPositiveValues[i];
                                            } else {
                                                graphDataItem.values.open = baseValue;
                                            }
                                            previousPositiveValues[i] = graphDataItem.values.close;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        for (i = _this.start; i <= _this.end; i++) {
            for (j = 0; j < graphs.length; j++) {
                graph = graphs[j];
                if (!graph.hidden) {
                    graphType = graph.type;
                    if (graph.chart == _this.chart && graph.valueAxis == this && type == graphType && graph.stackable) {
                        graphDataItem = _this.data[i].axes[_this.id].graphs[graph.id];
                        value = graphDataItem.values.value;

                        if (!isNaN(value)) {
                            var percents = value / sum[i] * 100;
                            graphDataItem.values.percents = percents;
                            graphDataItem.values.total = sum[i];

                            if (stackType == "100%") {
                                if (isNaN(previousNegativeValues[i])) {
                                    previousNegativeValues[i] = 0;
                                }

                                if (isNaN(previousPositiveValues[i])) {
                                    previousPositiveValues[i] = 0;
                                }

                                if (percents < 0) {
                                    graphDataItem.values.close = AmCharts.fitToBounds(percents + previousNegativeValues[i], -100, 100);
                                    graphDataItem.values.open = previousNegativeValues[i];
                                    previousNegativeValues[i] = graphDataItem.values.close;
                                } else {
                                    // this fixes 100.000000001 error
                                    graphDataItem.values.close = AmCharts.fitToBounds(percents + previousPositiveValues[i], -100, 100);
                                    graphDataItem.values.open = previousPositiveValues[i];
                                    previousPositiveValues[i] = graphDataItem.values.close;
                                }
                            }
                        }
                    }
                }
            }
        }
    },


    recalculate: function () {
        var _this = this;
        var graphs = _this.chart.graphs;
        var j;
        for (j = 0; j < graphs.length; j++) {
            var graph = graphs[j];

            if (graph.valueAxis == this) {
                var fieldName = "value";
                if (graph.type == "candlestick" || graph.type == "ohlc") {
                    fieldName = "open";
                }

                var baseValue;
                var graphDataItem;
                var end = _this.end + 2;
                end = AmCharts.fitToBounds(_this.end + 1, 0, _this.data.length - 1);
                var start = _this.start;

                if (start > 0) {
                    start--;
                }

                var ii;

                var thisStart = _this.start;
                if (graph.compareFromStart) {
                    thisStart = 0;
                }

                for (ii = thisStart; ii <= end; ii++) {
                    graphDataItem = _this.data[ii].axes[_this.id].graphs[graph.id];
                    baseValue = graphDataItem.values[fieldName];

                    if (!isNaN(baseValue)) {
                        break;
                    }
                }

                var i;
                for (i = start; i <= end; i++) {
                    graphDataItem = _this.data[i].axes[_this.id].graphs[graph.id];
                    graphDataItem.percents = {};
                    var values = graphDataItem.values;

                    var k;
                    for (k in values) {
                        if (k != "percents") {
                            var val = values[k];
                            var percent = val / baseValue * 100 - 100;

                            graphDataItem.percents[k] = percent;
                        } else {
                            graphDataItem.percents[k] = values[k];
                        }
                    }
                }
            }
        }
    },


    getMinMax: function () {
        var _this = this;
        var expand = false;
        var chart = _this.chart;
        var graphs = chart.graphs;
        var g;
        for (g = 0; g < graphs.length; g++) {
            var type = graphs[g].type;

            if (type == "line" || type == "step" || type == "smoothedLine") {
                if (_this.expandMinMax) {
                    expand = true;
                }
            }
        }

        if (expand) {
            if (_this.start > 0) {
                _this.start--;
            }

            if (_this.end < _this.data.length - 1) {
                _this.end++;
            }
        }

        if (chart.type == 'serial') {
            if (chart.categoryAxis.parseDates === true && !expand) {
                if (_this.end < _this.data.length - 1) {
                    _this.end++;
                }
            }
        }

        // get min and max
        var minMaxMultiplier = _this.minMaxMultiplier;
        _this.min = _this.getMin(_this.start, _this.end);
        _this.max = _this.getMax();

        var delta = (_this.max - _this.min) * (minMaxMultiplier - 1);
        _this.min -= delta;
        _this.max += delta;

        var guideCount = _this.guides.length;
        if (_this.includeGuidesInMinMax && guideCount > 0) {
            var i;
            for (i = 0; i < guideCount; i++) {
                var guide = _this.guides[i];

                if (guide.toValue < _this.min) {
                    _this.min = guide.toValue;
                }

                if (guide.value < _this.min) {
                    _this.min = guide.value;
                }

                if (guide.toValue > _this.max) {
                    _this.max = guide.toValue;
                }

                if (guide.value > _this.max) {
                    _this.max = guide.value;
                }
            }
        }

        // set defined
        if (!isNaN(_this.minimum)) {
            _this.min = _this.minimum;
        }

        if (!isNaN(_this.maximum)) {
            _this.max = _this.maximum;
        }

        if (_this.min > _this.max) {
            var maxT = _this.max;
            _this.max = _this.min;
            _this.min = maxT;
        }

        // set temp if not reseted
        if (!isNaN(_this.minTemp)) {
            _this.min = _this.minTemp;
        }

        if (!isNaN(_this.maxTemp)) {
            _this.max = _this.maxTemp;
        }

        _this.minReal = _this.min;
        _this.maxReal = _this.max;

        if (_this.min === 0 && _this.max === 0) {
            _this.max = 9;
        }

        if (_this.min > _this.max) {
            _this.min = _this.max - 1;
        }

        var initialMin = _this.min; //initial minimum
        var initialMax = _this.max; //initial maximum
        var dif = _this.max - _this.min; //difference
        var difE; //row of difference
        if (dif === 0) {
            // difference is 0 if all values of the period are equal
            // then difference will be
            difE = Math.pow(10, Math.floor(Math.log(Math.abs(_this.max)) * Math.LOG10E)) / 10;
        } else {
            difE = Math.pow(10, Math.floor(Math.log(Math.abs(dif)) * Math.LOG10E)) / 10;
        }

        // new min and max
        if (isNaN(_this.maximum) && isNaN(_this.maxTemp)) {
            _this.max = Math.ceil(_this.max / difE) * difE + difE;
        }

        if (isNaN(_this.minimum) && isNaN(_this.minTemp)) {
            _this.min = Math.floor(_this.min / difE) * difE - difE;
        }

        if (_this.min < 0 && initialMin >= 0) { //min is zero if initial min > 0
            _this.min = 0;
        }

        if (_this.max > 0 && initialMax <= 0) { //min is zero if initial min > 0
            _this.max = 0;
        }

        if (_this.stackType == "100%") {
            if (_this.min < 0) {
                _this.min = -100;
            } else {
                _this.min = 0;
            }

            if (_this.max < 0) {
                _this.max = 0;
            } else {
                _this.max = 100;
            }
        }

        // new difference
        dif = _this.max - _this.min;
        difE = Math.pow(10, Math.floor(Math.log(Math.abs(dif)) * Math.LOG10E)) / 10;

        // aprox size of the step
        _this.step = Math.ceil((dif / _this.gridCountR) / difE) * difE;

        // row of the step
        var stepE = Math.pow(10, Math.floor(Math.log(Math.abs(_this.step)) * Math.LOG10E));
        stepE = _this.fixStepE(stepE);

        var temp = Math.ceil(_this.step / stepE); //number from 1 to 10
        if (temp > 5) {
            temp = 10;
        }

        if (temp <= 5 && temp > 2) {
            temp = 5;
        }

        //real step
        _this.step = Math.ceil(_this.step / (stepE * temp)) * stepE * temp;

        if (stepE < 1) {
            _this.maxDecCount = Math.abs(Math.log(Math.abs(stepE)) * Math.LOG10E);
            _this.maxDecCount = Math.round(_this.maxDecCount);
            _this.step = AmCharts.roundTo(_this.step, _this.maxDecCount + 1);
        } else {
            _this.maxDecCount = 0;
        }

        _this.min = _this.step * Math.floor(_this.min / _this.step);
        _this.max = _this.step * Math.ceil(_this.max / _this.step);

        if (_this.min < 0 && initialMin >= 0) { //min is zero if initial min > 0
            _this.min = 0;
        }

        if (_this.max > 0 && initialMax <= 0) { //min is zero if initial min > 0
            _this.max = 0;
        }

        // tweek real min
        // round
        if (_this.minReal > 1 && _this.max - _this.minReal > 1) {
            _this.minReal = Math.floor(_this.minReal);
        }

        dif = (Math.pow(10, Math.floor(Math.log(Math.abs(_this.minReal)) * Math.LOG10E)));

        // find next after zero
        if (_this.min === 0) {
            _this.minReal = dif;
        }
        if (_this.min === 0 && _this.minReal > 1) {
            _this.minReal = 1;
        }

        if (_this.min > 0 && _this.minReal - _this.step > 0) {
            if (_this.min + _this.step < _this.minReal) {
                _this.minReal = _this.min + _this.step;
            } else {
                _this.minReal = _this.min;
            }
        }

        var degrees = Math.log(initialMax) * Math.LOG10E - Math.log(initialMin) * Math.LOG10E;

        if (_this.logarithmic) {
            if (degrees > 2) {
                _this.min = Math.pow(10, Math.floor(Math.log(Math.abs(initialMin)) * Math.LOG10E));
                _this.minReal = _this.min;
                _this.max = Math.pow(10, Math.ceil(Math.log(Math.abs(initialMax)) * Math.LOG10E));
            } else {
                var minE = Math.pow(10, Math.floor(Math.log(Math.abs(_this.min)) * Math.LOG10E)) / 10;
                var minRealE = Math.pow(10, Math.floor(Math.log(Math.abs(initialMin)) * Math.LOG10E)) / 10;

                if (minE < minRealE) {
                    _this.min = 10 * minRealE;
                    _this.minReal = _this.min;
                }
            }
        }
    },

    fixStepE: function (stepE) {
        // fix step e beacuse of roundoff problem
        var stepExp = stepE.toExponential(0);
        var stepExpArr = stepExp.split("e");
        var base = Number(stepExpArr[0]);
        var mant = Number(stepExpArr[1]);
        if (base == 9) {
            mant++;
        }
        return this.generateNumber(1, mant);
    },

    generateNumber: function (num, mant) {
        var zeroes = "";
        var n;

        if (mant < 0) {
            n = Math.abs(mant) - 1;
        } else {
            n = Math.abs(mant);
        }

        var i;
        for (i = 0; i < n; i++) {
            zeroes = zeroes + "0";
        }
        if (mant < 0) {
            return Number("0." + zeroes + String(num));
        } else {
            return Number(String(num) + zeroes);
        }
    },


    getMin: function (start, end) {
        var _this = this;
        var min;

        var i;
        for (i = start; i <= end; i++) {
            var graphs = _this.data[i].axes[_this.id].graphs;

            var j;
            for (j in graphs) {
                if (graphs.hasOwnProperty(j)) {
                    var graph = _this.chart.getGraphById(j);

                    if (graph.includeInMinMax) {
                        if (!graph.hidden || _this.includeHidden) {
                            if (isNaN(min)) {
                                min = Infinity;
                            }

                            _this.foundGraphs = true;

                            var values = graphs[j].values;
                            if (_this.recalculateToPercents) {
                                values = graphs[j].percents;
                            }

                            var val;

                            if (_this.minMaxField) {
                                val = values[_this.minMaxField];

                                if (val < min) {
                                    min = val;
                                }
                            } else {
                                var k;
                                for (k in values) {
                                    if (values.hasOwnProperty(k)) {
                                        if (k != "percents" && k != "total") {
                                            val = values[k];
                                            if (val < min) {
                                                min = val;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        return min;
    },


    getMax: function () {
        var _this = this;
        var max;
        var i;

        for (i = _this.start; i <= _this.end; i++) {
            var graphs = _this.data[i].axes[_this.id].graphs;

            var j;
            for (j in graphs) {
                if (graphs.hasOwnProperty(j)) {
                    var graph = _this.chart.getGraphById(j);
                    if (graph.includeInMinMax) {
                        if (!graph.hidden || _this.includeHidden) {
                            if (isNaN(max)) {
                                max = -Infinity;
                            }

                            _this.foundGraphs = true;

                            var values = graphs[j].values;
                            if (_this.recalculateToPercents) {
                                values = graphs[j].percents;
                            }

                            var val;

                            if (_this.minMaxField) {
                                val = values[_this.minMaxField];

                                if (val > max) {
                                    max = val;
                                }
                            } else {
                                var k;
                                for (k in values) {
                                    if (values.hasOwnProperty(k)) {
                                        if (k != "percents" && k != "total") {
                                            val = values[k];
                                            if (val > max) {
                                                max = val;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        return max;
    },


    dispatchZoomEvent: function (startValue, endValue) {
        var _this = this;
        var event = {
            type: "axisZoomed",
            startValue: startValue,
            endValue: endValue,
            target: _this,
            chart: _this.chart
        };
        _this.fire(event.type, event);
    },


    zoomToValues: function (startValue, endValue) {
        var _this = this;
        if (endValue < startValue) {
            var temp = endValue;
            endValue = startValue;
            startValue = temp;
        }

        if (startValue < _this.min) {
            startValue = _this.min;
        }

        if (endValue > _this.max) {
            endValue = _this.max;
        }

        var event = {};
        event.type = "axisSelfZoomed";
        event.chart = _this.chart;
        event.valueAxis = _this;
        event.multiplier = _this.axisWidth / Math.abs((_this.getCoordinate(endValue) - _this.getCoordinate(startValue)));

        if (_this.orientation == "V") {
            if (_this.reversed) {
                event.position = _this.getCoordinate(startValue);
            } else {
                event.position = _this.getCoordinate(endValue);
            }
        } else {
            if (_this.reversed) {
                event.position = _this.getCoordinate(endValue);
            } else {
                event.position = _this.getCoordinate(startValue);
            }
        }

        _this.fire(event.type, event);
    },


    coordinateToValue: function (coordinate) {
        var _this = this;
        if (isNaN(coordinate)) {
            return NaN;
        }

        var value;
        var axisWidth = _this.axisWidth;
        var stepWidth = _this.stepWidth;
        var reversed = _this.reversed;
        var rotate = _this.rotate;
        var min = _this.min;
        var minReal = _this.minReal;

        // LOGARITHMIC
        if (_this.logarithmic === true) {
            var degree;

            if (rotate) {
                // REVERSED
                if (reversed === true) {
                    degree = (axisWidth - coordinate) / stepWidth;
                }
                // NOT REVERSED
                else {
                    degree = coordinate / stepWidth;
                }
            } else {
                // REVERSED
                if (reversed === true) {
                    degree = coordinate / stepWidth;
                }
                // NOT REVERSED
                else {
                    degree = (axisWidth - coordinate) / stepWidth;
                }
            }
            value = Math.pow(10, degree + Math.log(minReal) * Math.LOG10E);
        }

        // LINEAR (SIMPLE)
        else {
            // REVERSED
            if (reversed === true) {
                if (rotate) {
                    value = min - (coordinate - axisWidth) / stepWidth;
                } else {
                    value = coordinate / stepWidth + min;
                }
            }
            // NOT REVERSED
            else {
                if (rotate) {
                    value = coordinate / stepWidth + min;
                } else {
                    value = min - (coordinate - axisWidth) / stepWidth;
                }
            }
        }
        return value;
    },


    getCoordinate: function (value) {
        var _this = this;
        if (isNaN(value)) {
            return NaN;
        }
        var rotate = _this.rotate;
        var reversed = _this.reversed;
        var coord;
        var axisWidth = _this.axisWidth;
        var stepWidth = _this.stepWidth;
        var min = _this.min;
        var minReal = _this.minReal;

        // LOGARITHMIC
        if (_this.logarithmic === true) {
            var degree = (Math.log(value) * Math.LOG10E) - Math.log(minReal) * Math.LOG10E;
            if (rotate) {
                // REVERSED
                if (reversed === true) {
                    coord = axisWidth - stepWidth * degree;
                }
                // NOT REVERSED
                else {
                    coord = stepWidth * degree;
                }
            } else {
                // REVERSED
                if (reversed === true) {
                    coord = stepWidth * degree;
                }
                // NOT REVERSED
                else {
                    coord = axisWidth - stepWidth * degree;
                }
            }
        }
        // LINEAR (SIMPLE)
        else {
            // REVERSED
            if (reversed === true) {
                if (rotate) {
                    coord = axisWidth - stepWidth * (value - min);
                } else {
                    coord = stepWidth * (value - min);
                }
            }
            // NOT REVERSED
            else {
                if (rotate) {
                    coord = stepWidth * (value - min);
                } else {
                    coord = axisWidth - stepWidth * (value - min);
                }
            }
        }

        if (_this.rotate) {
            coord += _this.x - _this.viX;
        } else {
            coord += _this.y - _this.viY;
        }

        return Math.round(coord);
    },

    /**
     * One value axis can be synchronized with another value axis.
     * You should set synchronizationMultiplier in order for this to work.
     */
    synchronizeWithAxis: function (value) {
        var _this = this;
        _this.synchronizeWith = value;
        _this.listenTo(_this.synchronizeWith, "axisChanged", _this.handleSynchronization);
    },


    handleSynchronization: function (event) {
        var _this = this;
        var synchronizeWith = _this.synchronizeWith;
        var syncMin = synchronizeWith.min;
        var syncMax = synchronizeWith.max;
        var syncStep = synchronizeWith.step;

        var synchronizationMultiplier = _this.synchronizationMultiplier;

        if (synchronizationMultiplier) {
            _this.min = syncMin * synchronizationMultiplier;
            _this.max = syncMax * synchronizationMultiplier;
            _this.step = syncStep * synchronizationMultiplier;

            var stepE = Math.pow(10, Math.floor(Math.log(Math.abs(_this.step)) * Math.LOG10E));

            var maxDecCount = Math.abs(Math.log(Math.abs(stepE)) * Math.LOG10E);
            maxDecCount = Math.round(maxDecCount);

            _this.maxDecCount = maxDecCount;

            _this.draw();
        }
    }

});

// @tag amchart
AmCharts.AmBalloon = AmCharts.Class({

    construct: function (theme) {
        var _this = this;
        _this.cname = "AmBalloon";
        _this.enabled = true;
        _this.fillColor = '#FFFFFF';
        _this.fillAlpha = 0.8;
        _this.borderThickness = 2;
        _this.borderColor = '#FFFFFF';
        _this.borderAlpha = 1;
        _this.cornerRadius = 0;
        _this.maximumWidth = 220;
        _this.horizontalPadding = 8;
        _this.verticalPadding = 4;
        _this.pointerWidth = 6;
        _this.pointerOrientation = "V";
        _this.color = '#000000';
        _this.adjustBorderColor = true;
        _this.showBullet = false;
        _this.follow = false;
        _this.show = false;
        _this.bulletSize = 3;
        _this.shadowAlpha = 0.4;
        _this.shadowColor = "#000000";
        _this.animationDuration = 0.3;
        _this.fadeOutDuration = 0.3;
        _this.fixedPosition = false;
        _this.offsetY = 6;
        _this.offsetX = 1;
        _this.textAlign = "center";

        if (!AmCharts.isModern) {
            _this.offsetY *= 1.5;
        }
        AmCharts.applyTheme(_this, theme, _this.cname);
    },

    draw: function () {
        var _this = this;
        var ptx = _this.pointToX;
        var pty = _this.pointToY;
        var PX = "px";
        _this.deltaSignY = 1;
        _this.deltaSignX = 1;
        var chart = _this.chart;
        var UNDEFINED;

        if (AmCharts.VML) {
            _this.fadeOutDuration = 0;
        }

        if (_this.xAnim) {
            chart.stopAnim(_this.xAnim);
        }
        if (_this.yAnim) {
            chart.stopAnim(_this.yAnim);
        }

        if (!isNaN(ptx)) {
            var follow = _this.follow;
            var container = chart.container;
            var set = _this.set;
            AmCharts.remove(set);

            _this.removeDiv();

            set = container.set();
            _this.set = set;

            chart.balloonsSet.push(set);

            if (_this.show) {
                var ll = _this.l;
                var tt = _this.t;
                var rr = _this.r;
                var bb = _this.b;

                var balloonColor = _this.balloonColor;
                var fillColor = _this.fillColor;
                var borderColor = _this.borderColor;
                var pointerColor = fillColor;

                if (balloonColor != UNDEFINED) {
                    if (_this.adjustBorderColor) {
                        borderColor = balloonColor;
                        pointerColor = borderColor;
                    } else {
                        fillColor = balloonColor;
                    }
                }

                var horizontalPadding = _this.horizontalPadding;
                var verticalPadding = _this.verticalPadding;
                var pointerWidth = _this.pointerWidth;
                var pointerOrientation = _this.pointerOrientation;
                var cornerRadius = _this.cornerRadius;
                var fontFamily = chart.fontFamily;
                var textSize = _this.fontSize;

                if (textSize == UNDEFINED) {
                    textSize = chart.fontSize;
                }

                var textDiv = document.createElement("div");
                var divStyle = textDiv.style;
                divStyle.position = "absolute";

                var minWidth = _this.minWidth;
                var minWidthStyle = "";
                if(!isNaN(minWidth)){
                    minWidthStyle = "min-width:" + (minWidth - horizontalPadding * 2) + "px; ";
                }

                var text = '<div style="text-align:' + _this.textAlign + '; '+ minWidthStyle +'max-width:' + _this.maxWidth + 'px; font-size:' + textSize + 'px; color:' + _this.color + '; font-family:' + fontFamily + '">' + _this.text + '</div>';
                textDiv.innerHTML = text;
                chart.chartDiv.appendChild(textDiv);
                _this.textDiv = textDiv;

                var divWidth = textDiv.offsetWidth;
                var divHeight = textDiv.offsetHeight;

                if (textDiv.clientHeight) {
                    divWidth = textDiv.clientWidth;
                    divHeight = textDiv.clientHeight;
                }

                var h = divHeight + 2 * verticalPadding;
                var w = divWidth + 2 * horizontalPadding;


                if(!isNaN(minWidth) && w < minWidth){
                    w = minWidth;
                }

                if (window.opera) {
                    h += 2;
                }

                var cx;
                var cy;

                var switched = false;
                var offsetY = _this.offsetY;
                if(chart.handDrawn){
                    offsetY += chart.handDrawScatter + 2;
                }

                // position of the balloon
                if (pointerOrientation != "H") {
                    cx = ptx - w / 2;
                    if (pty < tt + h + 10 && pointerOrientation != "down") {
                        switched = true;
                        if (follow) {
                            pty += offsetY;
                        }
                        cy = pty + pointerWidth;
                        _this.deltaSignY = -1;

                    } else {
                        if (follow) {
                            pty -= offsetY;
                        }
                        cy = pty - h - pointerWidth;
                        _this.deltaSignY = 1;
                        ty = -(pointerWidth + h - verticalPadding);
                    }

                } else {
                    if (pointerWidth * 2 > h) {
                        pointerWidth = h / 2;
                    }

                    cy = pty - h / 2;
                    if (ptx < ll + (rr - ll) / 2) {
                        cx = ptx + pointerWidth;
                        _this.deltaSignX = -1;
                    } else {
                        cx = ptx - w - pointerWidth;
                        _this.deltaSignX = 1;
                    }

                }
                // fit to bounds
                if (cy + h >= bb) {
                    cy = bb - h;
                }
                if (cy < tt) {
                    cy = tt;
                }
                if (cx < ll) {
                    cx = ll;
                }
                if (cx + w > rr) {
                    cx = rr - w;
                }


                var ty = cy + verticalPadding;
                var tx = cx + horizontalPadding;


                var shadowAlpha = _this.shadowAlpha;
                var shadowColor = _this.shadowColor;
                var borderThickness = _this.borderThickness;
                //place the ballloon
                var bg;
                var bulletSize = _this.bulletSize;
                var bgShadow;
                var pointer;
                if (cornerRadius > 0 || pointerWidth === 0) {
                    if (shadowAlpha > 0) {
                        bgShadow = AmCharts.rect(container, w, h, fillColor, 0, borderThickness + 1, shadowColor, shadowAlpha, _this.cornerRadius);
                        if (AmCharts.isModern) {
                            bgShadow.translate(1, 1);
                        } else {
                            bgShadow.translate(4, 4);
                        }

                        set.push(bgShadow);
                    }

                    bg = AmCharts.rect(container, w, h, fillColor, _this.fillAlpha, borderThickness, borderColor, _this.borderAlpha, _this.cornerRadius);
                    if (_this.showBullet) {
                        pointer = AmCharts.circle(container, bulletSize, pointerColor, _this.fillAlpha);
                        set.push(pointer);
                    }

                } else {
                    var xx = [];
                    var yy = [];
                    if (pointerOrientation != "H") {
                        var zx = ptx - cx; // center of the pointer root
                        if (zx > w - pointerWidth) {
                            zx = w - pointerWidth;
                        }

                        if (zx < pointerWidth) {
                            zx = pointerWidth;
                        }

                        xx = [0, zx - pointerWidth, ptx - cx, zx + pointerWidth, w, w, 0, 0];

                        if (switched) {
                            yy = [0, 0, pty - cy, 0, 0, h, h, 0];
                        } else {
                            yy = [h, h, pty - cy, h, h, 0, 0, h];
                        }
                    } else {
                        var zy = pty - cy; // center of the pointer root
                        if (zy > h - pointerWidth) {
                            zy = h - pointerWidth;
                        }

                        if (zy < pointerWidth) {
                            zy = pointerWidth;
                        }

                        yy = [0, zy - pointerWidth, pty - cy, zy + pointerWidth, h, h, 0, 0];

                        var midX;
                        if (ptx < ll + (rr - ll) / 2) {

                            if (cx < ptx) {
                                midX = 0;
                            } else {
                                midX = ptx - cx;
                            }

                            xx = [0, 0, midX, 0, 0, w, w, 0];
                        } else {


                            if (cx + w > ptx) {
                                midX = w;
                            } else {
                                midX = ptx - cx;
                            }

                            xx = [w, w, midX, w, w, 0, 0, w];
                        }
                    }

                    if (shadowAlpha > 0) {
                        bgShadow = AmCharts.polygon(container, xx, yy, fillColor, 0, borderThickness, shadowColor, shadowAlpha);
                        bgShadow.translate(1, 1);
                        set.push(bgShadow);
                    }

                    bg = AmCharts.polygon(container, xx, yy, fillColor, _this.fillAlpha, borderThickness, borderColor, _this.borderAlpha);

                }
                _this.bg = bg;
                set.push(bg);
                bg.toFront();

                var dx = 1 * _this.deltaSignX;

                divStyle.left = tx + PX;
                divStyle.top = ty + PX;

                set.translate(cx - dx, cy);
                var bgbox = bg.getBBox();
                _this.bottom = cy + h + 1;
                _this.yPos = bgbox.y + cy;

                if (pointer) {
                    pointer.translate(_this.pointToX - cx + dx, pty - cy);
                }

                var animationDuration = _this.animationDuration;
                if (_this.animationDuration > 0 && !follow) {
                    var effect = "easeOutSine";
                    if (!isNaN(_this.prevX)) {
                        set.translate(_this.prevX, _this.prevY);
                        set.animate({
                            'translate': cx - dx + ',' + cy
                        }, animationDuration, effect);

                        if (textDiv) {
                            divStyle.left = _this.prevTX + PX;
                            divStyle.top = _this.prevTY + PX;
                            _this.xAnim = chart.animate({
                                node: textDiv
                            }, 'left', _this.prevTX, tx, animationDuration, effect, PX);
                            _this.yAnim = chart.animate({
                                node: textDiv
                            }, 'top', _this.prevTY, ty, animationDuration, effect, PX);
                        }
                    }
                }

                _this.prevX = cx - dx;
                _this.prevY = cy;
                _this.prevTX = tx;
                _this.prevTY = ty;
            }
        }
    },

    followMouse: function () {
        var _this = this;
        if (_this.follow && _this.show) {
            var ptx = _this.chart.mouseX - (_this.offsetX * _this.deltaSignX);
            var pty = _this.chart.mouseY;
            _this.pointToX = ptx;
            _this.pointToY = pty;

            if (ptx != _this.previousX || pty != _this.previousY) {
                _this.previousX = ptx;
                _this.previousY = pty;
                if (_this.cornerRadius === 0) {
                    _this.draw();
                } else {
                    var set = _this.set;
                    if (set) {
                        var bb = set.getBBox();

                        var x = ptx - bb.width / 2;
                        var y = pty - bb.height - 10;

                        if (x < _this.l) {
                            x = _this.l;
                        }
                        if (x > _this.r - bb.width) {
                            x = _this.r - bb.width;
                        }

                        if (y < _this.t) {
                            y = pty + 10;
                        }

                        set.translate(x, y);
                        var divStyle = _this.textDiv.style;
                        divStyle.left = x + _this.horizontalPadding + "px";
                        divStyle.top = y + _this.verticalPadding + "px";
                    }
                }
            }
        }
    },

    changeColor: function (color) {
        this.balloonColor = color;
    },

    setBounds: function (l, t, r, b) {
        var _this = this;
        _this.l = l;
        _this.t = t;
        _this.r = r;
        _this.b = b;
        if (_this.destroyTO) {
            clearTimeout(_this.destroyTO);
        }
    },

    showBalloon: function (value) {
        var _this = this;
        _this.text = value;
        _this.show = true;
        if (_this.destroyTO) {
            clearTimeout(_this.destroyTO);
        }
        var chart = _this.chart;

        if(_this.fadeAnim1){
            chart.stopAnim(_this.fadeAnim1);
        }

        if(_this.fadeAnim2){
            chart.stopAnim(_this.fadeAnim2);
        }

        _this.draw();
    },

    hide: function () {
        var _this = this;
        var fadeOutDuration = _this.fadeOutDuration;
        var chart = _this.chart;
        if (fadeOutDuration > 0) {
            _this.destroyTO = setTimeout(function () {
                _this.destroy.call(_this);
            }, fadeOutDuration * 1000);

            _this.follow = false;
            _this.show = false;
            var set = _this.set;

            if (set) {
                set.setAttr("opacity", _this.fillAlpha);
                _this.fadeAnim1 = set.animate({
                    opacity: 0
                }, fadeOutDuration, "easeInSine");
            }

            if (_this.textDiv) {
                _this.fadeAnim2 = chart.animate({
                    node: _this.textDiv
                }, 'opacity', 1, 0, fadeOutDuration, "easeInSine", "");
            }
        } else {
            _this.show = false;
            _this.follow = false;
            _this.destroy();
        }
    },


    setPosition: function (x, y, redraw) {
        var _this = this;

        _this.pointToX = x;
        _this.pointToY = y;

        if (redraw) {
            if (x != _this.previousX || y != _this.previousY) {
                _this.draw();
            }
        }
        _this.previousX = x;
        _this.previousY = y;
    },

    followCursor: function (value) {
        var _this = this;
        _this.follow = value;
        if (value) {
            _this.pShowBullet = _this.showBullet;
            _this.showBullet = false;
        } else {
            if (_this.pShowBullet !== undefined) {
                _this.showBullet = _this.pShowBullet;
            }
        }
        clearInterval(_this.interval);

        var mouseX = _this.chart.mouseX;
        var mouseY = _this.chart.mouseY;

        if (!isNaN(mouseX)) {
            if (value) {
                _this.pointToX = mouseX - (_this.offsetX * _this.deltaSignX);
                _this.pointToY = mouseY;
                _this.followMouse();
                _this.interval = setInterval(function () {
                    _this.followMouse.call(_this);
                }, 40);
            }
        }
    },

    removeDiv: function () {
        var _this = this;
        if (_this.textDiv) {
            var parent = _this.textDiv.parentNode;
            if (parent) {
                parent.removeChild(_this.textDiv);
            }
        }
    },

    destroy: function () {
        var _this = this;
        clearInterval(_this.interval);
        AmCharts.remove(_this.set);
        _this.removeDiv();
        _this.set = null;
    }


});

// @tag amchart
AmCharts.AmChart = AmCharts.Class({

    construct: function(theme) {
        var _this = this;
        _this.theme = theme;
        _this.version = "3.4.8";
        AmCharts.addChart(_this);
        _this.createEvents('dataUpdated', 'init', 'rendered', 'drawn');
        _this.width = '100%';
        _this.height = '100%';
        _this.dataChanged = true;
        _this.chartCreated = false;
        _this.previousHeight = 0;
        _this.previousWidth = 0;
        _this.backgroundColor = "#FFFFFF";
        _this.backgroundAlpha = 0;
        _this.borderAlpha = 0;
        _this.borderColor = "#000000";
        _this.color = "#000000";
        _this.fontFamily = "Verdana";
        _this.fontSize = 11;
        _this.usePrefixes = false;
/*
        _this.numberFormatter = {
            precision: -1,
            decimalSeparator: '.',
            thousandsSeparator: ','
        };
        _this.percentFormatter = {
            precision: 2,
            decimalSeparator: '.',
            thousandsSeparator: ','
        };
*/
        _this.precision = -1;
        _this.percentPrecision = 2;
        _this.decimalSeparator = ".";
        _this.thousandsSeparator = ",";

        _this.labels = [];
        _this.allLabels = [];
        _this.titles = [];
        _this.autoMarginOffset = 0;
        _this.marginLeft = 0;
        _this.marginRight = 0;
        _this.timeOuts = [];
        _this.creditsPosition = "top-left";

        var chartDiv = document.createElement("div");
        var chartStyle = chartDiv.style;
        chartStyle.overflow = "hidden";
        chartStyle.position = "relative";
        chartStyle.textAlign = "left";
        _this.chartDiv = chartDiv;

        var legendDiv = document.createElement("div");
        var legendStyle = legendDiv.style;
        legendStyle.overflow = "hidden";
        legendStyle.position = "relative";
        legendStyle.textAlign = "left";
        _this.legendDiv = legendDiv;

        _this.titleHeight = 0;
        _this.hideBalloonTime = 150;

        _this.handDrawScatter = 2;
        _this.handDrawThickness = 1;


        _this.prefixesOfBigNumbers = [{
            number: 1e+3,
            prefix: "k"
        }, {
            number: 1e+6,
            prefix: "M"
        }, {
            number: 1e+9,
            prefix: "G"
        }, {
            number: 1e+12,
            prefix: "T"
        }, {
            number: 1e+15,
            prefix: "P"
        }, {
            number: 1e+18,
            prefix: "E"
        }, {
            number: 1e+21,
            prefix: "Z"
        }, {
            number: 1e+24,
            prefix: "Y"
        }];
        _this.prefixesOfSmallNumbers = [{
            number: 1e-24,
            prefix: "y"
        }, {
            number: 1e-21,
            prefix: "z"
        }, {
            number: 1e-18,
            prefix: "a"
        }, {
            number: 1e-15,
            prefix: "f"
        }, {
            number: 1e-12,
            prefix: "p"
        }, {
            number: 1e-9,
            prefix: "n"
        }, {
            number: 1e-6,
            prefix: ""
        }, {
            number: 1e-3,
            prefix: "m"
        }];
        _this.panEventsEnabled = true; // changed since 3.4.4
        AmCharts.bezierX = 3;
        AmCharts.bezierY = 6;

        _this.product = "amcharts";

        _this.animations = [];

        _this.balloon = new AmCharts.AmBalloon(_this.theme);
        _this.balloon.chart = this;

        AmCharts.applyTheme(_this, theme, "AmChart");
    },

    drawChart: function() {
        var _this = this;

        _this.drawBackground();

        _this.redrawLabels();

        _this.drawTitles();

        _this.brr();
    },

    drawBackground: function() {
        var _this = this;
        AmCharts.remove(_this.background);
        var container = _this.container;
        var backgroundColor = _this.backgroundColor;
        var backgroundAlpha = _this.backgroundAlpha;
        var set = _this.set;

        if (!AmCharts.isModern && backgroundAlpha === 0) {
            backgroundAlpha = 0.001;
        }

        var realWidth = _this.updateWidth();
        _this.realWidth = realWidth;

        var realHeight = _this.updateHeight();
        _this.realHeight = realHeight;

        var background = AmCharts.polygon(container, [0, realWidth - 1, realWidth - 1, 0], [0, 0, realHeight - 1, realHeight - 1], backgroundColor, backgroundAlpha, 1, _this.borderColor, _this.borderAlpha);
        _this.background = background;
        set.push(background);

        var backgroundImage = _this.backgroundImage;
        if (backgroundImage) {
            if (_this.path) {
                backgroundImage = _this.path + backgroundImage;
            }

            var bgImg = container.image(backgroundImage, 0, 0, realWidth, realHeight);
            _this.bgImg = bgImg;
            set.push(bgImg);
        }
    },

    drawTitles: function() {
        var _this = this;
        var titles = _this.titles;
        if (AmCharts.ifArray(titles)) {
            var nextY = 20;
            var i;
            for (i = 0; i < titles.length; i++) {
                var title = titles[i];
                var color = title.color;
                if (color === undefined) {
                    color = _this.color;
                }
                var size = title.size;

                if(isNaN(size)){
                    size = _this.fontSize + 2;
                }

                var alpha = title.alpha;
                if (isNaN(alpha)) {
                    alpha = 1;
                }

                var marginLeft = _this.marginLeft;
                var titleLabel = AmCharts.text(_this.container, title.text, color, _this.fontFamily, size);
                titleLabel.translate(marginLeft + (_this.realWidth - _this.marginRight - marginLeft) / 2, nextY);

                var bold = true;
                if (title.bold !== undefined) {
                    bold = title.bold;
                }
                if (bold) {
                    titleLabel.attr({
                        'font-weight': 'bold'
                    });
                }

                titleLabel.attr({opacity:title.alpha});

                nextY += size + 6;
                _this.freeLabelsSet.push(titleLabel);
            }
        }
    },

    write: function(divId) {

        var _this = this;

        var div;
        if (typeof(divId) != "object") {
            div = document.getElementById(divId);
        } else {
            div = divId;
        }
        div.innerHTML = "";
        _this.div = div;
        div.style.overflow = "hidden";
        div.style.textAlign = "left";

        var chartDiv = _this.chartDiv;
        var legendDiv = _this.legendDiv;
        var legend = _this.legend;
        var legendStyle = legendDiv.style;
        var chartStyle = chartDiv.style;
        _this.measure();

        var UNDEFINED;
        var ABSOLUTE = "absolute";
        var RELATIVE = "relative";
        var PX = "px";
        var containerStyle;

        var container = document.createElement("div");
        containerStyle = container.style;
        containerStyle.position = RELATIVE;
        _this.containerDiv = container;
        div.appendChild(container);

        var exportConfig = _this.exportConfig;
        if (exportConfig && AmCharts.AmExport) {
            var amExport = _this.AmExport;
            if (!amExport) {
                _this.AmExport = new AmCharts.AmExport(this, exportConfig);
            }
        }

        if (legend) {

            legend = _this.addLegend(legend, legend.divId);

            switch (legend.position) {
                case "bottom":
                    container.appendChild(chartDiv);
                    container.appendChild(legendDiv);
                    break;
                case "top":
                    container.appendChild(legendDiv);
                    container.appendChild(chartDiv);
                    break;
                case ABSOLUTE:
                    containerStyle.width = div.style.width;
                    containerStyle.height = div.style.height;

                    legendStyle.position = ABSOLUTE;
                    chartStyle.position = ABSOLUTE;
                    if (legend.left !== UNDEFINED) {
                        legendStyle.left = legend.left + PX;
                    }
                    if (legend.right !== UNDEFINED) {
                        legendStyle.right = legend.right + PX;
                    }
                    if (legend.top !== UNDEFINED) {
                        legendStyle.top = legend.top + PX;
                    }
                    if (legend.bottom !== UNDEFINED) {
                        legendStyle.bottom = legend.bottom + PX;
                    }
                    legend.marginLeft = 0;
                    legend.marginRight = 0;

                    container.appendChild(chartDiv);
                    container.appendChild(legendDiv);
                    break;
                case "right":
                    containerStyle.width = div.style.width;
                    containerStyle.height = div.style.height;

                    legendStyle.position = RELATIVE;
                    chartStyle.position = ABSOLUTE;
                    container.appendChild(chartDiv);
                    container.appendChild(legendDiv);
                    break;
                case "left":
                    containerStyle.width = div.style.width;
                    containerStyle.height = div.style.height;
                    legendStyle.position = ABSOLUTE;
                    chartStyle.position = RELATIVE;
                    container.appendChild(chartDiv);
                    container.appendChild(legendDiv);
                    break;
                case "outside":
                    container.appendChild(chartDiv);
                    break;
            }
        } else {
            container.appendChild(chartDiv);
        }

        if (!_this.listenersAdded) {
            _this.addListeners();
            _this.listenersAdded = true;
        }

        _this.initChart();
    },

    createLabelsSet: function() {
        var _this = this;
        AmCharts.remove(_this.labelsSet);
        _this.labelsSet = _this.container.set();
        _this.freeLabelsSet.push(_this.labelsSet);
    },

    initChart: function() {

        var _this = this;

        // this is to handle backwards compatibility when numberFormatter and percentFromatter were objects
        var numberFormatter = _this.numberFormatter;
        if(numberFormatter){
            if(!isNaN(numberFormatter.precision)){
                _this.precision = numberFormatter.precision;
            }

            if(numberFormatter.thousandsSeparator !== undefined){
                _this.thousandsSeparator = numberFormatter.thousandsSeparator;
            }

            if(numberFormatter.decimalSeparator !== undefined){
                _this.decimalSeparator = numberFormatter.decimalSeparator;
            }
        }

        var percentFormatter = _this.percentFormatter;
        if(percentFormatter){
            if(!isNaN(percentFormatter.precision)){
                _this.percentPrecision = percentFormatter.precision;
            }
        }

        _this.nf = {precision:_this.precision, thousandsSeparator:_this.thousandsSeparator, decimalSeparator:_this.decimalSeparator};
        _this.pf = {precision:_this.percentPrecision, thousandsSeparator:_this.thousandsSeparator, decimalSeparator:_this.decimalSeparator};

        _this.divIsFixed = AmCharts.findIfFixed(_this.chartDiv);

        _this.previousHeight = _this.divRealHeight;
        _this.previousWidth = _this.divRealWidth;
        _this.destroy();

        _this.startInterval();

        var mouseMode = 0;
        if (document.attachEvent && !window.opera) {
            mouseMode = 1;
        }

        _this.dmouseY = 0;
        _this.dmouseX = 0;

        var element = document.getElementsByTagName('html')[0];
        if (element) {
            if (window.getComputedStyle) {
                var style = window.getComputedStyle(element, null);
                if (style) {
                    _this.dmouseY = AmCharts.removePx(style.getPropertyValue('margin-top'));
                    _this.dmouseX = AmCharts.removePx(style.getPropertyValue('margin-left'));
                }
            }
        }

        _this.mouseMode = mouseMode;

        var container = new AmCharts.AmDraw(_this.chartDiv, _this.realWidth, _this.realHeight, _this);
        container.handDrawn = _this.handDrawn;
        container.handDrawScatter = _this.handDrawScatter;
        container.handDrawThickness = _this.handDrawThickness;
        _this.container = container;


        if (AmCharts.VML || AmCharts.SVG) {
            container = _this.container;
            _this.set = container.set();
            //_this.set.setAttr("id", "mainSet");

            _this.gridSet = container.set();
            //_this.gridSet.setAttr("id", "grid");
            _this.cursorLineSet = container.set();

            _this.graphsBehindSet = container.set();

            _this.bulletBehindSet = container.set();

            _this.columnSet = container.set();
            //_this.columnSet.setAttr("id", "columns");
            _this.graphsSet = container.set();

            _this.trendLinesSet = container.set();
            //_this.trendLinesSet.setAttr("id", "trendlines");
            _this.axesLabelsSet = container.set();
            //_this.axesLabelsSet.setAttr("id", "axes labels");
            _this.axesSet = container.set();
            //_this.axesSet.setAttr("id", "axes");
            _this.cursorSet = container.set();
            //_this.cursorSet.setAttr("id", "cursor");
            _this.scrollbarsSet = container.set();
            //_this.scrollbarsSet.setAttr("id", "scrollbars");
            _this.bulletSet = container.set();
            //_this.bulletSet.setAttr("id", "bullets");
            _this.freeLabelsSet = container.set();
            //_this.freeLabelsSet.setAttr("id", "free labels");
            _this.balloonsSet = container.set();
            _this.balloonsSet.setAttr("id", "balloons");

            _this.zoomButtonSet = container.set();
            //_this.zoomButtonSet.setAttr("id", "zoom out button");
            _this.linkSet = container.set();

            _this.renderFix();
        }
    },

    measure: function() {
        var _this = this;

        var div = _this.div;
        var chartDiv = _this.chartDiv;
        var divRealWidth = div.offsetWidth;
        var divRealHeight = div.offsetHeight;
        var container = _this.container;
        var PX = "px";

        if (div.clientHeight) {
            divRealWidth = div.clientWidth;
            divRealHeight = div.clientHeight;
        }

        var paddingLeft = AmCharts.removePx(AmCharts.getStyle(div, "padding-left"));
        var paddingRight = AmCharts.removePx(AmCharts.getStyle(div, "padding-right"));
        var paddingTop = AmCharts.removePx(AmCharts.getStyle(div, "padding-top"));
        var paddingBottom = AmCharts.removePx(AmCharts.getStyle(div, "padding-bottom"));

        if (!isNaN(paddingLeft)) {
            divRealWidth -= paddingLeft;
        }
        if (!isNaN(paddingRight)) {
            divRealWidth -= paddingRight;
        }
        if (!isNaN(paddingTop)) {
            divRealHeight -= paddingTop;
        }
        if (!isNaN(paddingBottom)) {
            divRealHeight -= paddingBottom;
        }

        var divStyle = div.style;
        var w = divStyle.width;
        var h = divStyle.height;

        if (w.indexOf(PX) != -1) {
            divRealWidth = AmCharts.removePx(w);
        }
        if (h.indexOf(PX) != -1) {
            divRealHeight = AmCharts.removePx(h);
        }

        var realWidth = AmCharts.toCoordinate(_this.width, divRealWidth);
        var realHeight = AmCharts.toCoordinate(_this.height, divRealHeight);

        _this.balloon = AmCharts.processObject(_this.balloon, AmCharts.AmBalloon, _this.theme);
        _this.balloon.chart = this;

        if (realWidth != _this.previousWidth || realHeight != _this.previousHeight) {
            chartDiv.style.width = realWidth + PX;
            chartDiv.style.height = realHeight + PX;

            if (container) {
                container.setSize(realWidth, realHeight);
            }
        }
        _this.balloon.setBounds(2, 2, realWidth - 2, realHeight);

        _this.realWidth = realWidth;
        _this.realHeight = realHeight;
        _this.divRealWidth = divRealWidth;
        _this.divRealHeight = divRealHeight;
    },

    destroy: function() {
        var _this = this;
        _this.chartDiv.innerHTML = "";
        _this.clearTimeOuts();
        if (_this.interval) {
            clearInterval(_this.interval);
        }
        _this.interval = NaN;
    },

    clearTimeOuts: function() {
        var _this = this;
        var timeOuts = _this.timeOuts;
        if (timeOuts) {
            var i;
            for (i = 0; i < timeOuts.length; i++) {
                clearTimeout(timeOuts[i]);
            }
        }
        _this.timeOuts = [];
    },

    clear: function(keepChart) {
        var _this = this;
        AmCharts.callMethod("clear", [_this.chartScrollbar, _this.scrollbarV, _this.scrollbarH, _this.chartCursor]);
        _this.chartScrollbar = null;
        _this.scrollbarV = null;
        _this.scrollbarH = null;
        _this.chartCursor = null;
        _this.clearTimeOuts();

        if (_this.interval) {
            clearInterval(_this.interval);
        }

        if (_this.container) {
            _this.container.remove(_this.chartDiv);
            _this.container.remove(_this.legendDiv);
        }
        if (!keepChart) {
            AmCharts.removeChart(this);
        }
    },

    setMouseCursor: function(cursor) {
        if (cursor == "auto" && AmCharts.isNN) {
            cursor = "default";
        }
        this.chartDiv.style.cursor = cursor;
        this.legendDiv.style.cursor = cursor;
    },

    redrawLabels: function() {
        var _this = this;
        _this.labels = [];
        var allLabels = _this.allLabels;

        _this.createLabelsSet();

        var i;
        for (i = 0; i < allLabels.length; i++) {
            _this.drawLabel(allLabels[i]);
        }
    },

    drawLabel: function(label) {
        var _this = this;

        if (_this.container) {
            var x = label.x;
            var y = label.y;
            var text = label.text;
            var align = label.align;
            var size = label.size;
            var color = label.color;
            var rotation = label.rotation;
            var alpha = label.alpha;
            var bold = label.bold;
            var UNDEFINED;

            var nx = AmCharts.toCoordinate(x, _this.realWidth);
            var ny = AmCharts.toCoordinate(y, _this.realHeight);

            if (!nx) {
                nx = 0;
            }

            if (!ny) {
                ny = 0;
            }

            if (color === UNDEFINED) {
                color = _this.color;
            }
            if (isNaN(size)) {
                size = _this.fontSize;
            }
            if (!align) {
                align = "start";
            }
            if (align == "left") {
                align = "start";
            }
            if (align == "right") {
                align = "end";
            }
            if (align == "center") {
                align = "middle";
                if (!rotation) {
                    nx = _this.realWidth / 2 - nx;
                } else {
                    ny = _this.realHeight - ny + ny / 2;
                }
            }
            if (alpha === UNDEFINED) {
                alpha = 1;
            }
            if (rotation === UNDEFINED) {
                rotation = 0;
            }

            ny += size / 2;

            var labelObj = AmCharts.text(_this.container, text, color, _this.fontFamily, size, align, bold, alpha);
            labelObj.translate(nx, ny);

            if (rotation !== 0) {
                labelObj.rotate(rotation);
            }

            if (label.url) {
                labelObj.setAttr("cursor", "pointer");
                labelObj.click(function() {
                    AmCharts.getURL(label.url);
                });
            }

            _this.labelsSet.push(labelObj);
            _this.labels.push(labelObj);
        }
    },

    addLabel: function(x, y, text, align, size, color, rotation, alpha, bold, url) {
        var _this = this;
        var label = {
            x: x,
            y: y,
            text: text,
            align: align,
            size: size,
            color: color,
            alpha: alpha,
            rotation: rotation,
            bold: bold,
            url: url
        };

        if (_this.container) {
            _this.drawLabel(label);
        }
        _this.allLabels.push(label);
    },

    clearLabels: function() {
        var _this = this;
        var labels = _this.labels;
        var i;
        for (i = labels.length - 1; i >= 0; i--) {
            labels[i].remove();
        }
        _this.labels = [];
        _this.allLabels = [];
    },

    updateHeight: function() {
        var _this = this;
        var height = _this.divRealHeight;

        var legend = _this.legend;
        if (legend) {
            var legendHeight = _this.legendDiv.offsetHeight;

            var lPosition = legend.position;
            if (lPosition == "top" || lPosition == "bottom") {
                height -= legendHeight;
                if (height < 0 || isNaN(height)) {
                    height = 0;
                }
                _this.chartDiv.style.height = height + "px";
            }
        }
        return height;
    },


    updateWidth: function() {
        var _this = this;
        var width = _this.divRealWidth;
        var height = _this.divRealHeight;
        var legend = _this.legend;
        if (legend) {
            var legendDiv = _this.legendDiv;
            var legendWidth = legendDiv.offsetWidth;
            if(!isNaN(legend.width)){
                legendWidth = legend.width;
            }
            var legendHeight = legendDiv.offsetHeight;
            var legendStyle = legendDiv.style;

            var chartDiv = _this.chartDiv;
            var chartStyle = chartDiv.style;

            var lPosition = legend.position;
            var px = "px";

            if (lPosition == "right" || lPosition == "left") {
                width -= legendWidth;
                if (width < 0 || isNaN(width)) {
                    width = 0;
                }
                chartStyle.width = width + px;

                if (lPosition == "left") {
                    //chartStyle.left = (AmCharts.findPosX(_this.div) + legendWidth) + px;
                    chartStyle.left = legendWidth + px;
                } else {
                    legendStyle.left = width + px;
                }
                legendStyle.top = (height - legendHeight) / 2 + px;
            }
        }
        return width;
    },


    getTitleHeight: function() {
        var titleHeight = 0;
        var titles = this.titles;
        if (titles.length > 0) {
            titleHeight = 15;
            var i;
            for (i = 0; i < titles.length; i++) {
                var title = titles[i];
                var size = title.size;
                if(isNaN(size)){
                    size = this.fontSize + 2;
                }
                titleHeight += size + 6;
            }
        }
        return titleHeight;
    },

    addTitle: function(text, size, color, alpha, bold) {
        var _this = this;

        if (isNaN(size)) {
            size = _this.fontSize + 2;
        }
        var tObj = {
            text: text,
            size: size,
            color: color,
            alpha: alpha,
            bold: bold
        };
        _this.titles.push(tObj);
        return tObj;
    },

    addMouseWheel: function() {
        var _this = this;

        if (window.addEventListener) {
            window.addEventListener('DOMMouseScroll', function(event) {
                _this.handleWheel.call(_this, event);
            }, false);

            document.addEventListener('mousewheel', function(event) {
                _this.handleWheel.call(_this, event);
            }, false);
        }

    },

    handleWheel: function(event) {

        var _this = this;

        if (_this.mouseIsOver) {

            var delta = 0;
            if (!event) {
                event = window.event;
            }
            if (event.wheelDelta) {
                delta = event.wheelDelta / 120;
            } else if (event.detail) {
                delta = -event.detail / 3;
            }
            if (delta) {
                _this.handleWheelReal(delta, event.shiftKey);
            }
            if (event.preventDefault) {
                event.preventDefault();
            }
        }
    },

    handleWheelReal: function(delta) {
        // void
    },

    addListeners: function() {
        var _this = this;
        var chartDiv = _this.chartDiv;

        if (document.addEventListener) {

            if (_this.panEventsEnabled) {
                if ('ontouchstart' in document.documentElement) {
                    chartDiv.addEventListener('touchstart', function(event) {
                        _this.handleTouchMove.call(_this, event);
                        _this.handleTouchStart.call(_this, event);
                    }, true);

                    chartDiv.addEventListener('touchmove', function(event) {
                        _this.handleTouchMove.call(_this, event);
                    }, true);

                    chartDiv.addEventListener("touchend", function(event) {
                        _this.handleTouchEnd.call(_this, event);
                    }, true);
                }
            }

            chartDiv.addEventListener("mousedown", function(event) {
                _this.handleMouseDown.call(_this, event);
            }, true);

            chartDiv.addEventListener("mouseover", function(event) {
                _this.handleMouseOver.call(_this, event);
            }, true);

            chartDiv.addEventListener("mouseout", function(event) {
                _this.handleMouseOut.call(_this, event);
            }, true);
        } else {
            chartDiv.attachEvent("onmousedown", function(event) {
                _this.handleMouseDown.call(_this, event);
            });

            chartDiv.attachEvent("onmouseover", function(event) {
                _this.handleMouseOver.call(_this, event);
            });

            chartDiv.attachEvent("onmouseout", function(event) {
                _this.handleMouseOut.call(_this, event);
            });
        }
    },

    dispDUpd: function() {
        var _this = this;
        var type;
        if (_this.dispatchDataUpdated) {
            _this.dispatchDataUpdated = false;
            type = 'dataUpdated';
            _this.fire(type, {
                type: type,
                chart: _this
            });
        }
        if (!_this.chartCreated) {
            type = 'init';
            _this.fire(type, {
                type: type,
                chart: _this
            });
        }

        if (!_this.chartRendered) {
            type = 'rendered';
            _this.fire(type, {
                type: type,
                chart: _this
            });
            _this.chartRendered = true;
        }
        type = 'drawn';
        _this.fire(type, {
            type: type,
            chart: _this
        });
    },




    validateSize: function() {
        var _this = this;
        _this.measure();
        var legend = _this.legend;

        if (_this.realWidth != _this.previousWidth || _this.realHeight != _this.previousHeight) {

            if (_this.realWidth > 0 && _this.realHeight > 0) {
                _this.sizeChanged = true;
                if (legend) {
                    clearTimeout(_this.legendInitTO);
                    var legendInitTO = setTimeout(function() {
                        legend.invalidateSize();
                    }, 100);
                    _this.timeOuts.push(legendInitTO);
                    _this.legendInitTO = legendInitTO;
                }

                if (_this.type != "xy") {
                    _this.marginsUpdated = false;
                } else {
                    _this.marginsUpdated = true;
                }

                clearTimeout(_this.initTO);
                var initTO = setTimeout(function() {
                    _this.initChart();
                }, 150);
                _this.timeOuts.push(initTO);
                _this.initTO = initTO;
            }
        }
        _this.renderFix();
        if (legend) {
            legend.renderFix();
        }
    },

    invalidateSize: function() {
        var _this = this;
        _this.previousWidth = NaN;
        _this.previousHeight = NaN;
        _this.invalidateSizeReal();
    },

    invalidateSizeReal: function() {
        var _this = this;
        _this.marginsUpdated = false;
        clearTimeout(_this.validateTO);
        var validateTO = setTimeout(function() {
            _this.validateSize();
        }, 5);
        _this.timeOuts.push(validateTO);
        _this.validateTO = validateTO;
    },

    validateData: function(noReset) {
        var _this = this;
        if (_this.chartCreated) {
            _this.dataChanged = true;
            if (_this.type != "xy") {
                _this.marginsUpdated = false;
            } else {
                _this.marginsUpdated = true;
            }
            _this.initChart(noReset);
        }
    },

    validateNow: function() {
        var _this = this;
        _this.listenersAdded = false;
        _this.chartRendered = false;
        _this.write(_this.div);
    },

    showItem: function(dItem) {
        var _this = this;
        dItem.hidden = false;
        _this.initChart();
    },

    hideItem: function(dItem) {
        var _this = this;
        dItem.hidden = true;
        _this.initChart();
    },

    hideBalloon: function() {
        var _this = this;
        clearInterval(_this.hoverInt);
        clearTimeout(_this.balloonTO);
        _this.hoverInt = setTimeout(function() {
            _this.hideBalloonReal.call(_this);
        }, _this.hideBalloonTime);
    },

    cleanChart: function() {
        // do not delete
    },

    hideBalloonReal: function() {
        var balloon = this.balloon;
        if (balloon) {
            balloon.hide();
        }
    },

    showBalloon: function(text, color, follow, x, y) {
        var _this = this;
        clearTimeout(_this.balloonTO);
        clearInterval(_this.hoverInt);
        _this.balloonTO = setTimeout(function() {
            _this.showBalloonReal.call(_this, text, color, follow, x, y);
        }, 1);
    },

    showBalloonReal: function(text, color, follow, x, y) {
        var _this = this;
        _this.handleMouseMove();

        var balloon = _this.balloon;
        if (balloon.enabled) {
            balloon.followCursor(false);
            balloon.changeColor(color);

            if (!follow || balloon.fixedPosition) {
                balloon.setPosition(x, y);
                balloon.followCursor(false);
            } else {
                balloon.followCursor(true);
            }
            if (text) {
                balloon.showBalloon(text);
            }
        }
    },


    // EVENT HANDLERS
    handleTouchMove: function(e) {
        var _this = this;
        _this.hideBalloon();
        var x;
        var y;
        var div = _this.chartDiv;

        if (e.touches) {
            var targetEvent = e.touches.item(0);

            _this.mouseX = targetEvent.pageX - AmCharts.findPosX(div);
            _this.mouseY = targetEvent.pageY - AmCharts.findPosY(div);
        }
    },

    handleMouseOver: function(e) {
        AmCharts.resetMouseOver();
        this.mouseIsOver = true;
    },

    handleMouseOut: function(e) {
        AmCharts.resetMouseOver();
        this.mouseIsOver = false;
    },

    handleMouseMove: function(e) {
        var _this = this;
        if (_this.mouseIsOver) {

            var div = _this.chartDiv;
            if (!e) {
                e = window.event;
            }

            var x;
            var y;

            if (e) {

                _this.posX = AmCharts.findPosX(div);
                _this.posY = AmCharts.findPosY(div);

                switch (_this.mouseMode) {
                    case 1:
                        x = e.clientX - _this.posX;
                        y = e.clientY - _this.posY;

                        if (!_this.divIsFixed) {
                            var body = document.body;
                            var x1;
                            var x2;

                            if (body) {
                                x1 = body.scrollLeft;
                                y1 = body.scrollTop;
                            }

                            var documentElement = document.documentElement;
                            if (documentElement) {
                                x2 = documentElement.scrollLeft;
                                y2 = documentElement.scrollTop;
                            }

                            var dx = Math.max(x1, x2);
                            var dy = Math.max(y1, y2);

                            x += dx;
                            y += dy;
                        }
                        break;
                    case 0:
                        if (_this.divIsFixed) {
                            x = e.clientX - _this.posX;
                            y = e.clientY - _this.posY;
                        } else {
                            x = e.pageX - _this.posX;
                            y = e.pageY - _this.posY;
                        }
                        break;
                }

                if (e.touches) {
                    var targetEvent = e.touches.item(0);

                    x = targetEvent.pageX - _this.posX;
                    y = targetEvent.pageY - _this.posY;
                }

                _this.mouseX = x - _this.dmouseX;
                _this.mouseY = y - _this.dmouseY;
            }
        }
    },

    handleTouchStart: function(e) {
        this.handleMouseDown(e);
    },

    handleTouchEnd: function(e) {
        AmCharts.resetMouseOver();
        this.handleReleaseOutside(e);
    },

    handleReleaseOutside: function(e) {
        // void
    },

    handleMouseDown: function(e) {
        AmCharts.resetMouseOver();
        this.mouseIsOver = true;

        if (e) {
            if (e.preventDefault) {
                e.preventDefault();
            }
        }
    },



    addLegend: function(legend, divId) {

        var _this = this;
        legend = AmCharts.processObject(legend, AmCharts.AmLegend, _this.theme);
        legend.divId = divId;

        var div;
        if (typeof(divId) != "object" && divId) {
            div = document.getElementById(divId);
        } else {
            div = divId;
        }

        _this.legend = legend;
        legend.chart = this;
        if (div) {
            legend.div = div;
            legend.position = "outside";
            legend.autoMargins = false;
        } else {
            legend.div = _this.legendDiv;
        }
        var handleLegendEvent = _this.handleLegendEvent;

        _this.listenTo(legend, "showItem", handleLegendEvent);
        _this.listenTo(legend, "hideItem", handleLegendEvent);
        _this.listenTo(legend, "clickMarker", handleLegendEvent);
        _this.listenTo(legend, "rollOverItem", handleLegendEvent);
        _this.listenTo(legend, "rollOutItem", handleLegendEvent);
        _this.listenTo(legend, "rollOverMarker", handleLegendEvent);
        _this.listenTo(legend, "rollOutMarker", handleLegendEvent);
        _this.listenTo(legend, "clickLabel", handleLegendEvent);
        return legend;
    },

    removeLegend: function() {
        this.legend = undefined;
        this.legendDiv.innerHTML = "";
    },

    handleResize: function() {
        var _this = this;

        if (AmCharts.isPercents(_this.width) || AmCharts.isPercents(_this.height)) {
            _this.invalidateSizeReal();
        }
        _this.renderFix();
    },

    renderFix: function() {
        if (!AmCharts.VML) {
            var container = this.container;
            if (container) {
                container.renderFix();
            }
        }
    },

    getSVG: function() {
        if (AmCharts.hasSVG) {
            return this.container;
        }
    },

    animate: function(obj, attribute, from, to, time, effect, suffix) {
        var _this = this;
        var node = obj.node;
        var nodeStyle = node.style;

        if (obj["an_" + attribute]) {
            AmCharts.removeFromArray(_this.animations, obj["an_" + attribute]);
        }

        var animation = {
            obj: obj,
            frame: 0,
            attribute: attribute,
            from: from,
            to: to,
            time: time,
            effect: effect,
            suffix: suffix
        };
        obj["an_" + attribute] = animation;
        _this.animations.push(animation);

        return animation;
    },

    setLegendData: function(data) {
        var _this = this;
        var legend = _this.legend;
        if (legend) {
            legend.setData(data);
        }
    },

    startInterval: function() {
        var _this = this;
        clearInterval(_this.interval);

        _this.interval = setInterval(function() {
            _this.updateAnimations.call(_this);
        }, AmCharts.updateRate);
    },

    stopAnim: function(animation) {
        var _this = this;
        AmCharts.removeFromArray(_this.animations, animation);
    },

    updateAnimations: function() {
        var _this = this;
        var i;

        if (_this.container) {
            _this.container.update();
        }

        for (i = _this.animations.length - 1; i >= 0; i--) {
            var animation = _this.animations[i];
            var totalCount = animation.time * 1000 / AmCharts.updateRate;
            var frame = animation.frame + 1;
            var obj = animation.obj;
            var attribute = animation.attribute;

            if (frame <= totalCount) {
                var value;
                animation.frame++;

                var from = Number(animation.from);
                var to = Number(animation.to);

                var change = to - from;

                value = AmCharts[animation.effect](0, frame, from, change, totalCount);

                if (change === 0) {
                    _this.animations.splice(i, 1);
                } else {
                    obj.node.style[attribute] = value + animation.suffix;
                }
            } else {
                obj.node.style[attribute] = Number(animation.to) + animation.suffix;
                _this.animations.splice(i, 1);
            }
        }
    },

    brr: function() {
/*
        var _this = this;
        var product = _this.product;
        var url = "amcharts.com";

        var host = window.location.hostname;
        var har = host.split(".");
        var mh;
        if (har.length >= 2) {
            mh = har[har.length - 2] + "." + har[har.length - 1];
        }

        if(_this.amLink){
            var parent = _this.amLink.parentNode;
            if(parent){
                parent.removeChild(_this.amLink);
            }
        }
        var creditsPosition =_this.creditsPosition;
        var PX = "px";

        if(mh != url){

            var x0 = 0;
            var y0 = 0;
            var w = _this.realWidth;
            var h = _this.realHeight;

            if(_this.type == "serial" || _this.type == "xy"){
                x0 = _this.marginLeftReal;
                y0 = _this.marginTopReal;
                w = x0 + _this.plotAreaWidth;
                h = y0 + _this.plotAreaHeight;
            }

            var link = "http://www.amcharts.com/javascript-charts/";
            var title = "JavaScript charts";
            var txt = "JS chart by amCharts";
            if(_this.product == "ammap"){
               link = "http://www.ammap.com/javascript-maps/";
               title = "Interactive JavaScript maps";
               txt = "JS map by amCharts";
            }

            var a = document.createElement('a');
            var aLabel = document.createTextNode(txt);
            a.setAttribute('href', link);
            a.setAttribute('title', title);
            a.appendChild(aLabel);
            _this.chartDiv.appendChild(a);

            _this.amLink = a;

            var astyle = a.style;
            astyle.position = "absolute";
            astyle.textDecoration = "none";
            astyle.color = _this.color;
            astyle.fontFamily = _this.fontFamily;
            astyle.fontSize = _this.fontSize + PX;
            astyle.opacity = 0.7;
            astyle.display = "block";

            var linkWidth = a.offsetWidth;
            var linkHeight = a.offsetHeight;

            var left = 5 + x0;
            var top = y0 + 5;

            if(creditsPosition == "bottom-left"){
                left = 5 + x0;
                top = h - linkHeight - 3;
            }

            if(creditsPosition == "bottom-right"){
                left = w - linkWidth - 5;
                top = h - linkHeight - 3;
            }

            if(creditsPosition == "top-right"){
                left = w - linkWidth - 5;
                top = y0 + 5;
            }

            astyle.left = left + PX;
            astyle.top = top + PX;
        }
*/
    }

});

// declaring only
AmCharts.Slice = AmCharts.Class({
    construct: function() {}
});
AmCharts.SerialDataItem = AmCharts.Class({
    construct: function() {}
});
AmCharts.GraphDataItem = AmCharts.Class({
    construct: function() {}
});
AmCharts.Guide = AmCharts.Class({
    construct: function(theme) {
        var _this = this;
        _this.cname = "Guide";
        AmCharts.applyTheme(_this, theme, _this.cname);
    }
});

// @tag amchart
AmCharts.AmCoordinateChart = AmCharts.Class({

    inherits: AmCharts.AmChart,

    construct: function (theme) {
        var _this = this;
        AmCharts.AmCoordinateChart.base.construct.call(_this, theme);
        _this.theme = theme;
        _this.createEvents('rollOverGraphItem', 'rollOutGraphItem', 'clickGraphItem', 'doubleClickGraphItem', 'rightClickGraphItem', 'clickGraph', 'rollOverGraph', 'rollOutGraph');
        _this.startAlpha = 1;
        _this.startDuration = 0;
        _this.startEffect = 'elastic';
        _this.sequencedAnimation = true;
        _this.colors = ['#FF6600', '#FCD202', '#B0DE09', '#0D8ECF', '#2A0CD0', '#CD0D74', '#CC0000', '#00CC00', '#0000CC', '#DDDDDD', '#999999', '#333333', '#990000'];
        _this.balloonDateFormat = "MMM DD, YYYY";
        _this.valueAxes = [];
        _this.graphs = [];
        _this.guides = [];
        _this.gridAboveGraphs = false;

        AmCharts.applyTheme(_this, theme, "AmCoordinateChart");
    },

    initChart: function () {
        var _this = this;
        AmCharts.AmCoordinateChart.base.initChart.call(_this);

        var categoryAxis = _this.categoryAxis;
        if(categoryAxis){
            _this.categoryAxis = AmCharts.processObject(categoryAxis, AmCharts.CategoryAxis, _this.theme);
        }

        _this.processValueAxes();

        _this.createValueAxes();

        _this.processGraphs();

        _this.processGuides();

        if (AmCharts.VML) {
            _this.startAlpha = 1;
        }
        _this.setLegendData(_this.graphs);

        if(_this.gridAboveGraphs){
            _this.gridSet.toFront();
        }
    },


    createValueAxes: function () {
        var _this = this;
        if (_this.valueAxes.length === 0) {
            var valueAxis = new AmCharts.ValueAxis();
            _this.addValueAxis(valueAxis);
        }
    },


    parseData: function () {
        var _this = this;
        _this.processValueAxes();
        _this.processGraphs();
    },

    parseSerialData: function () {
        var _this = this;

        var graphs = _this.graphs;
        var graph;
        var emptyObj = {};
        var seriesIdField = _this.seriesIdField;
        if (!seriesIdField) {
            seriesIdField = _this.categoryField;
        }

        _this.chartData = [];
        var dataProvider = _this.dataProvider;
        if (dataProvider) {
            var parseDates = false;
            var categoryFunction;
            var categoryAxis = _this.categoryAxis;
            var forceShowField;
            if (categoryAxis) {
                parseDates = categoryAxis.parseDates;
                forceShowField = categoryAxis.forceShowField;
                categoryFunction = categoryAxis.categoryFunction;
            }

            var periodObj;
            var cleanPeriod;
            var periodCount;
            var previousTime;
            var periodDuration;

            if (parseDates) {
                periodObj = AmCharts.extractPeriod(categoryAxis.minPeriod);
                cleanPeriod = periodObj.period;
                periodCount = periodObj.count;
                periodDuration = AmCharts.getPeriodDuration(cleanPeriod, periodCount);
            }

            var lookupTable = {};
            _this.lookupTable = lookupTable;

            var i;
            var dataDateFormat = _this.dataDateFormat;
            var previousDataItem;


            for (i = 0; i < dataProvider.length; i++) {
                var serialDataItem = {};
                var dataItemRaw = dataProvider[i];
                var value = dataItemRaw[_this.categoryField];
                serialDataItem.dataContext = dataItemRaw;

                if (categoryFunction) {
                    serialDataItem.category = categoryFunction(value, dataItemRaw, categoryAxis);
                } else {
                    serialDataItem.category = String(value);
                }

                if (forceShowField) {
                    serialDataItem.forceShow = dataItemRaw[forceShowField];
                }

                var seriesId = dataItemRaw[seriesIdField];
                lookupTable[seriesId] = serialDataItem;

                if (parseDates) {

                    if (categoryAxis.categoryFunction) {
                        value = categoryAxis.categoryFunction(value, dataItemRaw, categoryAxis);
                    } else {
                        if (value instanceof Date) {
                            // it is required to get each period, as in case milliseconds are used, FF and IE won't get them
                            if (categoryAxis.minPeriod == "fff") {
                                if (AmCharts.useUTC) {
                                    value = new Date(value.getUTCFullYear(), value.getUTCMonth(), value.getUTCDate(), value.getUTCHours(), value.getUTCMinutes(), value.getUTCSeconds(), value.getUTCMilliseconds());
                                } else {
                                    value = new Date(value.getFullYear(), value.getMonth(), value.getDate(), value.getHours(), value.getMinutes(), value.getSeconds(), value.getMilliseconds());
                                }
                            }
                            // the above would do the same, but this is faster
                            else {
                                value = new Date(value);
                            }
                        } else if (dataDateFormat) {
                            value = AmCharts.stringToDate(value, dataDateFormat);
                        } else {
                            value = new Date(value);
                        }
                    }

                    value = AmCharts.resetDateToMin(value, cleanPeriod, periodCount, categoryAxis.firstDayOfWeek);

                    serialDataItem.category = value;
                    serialDataItem.time = value.getTime();
                }

                var valueAxes = _this.valueAxes;
                serialDataItem.axes = {};
                serialDataItem.x = {};
                var j;
                for (j = 0; j < valueAxes.length; j++) {
                    var axisId = valueAxes[j].id;

                    serialDataItem.axes[axisId] = {};
                    serialDataItem.axes[axisId].graphs = {};
                    var k;
                    for (k = 0; k < graphs.length; k++) {
                        graph = graphs[k];
                        var graphId = graph.id;

                        var periodValue = graph.periodValue;

                        if (graph.valueAxis.id == axisId) {
                            serialDataItem.axes[axisId].graphs[graphId] = {};

                            var graphDataItem = {};
                            graphDataItem.index = i;

                            var rawItem = dataItemRaw;
                            if (graph.dataProvider) {
                                rawItem = emptyObj;
                            }

                            graphDataItem.values = _this.processValues(rawItem, graph, periodValue);

                            if(!graph.connect){
                                if(previousDataItem){
                                    if(serialDataItem.time - previousTime > periodDuration * 1.1){
                                        previousDataItem.gap = true;
                                    }
                                }
                            }

                            _this.processFields(graph, graphDataItem, rawItem);

                            graphDataItem.category = serialDataItem.category;
                            graphDataItem.serialDataItem = serialDataItem;
                            graphDataItem.graph = graph;
                            serialDataItem.axes[axisId].graphs[graphId] = graphDataItem;
                        }
                    }
                }
                _this.chartData[i] = serialDataItem;
                previousTime = serialDataItem.time;
                previousDataItem = graphDataItem;
            }
        }

        var g;
        for (g = 0; g < graphs.length; g++) {
            graph = graphs[g];
            if (graph.dataProvider) {
                _this.parseGraphData(graph);
            }
        }
    },


    processValues: function (dataItemRaw, graph, periodValue) {
        var values = {};
        var val;
        var candle = false;
        if ((graph.type == "candlestick" || graph.type == "ohlc") && periodValue !== "") {
            candle = true;
        }
        val = Number(dataItemRaw[graph.valueField + periodValue]);

        if (!isNaN(val)) {
            values.value = val;
        }

        // error
        val = Number(dataItemRaw[graph.errorField + periodValue]);

        if (!isNaN(val)) {
            values.error = val;
        }
        // end of error

        if (candle) {
            periodValue = "Open";
        }

        val = Number(dataItemRaw[graph.openField + periodValue]);

        if (!isNaN(val)) {
            values.open = val;
        }

        if (candle) {
            periodValue = "Close";
        }

        val = Number(dataItemRaw[graph.closeField + periodValue]);
        if (!isNaN(val)) {
            values.close = val;
        }

        if (candle) {
            periodValue = "Low";
        }

        val = Number(dataItemRaw[graph.lowField + periodValue]);
        if (!isNaN(val)) {
            values.low = val;
        }

        if (candle) {
            periodValue = "High";
        }

        val = Number(dataItemRaw[graph.highField + periodValue]);
        if (!isNaN(val)) {
            values.high = val;
        }

        return values;
    },


    parseGraphData: function (graph) {
        var _this = this;
        var dataProvider = graph.dataProvider;
        var categoryField = graph.categoryField;
        if (!categoryField) {
            categoryField = _this.categoryField;
        }

        var seriesIdField = graph.seriesIdField;
        if (!seriesIdField) {
            seriesIdField = _this.seriesIdField;
        }
        if (!seriesIdField) {
            seriesIdField = _this.categoryField;
        }
        var i;
        for (i = 0; i < dataProvider.length; i++) {
            var dataItemRaw = dataProvider[i];
            var seriesId = String(dataItemRaw[seriesIdField]);
            var serialDataItem = _this.lookupTable[seriesId];
            var chartId = graph.chart.id;
            var axisId = graph.valueAxis.id;

            if (serialDataItem) {
                var graphDataItem = serialDataItem.axes[axisId].graphs[graph.id];
                graphDataItem.serialDataItem = serialDataItem;
                var periodValue = graph.periodValue;
                graphDataItem.values = _this.processValues(dataItemRaw, graph, periodValue);
                _this.processFields(graph, graphDataItem, dataItemRaw);
            }
        }
    },


    addValueAxis: function (axis) {
        var _this = this;
        axis.chart = this;
        _this.valueAxes.push(axis);
        _this.validateData();
    },

    removeValueAxesAndGraphs: function () {
        var _this = this;
        var valueAxes = _this.valueAxes;
        var i;
        for (i = valueAxes.length - 1; i > -1; i--) {
            _this.removeValueAxis(valueAxes[i]);
        }
    },

    removeValueAxis: function (valueAxis) {
        var _this = this;
        var graphs = _this.graphs;
        var i;

        for (i = graphs.length - 1; i >= 0; i--) {
            var graph = graphs[i];
            if (graph) {
                if (graph.valueAxis == valueAxis) {
                    _this.removeGraph(graph);
                }
            }
        }

        var valueAxes = _this.valueAxes;

        for (i = valueAxes.length - 1; i >= 0; i--) {
            if (valueAxes[i] == valueAxis) {
                valueAxes.splice(i, 1);
            }
        }
        _this.validateData();
    },

    addGraph: function (graph) {
        var _this = this;
        _this.graphs.push(graph);
        _this.chooseGraphColor(graph, _this.graphs.length - 1);
        _this.validateData();
    },

    removeGraph: function (graph) {
        var _this = this;
        var graphs = _this.graphs;
        var i;
        for (i = graphs.length - 1; i >= 0; i--) {
            if (graphs[i] == graph) {
                graphs.splice(i, 1);
                graph.destroy();
            }
        }
        _this.validateData();
    },

    processValueAxes: function () {
        var _this = this;
        var valueAxes = _this.valueAxes;
        var i;

        for (i = 0; i < valueAxes.length; i++) {
            var valueAxis = valueAxes[i];
            valueAxis = AmCharts.processObject(valueAxis, AmCharts.ValueAxis, _this.theme);
            valueAxes[i] = valueAxis;
            valueAxis.chart = this;

            if (!valueAxis.id) {
                valueAxis.id = "valueAxisAuto" + i + "_" + new Date().getTime();
            }
            if (valueAxis.usePrefixes === undefined) {
                valueAxis.usePrefixes = _this.usePrefixes;
            }
        }
    },

    processGuides: function () {
        var _this = this;
        var guides = _this.guides;
        var categoryAxis = _this.categoryAxis;
        if(guides){
            for(var i = 0; i < guides.length; i++){
                var guide = guides[i];
                if(guide.category !== undefined || guide.date !== undefined){
                    if(categoryAxis){
                        categoryAxis.addGuide(guide);
                    }
                }
                if(guide.valueAxis){
                    guide.valueAxis.addGuide(guide);
                }
                else if(!isNaN(guide.value)){
                    _this.valueAxes[0].addGuide(guide);
                }
            }
        }
    },

    processGraphs: function () {
        var _this = this;
        var graphs = _this.graphs;
        var i;

        for (i = 0; i < graphs.length; i++) {
            var graph = graphs[i];

            graph = AmCharts.processObject(graph, AmCharts.AmGraph, _this.theme);
            graphs[i] = graph;
            _this.chooseGraphColor(graph, i);

            graph.chart = this;

            if(AmCharts.isString(graph.valueAxis)){
                graph.valueAxis = _this.getValueAxisById(graph.valueAxis);
            }

            if (!graph.valueAxis) {
                graph.valueAxis = _this.valueAxes[0];
            }

            if (!graph.id) {
                graph.id = "graphAuto" + i + "_" + new Date().getTime();
            }
        }
    },

    formatString: function (text, dItem, noFixBrakes) {
        var _this = this;
        var graph = dItem.graph;

        // format duration
        var valAxis = graph.valueAxis;
        if (valAxis.duration) {
            if (dItem.values.value) {
                var duration = AmCharts.formatDuration(dItem.values.value, valAxis.duration, "", valAxis.durationUnits, valAxis.maxInterval, valAxis.numberFormatter);
                text = text.split("[[value]]").join(duration);
            }
        }

        text = AmCharts.massReplace(text, {
            "[[title]]": graph.title,
                "[[description]]": dItem.description
        });
        if(!noFixBrakes){
           text = AmCharts.fixBrakes(text);
        }
        else{
            // balloon
           text = AmCharts.fixNewLines(text);
        }
        text = AmCharts.cleanFromEmpty(text);

        return text;
    },


    getBalloonColor: function (graph, graphDataItem, graphIsPriority) {
        var _this = this;
        var color = graph.lineColor;
        var balloonColor = graph.balloonColor;

        if(graphIsPriority){
            balloonColor = color;
        }

        var fillColors = graph.fillColorsR;
        var UNDEFINED;

        if (typeof (fillColors) == 'object') {
            color = fillColors[0];
        } else if (fillColors !== UNDEFINED) {
            color = fillColors;
        }

        if (graphDataItem.isNegative) {
            var negativeColor = graph.negativeLineColor;
            var negativeFillColors = graph.negativeFillColors;
            if (typeof (negativeFillColors) == 'object') {
                negativeColor = negativeFillColors[0];
            } else if (negativeFillColors !== UNDEFINED) {
                negativeColor = negativeFillColors;
            }

            if (negativeColor !== UNDEFINED) {
                color = negativeColor;
            }
        }

        if (graphDataItem.color !== UNDEFINED) {
            color = graphDataItem.color;
        }

        if (balloonColor === UNDEFINED) {
            balloonColor = color;
        }
        return balloonColor;
    },

    getGraphById: function (id) {
        return AmCharts.getObjById(this.graphs, id);
    },

    getValueAxisById: function (id) {
        return AmCharts.getObjById(this.valueAxes, id);
    },


    processFields: function (graph, graphDataItem, dataItemRaw) {
        var _this = this;
        if (graph.itemColors) {
            var itemColors = graph.itemColors;
            var index = graphDataItem.index;

            if (index < itemColors.length) {
                graphDataItem.color = itemColors[index];
            } else {
                graphDataItem.color = AmCharts.randomColor();
            }
        }

        var fields = ['lineColor', 'color', 'alpha', 'fillColors', 'description', 'bullet', 'customBullet', 'bulletSize', 'bulletConfig', 'url', 'labelColor', 'dashLength', 'pattern'];
        var i;
        for (i = 0; i < fields.length; i++) {
            var field = fields[i];
            var fieldName = graph[field + 'Field'];

            if (fieldName) {
                var val = dataItemRaw[fieldName];
                if (AmCharts.isDefined(val)) {
                    graphDataItem[field] = val;
                }
            }
        }
        graphDataItem.dataContext = dataItemRaw;
    },

    chooseGraphColor: function (graph, index) {

        var _this = this;
        if (!graph.lineColor) {
            var color;
            if (_this.colors.length > index) {
                color = _this.colors[index];
            } else {
                color = AmCharts.randomColor();
            }

            graph.lineColorR = color;
        }
        else{
            graph.lineColorR = graph.lineColor;
        }
        if(!graph.fillColors){
            graph.fillColorsR = graph.lineColorR;
        }
        else{
            graph.fillColorsR = graph.fillColors;
        }
        if(!graph.bulletBorderColor){
            if(graph.useLineColorForBulletBorder){
                graph.bulletBorderColorR = graph.lineColorR;
            }
            else{
                graph.bulletBorderColorR = graph.bulletColor;
            }
        }
        else{
            graph.bulletBorderColorR = graph.bulletBorderColor;
        }

        if(!graph.bulletColor){
            graph.bulletColorR =graph.lineColorR;
        }
        else{
            graph.bulletColorR = graph.bulletColor;
        }

        var patterns = _this.patterns;
        if(patterns){
            graph.pattern = patterns[index];
        }
    },

    handleLegendEvent: function (event) {
        var _this = this;
        var type = event.type;
        var dataItem = event.dataItem;
        if(!_this.legend.data){
            if (dataItem) {
                var hidden = dataItem.hidden;
                var showBalloon = dataItem.showBalloon;

                switch (type) {
                    case 'clickMarker':
                        if (showBalloon) {
                            _this.hideGraphsBalloon(dataItem);
                        } else {
                            _this.showGraphsBalloon(dataItem);
                        }
                        break;

                    case 'clickLabel':

                        if (showBalloon) {
                            _this.hideGraphsBalloon(dataItem);
                        } else {
                            _this.showGraphsBalloon(dataItem);
                        }
                        break;

                    case 'rollOverItem':
                        if (!hidden) {
                            _this.highlightGraph(dataItem);
                        }
                        break;

                    case 'rollOutItem':
                        if (!hidden) {
                            _this.unhighlightGraph();
                        }
                        break;

                    case 'hideItem':
                        _this.hideGraph(dataItem);
                        break;

                    case 'showItem':
                        _this.showGraph(dataItem);
                        break;
                }
            }
        }
    },


    highlightGraph: function (thisGraph) {
        var _this = this;
        var graphs = _this.graphs;
        var i;
        var alpha = 0.2;

        if (_this.legend) {
            alpha = _this.legend.rollOverGraphAlpha;
        }

        if (alpha != 1) {
            for (i = 0; i < graphs.length; i++) {
                var graph = graphs[i];
                if (graph != thisGraph) {
                    graph.changeOpacity(alpha);
                }
            }
        }
    },

    unhighlightGraph: function () {
        var _this = this;
        var alpha;

        if (_this.legend) {
            alpha = _this.legend.rollOverGraphAlpha;
        }

        if (alpha != 1) {
            var graphs = _this.graphs;
            var i;
            for (i = 0; i < graphs.length; i++) {
                var graph = graphs[i];
                graph.changeOpacity(1);
            }
        }
    },

    showGraph: function (graph) {
        var _this = this;
        graph.hidden = false;
        _this.dataChanged = true;
        _this.marginsUpdated = false;
        if (_this.chartCreated) {
            _this.initChart();
        }
    },

    hideGraph: function (graph) {
        var _this = this;
        _this.dataChanged = true;
        _this.marginsUpdated = false;
        graph.hidden = true;
        if (_this.chartCreated) {
            _this.initChart();
        }
    },

    hideGraphsBalloon: function (graph) {
        var _this = this;
        graph.showBalloon = false;
        _this.updateLegend();
    },

    showGraphsBalloon: function (graph) {
        var _this = this;
        graph.showBalloon = true;
        _this.updateLegend();
    },

    updateLegend: function () {
        var _this = this;
        if (_this.legend) {
            _this.legend.invalidateSize();
        }
    },

    resetAnimation: function () {
        var _this = this;
        var graphs = _this.graphs;
        if (graphs) {
            var i;
            for (i = 0; i < graphs.length; i++) {
                graphs[i].animationPlayed = false;
            }
        }
    },

    animateAgain: function () {
        var _this = this;
        _this.resetAnimation();
        _this.validateNow();
    }

});

// @tag amchart
AmCharts.AmGraph = AmCharts.Class({

    construct: function(theme) {
        var _this = this;
        _this.cname = "AmGraph";
        _this.createEvents('rollOverGraphItem', 'rollOutGraphItem', 'clickGraphItem', 'doubleClickGraphItem', 'rightClickGraphItem', 'clickGraph', 'rollOverGraph', 'rollOutGraph');
        _this.type = "line";
        _this.stackable = true;
        _this.columnCount = 1;
        _this.columnIndex = 0;
        _this.showBalloon = true;
        _this.centerCustomBullets = true;
        _this.maxBulletSize = 50;
        _this.minBulletSize = 4;
        _this.balloonText = "[[value]]";
        _this.animationPlayed = false;
        _this.scrollbar = false;
        _this.hidden = false;
        //_this.columnWidth;
        _this.pointPosition = "middle";
        _this.depthCount = 1;
        _this.includeInMinMax = true;
        _this.negativeBase = 0;
        _this.visibleInLegend = true;
        _this.showAllValueLabels = false;
        _this.showBalloonAt = "close";
        _this.showBulletsAt = "close";
        _this.lineThickness = 1;
        _this.dashLength = 0;
        _this.connect = true;
        _this.lineAlpha = 1;
        _this.bullet = "none";
        _this.bulletBorderThickness = 2;
        _this.bulletBorderAlpha = 0;
        _this.bulletAlpha = 1;
        _this.bulletSize = 8;
        _this.bulletOffset = 0;
        _this.hideBulletsCount = 0;
        _this.labelPosition = "top";
        _this.cornerRadiusTop = 0;
        _this.cursorBulletAlpha = 1;
        _this.gradientOrientation = "vertical";
        _this.dx = 0;
        _this.dy = 0;
        _this.periodValue = "";
        _this.clustered = true;
        _this.periodSpan = 1;
        //_this.useLineColorForBulletBorder = false;
        //_this.showHandOnHover;
        _this.x = 0;
        _this.y = 0;
        _this.minDistance = 1;
        //_this.legendPeriodValueText;
        AmCharts.applyTheme(_this, theme, _this.cname);
    },

    draw: function() {

        var _this = this;
        var chart = _this.chart;
        // handling backwards compatibility with numberformatter
        if(!isNaN(_this.precision)){
            if(!_this.numberFormatter){
                _this.numberFormatter = {precision:_this.precision, decimalSeparator:chart.decimalSeparator, thousandsSeparator:chart.thousandsSeparator};
            }
            else{
                _this.numberFormatter.precision = _this.precision;
            }
        }

        var container = chart.container;
        _this.container = container;

        _this.destroy();
        var set = container.set();
        var bulletSet = container.set();


        if (_this.behindColumns) {
            chart.graphsBehindSet.push(set);
            chart.bulletBehindSet.push(bulletSet);
        } else {
            chart.graphsSet.push(set);
            chart.bulletSet.push(bulletSet);
        }

        var bulletAxis = _this.bulletAxis;
        if (AmCharts.isString(bulletAxis)) {
            _this.bulletAxis = chart.getValueAxisById(bulletAxis);
        }

        _this.bulletSet = bulletSet;

        if (!_this.scrollbar) {
            var x = chart.marginLeftReal;
            var y = chart.marginTopReal;
            set.translate(x, y);
            bulletSet.translate(x, y);
        }


        var columnsSet = container.set();
        AmCharts.remove(_this.columnsSet);
        set.push(columnsSet);
        _this.set = set;
        _this.columnsSet = columnsSet;

        _this.columnsArray = [];
        _this.ownColumns = [];
        _this.allBullets = [];
        _this.animationArray = [];

        if (AmCharts.ifArray(_this.data)) {
            var create = false;

            if (_this.chart.type == "xy") {
                if (_this.xAxis.axisCreated && _this.yAxis.axisCreated) {
                    create = true;
                }
            } else {
                if (_this.valueAxis.axisCreated) {
                    create = true;
                }
            }
            if (!_this.hidden && create) {
                _this.createGraph();
            }
        }
    },


    createGraph: function() {
        var _this = this;
        var chart = _this.chart;
        var UNDEFINED;

        if (_this.labelPosition == "inside" && _this.type != "column") {
            _this.labelPosition = "bottom";
        }

        _this.startAlpha = chart.startAlpha;

        _this.seqAn = chart.sequencedAnimation;
        _this.baseCoord = _this.valueAxis.baseCoord;

        if (_this.fillAlphas === UNDEFINED) {
            _this.fillAlphas = 0;
        }

        _this.bulletColorR = _this.bulletColor;
        if (_this.bulletColorR === UNDEFINED) {
            _this.bulletColorR = _this.lineColorR;
            _this.bulletColorNegative = _this.negativeLineColor;
        }

        if (_this.bulletAlpha === UNDEFINED) {
            _this.bulletAlpha = _this.lineAlpha;
        }

        /*
        if (!_this.bulletBorderColor) {
            _this.bulletBorderAlpha = 0;
        }
       */

        clearTimeout(_this.playedTO);
        if (!isNaN(_this.valueAxis.min) && !isNaN(_this.valueAxis.max)) {
            switch (chart.type) {
                case "serial":
                    if (_this.categoryAxis) {
                        _this.createSerialGraph();

                        if (_this.type == "candlestick") {
                            var valueAxis = _this.valueAxis;
                            if (valueAxis.minMaxMultiplier < 1) {
                                _this.positiveClip(_this.set);
                            }
                        }
                    }

                    break;
                case "radar":
                    _this.createRadarGraph();
                    break;
                case "xy":
                    _this.createXYGraph();
                    _this.positiveClip(_this.set);
                    break;
            }

            _this.playedTO = setTimeout(function() {
                _this.setAnimationPlayed.call(_this);
            }, _this.chart.startDuration * 500);
        }
    },

    setAnimationPlayed: function() {
        this.animationPlayed = true;
    },

    createXYGraph: function() {
        var _this = this;
        var labelPosition = _this.labelPosition;
        var xx = [];
        var yy = [];

        var xAxis = _this.xAxis;
        var yAxis = _this.yAxis;

        _this.pmh = yAxis.viH + 1;
        _this.pmw = xAxis.viW + 1;
        _this.pmx = 0;
        _this.pmy = 0;
        var i;

        for (i = _this.start; i <= _this.end; i++) {
            var serialDataItem = _this.data[i];
            var graphDataItem = serialDataItem.axes[xAxis.id].graphs[_this.id];

            var values = graphDataItem.values;
            var xValue = values.x;
            var yValue = values.y;
            var value = values.value;

            var xxx = xAxis.getCoordinate(xValue);
            var yyy = yAxis.getCoordinate(yValue);

            if (!isNaN(xValue) && !isNaN(yValue)) {
                xx.push(xxx);
                yy.push(yyy);

                var bulletSize = _this.createBullet(graphDataItem, xxx, yyy, i);
                if (!bulletSize) {
                    bulletSize = 0;
                }

                // LABELS ////////////////////////////////////////////////////////
                var labelText = _this.labelText;
                if (labelText) {
                    var lText = _this.createLabel(graphDataItem, xxx, yyy, labelText);
                    _this.allBullets.push(lText);
                    _this.positionLabel(xxx, yyy, lText, _this.labelPosition, bulletSize);
                }
            }
        }
        _this.drawLineGraph(xx, yy);
        _this.launchAnimation();
    },


    createRadarGraph: function() {
        var _this = this;
        var stackType = _this.valueAxis.stackType;
        var xx = [];
        var yy = [];
        var firstX;
        var firstY;

        var i;
        for (i = _this.start; i <= _this.end; i++) {
            var serialDataItem = _this.data[i];
            var graphDataItem = serialDataItem.axes[_this.valueAxis.id].graphs[_this.id];

            var close;

            if (stackType == "none" || stackType == "3d") {
                close = graphDataItem.values.value;
            } else {
                close = graphDataItem.values.close;
            }


            if (isNaN(close)) {
                _this.drawLineGraph(xx, yy);
                xx = [];
                yy = [];
            } else {
                var coord = _this.y - (_this.valueAxis.getCoordinate(close) - _this.height);
                var angle = 180 - 360 / (_this.end - _this.start + 1) * i;

                var xxx = (coord * Math.sin((angle) / (180) * Math.PI));
                var yyy = (coord * Math.cos((angle) / (180) * Math.PI));

                xx.push(xxx);
                yy.push(yyy);

                var bulletSize = _this.createBullet(graphDataItem, xxx, yyy, i);

                if (!bulletSize) {
                    bulletSize = 0;
                }

                // LABELS ////////////////////////////////////////////////////////
                var labelText = _this.labelText;
                if (labelText) {
                    var lText = _this.createLabel(graphDataItem, xxx, yyy, labelText);
                    _this.allBullets.push(lText);
                    _this.positionLabel(xxx, yyy, lText, _this.labelPosition, bulletSize);
                }
                if (isNaN(firstX)) {
                    firstX = xxx;
                }
                if (isNaN(firstY)) {
                    firstY = yyy;
                }
            }
        }
        xx.push(firstX);
        yy.push(firstY);

        _this.drawLineGraph(xx, yy);
        _this.launchAnimation();
    },


    positionLabel: function(x, y, lText, labelPosition, bulletSize) {
        var _this = this;
        var bbox = lText.getBBox();
        var fontSize = _this.fontSize;
        if (fontSize === undefined) {
            fontSize = _this.chart.fontSize;
        }

        var dx = 0;
        var dy = 0;
        switch (labelPosition) {
            case "left":
                x -= ((bbox.width + bulletSize) / 2 + 2);
                dx = bbox.width / 2;
                dy = -2;
                break;
            case "top":
                y -= ((bulletSize + bbox.height) / 2 + 1);
                break;
            case "right":
                x += (bbox.width + bulletSize) / 2 + 2;
                dx = bbox.width / 2;
                dy = -2;
                break;
            case "bottom":
                y += (bulletSize + bbox.height) / 2 + 1;
                break;
        }

        lText.translate(x, y);
    },

    getGradRotation: function() {
        var _this = this;
        var gradientRotation = 270;
        if (_this.gradientOrientation == "horizontal") {
            gradientRotation = 0;
        }
        _this.gradientRotation = gradientRotation;
        return gradientRotation;
    },

    createSerialGraph: function() {

        var _this = this;
        var UNDEFINED;
        _this.lineColorSwitched = UNDEFINED;
        _this.fillColorsSwitched = UNDEFINED;
        _this.dashLengthSwitched = UNDEFINED;
        var chart = _this.chart;
        var id = _this.id;
        var index = _this.index;
        var data = _this.data;
        var container = _this.chart.container;
        var valueAxis = _this.valueAxis;
        var type = _this.type;
        var columnWidth = _this.columnWidthReal;
        var showBulletsAt = _this.showBulletsAt;

        if (!isNaN(_this.columnWidth)) {
            columnWidth = _this.columnWidth;
        }

        if (isNaN(columnWidth)) {
            columnWidth = 0.8; // this is mainly for scrollbar
        }

        var width = _this.width;
        var height = _this.height;
        var x = _this.x;
        var y = _this.y;
        var rotate = _this.rotate;
        var columnCount = _this.columnCount;
        var crt = AmCharts.toCoordinate(_this.cornerRadiusTop, columnWidth / 2);
        var connect = _this.connect;
        var xx = [];
        var yy = [];
        var previousxClose;
        var previousyClose;
        var previousxOpen;
        var previousyOpen;
        var totalGarphs = _this.chart.graphs.length;
        var depth;
        var dx = _this.dx / _this.depthCount;
        var dy = _this.dy / _this.depthCount;
        var stackType = valueAxis.stackType;
        var labelPosition = _this.labelPosition;
        var start = _this.start;
        var end = _this.end;
        var scrollbar = _this.scrollbar;
        var categoryAxis = _this.categoryAxis;
        var baseCoord = _this.baseCoord;
        var negativeBase = _this.negativeBase;
        var columnIndex = _this.columnIndex;
        var lineThickness = _this.lineThickness;
        var lineAlpha = _this.lineAlpha;
        var lineColor = _this.lineColorR;
        var dashLength = _this.dashLength;
        var set = _this.set;

        // backward compatibility with old flash version
        /*
        if (labelPosition == "above") {
            labelPosition = "top";
        }
        if (labelPosition == "below") {
            labelPosition = "bottom";
        }*/
        var labelPositionOriginal = labelPosition;
        var timeout;

        var gradientRotation = _this.getGradRotation();

        var columnSpacing = _this.chart.columnSpacing;
        var cellWidth = categoryAxis.cellWidth;
        var maxSpacing = (cellWidth * columnWidth - columnCount) / columnCount;
        if (columnSpacing > maxSpacing) {
            columnSpacing = maxSpacing;
        }

        var serialDataItem;
        var graphDataItem;
        var value;

        // dimensions and position of positive mask
        var pmh = height + 1;
        var pmw = width + 1;
        var pmx = 0;
        var pmy = 0;
        // dimensions and position of negative mask
        var nmh;
        var nmw;
        var nmx;
        var nmy;

        var fillColors = _this.fillColorsR;
        var negativeFillColors = _this.negativeFillColors;
        var negativeLineColor = _this.negativeLineColor;
        var fillAlphas = _this.fillAlphas;
        var negativeFillAlphas = _this.negativeFillAlphas;

        // arrays of fillAlphas are not supported, but might be received, take first value only.
        if (typeof(fillAlphas) == 'object') {
            fillAlphas = fillAlphas[0];
        }
        if (typeof(negativeFillAlphas) == 'object') {
            negativeFillAlphas = negativeFillAlphas[0];
        }

        // get coordinate of minimum axis value
        var minCoord = valueAxis.getCoordinate(valueAxis.min);

        if (valueAxis.logarithmic) {
            minCoord = valueAxis.getCoordinate(valueAxis.minReal);
        }
        _this.minCoord = minCoord;

        // bullet could be set previously if only one data point was available
        if (_this.resetBullet) {
            _this.bullet = "none";
        }
        // if it's line/smoothedLine/step graph, mask (clip rectangle will be applied on a line. Calculate mask dimensions here.
        if (!scrollbar && (type == "line" || type == "smoothedLine" || type == "step")) {
            // if it's line/smoothedLine and there is one data point only, set bullet to round if not set any
            if (data.length == 1 && type != "step" && _this.bullet == "none") {
                _this.bullet = "round";
                _this.resetBullet = true;
            }
            // only need to do adjustments if negative colors are set
            if (negativeFillColors || negativeLineColor != UNDEFINED) {
                var zeroValue = negativeBase;
                if (zeroValue > valueAxis.max) {
                    zeroValue = valueAxis.max;
                }

                if (zeroValue < valueAxis.min) {
                    zeroValue = valueAxis.min;
                }

                if (valueAxis.logarithmic) {
                    zeroValue = valueAxis.minReal;
                }

                var zeroCoord = valueAxis.getCoordinate(zeroValue);

                var maxCoord = valueAxis.getCoordinate(valueAxis.max);

                if (rotate) {
                    pmh = height;
                    pmw = Math.abs(maxCoord - zeroCoord);
                    nmh = height;
                    nmw = Math.abs(minCoord - zeroCoord);

                    pmy = 0;
                    nmy = 0;

                    if (valueAxis.reversed) {
                        pmx = 0;
                        nmx = zeroCoord;
                    } else {
                        pmx = zeroCoord;
                        nmx = 0;
                    }
                } else {
                    pmw = width;
                    pmh = Math.abs(maxCoord - zeroCoord);
                    nmw = width;
                    nmh = Math.abs(minCoord - zeroCoord);

                    pmx = 0;
                    nmx = 0;

                    if (valueAxis.reversed) {
                        nmy = y;
                        pmy = zeroCoord;
                    } else {
                        nmy = zeroCoord + 1;
                    }
                }
            }
        }
        var round = Math.round;

        _this.pmx = round(pmx);
        _this.pmy = round(pmy);
        _this.pmh = round(pmh);
        _this.pmw = round(pmw);

        _this.nmx = round(nmx);
        _this.nmy = round(nmy);
        _this.nmh = round(nmh);
        _this.nmw = round(nmw);

        if (!AmCharts.isModern) {
            _this.nmx = 0;
            _this.nmy = 0;
            _this.nmh = _this.height;
        }

        // get column width
        if (type == "column") {
            columnWidth = (cellWidth * columnWidth - (columnSpacing * (columnCount - 1))) / columnCount;
        } else {
            columnWidth = cellWidth * columnWidth;
        }
        // set one pixel if actual width is less
        if (columnWidth < 1) {
            columnWidth = 1;
        }

        // find first not missing value
        var i;
        if (type == "line" || type == "step" || type == "smoothedLine") {
            if (start > 0) {
                for (i = start - 1; i > -1; i--) {
                    serialDataItem = data[i];
                    graphDataItem = serialDataItem.axes[valueAxis.id].graphs[id];
                    value = graphDataItem.values.value;

                    if (!isNaN(value)) {
                        start = i;
                        break;
                    }
                }
                // if lineColorField or other simmilar are set, we need to check if there are any set before
                if (_this.lineColorField) {
                    for (i = start; i > -1; i--) {

                        serialDataItem = data[i];
                        graphDataItem = serialDataItem.axes[valueAxis.id].graphs[id];

                        if (graphDataItem.lineColor) {
                            _this.lineColorSwitched = graphDataItem.lineColor;
                            _this.bulletColorSwitched = _this.lineColorSwitched;
                            break;
                        }
                    }
                }

                if (_this.fillColorsField) {
                    for (i = start; i > -1; i--) {

                        serialDataItem = data[i];
                        graphDataItem = serialDataItem.axes[valueAxis.id].graphs[id];

                        if (graphDataItem.fillColors) {
                            _this.fillColorsSwitched = graphDataItem.fillColors;
                            break;
                        }
                    }
                }

                if (_this.dashLengthField) {
                    for (i = start; i > -1; i--) {

                        serialDataItem = data[i];
                        graphDataItem = serialDataItem.axes[valueAxis.id].graphs[id];

                        if (!isNaN(graphDataItem.dashLength)) {
                            _this.dashLengthSwitched = graphDataItem.dashLength;
                            break;
                        }
                    }
                }

            }
            if (end < data.length - 1) {
                for (i = end + 1; i < data.length; i++) {
                    serialDataItem = data[i];
                    graphDataItem = serialDataItem.axes[valueAxis.id].graphs[id];
                    value = graphDataItem.values.value;

                    if (!isNaN(value)) {
                        end = i;
                        break;
                    }
                }
            }
        }
        // add one more
        if (end < data.length - 1) {
            end++;
        }

        var sxx = [];
        var syy = [];

        var stackableLine = false;
        if (type == "line" || type == "step" || type == "smoothedLine") {
            if (_this.stackable && stackType == "regular" || stackType == "100%" || _this.fillToGraph) {
                stackableLine = true;
            }
        }

        var noStepRisers = _this.noStepRisers;

        var previousLX = -1000;
        var previousLY = -1000;
        var minDistance = _this.minDistance;
        ///////////////////////////////////////////////////////////////////////////
        // now go through all data items and get coordinates or draw actual objects
        for (i = start; i <= end; i++) {
            serialDataItem = data[i];
            graphDataItem = serialDataItem.axes[valueAxis.id].graphs[id];
            graphDataItem.index = i;

            var cx;
            var cy;
            var cw;
            var ch;
            var finalDimension;
            var property;
            var xxx = NaN;
            var xClose = NaN;
            var yClose = NaN;
            var xOpen = NaN;
            var yOpen = NaN;
            var xLow = NaN;
            var yLow = NaN;
            var xHigh = NaN;
            var yHigh = NaN;

            var labelX = NaN;
            var labelY = NaN;
            var bulletX = NaN;
            var bulletY = NaN;

            var close = NaN;
            var high = NaN;
            var low = NaN;
            var open = NaN;
            var cuboid = UNDEFINED;

            var fillColorsReal = fillColors;
            var fillAlphasReal = fillAlphas;
            var lineColorReal = lineColor;
            var borderColor;
            var cset;

            var pattern = _this.pattern;
            if (graphDataItem.pattern != UNDEFINED) {
                pattern = graphDataItem.pattern;
            }

            if (graphDataItem.color != UNDEFINED) {
                fillColorsReal = graphDataItem.color;
            }

            if (graphDataItem.fillColors) {
                fillColorsReal = graphDataItem.fillColors;
            }

            if (!isNaN(graphDataItem.alpha)) {
                fillAlphasReal = graphDataItem.alpha;
            }

            if (!isNaN(graphDataItem.dashLength)) {
                dashLength = graphDataItem.dashLength;
            }

            var values = graphDataItem.values;
            if (valueAxis.recalculateToPercents) {
                values = graphDataItem.percents;
            }

            if (values) {
                if (!_this.stackable || stackType == "none" || stackType == "3d") {
                    close = values.value;
                } else {
                    close = values.close;
                }

                // in case candlestick
                if (type == "candlestick" || type == "ohlc") {
                    close = values.close;
                    low = values.low;
                    yLow = valueAxis.getCoordinate(low);

                    high = values.high;
                    yHigh = valueAxis.getCoordinate(high);
                }

                open = values.open;
                yClose = valueAxis.getCoordinate(close);

                if (!isNaN(open)) {
                    yOpen = valueAxis.getCoordinate(open);
                }

                // do not store y if this is scrollbar
                if (!scrollbar) {
                    switch (_this.showBalloonAt) {
                        case "close":
                            graphDataItem.y = yClose;
                            break;
                        case "open":
                            graphDataItem.y = yOpen;
                            break;
                        case "high":
                            graphDataItem.y = yHigh;
                            break;
                        case "low":
                            graphDataItem.y = yLow;
                            break;
                    }
                }

                // x coordinate
                xxx = serialDataItem.x[categoryAxis.id];
                var periodSpan = _this.periodSpan - 1;

                var stepLineDelta1 = Math.floor(cellWidth / 2) + Math.floor(periodSpan * cellWidth / 2);
                var stepLineDelta2 = stepLineDelta1;
                var stepShift = 0;
                if(_this.stepDirection == "left"){
                    stepShift = (cellWidth * 2 + periodSpan * cellWidth) / 2;
                    xxx -= stepShift;
                }

                if (_this.pointPosition == "start") {
                    xxx -= cellWidth / 2 +  Math.floor(periodSpan * cellWidth / 2);
                    stepLineDelta1 = 0;
                    stepLineDelta2 = Math.floor(cellWidth) + Math.floor(periodSpan * cellWidth);
                }

                if (_this.pointPosition == "end") {
                    xxx += cellWidth / 2 + Math.floor(periodSpan * cellWidth / 2);
                    stepLineDelta1 = Math.floor(cellWidth) + Math.floor(periodSpan * cellWidth);
                    stepLineDelta2 = 0;
                }

                if (noStepRisers) {
                    var stepWidth = _this.columnWidth;

                    if (!isNaN(stepWidth)) {
                        stepLineDelta1 = stepWidth * stepLineDelta1;
                        stepLineDelta2 = stepWidth * stepLineDelta2;
                    }
                }

                if (!scrollbar) {
                    graphDataItem.x = xxx;
                }

                // fix to avoid wrong behavior when lines are too long
                // theorethically this is not 100% correct approach, but visually there is no any diference.
                var maxmax = 100000;

                if (xxx < -maxmax) {
                    xxx = -maxmax;
                }

                if (xxx > width + maxmax) {
                    xxx = width + maxmax;
                }

                if (rotate) {
                    xClose = yClose;
                    xOpen = yOpen;

                    yClose = xxx;
                    yOpen = xxx;

                    if (isNaN(open) && !_this.fillToGraph) {
                        xOpen = baseCoord;
                    }

                    xLow = yLow;
                    xHigh = yHigh;
                } else {
                    xClose = xxx;
                    xOpen = xxx;

                    if (isNaN(open) && !_this.fillToGraph) {
                        yOpen = baseCoord;
                    }
                }

                if (close < open) {
                    graphDataItem.isNegative = true;

                    if (negativeFillColors) {
                        fillColorsReal = negativeFillColors;
                    }

                    if (negativeFillAlphas) {
                        fillAlphasReal = negativeFillAlphas;
                    }

                    if (negativeLineColor != UNDEFINED) {
                        lineColorReal = negativeLineColor;
                    }
                }



                switch (type) {
                    // LINE
                    case "line":
                        if (!isNaN(close)) {
                            if (close < negativeBase) {
                                graphDataItem.isNegative = true;
                            } else {
                                graphDataItem.isNegative = false;
                            }

                            if(Math.abs(xClose - previousLX) >= minDistance || Math.abs(yClose - previousLY) >= minDistance){
                                xx.push(xClose);
                                yy.push(yClose);

                                previousLX = xClose;
                                previousLY = yClose;
                            }

                            labelX = xClose;
                            labelY = yClose;
                            bulletX = xClose;
                            bulletY = yClose;

                            if (stackableLine) {
                                if (!isNaN(yOpen) && !isNaN(xOpen)) {
                                    sxx.push(xOpen);
                                    syy.push(yOpen);
                                }
                            }
                            if (graphDataItem.lineColor != UNDEFINED || graphDataItem.fillColors != UNDEFINED || !isNaN(graphDataItem.dashLength)) {
                                _this.drawLineGraph(xx, yy, sxx, syy);
                                xx = [xClose];
                                yy = [yClose];

                                sxx = [];
                                syy = [];

                                if(stackableLine){
                                    if (!isNaN(yOpen) && !isNaN(xOpen)) {
                                        sxx.push(xOpen);
                                        syy.push(yOpen);
                                    }
                                }

                                _this.lineColorSwitched = graphDataItem.lineColor;
                                _this.fillColorsSwitched = graphDataItem.fillColors;
                                _this.dashLengthSwitched = graphDataItem.dashLength;
                            }

                            if(graphDataItem.gap){
                                _this.drawLineGraph(xx, yy, sxx, syy);
                                xx = [];
                                yy = [];

                                sxx = [];
                                syy = [];
                            }

                        } else if (!connect) {
                            _this.drawLineGraph(xx, yy, sxx, syy);
                            xx = [];
                            yy = [];

                            sxx = [];
                            syy = [];
                        }
                        break;

                    case "smoothedLine":
                        if (!isNaN(close)) {
                            if (close < negativeBase) {
                                graphDataItem.isNegative = true;
                            } else {
                                graphDataItem.isNegative = false;
                            }


                            if(Math.abs(xClose - previousLX) >= minDistance || Math.abs(yClose - previousLY) >= minDistance){
                                xx.push(xClose);
                                yy.push(yClose);

                                previousLX = xClose;
                                previousLY = yClose;
                            }

                            labelX = xClose;
                            labelY = yClose;
                            bulletX = xClose;
                            bulletY = yClose;

                            if (stackableLine) {
                                if (!isNaN(yOpen) && !isNaN(xOpen)) {
                                    sxx.push(xOpen);
                                    syy.push(yOpen);
                                }
                            }
                            if (graphDataItem.lineColor != UNDEFINED || graphDataItem.fillColors != UNDEFINED || !isNaN(graphDataItem.dashLength)) {
                                _this.drawSmoothedGraph(xx, yy, sxx, syy);
                                xx = [xClose];
                                yy = [yClose];

                                sxx = [];
                                syy = [];

                                if(stackableLine){
                                    if (!isNaN(yOpen) && !isNaN(xOpen)) {
                                        sxx.push(xOpen);
                                        syy.push(yOpen);
                                    }
                                }

                                _this.lineColorSwitched = graphDataItem.lineColor;
                                _this.fillColorsSwitched = graphDataItem.fillColors;
                                _this.dashLengthSwitched = graphDataItem.dashLength;
                            }
                            if(graphDataItem.gap){
                                _this.drawSmoothedGraph(xx, yy, sxx, syy);
                                xx = [];
                                yy = [];

                                sxx = [];
                                syy = [];
                            }

                        } else if (!connect) {
                            _this.drawSmoothedGraph(xx, yy, sxx, syy);
                            xx = [];
                            yy = [];

                            sxx = [];
                            syy = [];
                        }
                        break;

                        // STEP
                    case "step":
                        if (!isNaN(close)) {
                            if (close < negativeBase) {
                                graphDataItem.isNegative = true;
                            } else {
                                graphDataItem.isNegative = false;
                            }

                            if (graphDataItem.lineColor != UNDEFINED || graphDataItem.fillColors != UNDEFINED || !isNaN(graphDataItem.dashLength)) {
                                _this.drawLineGraph(xx, yy, sxx, syy);
                                xx = [];
                                yy = [];

                                sxx = [];
                                syy = [];
                                _this.lineColorSwitched = graphDataItem.lineColor;
                                _this.fillColorsSwitched = graphDataItem.fillColors;
                                _this.dashLengthSwitched = graphDataItem.dashLength;
                            }

                            if (rotate) {
                                if (!isNaN(previousxClose)) {
                                    xx.push(previousxClose);
                                    yy.push(yClose - stepLineDelta1);
                                }
                                yy.push(yClose - stepLineDelta1);
                                xx.push(xClose);
                                yy.push(yClose + stepLineDelta2);
                                xx.push(xClose);

                                if (stackableLine) {
                                    if (!isNaN(yOpen) && !isNaN(xOpen)) {
                                        sxx.push(previousxOpen);
                                        syy.push(yOpen - stepLineDelta1);
                                        sxx.push(xOpen);
                                        syy.push(yOpen - stepLineDelta1);
                                        sxx.push(xOpen);
                                        syy.push(yOpen + stepLineDelta2);
                                    }
                                }
                            } else {
                                if (!isNaN(previousyClose)) {
                                    yy.push(previousyClose);
                                    xx.push(previousxClose);

                                    yy.push(previousyClose);
                                    xx.push(xClose - stepLineDelta1);
                                }
                                xx.push(xClose - stepLineDelta1);
                                yy.push(yClose);
                                xx.push(xClose + stepLineDelta2);
                                yy.push(yClose);

                                if (stackableLine) {
                                    if (!isNaN(yOpen) && !isNaN(xOpen)) {
                                        sxx.push(xOpen - stepLineDelta1);
                                        syy.push(previousyOpen);

                                        sxx.push(xOpen - stepLineDelta1);
                                        syy.push(yOpen);
                                        sxx.push(xOpen + stepLineDelta2);
                                        syy.push(yOpen);
                                    }
                                }
                            }
                            previousxClose = xClose;
                            previousyClose = yClose;
                            previousxOpen = xOpen;
                            previousyOpen = yOpen;
                            labelX = xClose;
                            labelY = yClose;
                            bulletX = xClose;
                            bulletY = yClose;

                            if (noStepRisers || graphDataItem.gap) {
                                previousyClose = NaN;
                                previousxClose = NaN;

                                _this.drawLineGraph(xx, yy, sxx, syy);
                                xx = [];
                                yy = [];

                                sxx = [];
                                syy = [];
                            }
                        } else if (!connect) {
                            if (_this.periodSpan <= 1 || (_this.periodSpan > 1 && xClose - previousxClose > stepLineDelta1 + stepLineDelta2)) {
                                previousyClose = NaN;
                                previousxClose = NaN;
                            }
                            _this.drawLineGraph(xx, yy, sxx, syy);
                            xx = [];
                            yy = [];

                            sxx = [];
                            syy = [];
                        }
                        break;


                        // COLUMN
                    case "column":
                        borderColor = lineColorReal;
                        if (graphDataItem.lineColor != UNDEFINED) {
                            borderColor = graphDataItem.lineColor;
                        }

                        if (!isNaN(close)) {
                            if (close < negativeBase) {
                                graphDataItem.isNegative = true;

                                if (negativeFillColors) {
                                    fillColorsReal = negativeFillColors;
                                }

                                if (negativeLineColor != UNDEFINED) {
                                    borderColor = negativeLineColor;
                                }
                            } else {
                                graphDataItem.isNegative = false;
                            }
                            var min = valueAxis.min;
                            var max = valueAxis.max;

                            if ((close < min && open < min) || (close > max && open > max)) {
                                // void
                            } else {
                                if (rotate) {
                                    if (stackType == '3d') {
                                        cy = yClose - 0.5 * (columnWidth + columnSpacing) + columnSpacing / 2 + dy * columnIndex;
                                        cx = xOpen + dx * columnIndex;
                                    } else {
                                        cy = Math.floor(yClose - (columnCount / 2 - columnIndex) * (columnWidth + columnSpacing) + columnSpacing / 2);
                                        cx = xOpen;
                                    }

                                    cw = columnWidth;

                                    labelX = xClose;
                                    labelY = cy + columnWidth / 2;

                                    bulletX = xClose;
                                    bulletY = cy + columnWidth / 2;

                                    if (cy + cw > height) {
                                        cw = height - cy;
                                    }

                                    if (cy < 0) {
                                        cw += cy;
                                        cy = 0;
                                    }

                                    ch = xClose - xOpen;
                                    var cxr = cx;
                                    cx = AmCharts.fitToBounds(cx, 0, width);
                                    ch = ch + (cxr - cx);
                                    ch = AmCharts.fitToBounds(ch, -cx, width - cx + dx * columnIndex);

                                    if (cy < height && cw > 0) {
                                        cuboid = new AmCharts.Cuboid(container, ch, cw, dx - chart.d3x, dy - chart.d3y, fillColorsReal, fillAlphasReal, lineThickness, borderColor, lineAlpha, gradientRotation, crt, rotate, dashLength, pattern);

                                        if (labelPosition != "bottom" && labelPosition != "inside" && labelPosition != "middle") {
                                            if (!valueAxis.reversed) {
                                                labelPosition = "right";
                                            } else {
                                                labelPosition = "left";
                                            }

                                            if (close < 0) {
                                                if (!valueAxis.reversed) {
                                                    labelPosition = "left";
                                                } else {
                                                    labelPosition = "right";
                                                }
                                            } else {
                                                if (stackType == "regular" || stackType == "100%") {
                                                    labelX += _this.dx;
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if (stackType == '3d') {
                                        cx = xClose - 0.5 * (columnWidth + columnSpacing) + columnSpacing / 2 + dx * columnIndex;
                                        cy = yOpen + dy * columnIndex;
                                    } else {
                                        cx = xClose - (columnCount / 2 - columnIndex) * (columnWidth + columnSpacing) + columnSpacing / 2;
                                        cy = yOpen;
                                    }
                                    cw = columnWidth;

                                    labelX = cx + columnWidth / 2;
                                    labelY = yClose;

                                    bulletX = cx + columnWidth / 2;
                                    bulletY = yClose;

                                    if (cx + cw > width + columnIndex * dx) {
                                        cw = width - cx + columnIndex * dx;
                                    }

                                    if (cx < 0) {
                                        cw += cx;
                                        cx = 0;
                                    }

                                    ch = yClose - yOpen;

                                    var cyr = cy;
                                    cy = AmCharts.fitToBounds(cy, _this.dy, height);
                                    ch = ch + (cyr - cy);
                                    ch = AmCharts.fitToBounds(ch, -cy + dy * columnIndex, height - cy);

                                    if (cx < width + columnIndex * dx && cw > 0) {
                                        cuboid = new AmCharts.Cuboid(container, cw, ch, dx - chart.d3x, dy - chart.d3y, fillColorsReal, fillAlphasReal, lineThickness, borderColor, _this.lineAlpha, gradientRotation, crt, rotate, dashLength, pattern);

                                        if (close < 0 && labelPosition != "middle" && labelPosition != "inside") {
                                            labelPosition = "bottom";
                                        } else {
                                            labelPosition = labelPositionOriginal;
                                            if (stackType == "regular" || stackType == "100%") {
                                                labelY += _this.dy;
                                            }
                                        }
                                    }
                                }
                            }


                            if (cuboid) {
                                cset = cuboid.set;

                                cset.translate(cx, cy);
                                _this.columnsSet.push(cset);

                                if (graphDataItem.url || _this.showHandOnHover) {
                                    cset.setAttr("cursor", "pointer");
                                }

                                // in case columns array is passed (it is not passed only for the scrollers chart, as it can't be 3d
                                // all columns are placed into array with predicted depth, then sorted by depth in Serial Chart and
                                // added to columnsContainer which was created in AmSerialChart class
                                if (!scrollbar) {
                                    if (stackType == "none") {
                                        if (rotate) {
                                            depth = (_this.end + 1 - i) * totalGarphs - index;
                                        } else {
                                            depth = totalGarphs * i + index;
                                        }
                                    }

                                    if (stackType == "3d") {
                                        if (rotate) {
                                            depth = (totalGarphs - index) * (_this.end + 1 - i);
                                            labelX += dx * _this.columnIndex;
                                            bulletX += dx * _this.columnIndex;
                                            graphDataItem.y += dx * _this.columnIndex;

                                        } else {
                                            depth = (totalGarphs - index) * (i + 1);
                                            labelX += 3;
                                            labelY += dy * _this.columnIndex + 7;
                                            bulletY += dy * _this.columnIndex;
                                            graphDataItem.y += dy * _this.columnIndex;
                                        }

                                    }
                                    if (stackType == "regular" || stackType == "100%") {
                                        if (labelPosition != "inside") {
                                            labelPosition = "middle";
                                        }
                                        if (rotate) {
                                            if (values.value > 0) {
                                                depth = (_this.end + 1 - i) * totalGarphs + index;
                                            } else {
                                                depth = (_this.end + 1 - i) * totalGarphs - index;
                                            }
                                        } else {
                                            if (values.value > 0) {
                                                depth = (totalGarphs * i) + index;
                                            } else {
                                                depth = totalGarphs * i - index;
                                            }
                                        }
                                    }

                                    _this.columnsArray.push({
                                        column: cuboid,
                                        depth: depth
                                    });

                                    if (rotate) {
                                        graphDataItem.x = cy + cw / 2;
                                    } else {
                                        graphDataItem.x = cx + cw / 2;
                                    }
                                    _this.ownColumns.push(cuboid);
                                    _this.animateColumns(cuboid, i, xClose, xOpen, yClose, yOpen);
                                    _this.addListeners(cset, graphDataItem);
                                }
                                //graphDataItem.columnSprite = cset;
                            }
                        }
                        break;
                        // CANDLESTICK
                    case "candlestick":
                        if (!isNaN(open) && !isNaN(close)) {

                            var highLine;
                            var lowLine;

                            borderColor = lineColorReal;
                            if (graphDataItem.lineColor != UNDEFINED) {
                                borderColor = graphDataItem.lineColor;
                            }

                            if (rotate) {
                                cy = yClose - columnWidth / 2;
                                cx = xOpen;

                                cw = columnWidth;
                                if (cy + cw > height) {
                                    cw = height - cy;
                                }

                                if (cy < 0) {
                                    cw += cy;
                                    cy = 0;
                                }

                                if (cy < height && cw > 0) {
                                    var xArrayHigh;
                                    var xArrayLow;

                                    if (close > open) {
                                        xArrayHigh = [xClose, xHigh];
                                        xArrayLow = [xOpen, xLow];
                                    } else {
                                        xArrayHigh = [xOpen, xHigh];
                                        xArrayLow = [xClose, xLow];
                                    }
                                    if (!isNaN(xHigh) && !isNaN(xLow)) {
                                        if (yClose < height && yClose > 0) {
                                            highLine = AmCharts.line(container, xArrayHigh, [yClose, yClose], borderColor, lineAlpha, lineThickness);
                                            lowLine = AmCharts.line(container, xArrayLow, [yClose, yClose], borderColor, lineAlpha, lineThickness);
                                        }
                                    }
                                    ch = xClose - xOpen;

                                    cuboid = new AmCharts.Cuboid(container, ch, cw, dx, dy, fillColorsReal, fillAlphas, lineThickness, borderColor, lineAlpha, gradientRotation, crt, rotate, dashLength, pattern);
                                }
                            } else {
                                cx = xClose - columnWidth / 2;
                                cy = yOpen + lineThickness / 2;

                                cw = columnWidth;
                                if (cx + cw > width) {
                                    cw = width - cx;
                                }

                                if (cx < 0) {
                                    cw += cx;
                                    cx = 0;
                                }

                                ch = yClose - yOpen;

                                if (cx < width && cw > 0) {
                                    cuboid = new AmCharts.Cuboid(container, cw, ch, dx, dy, fillColorsReal, fillAlphasReal, lineThickness, borderColor, lineAlpha, gradientRotation, crt, rotate, dashLength, pattern);
                                    var yArrayHigh;
                                    var yArrayLow;
                                    if (close > open) {
                                        yArrayHigh = [yClose, yHigh];
                                        yArrayLow = [yOpen, yLow];
                                    } else {
                                        yArrayHigh = [yOpen, yHigh];
                                        yArrayLow = [yClose, yLow];
                                    }
                                    if (!isNaN(yHigh) && !isNaN(yLow)) {
                                        if (xClose < width && xClose > 0) {
                                            highLine = AmCharts.line(container, [xClose, xClose], yArrayHigh, borderColor, lineAlpha, lineThickness);
                                            lowLine = AmCharts.line(container, [xClose, xClose], yArrayLow, borderColor, lineAlpha, lineThickness);
                                        }
                                    }
                                }
                            }
                            if (cuboid) {
                                cset = cuboid.set;
                                set.push(cset);
                                cset.translate(cx, cy - lineThickness / 2);

                                if (graphDataItem.url || _this.showHandOnHover) {
                                    cset.setAttr("cursor", "pointer");
                                }

                                if (highLine) {
                                    set.push(highLine);
                                    set.push(lowLine);
                                }

                                labelX = xClose;
                                labelY = yClose;

                                if(rotate){
                                    bulletY = yClose;
                                    bulletX = xClose;
                                    if(showBulletsAt == "open"){
                                        bulletX = xOpen;
                                    }
                                    if(showBulletsAt == "high"){
                                        bulletX = xHigh;
                                    }
                                    if(showBulletsAt == "low"){
                                        bulletX = xLow;
                                    }
                                }
                                else{
                                    bulletY = yClose;
                                    if(showBulletsAt == "open"){
                                        bulletY = yOpen;
                                    }
                                    if(showBulletsAt == "high"){
                                        bulletY = yHigh;
                                    }
                                    if(showBulletsAt == "low"){
                                        bulletY = yLow;
                                    }
                                    bulletX = xClose;
                                }



                                if (!scrollbar) {
                                    if (rotate) {
                                        graphDataItem.x = cy + cw / 2;
                                    } else {
                                        graphDataItem.x = cx + cw / 2;
                                    }

                                    _this.animateColumns(cuboid, i, xClose, xOpen, yClose, yOpen);

                                    _this.addListeners(cset, graphDataItem);
                                }
                            }
                        }
                        break;

                        // OHLC ////////////////////////
                    case "ohlc":
                        if (!isNaN(open) && !isNaN(high) && !isNaN(low) && !isNaN(close)) {
                            if (close < open) {
                                graphDataItem.isNegative = true;

                                if (negativeLineColor != UNDEFINED) {
                                    lineColorReal = negativeLineColor;
                                }
                            }
                            var verticalLine;
                            var openLine;
                            var closeLine;
                            if (rotate) {
                                var y1 = yClose - columnWidth / 2;
                                y1 = AmCharts.fitToBounds(y1, 0, height);
                                var y2 = AmCharts.fitToBounds(yClose, 0, height);
                                var y3 = yClose + columnWidth / 2;
                                y3 = AmCharts.fitToBounds(y3, 0, height);
                                openLine = AmCharts.line(container, [xOpen, xOpen], [y1, y2], lineColorReal, lineAlpha, lineThickness, dashLength);
                                if (yClose > 0 && yClose < height) {
                                    verticalLine = AmCharts.line(container, [xLow, xHigh], [yClose, yClose], lineColorReal, lineAlpha, lineThickness, dashLength);
                                }

                                closeLine = AmCharts.line(container, [xClose, xClose], [y2, y3], lineColorReal, lineAlpha, lineThickness, dashLength);
                            } else {
                                var x1 = xClose - columnWidth / 2;
                                x1 = AmCharts.fitToBounds(x1, 0, width);
                                var x2 = AmCharts.fitToBounds(xClose, 0, width);
                                var x3 = xClose + columnWidth / 2;
                                x3 = AmCharts.fitToBounds(x3, 0, width);
                                openLine = AmCharts.line(container, [x1, x2], [yOpen, yOpen], lineColorReal, lineAlpha, lineThickness, dashLength);
                                if (xClose > 0 && xClose < width) {
                                    verticalLine = AmCharts.line(container, [xClose, xClose], [yLow, yHigh], lineColorReal, lineAlpha, lineThickness, dashLength);
                                }
                                closeLine = AmCharts.line(container, [x2, x3], [yClose, yClose], lineColorReal, lineAlpha, lineThickness, dashLength);
                            }

                            set.push(openLine);
                            set.push(verticalLine);
                            set.push(closeLine);

                            labelX = xClose;
                            labelY = yClose;
                            bulletX = xClose;
                            bulletY = yClose;
                        }
                        break;
                }

                // BULLETS AND LABELS
                if (!scrollbar && !isNaN(close)) {
                    var hideBulletsCount = _this.hideBulletsCount;
                    if (_this.end - _this.start <= hideBulletsCount || hideBulletsCount === 0) {
                        var bulletSize = _this.createBullet(graphDataItem, bulletX, bulletY, i);

                        if (!bulletSize) {
                            bulletSize = 0;
                        }



                        // LABELS ////////////////////////////////////////////////////////
                        var labelText = _this.labelText;
                        if (labelText) {
                            var lText = _this.createLabel(graphDataItem, 0, 0, labelText);
                            var lx = 0;
                            var ly = 0;
                            var bbox = lText.getBBox();
                            var textWidth = bbox.width;
                            var textHeight = bbox.height;

                            switch (labelPosition) {
                                case "left":
                                    lx = -(textWidth / 2 + bulletSize / 2 + 3);
                                    break;
                                case "top":
                                    ly = -(textHeight / 2 + bulletSize / 2 + 3);
                                    break;
                                case "right":
                                    lx = bulletSize / 2 + 2 + textWidth / 2;
                                    break;
                                case "bottom":
                                    if (rotate && type == "column") {
                                        labelX = baseCoord;

                                        if (close < 0 || (close > 0 && valueAxis.reversed)) {
                                            lx = -6;
                                            lText.attr({
                                                'text-anchor': 'end'
                                            });
                                        } else {
                                            lx = 6;
                                            lText.attr({
                                                'text-anchor': 'start'
                                            });
                                        }
                                    } else {
                                        ly = bulletSize / 2 + textHeight / 2;
                                        lText.x = -(textWidth / 2 + 2);
                                    }
                                    break;
                                case "middle":
                                    if (type == "column") {
                                        if (rotate) {
                                            ly = -(textHeight / 2) + _this.fontSize / 2;
                                            lx = -(xClose - xOpen) / 2 - dx;
                                            if (ch < 0) {
                                                lx += dx;
                                            }

                                            if (Math.abs(xClose - xOpen) < textWidth) {
                                                if (!_this.showAllValueLabels) {
                                                    lText.remove();
                                                    lText = null;
                                                }
                                            }
                                        } else {
                                            ly = -(yClose - yOpen) / 2;
                                            if (ch < 0) {
                                                ly -= dy;
                                            }

                                            if (Math.abs(yClose - yOpen) < textHeight) {
                                                if (!_this.showAllValueLabels) {
                                                    lText.remove();
                                                    lText = null;
                                                }
                                            }
                                        }
                                    }
                                    break;
                                case "inside":
                                    if (rotate) {
                                        ly = -(textHeight / 2) + _this.fontSize / 2;
                                        if (ch < 0) {
                                            lx = textWidth / 2 + 6;
                                        } else {
                                            lx = -textWidth / 2 - 6;
                                        }

                                    } else {
                                        if (ch < 0) {
                                            ly = textHeight;
                                        } else {

                                            ly = -textHeight;
                                        }
                                    }

                                    break;
                            }


                            if (lText) {
                                if (!isNaN(labelY) && !isNaN(labelX)) {
                                    labelX += lx;
                                    labelY += ly;
                                    lText.translate(labelX, labelY);

                                    if (rotate) {
                                        if (labelY < 0 || labelY > height) {
                                            lText.remove();
                                            lText = null;
                                        }
                                    } else {
                                        var ddx = 0;
                                        if (stackType == "3d") {
                                            ddx = dx * columnIndex;
                                        }

                                        if (labelX < 0 || labelX > width + ddx) {
                                            lText.remove();
                                            lText = null;
                                        }
                                    }
                                } else {
                                    lText.remove();
                                    lText = null;
                                }
                                if (lText) {
                                    _this.allBullets.push(lText);
                                }

                            }
                        }
                        // TOTALS
                        if (stackType == "regular" || stackType == "100%") {
                            var totalText = valueAxis.totalText;
                            if (totalText) {
                                var tText = _this.createLabel(graphDataItem, 0, 0, totalText, valueAxis.totalTextColor);
                                _this.allBullets.push(tText);

                                var tbox = tText.getBBox();
                                var tWidth = tbox.width;
                                var tHeight = tbox.height;
                                var tx;
                                var ty;

                                var previousTotal = valueAxis.totals[i];
                                if (previousTotal) {
                                    previousTotal.remove();
                                }

                                var lDelta = 0;
                                if (type != "column") {
                                    lDelta = bulletSize;
                                }

                                if (rotate) {
                                    ty = yClose;
                                    if (close < 0) {
                                        tx = xClose - tWidth / 2 - 2 - lDelta;
                                    } else {
                                        tx = xClose + tWidth / 2 + 3 + lDelta;
                                    }
                                } else {
                                    tx = xClose;
                                    if (close < 0) {
                                        ty = yClose + tHeight / 2 + lDelta;
                                    } else {
                                        ty = yClose - tHeight / 2 - 3 - lDelta;
                                    }
                                }
                                tText.translate(tx, ty);
                                valueAxis.totals[i] = tText;

                                if (rotate) {
                                    if (ty < 0 || ty > height) {
                                        tText.remove();
                                    }
                                } else {
                                    if (tx < 0 || tx > width) {
                                        tText.remove();
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }


        if (type == "line" || type == "step" || type == "smoothedLine") {
            if (type == "smoothedLine") {
                _this.drawSmoothedGraph(xx, yy, sxx, syy);
            } else {
                _this.drawLineGraph(xx, yy, sxx, syy);
            }
            if (!scrollbar) {
                _this.launchAnimation();
            }
        }

        if (_this.bulletsHidden) {
            _this.hideBullets();
        }
    },

    animateColumns: function(cuboid, i, xClose, xOpen, yClose, yOpen) {
        var _this = this;

        var duration = _this.chart.startDuration;

        if (duration > 0 && !_this.animationPlayed) {
            if (_this.seqAn) {
                cuboid.set.hide();
                _this.animationArray.push(cuboid);
                var timeout = setTimeout(function() {
                    _this.animate.call(_this);
                }, duration / (_this.end - _this.start + 1) * (i - _this.start) * 1000);
                _this.timeOuts.push(timeout);
            } else {
                _this.animate(cuboid);
            }
        }
    },

    createLabel: function(graphDataItem, labelX, labelY, labelText, textColor) {
        var _this = this;
        var chart = _this.chart;
        var numberFormatter = _this.numberFormatter;
        if (!numberFormatter) {
            numberFormatter = chart.nf;
        }

        var color = graphDataItem.labelColor;
        if (!color) {
            color = _this.color;
        }
        if (!color) {
            color = chart.color;
        }
        if (textColor) {
            color = textColor;
        }

        var fontSize = _this.fontSize;
        if (fontSize === undefined) {
            fontSize = chart.fontSize;
            _this.fontSize = fontSize;
        }

        var text = chart.formatString(labelText, graphDataItem);
        text = AmCharts.cleanFromEmpty(text);

        var lText = AmCharts.text(_this.container, text, color, chart.fontFamily, fontSize);
        lText.translate(labelX, labelY);

        _this.bulletSet.push(lText);
        return lText;
    },

    positiveClip: function(obj) {
        var _this = this;
        obj.clipRect(_this.pmx, _this.pmy, _this.pmw, _this.pmh);
    },

    negativeClip: function(obj) {
        var _this = this;
        obj.clipRect(_this.nmx, _this.nmy, _this.nmw, _this.nmh);
    },


    drawLineGraph: function(xx, yy, sxx, syy) {
        var _this = this;
        if (xx.length > 1) {
            var set = _this.set;
            var container = _this.container;

            var positiveSet = container.set();
            var negativeSet = container.set();

            set.push(negativeSet);
            set.push(positiveSet);


            var lineAlpha = _this.lineAlpha;
            var lineThickness = _this.lineThickness;

            var fillAlphas = _this.fillAlphas;
            var lineColor = _this.lineColorR;


            var negativeLineAlpha = _this.negativeLineAlpha;
            if (isNaN(negativeLineAlpha)) {
                negativeLineAlpha = lineAlpha;
            }

            var lineColorSwitched = _this.lineColorSwitched;
            if (lineColorSwitched) {
                lineColor = lineColorSwitched;
            }

            var fillColors = _this.fillColorsR;

            var fillColorsSwitched = _this.fillColorsSwitched;
            if (fillColorsSwitched) {
                fillColors = fillColorsSwitched;
            }

            var dashLength = _this.dashLength;
            var dashLengthSwitched = _this.dashLengthSwitched;
            if (dashLengthSwitched) {
                dashLength = dashLengthSwitched;
            }

            var negativeLineColor = _this.negativeLineColor;
            var negativeFillColors = _this.negativeFillColors;
            var negativeFillAlphas = _this.negativeFillAlphas;

            var baseCoord = _this.baseCoord;

            if (_this.negativeBase !== 0) {
                baseCoord = _this.valueAxis.getCoordinate(_this.negativeBase);
            }

            // draw lines
            var line = AmCharts.line(container, xx, yy, lineColor, lineAlpha, lineThickness, dashLength, false, true);
            positiveSet.push(line);

            positiveSet.click(function(ev) {
                _this.handleGraphEvent(ev, 'clickGraph');
            }).mouseover(function(ev) {
                _this.handleGraphEvent(ev, 'rollOverGraph');
            }).mouseout(function(ev) {
                _this.handleGraphEvent(ev, 'rollOutGraph');
            });

            if (negativeLineColor !== undefined) {
                var negativeLine = AmCharts.line(container, xx, yy, negativeLineColor, negativeLineAlpha, lineThickness, dashLength, false, true);
                negativeSet.push(negativeLine);
            }

            if (fillAlphas > 0 || negativeFillAlphas > 0) {
                var xxx = xx.join(";").split(";");
                var yyy = yy.join(";").split(";");

                if (_this.chart.type == "serial") {
                    if (sxx.length > 0) {
                        sxx.reverse();
                        syy.reverse();

                        xxx = xx.concat(sxx);
                        yyy = yy.concat(syy);
                    } else {
                        if (_this.rotate) {
                            yyy.push(yyy[yyy.length - 1]);
                            xxx.push(baseCoord);
                            yyy.push(yyy[0]);
                            xxx.push(baseCoord);
                            yyy.push(yyy[0]);
                            xxx.push(xxx[0]);
                        } else {
                            xxx.push(xxx[xxx.length - 1]);
                            yyy.push(baseCoord);
                            xxx.push(xxx[0]);
                            yyy.push(baseCoord);
                            xxx.push(xx[0]);
                            yyy.push(yyy[0]);
                        }
                    }
                }
                var gradientRotation = _this.gradientRotation;

                if (fillAlphas > 0) {
                    var fill = AmCharts.polygon(container, xxx, yyy, fillColors, fillAlphas, 1, "#000", 0, gradientRotation);
                    fill.pattern(_this.pattern);
                    positiveSet.push(fill);
                }

                if (negativeFillColors || negativeLineColor !== undefined) {
                    if (isNaN(negativeFillAlphas)) {
                        negativeFillAlphas = fillAlphas;
                    }
                    if (!negativeFillColors) {
                        negativeFillColors = negativeLineColor;
                    }

                    var negativeFill = AmCharts.polygon(container, xxx, yyy, negativeFillColors, negativeFillAlphas, 1, "#000", 0, gradientRotation);
                    negativeFill.pattern(_this.pattern);
                    negativeSet.push(negativeFill);

                    negativeSet.click(function(ev) {
                        _this.handleGraphEvent(ev, 'clickGraph');
                    }).mouseover(function(ev) {
                        _this.handleGraphEvent(ev, 'rollOverGraph');
                    }).mouseout(function(ev) {
                        _this.handleGraphEvent(ev, 'rollOutGraph');
                    });
                }
            }
            _this.applyMask(negativeSet, positiveSet);

        }
    },

    applyMask: function(negativeSet, positiveSet) {
        var _this = this;
        var length = negativeSet.length();
        if (_this.chart.type == "serial" && !_this.scrollbar) {
            _this.positiveClip(positiveSet);
            if (length > 0) {
                _this.negativeClip(negativeSet);
            }
        }
    },


    drawSmoothedGraph: function(xx, yy, sxx, syy) {
        var _this = this;
        if (xx.length > 1) {
            var set = _this.set;
            var container = _this.container;

            var positiveSet = container.set();
            var negativeSet = container.set();

            set.push(negativeSet);
            set.push(positiveSet);

            var lineAlpha = _this.lineAlpha;
            var lineThickness = _this.lineThickness;
            var dashLength = _this.dashLength;
            var fillAlphas = _this.fillAlphas;
            var lineColor = _this.lineColorR;
            var fillColors = _this.fillColorsR;
            var negativeLineColor = _this.negativeLineColor;
            var negativeFillColors = _this.negativeFillColors;
            var negativeFillAlphas = _this.negativeFillAlphas;
            var baseCoord = _this.baseCoord;

            var lineColorSwitched = _this.lineColorSwitched;
            if (lineColorSwitched) {
                lineColor = lineColorSwitched;
            }

            var fillColorsSwitched = _this.fillColorsSwitched;
            if (fillColorsSwitched) {
                fillColors = fillColorsSwitched;
            }

            var negativeLineAlpha = _this.negativeLineAlpha;
            if (isNaN(negativeLineAlpha)) {
                negativeLineAlpha = lineAlpha;
            }

            // draw lines
            var line = new AmCharts.Bezier(container, xx, yy, lineColor, lineAlpha, lineThickness, fillColors, 0, dashLength);
            positiveSet.push(line.path);

            if (negativeLineColor !== undefined) {
                var negativeLine = new AmCharts.Bezier(container, xx, yy, negativeLineColor, negativeLineAlpha, lineThickness, fillColors, 0, dashLength);
                negativeSet.push(negativeLine.path);
            }

            if (fillAlphas > 0) {
                var xxx = xx.join(";").split(";");
                var yyy = yy.join(";").split(";");

                var endStr = "";
                var comma = ",";

                if (sxx.length > 0) {
                    sxx.push("M");
                    syy.push("M");
                    sxx.reverse();
                    syy.reverse();

                    xxx = xx.concat(sxx);
                    yyy = yy.concat(syy);
                } else {

                    if (_this.rotate) {
                        endStr += " L" + baseCoord + comma + yy[yy.length - 1];
                        endStr += " L" + baseCoord + comma + yy[0];
                        endStr += " L" + xx[0] + comma + yy[0];
                    } else {
                        endStr += " L" + xx[xx.length - 1] + comma + baseCoord;
                        endStr += " L" + xx[0] + comma + baseCoord;
                        endStr += " L" + xx[0] + comma + yy[0];
                    }
                }
                var fill = new AmCharts.Bezier(container, xxx, yyy, NaN, 0, 0, fillColors, fillAlphas, dashLength, endStr);
                fill.path.pattern(_this.pattern);
                positiveSet.push(fill.path);

                if (negativeFillColors || negativeLineColor !== undefined) {
                    if (!negativeFillAlphas) {
                        negativeFillAlphas = fillAlphas;
                    }
                    if (!negativeFillColors) {
                        negativeFillColors = negativeLineColor;
                    }

                    var negativeFill = new AmCharts.Bezier(container, xx, yy, NaN, 0, 0, negativeFillColors, negativeFillAlphas, dashLength, endStr);
                    negativeFill.path.pattern(_this.pattern);
                    negativeSet.push(negativeFill.path);
                }
            }
            _this.applyMask(negativeSet, positiveSet);
        }
    },


    launchAnimation: function() {
        var _this = this;
        var duration = _this.chart.startDuration;

        if (duration > 0 && !_this.animationPlayed) {

            var set = _this.set;
            var bulletSet = _this.bulletSet;

            if (!AmCharts.VML) {
                set.attr({
                    'opacity': _this.startAlpha
                });
                bulletSet.attr({
                    'opacity': _this.startAlpha
                });
            }

            set.hide();
            bulletSet.hide();

            if (_this.seqAn) {
                var t = setTimeout(function() {
                    _this.animateGraphs.call(_this);
                }, _this.index * duration * 1000);
                _this.timeOuts.push(t);
            } else {
                _this.animateGraphs();
            }
        }
    },

    animateGraphs: function() {
        var _this = this;
        var chart = _this.chart;
        var set = _this.set;
        var bulletSet = _this.bulletSet;
        var x = _this.x;
        var y = _this.y;

        set.show();
        bulletSet.show();

        var duration = chart.startDuration;
        var effect = chart.startEffect;

        if (set) {
            if (_this.rotate) {
                set.translate(-1000, y);
                bulletSet.translate(-1000, y);
            } else {
                set.translate(x, -1000);
                bulletSet.translate(x, -1000);
            }
            set.animate({
                opacity: 1,
                translate: x + "," + y
            }, duration, effect);
            bulletSet.animate({
                opacity: 1,
                translate: x + "," + y
            }, duration, effect);
        }
    },

    animate: function(cuboid) {
        var _this = this;
        var chart = _this.chart;
        var container = _this.container;

        var animationArray = _this.animationArray;
        if (!cuboid && animationArray.length > 0) {
            cuboid = animationArray[0];
            animationArray.shift();
        }

        var effect = AmCharts[AmCharts.getEffect(chart.startEffect)];
        var duration = chart.startDuration;

        if (cuboid) {
            if (this.rotate) {
                cuboid.animateWidth(duration, effect);
            } else {
                cuboid.animateHeight(duration, effect);
            }
            var obj = cuboid.set;
            obj.show();
        }
    },

    legendKeyColor: function() {
        var _this = this;
        var color = _this.legendColor;
        var lineAlpha = _this.lineAlpha;

        if (color === undefined) {
            color = _this.lineColorR;

            if (lineAlpha === 0) {
                var colorArray = _this.fillColorsR;
                if (colorArray) {
                    if (typeof(colorArray) == 'object') {
                        color = colorArray[0];
                    } else {
                        color = colorArray;
                    }
                }
            }
        }
        return color;
    },

    legendKeyAlpha: function() {
        var _this = this;
        var alpha = _this.legendAlpha;
        if (alpha === undefined) {
            alpha = _this.lineAlpha;

            if (_this.fillAlphas > alpha) {
                alpha = _this.fillAlphas;
            }

            if (alpha === 0) {
                alpha = _this.bulletAlpha;
            }
            if (alpha === 0) {
                alpha = 1;
            }
        }
        return alpha;
    },


    createBullet: function(graphDataItem, bulletX, bulletY, index) {
        var _this = this;
        var container = _this.container;
        var bulletOffset = _this.bulletOffset;
        var bulletSize = _this.bulletSize;
        if (!isNaN(graphDataItem.bulletSize)) {
            bulletSize = graphDataItem.bulletSize;
        }

        var value = graphDataItem.values.value;
        var maxValue = _this.maxValue;
        var minValue = _this.minValue;
        var maxBulletSize = _this.maxBulletSize;
        var minBulletSize = _this.minBulletSize;
        if (!isNaN(maxValue)) {
            if (!isNaN(value)) {
                //bulletSize = value / _this.maxValue * _this.maxBulletSize;
                bulletSize = (value - minValue) / (maxValue - minValue) * (maxBulletSize - minBulletSize) + minBulletSize;
            }

            if(minValue == maxValue){
                bulletSize = maxBulletSize;
            }
        }

        var originalSize = bulletSize;

        if (_this.bulletAxis) {
            var error = graphDataItem.values.error;

            if (!isNaN(error)) {
                value = error;
            }
            bulletSize = _this.bulletAxis.stepWidth * value;
        }

        if (bulletSize < _this.minBulletSize) {
            bulletSize = _this.minBulletSize;
        }

        if (_this.rotate) {
            if(graphDataItem.isNegative){
                bulletX -= bulletOffset;
            }
            else{
                bulletX += bulletOffset;
            }

        } else {
            if(graphDataItem.isNegative){
                bulletY += bulletOffset;
            }
            else{
                bulletY -= bulletOffset;
            }

        }

        // BULLETS
        var bullet;

        var bulletColor = _this.bulletColorR;

        if (graphDataItem.lineColor) {
            _this.bulletColorSwitched = graphDataItem.lineColor;
        }

        if (_this.bulletColorSwitched) {
            bulletColor = _this.bulletColorSwitched;
        }

        if (graphDataItem.isNegative && _this.bulletColorNegative !== undefined) {
            bulletColor = _this.bulletColorNegative;
        }

        if (graphDataItem.color !== undefined) {
            bulletColor = graphDataItem.color;
        }

        var pattern;
        if(_this.chart.type == "xy"){
            if(_this.valueField){
                pattern = _this.pattern;
                if(graphDataItem.pattern){
                    pattern = graphDataItem.pattern;
                }
            }
        }

        var bulletType = _this.bullet;
        if (graphDataItem.bullet) {
            bulletType = graphDataItem.bullet;
        }

        var bbt = _this.bulletBorderThickness;
        var bbc = _this.bulletBorderColorR;
        var bba = _this.bulletBorderAlpha;
        var bc = bulletColor;
        var ba = _this.bulletAlpha;

        if (!bbc) {
            bbc = bc;
        }
        if(_this.useLineColorForBulletBorder){
            bbc = _this.lineColorR;
        }

        var customAlpha = graphDataItem.alpha;
        if (!isNaN(customAlpha)) {
            ba = customAlpha;
        }

        var extremeLeft = 0;
        if (_this.bullet == "none" && !graphDataItem.bullet) {
            //void
        } else {
            bullet = AmCharts.bullet(container, bulletType, bulletSize, bc, ba, bbt, bbc, bba, originalSize, 0, pattern);
        }
        var dbx = 0;
        var dby = 0;
        if (_this.customBullet || graphDataItem.customBullet) {
            var customBullet = _this.customBullet;

            if (graphDataItem.customBullet) {
                customBullet = graphDataItem.customBullet;
            }

            if (customBullet) {
                if (bullet) {
                    bullet.remove();
                }

                if (typeof(customBullet) == "function") {
                    var customBulletClass = new customBullet();

                    customBulletClass.chart = _this.chart;

                    if (graphDataItem.bulletConfig) {
                        customBulletClass.availableSpace = bulletY;
                        customBulletClass.graph = _this;
                        graphDataItem.bulletConfig.minCoord = _this.minCoord - bulletY;
                        customBulletClass.bulletConfig = graphDataItem.bulletConfig;
                    }
                    customBulletClass.write(container);
                    bullet = customBulletClass.set;
                } else {
                    if (_this.chart.path) {
                        customBullet = _this.chart.path + customBullet;
                    }
                    bullet = container.set();
                    var bulletImage = container.image(customBullet, 0, 0, bulletSize, bulletSize);
                    bullet.push(bulletImage);

                    if (_this.centerCustomBullets) {
                        bulletImage.translate(-bulletSize / 2, -bulletSize / 2);
                    }
                }
            }
        }

        if (bullet) {
            if (graphDataItem.url || _this.showHandOnHover) {
                bullet.setAttr("cursor", "pointer");
            }



            if (_this.chart.type == "serial") {
                if (bulletX - dbx < extremeLeft || bulletX - dbx > _this.width || bulletY < -bulletSize / 2 || bulletY - dby > _this.height) {
                    bullet.remove();
                    bullet = null;
                }
            }
            if (bullet) {
                _this.bulletSet.push(bullet);
                bullet.translate(bulletX, bulletY);
                _this.addListeners(bullet, graphDataItem);
                _this.allBullets.push(bullet);
            }
            graphDataItem.bx = bulletX;
            graphDataItem.by = bulletY;
        }

        graphDataItem.bulletGraphics = bullet;

        return bulletSize;
    },

    showBullets: function() {
        var _this = this;
        var allBullets = _this.allBullets;
        var i;
        _this.bulletsHidden = false;
        for (i = 0; i < allBullets.length; i++) {
            allBullets[i].show();
        }
    },

    hideBullets: function() {
        var _this = this;
        var allBullets = _this.allBullets;
        var i;
        _this.bulletsHidden = true;
        for (i = 0; i < allBullets.length; i++) {
            allBullets[i].hide();
        }
    },


    addListeners: function(obj, dItem) {
        var _this = this;
        obj.mouseover(function(ev) {
            _this.handleRollOver(dItem, ev);
        }).mouseout(function(ev) {
            _this.handleRollOut(dItem, ev);
        }).touchend(function(ev) {
            _this.handleRollOver(dItem, ev);
            if (_this.chart.panEventsEnabled) {
                _this.handleClick(dItem, ev);
            }
        }).touchstart(function(ev) {
            _this.handleRollOver(dItem, ev);
        }).click(function(ev) {
            _this.handleClick(dItem, ev);
        }).dblclick(function(ev) {
            _this.handleDoubleClick(dItem, ev);
        }).contextmenu(function(ev) {
            _this.handleRightClick(dItem, ev);
        });
    },

    handleRollOver: function(dItem, ev) {
        var _this = this;

        if (dItem) {
            var chart = _this.chart;
            var type = 'rollOverGraphItem';
            var event = {
                type: type,
                item: dItem,
                index: dItem.index,
                graph: _this,
                target: _this,
                chart: _this.chart,
                event: ev
            };
            _this.fire(type, event);
            chart.fire(type, event);
            clearTimeout(chart.hoverInt);


            var show = _this.showBalloon;

            if (chart.chartCursor && chart.type == "serial") {
                show = false;
                if (!chart.chartCursor.valueBalloonsEnabled && _this.showBalloon) {
                    show = true;
                }
            }
            if (show) {
                var text = chart.formatString(_this.balloonText, dItem, true);

                var balloonFunction = _this.balloonFunction;
                if (balloonFunction) {
                    text = balloonFunction(dItem, dItem.graph);
                }

                text = AmCharts.cleanFromEmpty(text);
                var color = chart.getBalloonColor(_this, dItem);
                chart.balloon.showBullet = false;
                chart.balloon.pointerOrientation = "V";
                var bx = dItem.x;
                var by = dItem.y;
                if (chart.rotate) {
                    bx = dItem.y;
                    by = dItem.x;
                }
                chart.showBalloon(text, color, true, bx + chart.marginLeftReal, by + chart.marginTopReal);
            }
        }

        _this.handleGraphEvent(ev, 'rollOverGraph');
    },


    handleRollOut: function(dItem, ev) {
        var _this = this;
        _this.chart.hideBalloon();

        if (dItem) {
            var type = 'rollOutGraphItem';
            var event = {
                type: type,
                item: dItem,
                index: dItem.index,
                graph: this,
                target: _this,
                chart: _this.chart,
                event: ev
            };
            _this.fire(type, event);
            _this.chart.fire(type, event);
        }

        _this.handleGraphEvent(ev, 'rollOutGraph');
    },

    handleClick: function(dItem, ev) {
        var _this = this;

        if (dItem) {
            var type = 'clickGraphItem';
            var event = {
                type: type,
                item: dItem,
                index: dItem.index,
                graph: _this,
                target: _this,
                chart: _this.chart,
                event: ev
            };
            _this.fire(type, event);
            _this.chart.fire(type, event);

            AmCharts.getURL(dItem.url, _this.urlTarget);
        }

        _this.handleGraphEvent(ev, 'clickGraph');
    },

    handleGraphEvent: function(ev, type) {
        var _this = this;

        var event = {
            type: type,
            graph: _this,
            target: _this,
            chart: _this.chart,
            event: ev
        };
        _this.fire(type, event);
        _this.chart.fire(type, event);
    },

    handleRightClick: function(dItem, ev) {
        var _this = this;

        if (dItem) {
            var type = 'rightClickGraphItem';
            var event = {
                type: type,
                item: dItem,
                index: dItem.index,
                graph: _this,
                target: _this,
                chart: _this.chart,
                event: ev
            };
            _this.fire(type, event);
            _this.chart.fire(type, event);
        }
    },


    handleDoubleClick: function(dItem, ev) {
        var _this = this;

        if (dItem) {
            var type = 'doubleClickGraphItem';
            var event = {
                type: type,
                item: dItem,
                index: dItem.index,
                graph: _this,
                target: _this,
                chart: _this.chart,
                event: ev
            };
            _this.fire(type, event);
            _this.chart.fire(type, event);
        }
    },

    zoom: function(start, end) {
        var _this = this;
        _this.start = start;
        _this.end = end;
        _this.draw();
    },

    changeOpacity: function(a) {
        var _this = this;
        var set = _this.set;
        var OPACITY = "opacity";
        if (set) {
            set.setAttr(OPACITY, a);
        }
        var ownColumns = _this.ownColumns;
        if (ownColumns) {
            var i;
            for (i = 0; i < ownColumns.length; i++) {
                var cset = ownColumns[i].set;
                if (cset) {
                    cset.setAttr(OPACITY, a);
                }
            }
        }
        var bulletSet = _this.bulletSet;
        if (bulletSet) {
            bulletSet.setAttr(OPACITY, a);
        }
    },

    destroy: function() {
        var _this = this;
        AmCharts.remove(_this.set);
        AmCharts.remove(_this.bulletSet);

        var timeOuts = _this.timeOuts;
        if (timeOuts) {
            var i;
            for (i = 0; i < timeOuts.length; i++) {
                clearTimeout(timeOuts[i]);
            }
        }
        _this.timeOuts = [];
    }

});

// @tag amchart
AmCharts.AmRectangularChart = AmCharts.Class({

    inherits: AmCharts.AmCoordinateChart,

    construct: function (theme) {
        var _this = this;
        AmCharts.AmRectangularChart.base.construct.call(_this, theme);
        _this.theme = theme;
        _this.createEvents('zoomed');

        _this.marginLeft = 20;
        _this.marginTop = 20;
        _this.marginBottom = 20;
        _this.marginRight = 20;
        _this.angle = 0;
        _this.depth3D = 0;
        _this.horizontalPosition = 0;
        _this.verticalPosition = 0;
        _this.widthMultiplier = 1;
        _this.heightMultiplier = 1;

        _this.plotAreaFillColors = "#FFFFFF";
        _this.plotAreaFillAlphas = 0;
        _this.plotAreaBorderColor = "#000000";
        _this.plotAreaBorderAlpha = 0;

        // this one is deprecated since 3.2.1
        /*
        _this.zoomOutButton = {
            backgroundColor: '#e5e5e5',
            backgroundAlpha: 1
        };*/

        _this.zoomOutButtonImageSize = 17;
        _this.zoomOutButtonImage = "lens.png";
        _this.zoomOutText = "Show all";
        _this.zoomOutButtonColor = '#e5e5e5';
        _this.zoomOutButtonAlpha = 0;
        _this.zoomOutButtonRollOverAlpha = 1;
        _this.zoomOutButtonPadding = 8;
        //_this.zoomOutButtonFontSize;
        //_this.zoomOutButtonFontColor;

        _this.trendLines = [];
        _this.autoMargins = true;
        _this.marginsUpdated = false;
        _this.autoMarginOffset = 10;

        AmCharts.applyTheme(_this, theme, "AmRectangularChart");
    },

    initChart: function () {
        var _this = this;
        AmCharts.AmRectangularChart.base.initChart.call(_this);
        _this.updateDxy();

        var updateGraphs = true;
        if (!_this.marginsUpdated && _this.autoMargins) {
            _this.resetMargins();
            updateGraphs = false;
        }
        _this.processScrollbars();
        _this.updateMargins();
        _this.updatePlotArea();
        _this.updateScrollbars();
        _this.updateTrendLines();
        _this.updateChartCursor();
        _this.updateValueAxes();

        // no need to draw graphs for the first time, as only axes are rendered to measure margins
        if (updateGraphs) {
            if (!_this.scrollbarOnly) {
                _this.updateGraphs();
            }
        }
    },

    drawChart: function () {
        var _this = this;
        AmCharts.AmRectangularChart.base.drawChart.call(_this);
        _this.drawPlotArea();
        var chartData = _this.chartData;
        if (AmCharts.ifArray(chartData)) {
            var chartCursor = _this.chartCursor;
            if (chartCursor) {
                chartCursor.draw();
            }
            var zoomOutText = _this.zoomOutText;
            if (zoomOutText !== "" && zoomOutText) {
                _this.drawZoomOutButton();
            }
        }
    },


    resetMargins: function () {
        var _this = this;

        var fixMargins = {};
        var i;

        if (_this.type == "serial") {
            var valueAxes = _this.valueAxes;

            for (i = 0; i < valueAxes.length; i++) {
                var valueAxis = valueAxes[i];
                if (!valueAxis.ignoreAxisWidth) {
                    valueAxis.setOrientation(_this.rotate);
                    valueAxis.fixAxisPosition();
                    fixMargins[valueAxis.position] = true;
                }
            }

            var categoryAxis = _this.categoryAxis;
            if (categoryAxis) {
                if (!categoryAxis.ignoreAxisWidth) {
                    categoryAxis.setOrientation(!_this.rotate);
                    categoryAxis.fixAxisPosition();
                    categoryAxis.fixAxisPosition();
                    fixMargins[categoryAxis.position] = true;
                }
            }
        }
        // xy
        else {
            var xAxes = _this.xAxes;
            var yAxes = _this.yAxes;

            for (i = 0; i < xAxes.length; i++) {
                var xAxis = xAxes[i];
                if (!xAxis.ignoreAxisWidth) {
                    xAxis.setOrientation(true);
                    xAxis.fixAxisPosition();
                    fixMargins[xAxis.position] = true;
                }
            }
            for (i = 0; i < yAxes.length; i++) {
                var yAxis = yAxes[i];
                if (!yAxis.ignoreAxisWidth) {
                    yAxis.setOrientation(false);
                    yAxis.fixAxisPosition();
                    fixMargins[yAxis.position] = true;
                }
            }
        }


        if (fixMargins.left) {
            _this.marginLeft = 0;
        }
        if (fixMargins.right) {
            _this.marginRight = 0;
        }
        if (fixMargins.top) {
            _this.marginTop = 0;
        }
        if (fixMargins.bottom) {
            _this.marginBottom = 0;
        }

        _this.fixMargins = fixMargins;
    },

    measureMargins: function () {

        var _this = this;
        var valueAxes = _this.valueAxes;
        var bounds;
        var autoMarginOffset = _this.autoMarginOffset;
        var fixMargins = _this.fixMargins;
        var realWidth = _this.realWidth;
        var realHeight = _this.realHeight;

        var l = autoMarginOffset;
        var t = autoMarginOffset;
        var r = realWidth; //3.4.3 - autoMarginOffset;
        var b = realHeight; // 3.4.3 - autoMarginOffset;
        var i;
        for (i = 0; i < valueAxes.length; i++) {
            bounds = _this.getAxisBounds(valueAxes[i], l, r, t, b);
            l = Math.round(bounds.l);
            r = Math.round(bounds.r);
            t = Math.round(bounds.t);
            b = Math.round(bounds.b);
        }

        var categoryAxis = _this.categoryAxis;
        if (categoryAxis) {
            bounds = _this.getAxisBounds(categoryAxis, l, r, t, b);
            l = Math.round(bounds.l);
            r = Math.round(bounds.r);
            t = Math.round(bounds.t);
            b = Math.round(bounds.b);
        }

        if (fixMargins.left && l < autoMarginOffset) {
            _this.marginLeft = Math.round(-l + autoMarginOffset);
        }
        if (fixMargins.right && r >= realWidth - autoMarginOffset) {
            _this.marginRight = Math.round(r - realWidth + autoMarginOffset);
        }
        if (fixMargins.top && t < autoMarginOffset + _this.titleHeight) {
            _this.marginTop = Math.round(_this.marginTop - t + autoMarginOffset + _this.titleHeight);
        }
        if (fixMargins.bottom && b > realHeight - autoMarginOffset) {
            _this.marginBottom = Math.round(_this.marginBottom + b - realHeight + autoMarginOffset);
        }
        //_this.resetAnimation();
        _this.initChart();
    },

    getAxisBounds: function (axis, l, r, t, b) {
        var x;
        var y;

        if (!axis.ignoreAxisWidth) {
            var set = axis.labelsSet;
            var tickLength = axis.tickLength;
            if (axis.inside) {
                tickLength = 0;
            }

            if (set) {
                var bbox = axis.getBBox();

                switch (axis.position) {
                    case "top":
                        y = bbox.y;

                        if (t > y) {
                            t = y;
                        }

                        break;
                    case "bottom":
                        y = bbox.y + bbox.height;

                        if (b < y) {
                            b = y;
                        }
                        break;
                    case "right":

                        x = bbox.x + bbox.width + tickLength + 3;

                        if (r < x) {
                            r = x;
                        }

                        break;
                    case "left":
                        x = bbox.x - tickLength;

                        if (l > x) {
                            l = x;
                        }
                        break;
                }
            }
        }

        return ({
            l: l,
            t: t,
            r: r,
            b: b
        });
    },


    drawZoomOutButton: function () {
        var _this = this;
        var zbSet = _this.container.set();
        _this.zoomButtonSet.push(zbSet);
        var color = _this.color;
        var fontSize = _this.fontSize;
        var zoomOutButtonImageSize = _this.zoomOutButtonImageSize;
        var zoomOutButtonImage = _this.zoomOutButtonImage;
        var zoomOutText = _this.zoomOutText;
        var zoomOutButtonColor = _this.zoomOutButtonColor;
        var zoomOutButtonAlpha = _this.zoomOutButtonAlpha;
        var zoomOutButtonFontSize = _this.zoomOutButtonFontSize;
        var zoomOutButtonPadding = _this.zoomOutButtonPadding;
        if(!isNaN(zoomOutButtonFontSize)){
            fontSize = zoomOutButtonFontSize;
        }
        var zoomOutButtonFontColor = _this.zoomOutButtonFontColor;
        if(zoomOutButtonFontColor){
            color = zoomOutButtonFontColor;
        }

        // this one is depracated, but still checking
        var zoomOutButton = _this.zoomOutButton;
        var bbox;

        if (zoomOutButton) {
            if (zoomOutButton.fontSize) {
                fontSize = zoomOutButton.fontSize;
            }
            if (zoomOutButton.color) {
                color = zoomOutButton.color;
            }
            if(zoomOutButton.backgroundColor){
                zoomOutButtonColor = zoomOutButton.backgroundColor;
            }
            if(!isNaN(zoomOutButton.backgroundAlpha)){
                _this.zoomOutButtonRollOverAlpha = zoomOutButton.backgroundAlpha;
            }
        }

        var labelX = 0;
        var labelY = 0;
        if (_this.pathToImages !== undefined && zoomOutButtonImage){
            var image = _this.container.image(_this.pathToImages + zoomOutButtonImage, 0, 0, zoomOutButtonImageSize, zoomOutButtonImageSize);
            zbSet.push(image);

            bbox = image.getBBox();
            labelX = bbox.width + 5;
        }

        if(zoomOutText !== undefined){
            var label = AmCharts.text(_this.container, zoomOutText, color, _this.fontFamily, fontSize, 'start');
            var labelBox = label.getBBox();

            if(bbox){
                labelY = bbox.height / 2 - 3;
            }
            else{
                labelY = labelBox.height / 2;
            }
            label.translate(labelX, labelY);
            zbSet.push(label);
        }

        bbox = zbSet.getBBox();
        var borderAlpha = 1;
        if(!AmCharts.isModern){
            borderAlpha = 0;
        }

        var bg = AmCharts.rect(_this.container, bbox.width + zoomOutButtonPadding * 2 + 5, bbox.height + zoomOutButtonPadding * 2 - 2, zoomOutButtonColor, 1, 1, zoomOutButtonColor, borderAlpha);
        bg.setAttr("opacity", zoomOutButtonAlpha);
        bg.translate(-zoomOutButtonPadding, -zoomOutButtonPadding);
        zbSet.push(bg);
        bg.toBack();
        _this.zbBG = bg;

        bbox = bg.getBBox();
        zbSet.translate((_this.marginLeftReal + _this.plotAreaWidth - bbox.width + zoomOutButtonPadding), _this.marginTopReal + zoomOutButtonPadding);
        zbSet.hide();

        zbSet.mouseover(function () {
            _this.rollOverZB();
        }).mouseout(function () {
            _this.rollOutZB();
        }).click(function () {
            _this.clickZB();
        }).touchstart(function () {
            _this.rollOverZB();
        }).touchend(function () {
            _this.rollOutZB();
            _this.clickZB();
        });
        var j;
        for (j = 0; j < zbSet.length; j++) {
            zbSet[j].attr({
                cursor: 'pointer'
            });
        }
        _this.zbSet = zbSet;
    },

    rollOverZB: function () {
        this.zbBG.setAttr("opacity", this.zoomOutButtonRollOverAlpha);
    },

    rollOutZB: function () {
        this.zbBG.setAttr("opacity", this.zoomOutButtonAlpha);
    },

    clickZB: function () {
        this.zoomOut();
    },

    zoomOut: function () {
        var _this = this;
        _this.updateScrollbar = true;
        _this.zoom();
    },

    drawPlotArea: function () {
        var _this = this;
        var dx = _this.dx;
        var dy = _this.dy;
        var x0 = _this.marginLeftReal;
        var y0 = _this.marginTopReal;
        var w = _this.plotAreaWidth - 1;
        var h = _this.plotAreaHeight - 1;
        var color = _this.plotAreaFillColors;
        var alpha = _this.plotAreaFillAlphas;
        var plotAreaBorderColor = _this.plotAreaBorderColor;
        var plotAreaBorderAlpha = _this.plotAreaBorderAlpha;

        // clip trend lines set
        _this.trendLinesSet.clipRect(x0, y0, w, h);

        if (typeof (alpha) == 'object') {
            alpha = alpha[0];
        }

        var bg = AmCharts.polygon(_this.container, [0, w, w, 0, 0], [0, 0, h, h, 0], color, alpha, 1, plotAreaBorderColor, plotAreaBorderAlpha, _this.plotAreaGradientAngle);
        bg.translate(x0 + dx, y0 + dy);
        //bg.node.setAttribute("class", "amChartsPlotArea"); // this made IE8 work incorrectly
        _this.set.push(bg);

        if (dx !== 0 && dy !== 0) {
            color = _this.plotAreaFillColors;
            if (typeof (color) == 'object') {
                color = color[0];
            }
            color = AmCharts.adjustLuminosity(color, -0.15);

            var attr = {
                'fill': color,
                    'fill-opacity': alpha,
                    'stroke': _this.plotAreaBorderColor,
                    'stroke-opacity': _this.plotAreaBorderAlpha
            };

            var hSide = AmCharts.polygon(_this.container, [0, dx, w + dx, w, 0], [0, dy, dy, 0, 0], color, alpha, 1, plotAreaBorderColor, plotAreaBorderAlpha);
            hSide.translate(x0, (y0 + h));
            _this.set.push(hSide);

            var vSide = AmCharts.polygon(_this.container, [0, 0, dx, dx, 0], [0, h, h + dy, dy, 0], color, alpha, 1, plotAreaBorderColor, plotAreaBorderAlpha);
            vSide.translate(x0, y0);
            _this.set.push(vSide);
        }

        var bbset = _this.bbset;
        if(bbset){
            if(_this.scrollbarOnly){
                bbset.remove();
            }
        }

    },

    updatePlotArea: function () {
        var _this = this;
        var realWidth = _this.updateWidth();
        var realHeight = _this.updateHeight();
        var container = _this.container;

        _this.realWidth = realWidth;
        _this.realWidth = realHeight;

        if (container) {
            _this.container.setSize(realWidth, realHeight);
        }

        var dx = _this.dx;
        var dy = _this.dy;
        var x0 = _this.marginLeftReal;
        var y0 = _this.marginTopReal;

        var w = realWidth - x0 - _this.marginRightReal - dx;
        var h = realHeight - y0 - _this.marginBottomReal;

        if (w < 1) {
            w = 1;
        }

        if (h < 1) {
            h = 1;
        }

        _this.plotAreaWidth = Math.round(w);
        _this.plotAreaHeight = Math.round(h);
    },

    updateDxy: function () {
        var _this = this;
        _this.dx = Math.round(_this.depth3D * Math.cos(_this.angle * Math.PI / 180));
        _this.dy = Math.round(-_this.depth3D * Math.sin(_this.angle * Math.PI / 180));

        _this.d3x = Math.round(_this.columnSpacing3D * Math.cos(_this.angle * Math.PI / 180));
        _this.d3y = Math.round(-_this.columnSpacing3D * Math.sin(_this.angle * Math.PI / 180));
    },

    updateMargins: function () {
        var _this = this;
        var titleHeight = _this.getTitleHeight();
        _this.titleHeight = titleHeight;
        _this.marginTopReal = _this.marginTop - _this.dy + titleHeight;
        _this.marginBottomReal = _this.marginBottom;
        _this.marginLeftReal = _this.marginLeft;
        _this.marginRightReal = _this.marginRight;
    },

    updateValueAxes: function () {
        var _this = this;
        var valueAxes = _this.valueAxes;

        var marginLeftReal = this.marginLeftReal;
        var marginTopReal = this.marginTopReal;
        var plotAreaHeight = _this.plotAreaHeight;
        var plotAreaWidth = _this.plotAreaWidth;
        var i;
        for (i = 0; i < valueAxes.length; i++) {
            var valueAxis = valueAxes[i];
            valueAxis.axisRenderer = AmCharts.RecAxis;
            valueAxis.guideFillRenderer = AmCharts.RecFill;
            valueAxis.axisItemRenderer = AmCharts.RecItem;
            valueAxis.dx = _this.dx;
            valueAxis.dy = _this.dy;
            valueAxis.viW = plotAreaWidth - 1;
            valueAxis.viH = plotAreaHeight - 1;
            valueAxis.marginsChanged = true;
            valueAxis.viX = marginLeftReal;
            valueAxis.viY = marginTopReal;
            _this.updateObjectSize(valueAxis);
        }
    },

    // graphs and value axes are updated using this method
    updateObjectSize: function (obj) {
        var _this = this;
        obj.width = (_this.plotAreaWidth - 1) * _this.widthMultiplier;
        obj.height = (_this.plotAreaHeight - 1) * _this.heightMultiplier;
        obj.x = _this.marginLeftReal + _this.horizontalPosition;
        obj.y = _this.marginTopReal + _this.verticalPosition;
    },

    updateGraphs: function () {
        var _this = this;
        var graphs = _this.graphs;
        var i;
        for (i = 0; i < graphs.length; i++) {
            var graph = graphs[i];
            graph.x = _this.marginLeftReal + _this.horizontalPosition;
            graph.y = _this.marginTopReal + _this.verticalPosition;
            graph.width = _this.plotAreaWidth * _this.widthMultiplier;
            graph.height = _this.plotAreaHeight * _this.heightMultiplier;
            graph.index = i;
            graph.dx = _this.dx;
            graph.dy = _this.dy;
            graph.rotate = _this.rotate;
        }
    },


    updateChartCursor: function () {
        var _this = this;
        var chartCursor = _this.chartCursor;

        if (chartCursor) {
            chartCursor = AmCharts.processObject(chartCursor, AmCharts.ChartCursor, _this.theme);
            _this.addChartCursor(chartCursor);

            chartCursor.x = _this.marginLeftReal;
            chartCursor.y = _this.marginTopReal;
            chartCursor.width = _this.plotAreaWidth - 1;
            chartCursor.height = _this.plotAreaHeight - 1;
            chartCursor.chart = this;
        }
    },

    processScrollbars: function () {
        var _this = this;
        var chartScrollbar = _this.chartScrollbar;
        if (chartScrollbar) {
            chartScrollbar = AmCharts.processObject(chartScrollbar, AmCharts.ChartScrollbar, _this.theme);
            _this.addChartScrollbar(chartScrollbar);
        }
    },

    updateScrollbars: function(){
        // void
    },

    addChartCursor: function (chartCursor) {
        var _this = this;
        AmCharts.callMethod("destroy", [_this.chartCursor]);

        if (chartCursor) {
            _this.listenTo(chartCursor, "changed", _this.handleCursorChange);
            _this.listenTo(chartCursor, "zoomed", _this.handleCursorZoom);
        }
        _this.chartCursor = chartCursor;
    },

    removeChartCursor: function () {
        var _this = this;
        AmCharts.callMethod("destroy", [_this.chartCursor]);
        _this.chartCursor = null;
    },

    zoomTrendLines: function () {
        var _this = this;
        var trendLines = _this.trendLines;
        var i;
        for (i = 0; i < trendLines.length; i++) {
            var trendLine = trendLines[i];

            if (!trendLine.valueAxis.recalculateToPercents) {
                trendLine.x = _this.marginLeftReal + _this.horizontalPosition;
                trendLine.y = _this.marginTopReal + _this.verticalPosition;
                trendLine.draw();
            } else {
                if (trendLine.set) {
                    trendLine.set.hide();
                }
            }
        }
    },

    addTrendLine: function (trendLine) {
        this.trendLines.push(trendLine);
    },



    removeTrendLine: function (trendLine) {
        var trendLines = this.trendLines;
        var i;
        for (i = trendLines.length - 1; i >= 0; i--) {
            if (trendLines[i] == trendLine) {
                trendLines.splice(i, 1);
            }
        }
    },


    adjustMargins: function (scrollbar, rotate) {
        var _this = this;
        var position = scrollbar.position;
        var scrollbarHeight = scrollbar.scrollbarHeight + scrollbar.offset;

        if (position == "top") {
            if (rotate) {
                _this.marginLeftReal += scrollbarHeight;
            } else {
                _this.marginTopReal += scrollbarHeight;
            }
        } else {
            if (rotate) {
                _this.marginRightReal += scrollbarHeight;
            } else {
                _this.marginBottomReal += scrollbarHeight;
            }
        }
    },


    getScrollbarPosition: function (scrollbar, rotate, axisPosition) {
        var _this = this;
        var scrollbarPosition;

        if (rotate) {
            if (axisPosition == "bottom" || axisPosition == "left") {
                scrollbarPosition = "bottom";
            } else {
                scrollbarPosition = "top";
            }
        } else {
            if (axisPosition == "top" || axisPosition == "right") {
                scrollbarPosition = "bottom";
            } else {
                scrollbarPosition = "top";
            }
        }
        scrollbar.position = scrollbarPosition;
    },


    updateChartScrollbar: function (scrollbar, rotate) {
        var _this = this;
        if (scrollbar) {
            scrollbar.rotate = rotate;
            var position = scrollbar.position;
            var marginTopReal = _this.marginTopReal;
            var marginLeftReal = _this.marginLeftReal;
            var scrollbarHeight = scrollbar.scrollbarHeight;
            var dx = _this.dx;
            var dy = _this.dy;
            var offset = scrollbar.offset;

            if (position == "top") {
                if (rotate) {
                    scrollbar.y = marginTopReal;
                    scrollbar.x = marginLeftReal - scrollbarHeight - offset;
                } else {
                    scrollbar.y = marginTopReal - scrollbarHeight + dy - 1 - offset;
                    scrollbar.x = marginLeftReal + dx;
                }
            } else {
                if (rotate) {
                    scrollbar.y = marginTopReal + dy;
                    scrollbar.x = marginLeftReal + _this.plotAreaWidth + dx + offset;
                } else {
                    scrollbar.y = marginTopReal + _this.plotAreaHeight + offset;
                    scrollbar.x = _this.marginLeftReal;
                }
            }
        }
    },

    showZB: function (show) {
        var _this = this;
        var zbSet = _this.zbSet;
        if (zbSet) {
            if (show) {
                zbSet.show();
            } else {
                zbSet.hide();
            }
            _this.rollOutZB();
        }
    },

    handleReleaseOutside: function (e) {
        var _this = this;
        AmCharts.AmRectangularChart.base.handleReleaseOutside.call(_this, e);

        var chartCursor = _this.chartCursor;
        if (chartCursor) {
            chartCursor.handleReleaseOutside();
        }
    },

    handleMouseDown: function (e) {
        var _this = this;
        AmCharts.AmRectangularChart.base.handleMouseDown.call(_this, e);
        var chartCursor = _this.chartCursor;
        if (chartCursor) {
            chartCursor.handleMouseDown(e);
        }
    },


    handleCursorChange: function (event) {
        //void
    }

});

// @tag amchart
AmCharts.AmSlicedChart = AmCharts.Class({

    inherits: AmCharts.AmChart,

    construct: function (theme) {
        var _this = this;
        _this.createEvents('rollOverSlice', 'rollOutSlice', 'clickSlice', 'pullOutSlice', 'pullInSlice', 'rightClickSlice');

        AmCharts.AmSlicedChart.base.construct.call(_this, theme);

        _this.colors = ["#FF0F00", "#FF6600", "#FF9E01", "#FCD202", "#F8FF01", "#B0DE09", "#04D215", "#0D8ECF", "#0D52D1", "#2A0CD0", "#8A0CCF", "#CD0D74", "#754DEB", "#DDDDDD", "#999999", "#333333", "#000000", "#57032A", "#CA9726", "#990000", "#4B0C25"];
        _this.alpha = 1;
        _this.groupPercent = 0;
        _this.groupedTitle = "Other";
        _this.groupedPulled = false;
        _this.groupedAlpha = 1;
        _this.marginLeft = 0;
        _this.marginTop = 10;
        _this.marginBottom = 10;
        _this.marginRight = 0;
        _this.hoverAlpha = 1;
        _this.outlineColor = '#FFFFFF';
        _this.outlineAlpha = 0;
        _this.outlineThickness = 1;
        _this.startAlpha = 0;
        _this.startDuration = 1;
        _this.startEffect = 'bounce';
        _this.sequencedAnimation = true;
        _this.pullOutDuration = 1;
        _this.pullOutEffect = 'bounce';
        _this.pullOutOnlyOne = false;
        _this.pullOnHover = false;
        _this.labelsEnabled = true;
        _this.labelTickColor = "#000000";
        _this.labelTickAlpha = 0.2;
        _this.hideLabelsPercent = 0;
        _this.urlTarget = "_self";
        _this.autoMarginOffset = 10;
        _this.gradientRatio = [];

        AmCharts.applyTheme(_this, theme, "AmSlicedChart");
    },

    initChart: function () {
        var _this = this;
        AmCharts.AmSlicedChart.base.initChart.call(_this);

        if (_this.dataChanged) {
            _this.parseData();
            _this.dispatchDataUpdated = true;
            _this.dataChanged = false;
            _this.setLegendData(_this.chartData);
        }
        _this.drawChart();
    },


    handleLegendEvent: function (event) {
        var _this = this;
        var type = event.type;
        var dItem = event.dataItem;
        if(!_this.legend.data){
            if (dItem) {
                var hidden = dItem.hidden;

                switch (type) {
                    case 'clickMarker':
                        if (!hidden) {
                            _this.clickSlice(dItem);
                        }
                        break;
                    case 'clickLabel':
                        if (!hidden) {
                            _this.clickSlice(dItem);
                        }
                        break;
                    case 'rollOverItem':
                        if (!hidden) {
                            _this.rollOverSlice(dItem, false);
                        }
                        break;
                    case 'rollOutItem':
                        if (!hidden) {
                            _this.rollOutSlice(dItem);
                        }
                        break;
                    case 'hideItem':
                        _this.hideSlice(dItem);
                        break;
                    case 'showItem':
                        _this.showSlice(dItem);
                        break;
                }
            }
        }
    },

    invalidateVisibility: function () {
        var _this = this;
        _this.recalculatePercents();
        _this.initChart();
        var legend = _this.legend;
        if (legend) {
            legend.invalidateSize();
        }
    },

    addEventListeners: function (wedge, dItem) {
        var _this = this;

        wedge.mouseover(function (ev) {
            _this.rollOverSlice(dItem, true, ev);
        }).mouseout(function (ev) {
            _this.rollOutSlice(dItem, ev);
        }).touchend(function (ev) {
            _this.rollOverSlice(dItem, ev);
            if(_this.panEventsEnabled){
                _this.clickSlice(dItem, ev);
            }
        }).touchstart(function (ev) {
            _this.rollOverSlice(dItem, ev);
        }).click(function (ev) {
            _this.clickSlice(dItem, ev);
        }).contextmenu(function (ev) {
            _this.handleRightClick(dItem, ev);
        });

    },


    formatString: function (text, dItem, noFixBrakes) {
        var _this = this;

        text = AmCharts.formatValue(text, dItem, ["value"], _this.nf, "", _this.usePrefixes, _this.prefixesOfSmallNumbers, _this.prefixesOfBigNumbers);
        text = AmCharts.formatValue(text, dItem, ["percents"], _this.pf);
        text = AmCharts.massReplace(text, {
            "[[title]]": dItem.title,
                "[[description]]": dItem.description
        });

        if (text.indexOf("[[") != -1) {
            text = AmCharts.formatDataContextValue(text, dItem.dataContext);
        }

        if(!noFixBrakes){
            text = AmCharts.fixBrakes(text);
        }
        else{
            // balloon
           text = AmCharts.fixNewLines(text);
        }
        text = AmCharts.cleanFromEmpty(text);

        return text;
    },

    startSlices: function () {
        var _this = this;

        var i;
        for (i = 0; i < _this.chartData.length; i++) {
            if (_this.startDuration > 0 && _this.sequencedAnimation) {
                _this.setStartTO(i);
            } else {
                _this.startSlice(_this.chartData[i]);
            }
        }
    },

    setStartTO: function (i) {
        var _this = this;
        var interval = _this.startDuration / _this.chartData.length * 500;
        var t = setTimeout(function () {
            _this.startSequenced.call(_this);
        }, interval * i);
        _this.timeOuts.push(t);
    },

    pullSlices: function (instant) {
        var _this = this;
        var chartData = _this.chartData;
        var i;
        for (i = 0; i < chartData.length; i++) {
            var slice = chartData[i];
            if (slice.pulled) {
                _this.pullSlice(slice, 1, instant);
            }
        }
    },

    startSequenced: function () {
        var _this = this;
        var chartData = _this.chartData;
        var i;
        for (i = 0; i < chartData.length; i++) {
            if (!chartData[i].started) {
                var dItem = _this.chartData[i];
                _this.startSlice(dItem);
                break;
            }
        }
    },

    startSlice: function (dItem) {
        var _this = this;
        dItem.started = true;
        var w = dItem.wedge;
        var startDuration = _this.startDuration;
        if (w && startDuration > 0) {
            if (dItem.alpha > 0) {
                w.show();
            }

            w.translate(dItem.startX, dItem.startY);
            w.animate({
                'opacity': 1,
                translate: '0,0'
            }, startDuration, _this.startEffect);
        }
    },


    showLabels: function () {
        var _this = this;
        var chartData = _this.chartData;
        var i;
        for (i = 0; i < chartData.length; i++) {
            var dItem = chartData[i];
            if (dItem.alpha > 0) {
                var label = dItem.label;
                if (label) {
                    label.show();
                }
                var tick = dItem.tick;
                if (tick) {
                    tick.show();
                }
            }
        }
    },

    showSlice: function (dItem) {
        var _this = this;
        if (isNaN(dItem)) {
            dItem.hidden = false;
        } else {
            _this.chartData[dItem].hidden = false;
        }
        //_this.hideBalloon();
        _this.invalidateVisibility();
    },

    hideSlice: function (dItem) {
        var _this = this;
        if (isNaN(dItem)) {
            dItem.hidden = true;
        } else {
            _this.chartData[dItem].hidden = true;
        }
        _this.hideBalloon();
        _this.invalidateVisibility();
    },

    rollOverSlice: function (dItem, follow, ev) {
        var _this = this;
        if (!isNaN(dItem)) {
            dItem = _this.chartData[dItem];
        }
        clearTimeout(_this.hoverInt);

        if(!dItem.hidden){

            if (_this.pullOnHover) {
                _this.pullSlice(dItem, 1);
            }

            if (_this.hoverAlpha < 1) {
                var wedge = dItem.wedge;
                if (wedge) {
                    dItem.wedge.attr({
                        'opacity': _this.hoverAlpha
                    });
                }
            }

            var x = dItem.balloonX;
            var y = dItem.balloonY;

            if (dItem.pulled) {
                x += dItem.pullX;
                y += dItem.pullY;
            }

            var text = _this.formatString(_this.balloonText, dItem, true);

            var color = AmCharts.adjustLuminosity(dItem.color, -0.15);

            _this.showBalloon(text, color, follow, x, y);

            var evt = {
                type: 'rollOverSlice',
                dataItem: dItem,
                chart: _this,
                event:ev
            };
            _this.fire(evt.type, evt);
        }
    },

    rollOutSlice: function (dItem, ev) {
        var _this = this;
        if (!isNaN(dItem)) {
            dItem = _this.chartData[dItem];
        }
        var wedge = dItem.wedge;
        if (wedge) {
            dItem.wedge.attr({
                'opacity': 1
            });
        }

        _this.hideBalloon();
        var evt = {
            type: 'rollOutSlice',
            dataItem: dItem,
            chart: _this,
            event:ev
        };
        _this.fire(evt.type, evt);
    },

    clickSlice: function (dItem, ev) {
        var _this = this;
        if (!isNaN(dItem)) {
            dItem = _this.chartData[dItem];
        }

        //_this.hideBalloon();
        if (dItem.pulled) {
            _this.pullSlice(dItem, 0);
        } else {
            _this.pullSlice(dItem, 1);
        }

        AmCharts.getURL(dItem.url, _this.urlTarget);

        var evt = {
            type: 'clickSlice',
            dataItem: dItem,
            chart: _this,
            event:ev
        };
        _this.fire(evt.type, evt);
    },

    handleRightClick: function (dItem, ev) {
        var _this = this;
        if (!isNaN(dItem)) {
            dItem = _this.chartData[dItem];
        }
        var evt = {
            type: 'rightClickSlice',
            dataItem: dItem,
            chart: _this,
            event:ev
        };
        _this.fire(evt.type, evt);
    },

    drawTicks: function () {
        var _this = this;
        var chartData = _this.chartData;
        var i;
        for (i = 0; i < chartData.length; i++) {
            var dItem = chartData[i];
            var label = dItem.label;
            if (label) {
                var x0 = dItem.tx0;
                var y0 = dItem.ty0;
                var x = dItem.tx;
                var x2 = dItem.tx2;
                var y = dItem.ty;
                var radiusReal = _this.radiusReal;

                var tick = AmCharts.line(_this.container, [x0, x, x2], [y0, y, y], _this.labelTickColor, _this.labelTickAlpha);
                dItem.tick = tick;
                dItem.wedge.push(tick);
            }
        }
    },

    initialStart: function () {
        var _this = this;
        var startDuration = _this.startDuration;
        var t = setTimeout(function () {
            _this.showLabels.call(_this);
        }, startDuration * 1000);
        _this.timeOuts.push(t);

        if (_this.chartCreated) {
            _this.pullSlices(true);
        } else {
            var to = setTimeout(function () {
                _this.pullSlices.call(_this);
            }, startDuration * 1200);
            _this.timeOuts.push(to);
            _this.startSlices();
        }
    },

    pullSlice: function (dItem, dir, instant) {
        var _this = this;
        var duration = _this.pullOutDuration;
        if (instant === true) {
            duration = 0;
        }
        var wedge = dItem.wedge;

        var radius = _this.pullOutRadiusReal;
        if (wedge) {
            wedge.animate({
                'translate': (dir * dItem.pullX) + ',' + (dir * dItem.pullY)
            }, duration, _this.pullOutEffect);
        }

        var evt;
        if (dir == 1) {
            dItem.pulled = true;
            if (_this.pullOutOnlyOne) {
                _this.pullInAll(dItem.index);
            }

            evt = {
                type: 'pullOutSlice',
                dataItem: dItem,
                chart: _this
            };
        } else {
            dItem.pulled = false;
            evt = {
                type: 'pullInSlice',
                dataItem: dItem,
                chart: _this
            };
        }
        _this.fire(evt.type, evt);
    },

    pullInAll: function (except) {
        var _this = this;
        var chartData = _this.chartData;
        var i;
        for (i = 0; i < _this.chartData.length; i++) {
            if (i != except) {
                if (chartData[i].pulled) {
                    _this.pullSlice(chartData[i], 0);
                }
            }
        }
    },

    pullOutAll: function (scale) {
        var _this = this;
        var chartData = _this.chartData;
        var i;
        for (i = 0; i < chartData.length; i++) {
            if (!chartData[i].pulled) {
                _this.pullSlice(chartData[i], 1);
            }
        }
    },

    parseData: function () {
        var _this = this;
        var chartData = [];
        _this.chartData = chartData;

        var dp = _this.dataProvider;

        // backward compatibility
        if (!isNaN(_this.pieAlpha)) {
            _this.alpha = _this.pieAlpha;
        }

        if (dp !== undefined) {
            var sliceCount = dp.length;

            var sum = 0;

            // caluclate sum
            var i;
            var dataItem;
            var color;
            for (i = 0; i < sliceCount; i++) {
                dataItem = {};
                var dataSource = dp[i];
                dataItem.dataContext = dataSource;

                dataItem.value = Number(dataSource[_this.valueField]);

                var title = dataSource[_this.titleField];
                if (!title) {
                    title = "";
                }
                dataItem.title = title;

                dataItem.pulled = AmCharts.toBoolean(dataSource[_this.pulledField], false);

                var description = dataSource[_this.descriptionField];
                if (!description) {
                    description = "";
                }
                dataItem.description = description;

                dataItem.labelRadius = Number(dataSource[_this.labelRadiusField]);

                dataItem.url = dataSource[_this.urlField];


                var pattern = dataSource[_this.patternField];
                if(!pattern && _this.patterns){
                    pattern = _this.patterns[i];
                }


                dataItem.pattern = pattern;

                dataItem.visibleInLegend = AmCharts.toBoolean(dataSource[_this.visibleInLegendField], true);

                var alpha = dataSource[_this.alphaField];
                if (alpha !== undefined) {
                    dataItem.alpha = Number(alpha);
                } else {
                    dataItem.alpha = _this.alpha;
                }

                color = dataSource[_this.colorField];
                if (color !== undefined) {
                    dataItem.color = AmCharts.toColor(color);
                }

                dataItem.labelColor = AmCharts.toColor(dataSource[_this.labelColorField]);

                sum += dataItem.value;

                dataItem.hidden = false;

                chartData[i] = dataItem;
            }

            // calculate percents
            var groupCount = 0;

            for (i = 0; i < sliceCount; i++) {
                dataItem = chartData[i];
                dataItem.percents = dataItem.value / sum * 100;

                if (dataItem.percents < _this.groupPercent) {
                    groupCount++;
                }
            }

            // group to others slice
            if (groupCount > 1) {
                _this.groupValue = 0;
                _this.removeSmallSlices();

                var value = _this.groupValue;
                var percents = _this.groupValue / sum * 100;
                chartData.push({
                    title: _this.groupedTitle,
                    value: value,
                    percents: percents,
                    pulled: _this.groupedPulled,
                    color: _this.groupedColor,
                    url: _this.groupedUrl,
                    description: _this.groupedDescription,
                    alpha: _this.groupedAlpha,
                    pattern: _this.groupedPattern,
                    dataContext:{}
                });
            }

            // v2 compatibility
            var baseColor = _this.baseColor;
            if (!baseColor) {
                baseColor = _this.pieBaseColor;
            }

            var brightnessStep = _this.brightnessStep;
            if (!brightnessStep) {
                brightnessStep = _this.pieBrightnessStep;
            }

            // now set colors
            for (i = 0; i < chartData.length; i++) {

                if (baseColor) {
                    color = AmCharts.adjustLuminosity(baseColor, i * brightnessStep / 100);
                } else {
                    color = _this.colors[i];
                    if (color === undefined) {
                        color = AmCharts.randomColor();
                    }
                }
                if (chartData[i].color === undefined) {
                    chartData[i].color = color;
                }
            }

            _this.recalculatePercents();
        }
    },


    recalculatePercents: function () {
        var _this = this;
        var chartData = _this.chartData;
        var sum = 0;
        var i;
        var dItem;
        for (i = 0; i < chartData.length; i++) {
            dItem = chartData[i];
            if (!dItem.hidden && dItem.value > 0) {
                sum += dItem.value;
            }
        }
        for (i = 0; i < chartData.length; i++) {
            dItem = _this.chartData[i];
            if (!dItem.hidden && dItem.value > 0) {
                dItem.percents = dItem.value * 100 / sum;
            } else {
                dItem.percents = 0;
            }
        }
    },


    // remove slices which are less then __config.group.percent
    removeSmallSlices: function () {
        var _this = this;
        var chartData = _this.chartData;
        var i;
        for (i = chartData.length - 1; i >= 0; i--) {
            if (chartData[i].percents < _this.groupPercent) {
                _this.groupValue += chartData[i].value;
                chartData.splice(i, 1);
            }
        }
    },


    animateAgain: function () {
        var _this = this;
        _this.startSlices();
        var t = setTimeout(function () {
            _this.pullSlices.call(_this);
        }, _this.startDuration * 1200);
        _this.timeOuts.push(t);
    },


    measureMaxLabel: function () {
        var _this = this;
        var chartData = _this.chartData;
        var maxWidth = 0;
        var i;
        for (i = 0; i < chartData.length; i++) {
            var dItem = chartData[i];
            var text = _this.formatString(_this.labelText, dItem);
            var txt = AmCharts.text(_this.container, text, _this.color, _this.fontFamily, _this.fontSize);
            var w = txt.getBBox().width;
            if (w > maxWidth) {
                maxWidth = w;
            }
            txt.remove();
        }
        return maxWidth;
    }
});

// @tag amchart
AmCharts.ChartCursor = AmCharts.Class({

    construct: function (theme) {
        var _this = this;
        _this.cname = "ChartCursor";
        _this.createEvents('changed', 'zoomed', 'onHideCursor', 'draw', 'selected', "moved");
        _this.enabled = true;
        _this.cursorAlpha = 1;
        _this.selectionAlpha = 0.2;
        _this.cursorColor = '#CC0000';
        _this.categoryBalloonAlpha = 1;
        _this.color = '#FFFFFF';
        _this.type = "cursor";
        _this.zoomed = false;
        _this.zoomable = true;
        _this.pan = false;
        _this.categoryBalloonDateFormat = "MMM DD, YYYY";
        _this.valueBalloonsEnabled = true;
        _this.categoryBalloonEnabled = true;
        _this.rolledOver = false;
        _this.cursorPosition = "middle";
        _this.skipZoomDispatch = false;
        _this.bulletsEnabled = false;
        _this.bulletSize = 8;
        _this.oneBalloonOnly = false;
        _this.selectWithoutZooming = false;
        _this.graphBulletSize = 1.7;
        _this.animationDuration = 0.3;
        _this.zooming = false;
        _this.adjustment = 0;
        //_this.fullWidth;

        AmCharts.applyTheme(_this, theme, _this.cname);
    },

    draw: function () {
        var _this = this;
        _this.destroy();
        var chart = _this.chart;
        var container = chart.container;
        _this.rotate = chart.rotate;
        _this.container = container;

        var set = container.set();
        set.translate(_this.x, _this.y);
        _this.set = set;
        chart.cursorSet.push(set);

        var categoryBalloon = new AmCharts.AmBalloon();
        categoryBalloon.chart = chart;
        _this.categoryBalloon = categoryBalloon;
        AmCharts.copyProperties(chart.balloon, categoryBalloon);
        categoryBalloon.cornerRadius = 0;
        categoryBalloon.shadowAlpha = 0;
        categoryBalloon.borderThickness = 1;
        categoryBalloon.borderAlpha = 1;
        categoryBalloon.showBullet = false;

        var categoryBalloonColor = _this.categoryBalloonColor;
        if (categoryBalloonColor === undefined) {
            categoryBalloonColor = _this.cursorColor;
        }
        categoryBalloon.fillColor = categoryBalloonColor;
        categoryBalloon.fillAlpha = _this.categoryBalloonAlpha;
        categoryBalloon.borderColor = categoryBalloonColor;
        categoryBalloon.color = _this.color;

        if (_this.rotate) {
            categoryBalloon.pointerOrientation = "H";
        }

        _this.extraWidth = 0;
        _this.prevX = [];
        _this.prevY = [];
        _this.prevTX = [];
        _this.prevTY = [];

        // create value balloons
        if (_this.valueBalloonsEnabled) {
            var i;
            for (i = 0; i < chart.graphs.length; i++) {
                var valueBalloon = new AmCharts.AmBalloon();
                valueBalloon.chart = chart;
                AmCharts.copyProperties(chart.balloon, valueBalloon);
                chart.graphs[i].valueBalloon = valueBalloon;
            }
        }

        if (_this.type == "cursor") {
            _this.createCursor();
        } else {
            _this.createCrosshair();
        }

        _this.interval = setInterval(function () {
            _this.detectMovement.call(_this);
        }, 40);
    },

    updateData: function () {
        var _this = this;
        var chart = _this.chart;
        _this.data = chart.chartData;

        _this.firstTime = chart.firstTime;
        _this.lastTime = chart.lastTime;
    },

    createCursor: function () {
        var _this = this;
        var chart = _this.chart;
        var cursorAlpha = _this.cursorAlpha;
        var categoryAxis = chart.categoryAxis;
        var categoryBalloonPosition = categoryAxis.position;
        var inside = categoryAxis.inside;
        var axisThickness = categoryAxis.axisThickness;
        var categoryBalloon = _this.categoryBalloon;
        var xx;
        var yy;
        var dx = chart.dx;
        var dy = chart.dy;
        var x = _this.x;
        var y = _this.y;
        var width = _this.width;
        var height = _this.height;
        var rotate = chart.rotate;
        var tickLength = categoryAxis.tickLength;
        categoryBalloon.pointerWidth = tickLength;

        if (rotate) {
            xx = [0, width, width + dx];
            yy = [0, 0, dy];
        } else {
            xx = [dx, 0, 0];
            yy = [dy, 0, height];
        }

        var line = AmCharts.line(_this.container, xx, yy, _this.cursorColor, cursorAlpha, 1);
        _this.line = line;
        var fullRectSet = _this.fullRectSet;
        if(fullRectSet){
            fullRectSet.push(line);
            fullRectSet.translate(_this.x, _this.y);
        }
        else{
            _this.set.push(line);
        }


        // BOUNDS OF X BALLOON
        // ROTATE
        if (rotate) {
            if (inside) {
                categoryBalloon.pointerWidth = 0;
            }
            // RIGHT
            if (categoryBalloonPosition == "right") {
                // INSIDE
                if (inside) {
                    categoryBalloon.setBounds(x, y + dy, x + width + dx, y + height + dy);
                }
                // OUTSIDE
                else {
                    categoryBalloon.setBounds(x + width + dx + axisThickness, y + dy, x + width + 1000, y + height + dy);
                }
            }
            // LEFT
            else {
                // INSIDE
                if (inside) {
                    categoryBalloon.setBounds(x, y, width + x, height + y);
                }
                // OUTSIDE
                else {
                    categoryBalloon.setBounds(-1000, -1000, x - tickLength - axisThickness, y + height + 15);
                }
            }
        }
        // DO NOT ROTATE
        else {
            categoryBalloon.maxWidth = width;

            if (categoryAxis.parseDates) {
                tickLength = 0;
                categoryBalloon.pointerWidth = 0;
            }

            // TOP
            if (categoryBalloonPosition == "top") {
                // INSIDE
                if (inside) {
                    categoryBalloon.setBounds(x + dx, y + dy, width + dx + x, height + y);
                }
                // OUTSIDE
                else {
                    categoryBalloon.setBounds(x + dx, -1000, width + dx + x, y + dy - tickLength - axisThickness);
                }
            }
            // BOTTOM
            else {
                // INSIDE
                if (inside) {
                    categoryBalloon.setBounds(x, y, width + x, height + y - tickLength);
                }
                // OUTSIDE
                else {
                    categoryBalloon.setBounds(x, y + height + tickLength + axisThickness - 1, x + width, y + height + tickLength + axisThickness);
                }
            }
        }
        _this.hideCursor();
    },

    createCrosshair: function () {
        var _this = this;
        var cursorAlpha = _this.cursorAlpha;
        var container = _this.container;

        var vLine = AmCharts.line(container, [0, 0], [0, _this.height], _this.cursorColor, cursorAlpha, 1);
        var hLine = AmCharts.line(container, [0, _this.width], [0, 0], _this.cursorColor, cursorAlpha, 1);

        _this.set.push(vLine);
        _this.set.push(hLine);

        _this.vLine = vLine;
        _this.hLine = hLine;
        _this.hideCursor();
    },

    detectMovement: function () {
        var _this = this;
        var chart = _this.chart;
        if (chart.mouseIsOver) {
            var mouseX = chart.mouseX - _this.x;
            var mouseY = chart.mouseY - _this.y;

            if (mouseX > 0 && mouseX < _this.width && mouseY > 0 && mouseY < _this.height) {
                if (_this.drawing) {
                    if (!_this.rolledOver) {
                        chart.setMouseCursor("crosshair");
                    }
                } else if (_this.pan) {
                    if (!_this.rolledOver) {
                        chart.setMouseCursor("move");
                    }
                }
                _this.rolledOver = true;
                _this.setPosition();
            } else {
                if (_this.rolledOver) {
                    _this.handleMouseOut();
                    _this.rolledOver = false;
                }
            }
        } else {
            if (_this.rolledOver) {
                _this.handleMouseOut();
                _this.rolledOver = false;
            }
        }
    },

    getMousePosition: function () {
        var _this = this;
        var mousePos;
        var width = _this.width;
        var height = _this.height;
        var chart = _this.chart;

        if (_this.rotate) {
            mousePos = chart.mouseY - _this.y;
            if (mousePos < 0) {
                mousePos = 0;
            }
            if (mousePos > height) {
                mousePos = height;
            }
        } else {
            mousePos = chart.mouseX - _this.x;
            if (mousePos < 0) {
                mousePos = 0;
            }

            if (mousePos > width) {
                mousePos = width;
            }
        }
        return mousePos;
    },


    updateCrosshair: function () {
        var _this = this;
        var chart = _this.chart;
        var mouseX = chart.mouseX - _this.x;
        var mouseY = chart.mouseY - _this.y;

        var vLine = _this.vLine;
        var hLine = _this.hLine;

        mouseX = AmCharts.fitToBounds(mouseX, 0, _this.width);
        mouseY = AmCharts.fitToBounds(mouseY, 0, _this.height);

        if (_this.cursorAlpha > 0) {
            vLine.show();
            hLine.show();

            vLine.translate(mouseX, 0);
            hLine.translate(0, mouseY);
        }
        if (_this.zooming) {
            var xx = mouseX;
            var yy = mouseY;

            if (chart.hideXScrollbar) {
                xx = NaN;
            }
            if (chart.hideYScrollbar) {
                yy = NaN;
            }
            _this.updateSelectionSize(xx, yy);
        }

        _this.fireMoved();

        if (!chart.mouseIsOver && !_this.zooming) {
            _this.hideCursor();
        }
    },

    fireMoved:function(){
        var _this = this;
        var chart = _this.chart;
        var name = "moved";
        var cursorEvent = {
            type: name
        };
        cursorEvent.target = _this;
        cursorEvent.chart = chart;
        cursorEvent.zooming = _this.zooming;

        cursorEvent.x = chart.mouseX - _this.x;
        cursorEvent.y = chart.mouseY - _this.y;

        _this.fire(name, cursorEvent);
    },

    updateSelectionSize: function (xx, yy) {
        var _this = this;
        AmCharts.remove(_this.selection);
        var selectionPosX = _this.selectionPosX;
        var selectionPosY = _this.selectionPosY;
        var x = 0;
        var y = 0;
        var width = _this.width;
        var height = _this.height;

        if (!isNaN(xx)) {
            if (selectionPosX > xx) {
                x = xx;
                width = selectionPosX - xx;
            }

            if (selectionPosX < xx) {
                x = selectionPosX;
                width = xx - selectionPosX;
            }

            if (selectionPosX == xx) {
                x = xx;
                width = 0;
            }

            width += _this.extraWidth;
            x -= _this.extraWidth / 2;
        }

        if (!isNaN(yy)) {
            if (selectionPosY > yy) {
                y = yy;
                height = selectionPosY - yy;
            }

            if (selectionPosY < yy) {
                y = selectionPosY;
                height = yy - selectionPosY;
            }

            if (selectionPosY == yy) {
                y = yy;
                height = 0;
            }

            height += _this.extraWidth;
            y -= _this.extraWidth / 2;
        }

        if (width > 0 && height > 0) {
            var selection = AmCharts.rect(_this.container, width, height, _this.cursorColor, _this.selectionAlpha);
            selection.translate(x + _this.x, y + _this.y);
            _this.selection = selection;
        }
    },

    arrangeBalloons: function () {
        var _this = this;
        var valueBalloons = _this.valueBalloons;
        var x = _this.x;
        var y = _this.y;
        var bottom = _this.height + y;

        valueBalloons.sort(_this.compareY);
        var i;

        for (i = 0; i < valueBalloons.length; i++) {
            var balloon = valueBalloons[i].balloon;
            balloon.setBounds(x, y, x + _this.width, bottom);

            balloon.prevX = _this.prevX[i];
            balloon.prevY = _this.prevY[i];

            balloon.prevTX = _this.prevTX[i];
            balloon.prevTY = _this.prevTY[i];

            balloon.draw();

            bottom = balloon.yPos - 3;
        }
        _this.arrangeBalloons2();
    },


    compareY: function (a, b) {
        if (a.yy < b.yy) {
            return 1;
        } else {
            return -1;
        }
    },

    arrangeBalloons2: function () {
        var _this = this;
        var valueBalloons = _this.valueBalloons;
        valueBalloons.reverse();
        var b;
        var x = _this.x;
        var y = _this.y;
        var bPrevious;
        var i;
        var count = valueBalloons.length;

        for (i = 0; i < count; i++) {
            var balloon = valueBalloons[i].balloon;
            b = balloon.bottom;
            var balloonHeight = balloon.bottom - balloon.yPos;
            var index = count - i - 1;

            if (i > 0) {
                if (b - balloonHeight < bPrevious + 3) {
                    balloon.setBounds(x, bPrevious + 3, x + _this.width, bPrevious + balloonHeight + 3);

                    balloon.prevX = _this.prevX[index];
                    balloon.prevY = _this.prevY[index];

                    balloon.prevTX = _this.prevTX[index];
                    balloon.prevTY = _this.prevTY[index];

                    balloon.draw();
                }
            }
            if (balloon.set) {
                balloon.set.show();
            }

            _this.prevX[index] = balloon.prevX;
            _this.prevY[index] = balloon.prevY;

            _this.prevTX[index] = balloon.prevTX;
            _this.prevTY[index] = balloon.prevTY;

            bPrevious = balloon.bottom;
        }
    },

    showBullets: function () {
        var _this = this;

        AmCharts.remove(_this.allBullets);
        var container = _this.container;

        var allBullets = container.set();
        _this.set.push(allBullets);
        _this.set.show();
        _this.allBullets = allBullets;

        var graphs = _this.chart.graphs;
        var i;
        for (i = 0; i < graphs.length; i++) {
            var graph = graphs[i];


            if (!graph.hidden && graph.balloonText) {
                var serialDataItem = _this.data[_this.index];
                var graphDataItem = serialDataItem.axes[graph.valueAxis.id].graphs[graph.id];
                var yy = graphDataItem.y;

                if (!isNaN(yy)) {
                    var xxx;
                    var bxx;
                    var byy;

                    xxx = graphDataItem.x;

                    if (_this.rotate) {
                        bxx = yy;
                        byy = xxx;
                    } else {
                        bxx = xxx;
                        byy = yy;
                    }
                    var bullet = AmCharts.circle(container, _this.bulletSize / 2, _this.chart.getBalloonColor(graph, graphDataItem, true), graph.cursorBulletAlpha);
                    bullet.translate(bxx, byy);
                    _this.allBullets.push(bullet);
                }
            }
        }
    },


    destroy: function () {
        var _this = this;
        _this.clear();

        AmCharts.remove(_this.selection);
        _this.selection = null;

        var categoryBalloon = _this.categoryBalloon;
        if (categoryBalloon) {
            categoryBalloon.destroy();
        }
        _this.destroyValueBalloons();

        AmCharts.remove(_this.set);
    },

    clear: function () {
        var _this = this;
        clearInterval(_this.interval);
    },

    destroyValueBalloons: function () {

        var _this = this;
        var valueBalloons = _this.valueBalloons;

        if (valueBalloons) {
            var i;
            for (i = 0; i < valueBalloons.length; i++) {
                valueBalloons[i].balloon.hide();
            }
        }
    },

    /**
     * @private
     */
    zoom: function (start, end, startTime, endTime) {
        var _this = this;
        var chart = _this.chart;
        _this.destroyValueBalloons();
        _this.zooming = false;
        var currentMouse;

        if (_this.rotate) {
            currentMouse = chart.mouseY;
            _this.selectionPosY = currentMouse;
        } else {
            currentMouse = chart.mouseX;
            _this.selectionPosX = currentMouse;
        }

        _this.start = start;
        _this.end = end;
        _this.startTime = startTime;
        _this.endTime = endTime;
        _this.zoomed = true;

        var categoryAxis = chart.categoryAxis;
        var rotate = _this.rotate;
        var width = _this.width;
        var height = _this.height;
        var stepWidth = categoryAxis.stepWidth;
        var lineWidth;
        var lineHeight;



        if(_this.fullWidth){

            var mult = 1;
            if (categoryAxis.parseDates && !categoryAxis.equalSpacing) {
                mult = categoryAxis.minDuration();
            }

            if (rotate) {
                lineHeight = stepWidth * mult;
                lineWidth = width;
                _this.extraWidth = lineHeight;
            } else {
                lineWidth = stepWidth * mult;
                lineHeight = height;
                _this.extraWidth = lineWidth;
                _this.categoryBalloon.minWidth = lineWidth;
            }

            if(_this.line){
                _this.line.remove();
            }
            _this.line = AmCharts.rect(_this.container, lineWidth, lineHeight, _this.cursorColor, _this.cursorAlpha, 0);
            if(_this.fullRectSet){
                _this.fullRectSet.push(_this.line);
            }
        }

        _this.stepWidth = stepWidth;
        _this.tempVal = _this.valueBalloonsEnabled;
        _this.valueBalloonsEnabled = false;
        _this.setPosition();
        _this.valueBalloonsEnabled = _this.tempVal;
        _this.hideCursor();
    },

    hideObj: function (obj) {
        if (obj) {
            obj.hide();
        }
    },


    hideCursor: function (dispatch) {
        if (dispatch === undefined) {
            dispatch = true;
        }

        var _this = this;
        _this.hideObj(_this.set);
        _this.hideObj(_this.categoryBalloon);
        _this.hideObj(_this.line);
        _this.hideObj(_this.vLine);
        _this.hideObj(_this.hLine);
        _this.hideObj(_this.allBullets);
        _this.destroyValueBalloons();

        if (!_this.selectWithoutZooming) {
            AmCharts.remove(_this.selection);
        }


        _this.previousIndex = NaN;

        if (dispatch) {
            var type = 'onHideCursor';
            _this.fire(type, {
                type: type,
                chart: _this.chart,
                target: _this
            });
        }
        if (!_this.drawing) {
            _this.chart.setMouseCursor('auto');
        }

        _this.normalizeBulletSize();
    },

    setPosition: function (position, dispatch) {
        var _this = this;
        if (dispatch === undefined) {
            dispatch = true;
        }

        if (_this.type == "cursor") {
            if (AmCharts.ifArray(_this.data)) {
                if (isNaN(position)) {
                    position = _this.getMousePosition();
                }
                if (position != _this.previousMousePosition || _this.zoomed === true || _this.oneBalloonOnly) {
                    if (!isNaN(position)) {
                        var index = _this.chart.categoryAxis.xToIndex(position);

                        if (index != _this.previousIndex || _this.zoomed || _this.cursorPosition == "mouse" || _this.oneBalloonOnly) {
                            _this.updateCursor(index, dispatch);
                            _this.zoomed = false;
                        }
                    }
                }

                _this.previousMousePosition = position;
            }
        } else {
            _this.updateCrosshair();
        }
    },


    normalizeBulletSize: function () {
        var _this = this;
        var resizedBullets = _this.resizedBullets;
        if (resizedBullets) {
            for (var i = 0; i < resizedBullets.length; i++) {
                var graphDataItem = resizedBullets[i];
                var bulletGraphics = graphDataItem.bulletGraphics;
                if (bulletGraphics) {
                    bulletGraphics.translate(graphDataItem.bx, graphDataItem.by, 1);
                }
            }
        }
    },

    updateCursor: function (index, dispatch) {
        var _this = this;
        var chart = _this.chart;
        var fullWidth = _this.fullWidth;

        var mouseX = chart.mouseX - _this.x;
        var mouseY = chart.mouseY - _this.y;

        if (_this.drawingNow) {
            AmCharts.remove(_this.drawingLine);
            _this.drawingLine = AmCharts.line(_this.container, [_this.x + _this.drawStartX, _this.x + mouseX], [_this.y + _this.drawStartY, _this.y + mouseY], _this.cursorColor, 1, 1);
        }

        if (_this.enabled) {
            if (dispatch === undefined) {
                dispatch = true;
            }
            index += _this.adjustment;
            _this.index = index;

            var categoryAxis = chart.categoryAxis;
            var dx = chart.dx;
            var dy = chart.dy;
            var x = _this.x + 1;
            var y = _this.y + 1;
            var width = _this.width;
            var height = _this.height;

            var serialDataItem = _this.data[index];

            _this.fireMoved();

            if (serialDataItem) {
                var xx = serialDataItem.x[categoryAxis.id];
                var rotate = chart.rotate;
                var inside = categoryAxis.inside;
                var stepWidth = _this.stepWidth;
                var categoryBalloon = _this.categoryBalloon;
                var firstTime = _this.firstTime;
                var lastTime = _this.lastTime;
                var cursorPosition = _this.cursorPosition;
                var categoryBalloonPosition = categoryAxis.position;
                var zooming = _this.zooming;
                var panning = _this.panning;
                var graphs = chart.graphs;
                var axisThickness = categoryAxis.axisThickness;
                var cursorEvent;

                if (chart.mouseIsOver || zooming || panning || this.forceShow) {
                    this.forceShow = false;
                    // PANNING
                    if (panning) {
                        var difference;
                        var panClickPos = _this.panClickPos;
                        var panClickEndTime = _this.panClickEndTime;
                        var panClickStartTime = _this.panClickStartTime;
                        var panClickEnd = _this.panClickEnd;
                        var panClickStart = _this.panClickStart;

                        if (rotate) {
                            difference = panClickPos - mouseY;
                        } else {
                            difference = panClickPos - mouseX;
                        }

                        var shiftCount = difference / stepWidth;

                        if (!categoryAxis.parseDates || categoryAxis.equalSpacing) {
                            shiftCount = Math.round(shiftCount);
                        }

                        if (shiftCount !== 0) {
                            cursorEvent = {};
                            cursorEvent.type = "zoomed";
                            cursorEvent.target = _this;
                            cursorEvent.chart = _this.chart;

                            if (categoryAxis.parseDates && !categoryAxis.equalSpacing) {
                                if (panClickEndTime + shiftCount > lastTime) {
                                    shiftCount = lastTime - panClickEndTime;
                                }

                                if (panClickStartTime + shiftCount < firstTime) {
                                    shiftCount = firstTime - panClickStartTime;
                                }

                                cursorEvent.start = Math.round(panClickStartTime + shiftCount);
                                cursorEvent.end = Math.round(panClickEndTime + shiftCount);

                                _this.fire(cursorEvent.type, cursorEvent);

                            } else {
                                if (panClickEnd + shiftCount >= _this.data.length || panClickStart + shiftCount < 0) {
                                    // void
                                } else {
                                    cursorEvent.start = panClickStart + shiftCount;
                                    cursorEvent.end = panClickEnd + shiftCount;
                                    _this.fire(cursorEvent.type, cursorEvent);
                                }
                            }
                        }
                    }
                    // SHOWING INDICATOR
                    else {
                        if (cursorPosition == "start") {
                            xx -= categoryAxis.cellWidth / 2;
                        }
                        else if (cursorPosition == "mouse" && chart.mouseIsOver) {
                            if (rotate) {
                                xx = mouseY - 2;
                            } else {
                                xx = mouseX - 2;
                            }
                        }

                        if (rotate) {
                            if (xx < 0) {
                                if (zooming) {
                                    xx = 0;
                                } else {
                                    _this.hideCursor();
                                    return;
                                }
                            }

                            if (xx > height + 1) {
                                if (zooming) {
                                    xx = height + 1;
                                } else {
                                    _this.hideCursor();
                                    return;
                                }
                            }
                        } else {
                            if (xx < 0) {
                                if (zooming) {
                                    xx = 0;
                                } else {
                                    _this.hideCursor();
                                    return;
                                }
                            }

                            if (xx > width) {
                                if (zooming) {
                                    xx = width;
                                } else {
                                    _this.hideCursor();
                                    return;
                                }
                            }
                        }
                        if (_this.cursorAlpha > 0) {
                            var line = _this.line;
                            var lxx;
                            var lyy;
                            if (rotate) {
                                lxx = 0;
                                lyy = xx + dy;
                                if(fullWidth){
                                    lyy -= categoryAxis.cellWidth / 2;
                                }
                            } else {
                                lxx = xx;
                                lyy = 0;
                                if(fullWidth){
                                    lxx -= categoryAxis.cellWidth / 2;
                                }
                            }
                            var animationDuration = _this.animationDuration;
                            if (animationDuration > 0 && !_this.zooming) {
                                if(!isNaN(_this.previousX)){
                                    line.translate(_this.previousX, _this.previousY);
                                    line.animate({
                                        'translate': lxx + ',' + lyy
                                    }, animationDuration, "easeOutSine");
                                }
                                else{
                                    line.translate(lxx, lyy);
                                }

                            } else {
                                line.translate(lxx, lyy);
                            }

                            _this.previousX = lxx;
                            _this.previousY = lyy;

                            line.show();
                        }

                        if (rotate) {
                            _this.linePos = xx + dy;
                        } else {
                            _this.linePos = xx;
                        }

                        // ZOOMING
                        if (zooming) {
                            if(fullWidth){
                                line.hide();
                            }

                            if (rotate) {
                                _this.updateSelectionSize(NaN, xx);
                            } else {
                                _this.updateSelectionSize(xx, NaN);
                            }
                        }

                        var showBalloons = true;
                        if (zooming) {
                            showBalloons = false;
                        }

                        if (_this.categoryBalloonEnabled && showBalloons) {
                            // POINT BALLOON
                            // ROTATE
                            if (rotate) {
                                // INSIDE requires adjusting bounds every time
                                if (inside) {
                                    // RIGHT
                                    if (categoryBalloonPosition == "right") {
                                        categoryBalloon.setBounds(x, y + dy, x + width + dx, y + xx + dy);
                                    }
                                    // LEFT
                                    else {
                                        categoryBalloon.setBounds(x, y + dy, x + width + dx, y + xx);
                                    }
                                }

                                // RIGHT
                                if (categoryBalloonPosition == "right") {
                                    if (inside) {
                                        categoryBalloon.setPosition(x + width + dx, y + xx + dy);
                                    } else {
                                        categoryBalloon.setPosition(x + width + dx + axisThickness, y + xx + dy);
                                    }
                                }
                                // LEFT
                                else {
                                    if (inside) {
                                        categoryBalloon.setPosition(x, y + xx);
                                    } else {
                                        categoryBalloon.setPosition(x - axisThickness, y + xx);
                                    }
                                }
                            }
                            // DO NOT ROTATE
                            else {
                                // TOP
                                if (categoryBalloonPosition == "top") {
                                    if (inside) {
                                        categoryBalloon.setPosition(x + xx + dx, y + dy);
                                    } else {
                                        categoryBalloon.setPosition(x + xx + dx, y + dy - axisThickness + 1);
                                    }
                                }
                                // BOTTOM
                                else {
                                    if (inside) {
                                        categoryBalloon.setPosition(x + xx, y + height);
                                    } else {
                                        categoryBalloon.setPosition(x + xx, y + height + axisThickness - 1);
                                    }
                                }
                            }

                            var categoryBalloonFunction = _this.categoryBalloonFunction;
                            if (categoryBalloonFunction) {
                                categoryBalloon.showBalloon(categoryBalloonFunction(serialDataItem.category));
                            } else {
                                if (categoryAxis.parseDates) {
                                    var fDate = AmCharts.formatDate(serialDataItem.category, _this.categoryBalloonDateFormat);

                                    if (fDate.indexOf("fff") != -1) {
                                        fDate = AmCharts.formatMilliseconds(fDate, serialDataItem.category);
                                    }

                                    categoryBalloon.showBalloon(fDate);
                                } else {
                                    categoryBalloon.showBalloon(AmCharts.fixNewLines(serialDataItem.category));
                                }
                            }
                        } else {
                            categoryBalloon.hide();
                        }

                        // BULLETS
                        if (graphs && _this.bulletsEnabled) {
                            _this.showBullets();
                        }

                        var graph;
                        var mostCloseGraph;
                        var graphDataItem;
                        var yy;
                        // find most close point if only one balloon at a time can be shown
                        if (_this.oneBalloonOnly) {
                            var mostClosePos = Infinity;

                            for (i = 0; i < graphs.length; i++) {
                                graph = graphs[i];

                                if (graph.showBalloon && !graph.hidden && graph.balloonText) {
                                    graphDataItem = serialDataItem.axes[graph.valueAxis.id].graphs[graph.id];
                                    yy = graphDataItem.y;

                                    if (!isNaN(yy)) {
                                        if (rotate) {
                                            if (Math.abs(mouseX - yy) < mostClosePos) {
                                                mostClosePos = Math.abs(mouseX - yy);
                                                mostCloseGraph = graph;
                                            }
                                        } else {
                                            if (Math.abs(mouseY - yy) < mostClosePos) {
                                                mostClosePos = Math.abs(mouseY - yy);
                                                mostCloseGraph = graph;
                                            }
                                        }
                                    }
                                }
                            }
                            if (_this.mostCloseGraph) {
                                mostCloseGraph = _this.mostCloseGraph;
                            }
                        }

                        // VALUE BALLOONS
                        if (index != _this.previousIndex || mostCloseGraph != _this.previousMostCloseGraph) {
                            _this.normalizeBulletSize();
                            _this.destroyValueBalloons();
                            var i;
                            _this.resizedBullets = [];
                            if (graphs && _this.valueBalloonsEnabled && showBalloons && chart.balloon.enabled) {
                                var valueBalloons = [];
                                _this.valueBalloons = valueBalloons;


                                // display balloons
                                for (i = 0; i < graphs.length; i++) {
                                    graph = graphs[i];

                                    if (_this.oneBalloonOnly && graph != mostCloseGraph) {
                                        // void
                                    } else {
                                        if (graph.showBalloon && !graph.hidden && graph.balloonText) {

                                            if(graph.type == "step" && graph.stepDirection == "left"){
                                                serialDataItem = _this.data[index + 1];
                                            }

                                            if(serialDataItem){
                                                graphDataItem = serialDataItem.axes[graph.valueAxis.id].graphs[graph.id];

                                                yy = graphDataItem.y;

                                                if(_this.showNextAvailable && isNaN(yy)){
                                                    if(index + 1 < _this.data.length){
                                                        for(var n = index + 1; n < _this.data.length; n++){
                                                            var nextSerialDataItem = _this.data[n];
                                                            if(nextSerialDataItem){
                                                                graphDataItem = nextSerialDataItem.axes[graph.valueAxis.id].graphs[graph.id];
                                                                yy = graphDataItem.y;
                                                                if (!isNaN(yy)) {
                                                                    break;
                                                                }
                                                            }
                                                        }
                                                    }
                                                }

                                                if (!isNaN(yy)) {
                                                    var xxx;
                                                    var bxx;
                                                    var byy;

                                                    xxx = graphDataItem.x;

                                                    var create = true;

                                                    if (rotate) {
                                                        bxx = yy;
                                                        byy = xxx;

                                                        if (byy < 0 || byy > height) {
                                                            create = false;
                                                        }
                                                    } else {
                                                        bxx = xxx;
                                                        byy = yy;

                                                        if (bxx < 0 || bxx > width + dx + 1) {
                                                            create = false;
                                                        }
                                                    }

                                                    if (create) {

                                                        if (_this.graphBulletSize != 1 && AmCharts.isModern) {
                                                            var bulletGraphics = graphDataItem.bulletGraphics;
                                                            if (bulletGraphics) {
                                                                var bbox = bulletGraphics.getBBox();
                                                                var bScale = _this.graphBulletSize;
                                                                bulletGraphics.translate(graphDataItem.bx, graphDataItem.by, bScale);
                                                                _this.resizedBullets.push(graphDataItem);
                                                            }
                                                        }

                                                        var valueBalloon = graph.valueBalloon;
                                                        var balloonColor = chart.getBalloonColor(graph, graphDataItem);
                                                        valueBalloon.setBounds(x, y, x + width, y + height);
                                                        valueBalloon.pointerOrientation = "H";
                                                        valueBalloon.changeColor(balloonColor);
                                                        if (graph.balloonAlpha !== undefined) {
                                                            valueBalloon.fillAlpha = graph.balloonAlpha;
                                                        }
                                                        if (graph.balloonTextColor !== undefined) {
                                                            valueBalloon.color = graph.balloonTextColor;
                                                        }

                                                        valueBalloon.setPosition(bxx + x, byy + y);

                                                        var balloonText = chart.formatString(graph.balloonText, graphDataItem, true);


                                                        var balloonFunction = graph.balloonFunction;

                                                        if (balloonFunction) {
                                                            balloonText = balloonFunction(graphDataItem, graph).toString();
                                                        }

                                                        if (balloonText !== "") {
                                                            if (rotate) {
                                                                valueBalloon.showBalloon(balloonText);
                                                            } else {
                                                                valueBalloon.text = balloonText;
                                                                valueBalloon.show = true;
                                                            }
                                                        }
                                                        if (!rotate && valueBalloon.set) {
                                                            valueBalloon.set.hide();
                                                        }

                                                        valueBalloons.push({
                                                            yy: yy,
                                                            balloon: valueBalloon
                                                        });
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }

                                if (!rotate) {
                                    _this.arrangeBalloons();
                                }
                            }
                        }

                        if (dispatch) {
                            var name = "changed";
                            cursorEvent = {
                                type: name
                            };
                            cursorEvent.index = index;
                            cursorEvent.chart = _this.chart;
                            cursorEvent.zooming = zooming;
                            cursorEvent.mostCloseGraph = mostCloseGraph;

                            if (rotate) {
                                cursorEvent.position = mouseY;
                            } else {
                                cursorEvent.position = mouseX;
                            }
                            cursorEvent.target = _this;
                            chart.fire(name, cursorEvent);
                            _this.fire(name, cursorEvent);
                            _this.skipZoomDispatch = false;
                        } else {
                            _this.skipZoomDispatch = true;
                            chart.updateLegendValues(index);
                        }

                        _this.previousIndex = index;
                        _this.previousMostCloseGraph = mostCloseGraph;
                    }
                }
            }
        } else {
            _this.hideCursor();
        }
    },

    enableDrawing: function (value) {
        var _this = this;
        _this.enabled = !value;
        _this.hideCursor();
        _this.rolledOver = false;
        _this.drawing = value;
    },

    isZooming: function (value) {
        var _this = this;
        if (value && value != _this.zooming) {
            _this.handleMouseDown('fake');
        }

        if (!value && value != _this.zooming) {
            _this.handleMouseUp();
        }
    },

    handleMouseOut: function () {
        var _this = this;
        if (_this.enabled) {
            if (_this.zooming) {
                _this.setPosition();
            } else {
                _this.index = undefined;
                var cursorEvent = {};
                var name = "changed";
                cursorEvent.type = name;
                cursorEvent.index = undefined;
                cursorEvent.target = _this;
                cursorEvent.chart = _this.chart;
                _this.fire(name, cursorEvent);
                _this.hideCursor();
            }
        }
    },

    handleReleaseOutside: function () {
        this.handleMouseUp();
    },

    handleMouseUp: function () {
        var _this = this;
        var chart = _this.chart;
        var data = _this.data;
        var cursorEvent;
        if (chart) {
            var mouseX = chart.mouseX - _this.x;
            var mouseY = chart.mouseY - _this.y;

            if (_this.drawingNow) {
                _this.drawingNow = false;
                AmCharts.remove(_this.drawingLine);
                var drawStartX = _this.drawStartX;
                var drawStartY = _this.drawStartY;

                if (Math.abs(drawStartX - mouseX) > 2 || Math.abs(drawStartY - mouseY) > 2) {
                    var drawEvent = {
                        type: "draw",
                        target: _this,
                        chart: chart,
                        initialX: drawStartX,
                        initialY: drawStartY,
                        finalX: mouseX,
                        finalY: mouseY
                    };
                    _this.fire(drawEvent.type, drawEvent);
                }
            }

            if (_this.enabled && data.length > 0) {
                if (_this.pan) {
                    _this.rolledOver = false;
                } else {
                    if (_this.zoomable) {
                        if (_this.zooming) {

                            if (_this.selectWithoutZooming) {
                                cursorEvent = {
                                    type: "selected"
                                };
                            } else {
                                cursorEvent = {
                                    type: "zoomed"
                                };
                            }
                            cursorEvent.target = _this;
                            cursorEvent.chart = chart;

                            if (_this.type == "cursor") {
                                var currentMouse;
                                if (_this.rotate) {
                                    currentMouse = mouseY;
                                    _this.selectionPosY = currentMouse;
                                } else {
                                    currentMouse = mouseX;
                                    _this.selectionPosX = currentMouse;
                                }

                                if (Math.abs(currentMouse - _this.initialMouse) < 2 && _this.fromIndex == _this.index) {
                                    // void
                                } else {
                                    if (_this.index < _this.fromIndex) {
                                        cursorEvent.end = _this.fromIndex;
                                        cursorEvent.start = _this.index;
                                    } else {
                                        cursorEvent.end = _this.index;
                                        cursorEvent.start = _this.fromIndex;
                                    }
                                    var categoryAxis = chart.categoryAxis;
                                    if (categoryAxis.parseDates && !categoryAxis.equalSpacing) {
                                        cursorEvent.start = data[cursorEvent.start].time;
                                        cursorEvent.end = chart.getEndTime(data[cursorEvent.end].time);
                                    }
                                    if (!_this.skipZoomDispatch) {
                                        _this.fire(cursorEvent.type, cursorEvent);
                                    }
                                }
                            } else {
                                var initialMouseX = _this.initialMouseX;
                                var initialMouseY = _this.initialMouseY;

                                if (Math.abs(mouseX - initialMouseX) < 3 && Math.abs(mouseY - initialMouseY) < 3) {
                                    // void
                                } else {
                                    var x0 = Math.min(initialMouseX, mouseX);
                                    var y0 = Math.min(initialMouseY, mouseY);

                                    var width = Math.abs(initialMouseX - mouseX);
                                    var height = Math.abs(initialMouseY - mouseY);

                                    if (chart.hideXScrollbar) {
                                        x0 = 0;
                                        width = _this.width;
                                    }

                                    if (chart.hideYScrollbar) {
                                        y0 = 0;
                                        height = _this.height;
                                    }

                                    cursorEvent.selectionHeight = height;
                                    cursorEvent.selectionWidth = width;
                                    cursorEvent.selectionY = y0;
                                    cursorEvent.selectionX = x0;
                                    if (!_this.skipZoomDispatch) {
                                        _this.fire(cursorEvent.type, cursorEvent);
                                    }
                                }
                            }
                            if (!_this.selectWithoutZooming) {
                                AmCharts.remove(_this.selection);
                            }
                        }
                    }
                }

                _this.skipZoomDispatch = false;
                _this.zooming = false;
                _this.panning = false;
            }
        }
    },

    showCursorAt: function (category) {
        var _this = this;
        var chart = _this.chart;
        var categoryAxis = chart.categoryAxis;
        var coordinate;
        if (categoryAxis.parseDates) {
            coordinate = categoryAxis.dateToCoordinate(category);
        } else {
            coordinate = categoryAxis.categoryToCoordinate(category);
        }

        _this.previousMousePosition = NaN;
        _this.forceShow = true;
        _this.setPosition(coordinate, false);
    },


    handleMouseDown: function (event) {
        var _this = this;
        if (_this.zoomable || _this.pan || _this.drawing) {
            var rotate = _this.rotate;
            var chart = _this.chart;
            var mouseX = chart.mouseX - _this.x;
            var mouseY = chart.mouseY - _this.y;

            if ((mouseX > 0 && mouseX < _this.width && mouseY > 0 && mouseY < _this.height) || event == "fake") {
                _this.setPosition();

                if (_this.selectWithoutZooming) {
                    AmCharts.remove(_this.selection);
                }

                if (_this.drawing) {
                    _this.drawStartY = mouseY;
                    _this.drawStartX = mouseX;
                    _this.drawingNow = true;
                } else if (_this.pan) {
                    _this.zoomable = false;
                    chart.setMouseCursor("move");
                    _this.panning = true;

                    if (rotate) {
                        _this.panClickPos = mouseY;
                    } else {
                        _this.panClickPos = mouseX;
                    }

                    _this.panClickStart = _this.start;
                    _this.panClickEnd = _this.end;
                    _this.panClickStartTime = _this.startTime;
                    _this.panClickEndTime = _this.endTime;
                } else if (_this.zoomable) {
                    if (_this.type == "cursor") {

                        _this.fromIndex = _this.index;

                        if (rotate) {
                            _this.initialMouse = mouseY;
                            _this.selectionPosY = _this.linePos;
                        } else {
                            _this.initialMouse = mouseX;
                            _this.selectionPosX = _this.linePos;
                        }
                    } else {
                        _this.initialMouseX = mouseX;
                        _this.initialMouseY = mouseY;

                        _this.selectionPosX = mouseX;
                        _this.selectionPosY = mouseY;
                    }
                    _this.zooming = true;
                }
            }
        }
    }
});

// @tag amchart
AmCharts.ChartScrollbar = AmCharts.Class({

    inherits: AmCharts.SimpleChartScrollbar,

    construct: function (theme) {
        var _this = this;
        _this.cname = "ChartScrollbar";
        AmCharts.ChartScrollbar.base.construct.call(_this, theme);
        _this.graphLineColor = "#BBBBBB";
        _this.graphLineAlpha = 0;
        _this.graphFillColor = "#BBBBBB";
        _this.graphFillAlpha = 1;
        _this.selectedGraphLineColor = "#888888";
        _this.selectedGraphLineAlpha = 0;
        _this.selectedGraphFillColor = "#888888";
        _this.selectedGraphFillAlpha = 1;
        _this.gridCount = 0;
        _this.gridColor = "#FFFFFF";
        _this.gridAlpha = 0.7;
        _this.autoGridCount = false;
        _this.skipEvent = false;
        _this.color = "#FFFFFF";
        _this.scrollbarCreated = false;
        _this.offset = 0;
        // _this.minimum
        // _this.maximum

        AmCharts.applyTheme(_this, theme, _this.cname);
    },


    init: function () {
        var _this = this;
        var categoryAxis = _this.categoryAxis;
        var chart = _this.chart;
        if (!categoryAxis) {
            categoryAxis = new AmCharts.CategoryAxis();
            _this.categoryAxis = categoryAxis;
        }

        categoryAxis.chart = chart;
        categoryAxis.id = "scrollbar";
        categoryAxis.dateFormats = chart.categoryAxis.dateFormats;
        categoryAxis.markPeriodChange = chart.categoryAxis.markPeriodChange;
        categoryAxis.boldPeriodBeginning = chart.categoryAxis.boldPeriodBeginning;
        categoryAxis.axisItemRenderer = AmCharts.RecItem;
        categoryAxis.axisRenderer = AmCharts.RecAxis;
        categoryAxis.guideFillRenderer = AmCharts.RecFill;
        categoryAxis.inside = true;
        categoryAxis.fontSize = _this.fontSize;
        categoryAxis.tickLength = 0;
        categoryAxis.axisAlpha = 0;

        if(AmCharts.isString(_this.graph)){
            _this.graph = AmCharts.getObjById(chart.graphs, _this.graph);
        }

        var graph = _this.graph;

        if (graph) {
            var valueAxis = _this.valueAxis;
            if (!valueAxis) {
                valueAxis = new AmCharts.ValueAxis();
                _this.valueAxis = valueAxis;
                valueAxis.visible = false;
                valueAxis.scrollbar = true;
                valueAxis.axisItemRenderer = AmCharts.RecItem;
                valueAxis.axisRenderer = AmCharts.RecAxis;
                valueAxis.guideFillRenderer = AmCharts.RecFill;
                valueAxis.labelsEnabled = false;
                valueAxis.chart = chart;
            }

            var unselectedGraph = _this.unselectedGraph;
            if (!unselectedGraph) {
                unselectedGraph = new AmCharts.AmGraph();
                unselectedGraph.scrollbar = true;
                _this.unselectedGraph = unselectedGraph;
                unselectedGraph.negativeBase = graph.negativeBase;
                unselectedGraph.noStepRisers = graph.noStepRisers;
            }
            var selectedGraph = _this.selectedGraph;
            if (!selectedGraph) {
                selectedGraph = new AmCharts.AmGraph();
                selectedGraph.scrollbar = true;
                _this.selectedGraph = selectedGraph;
                selectedGraph.negativeBase = graph.negativeBase;
                selectedGraph.noStepRisers = graph.noStepRisers;
            }
        }

        _this.scrollbarCreated = true;
    },


    draw: function () {
        var _this = this;
        AmCharts.ChartScrollbar.base.draw.call(_this);

        if (!_this.scrollbarCreated) {
            _this.init();
        }

        var chart = _this.chart;
        var data = chart.chartData;
        var categoryAxis = _this.categoryAxis;
        var rotate = _this.rotate;
        var x = _this.x;
        var y = _this.y;
        var width = _this.width;
        var height = _this.height;
        var chartCategoryAxis = chart.categoryAxis;
        var set = _this.set;

        categoryAxis.setOrientation(!rotate);
        categoryAxis.parseDates = chartCategoryAxis.parseDates;
        categoryAxis.rotate = rotate;
        categoryAxis.equalSpacing = chartCategoryAxis.equalSpacing;
        categoryAxis.minPeriod = chartCategoryAxis.minPeriod;
        categoryAxis.startOnAxis = chartCategoryAxis.startOnAxis;
        categoryAxis.viW = width;
        categoryAxis.viH = height;
        categoryAxis.width = width;
        categoryAxis.height = height;
        categoryAxis.gridCount = _this.gridCount;
        categoryAxis.gridColor = _this.gridColor;
        categoryAxis.gridAlpha = _this.gridAlpha;
        categoryAxis.color = _this.color;
        categoryAxis.tickLength = 0;
        categoryAxis.axisAlpha = 0;
        categoryAxis.autoGridCount = _this.autoGridCount;

        if (categoryAxis.parseDates && !categoryAxis.equalSpacing) {
            categoryAxis.timeZoom(chart.firstTime, chart.lastTime);
        }
        categoryAxis.zoom(0, data.length - 1);

        var graph = _this.graph;


        if (graph) {
            var valueAxis = _this.valueAxis;
            var graphValueAxis = graph.valueAxis;
            valueAxis.id = graphValueAxis.id;
            valueAxis.rotate = rotate;
            valueAxis.setOrientation(rotate);
            valueAxis.width = width;
            valueAxis.height = height;
            valueAxis.viW = width;
            valueAxis.viH = height;
            valueAxis.dataProvider = data;
            valueAxis.reversed = graphValueAxis.reversed;
            valueAxis.logarithmic = graphValueAxis.logarithmic;
            valueAxis.gridAlpha = 0;
            valueAxis.axisAlpha = 0;
            set.push(valueAxis.set);

            if (rotate) {
                valueAxis.y = y;
                valueAxis.x = 0;
            } else {
                valueAxis.x = x;
                valueAxis.y = 0;
            }

            var min = Infinity;
            var max = -Infinity;
            var i;
            for (i = 0; i < data.length; i++) {
                var values = data[i].axes[graphValueAxis.id].graphs[graph.id].values;
                var k;
                for (k in values) {
                    if (values.hasOwnProperty(k)) {
                        if (k != "percents" && k != "total") {
                            var val = values[k];

                            if (val < min) {
                                min = val;
                            }
                            if (val > max) {
                                max = val;
                            }
                        }
                    }
                }
            }

            if (min != Infinity) {
                valueAxis.minimum = min;
            }
            if (max != -Infinity) {
                valueAxis.maximum = max + (max - min) * 0.1;
            }

            if (min == max) {
                valueAxis.minimum -= 1;
                valueAxis.maximum += 1;
            }

            if (_this.minimum !== undefined) {
                valueAxis.minimum = _this.minimum;
            }

            if (_this.maximum !== undefined) {
                valueAxis.maximum = _this.maximum;
            }

            valueAxis.zoom(0, data.length - 1);

            var ug = _this.unselectedGraph;
            ug.id = graph.id;
            ug.rotate = rotate;
            ug.chart = chart;
            ug.data = data;
            ug.valueAxis = valueAxis;
            ug.chart = graph.chart;
            ug.categoryAxis = _this.categoryAxis;
            ug.periodSpan = graph.periodSpan;
            ug.valueField = graph.valueField;
            ug.openField = graph.openField;
            ug.closeField = graph.closeField;
            ug.highField = graph.highField;
            ug.lowField = graph.lowField;
            ug.lineAlpha = _this.graphLineAlpha;
            ug.lineColorR = _this.graphLineColor;
            ug.fillAlphas = _this.graphFillAlpha;
            ug.fillColorsR = _this.graphFillColor;
            ug.connect = graph.connect;
            ug.hidden = graph.hidden;
            ug.width = width;
            ug.height = height;
            ug.pointPosition = graph.pointPosition;
            ug.stepDirection = graph.stepDirection;
            ug.periodSpan = graph.periodSpan;


            var sg = _this.selectedGraph;
            sg.id = graph.id;
            sg.rotate = rotate;
            sg.chart = chart;
            sg.data = data;
            sg.valueAxis = valueAxis;
            sg.chart = graph.chart;
            sg.categoryAxis = categoryAxis;
            sg.periodSpan = graph.periodSpan;
            sg.valueField = graph.valueField;
            sg.openField = graph.openField;
            sg.closeField = graph.closeField;
            sg.highField = graph.highField;
            sg.lowField = graph.lowField;
            sg.lineAlpha = _this.selectedGraphLineAlpha;
            sg.lineColorR = _this.selectedGraphLineColor;
            sg.fillAlphas = _this.selectedGraphFillAlpha;
            sg.fillColorsR = _this.selectedGraphFillColor;
            sg.connect = graph.connect;
            sg.hidden = graph.hidden;
            sg.width = width;
            sg.height = height;

            sg.pointPosition = graph.pointPosition;
            sg.stepDirection = graph.stepDirection;
            sg.periodSpan = graph.periodSpan;

            var graphType = _this.graphType;

            if (!graphType) {
                graphType = graph.type;
            }

            ug.type = graphType;
            sg.type = graphType;

            var lastIndex = data.length - 1;
            ug.zoom(0, lastIndex);
            sg.zoom(0, lastIndex);

            var dragger = _this.dragger;

            sg.set.click(function () {
                _this.handleBackgroundClick();
            }).mouseover(function () {
                _this.handleMouseOver();
            }).mouseout(function () {
                _this.handleMouseOut();
            });

            ug.set.click(function () {
                _this.handleBackgroundClick();
            }).mouseover(function () {
                _this.handleMouseOver();
            }).mouseout(function () {
                _this.handleMouseOut();
            });
            set.push(ug.set);
            set.push(sg.set);
        }
        set.push(categoryAxis.set);
        set.push(categoryAxis.labelsSet);

        _this.bg.toBack();
        _this.invisibleBg.toFront();
        _this.dragger.toFront();
        _this.iconLeft.toFront();
        _this.iconRight.toFront();
    },

    timeZoom: function (startTime, endTime, dispatch) {
        var _this = this;
        _this.startTime = startTime;
        _this.endTime = endTime;
        _this.timeDifference = endTime - startTime;
        _this.skipEvent = !AmCharts.toBoolean(dispatch);
        _this.zoomScrollbar();

        if(!_this.skipEvent){
            _this.dispatchScrollbarEvent();
        }
    },

    zoom: function (start, end) {
        var _this = this;
        _this.start = start;
        _this.end = end;
        _this.skipEvent = true;
        _this.zoomScrollbar();
    },

    dispatchScrollbarEvent: function () {
        var _this = this;
        if (_this.skipEvent) {
            _this.skipEvent = false;
        } else {
            var data = _this.chart.chartData;
            var draggerPos;
            var draggerSize;
            var dBBox = _this.dragger.getBBox();
            var xx = dBBox.x;
            var yy = dBBox.y;
            var ww = dBBox.width;
            var hh = dBBox.height;
            var chart = _this.chart;

            if (_this.rotate) {
                draggerPos = yy;
                draggerSize = hh;
            } else {
                draggerPos = xx;
                draggerSize = ww;
            }

            var event = {
                type: "zoomed"
            };
            event.target = this;
            event.chart = chart;

            var categoryAxis = _this.categoryAxis;
            var stepWidth = _this.stepWidth;


            if (categoryAxis.parseDates && !categoryAxis.equalSpacing) {
                var lastTime = chart.lastTime;
                var firstTime = chart.firstTime;

                var minDuration = categoryAxis.minDuration();
                var startTime = Math.round(draggerPos / stepWidth) + firstTime;
                var endTime;

                if (!_this.dragging) {
                    endTime = Math.round((draggerPos + draggerSize) / stepWidth) + firstTime;
                } else {
                    endTime = startTime + _this.timeDifference;
                }

                if (startTime > endTime) {
                    startTime = endTime;
                }

                if (startTime != _this.startTime || endTime != _this.endTime) {
                    _this.startTime = startTime;
                    _this.endTime = endTime;
                    event.start = startTime;
                    event.end = endTime;
                    event.startDate = new Date(startTime);
                    event.endDate = new Date(endTime);
                    _this.fire(event.type, event);
                }
            } else {
                if (!categoryAxis.startOnAxis) {
                    var halfStep = stepWidth / 2;
                    draggerPos += halfStep;
                }

                draggerSize -= _this.stepWidth / 2;

                var start = categoryAxis.xToIndex(draggerPos);
                var end = categoryAxis.xToIndex(draggerPos + draggerSize);

                if (start != _this.start || _this.end != end) {
                    if (categoryAxis.startOnAxis) {
                        if (_this.resizingRight && start == end) {
                            end++;
                        }

                        if (_this.resizingLeft && start == end) {
                            if (start > 0) {
                                start--;
                            } else {
                                end = 1;
                            }
                        }
                    }

                    _this.start = start;
                    if (!_this.dragging) {
                        _this.end = end;
                    } else {
                        _this.end = _this.start + _this.difference;
                    }

                    event.start = _this.start;
                    event.end = _this.end;

                    if (categoryAxis.parseDates) {
                        if (data[_this.start]) {
                            event.startDate = new Date(data[_this.start].time);
                        }
                        if (data[_this.end]) {
                            event.endDate = new Date(data[_this.end].time);
                        }
                    }
                    _this.fire(event.type, event);
                }
            }
        }
    },


    zoomScrollbar: function () {
        var _this = this;
        var pos0;
        var pos1;
        var chart = _this.chart;
        var data = chart.chartData;
        var categoryAxis = _this.categoryAxis;
        var stepWidth;

        if (categoryAxis.parseDates && !categoryAxis.equalSpacing) {
            stepWidth = categoryAxis.stepWidth;

            var firstTime = chart.firstTime;

            pos0 = stepWidth * (_this.startTime - firstTime);
            pos1 = stepWidth * (_this.endTime - firstTime);
        } else {
            pos0 = data[_this.start].x[categoryAxis.id];
            pos1 = data[_this.end].x[categoryAxis.id];

            stepWidth = categoryAxis.stepWidth;

            if (!categoryAxis.startOnAxis) {
                var halfStep = stepWidth / 2;
                pos0 -= halfStep;
                pos1 += halfStep;
            }
        }
        _this.stepWidth = stepWidth;
        _this.updateScrollbarSize(pos0, pos1);
    },


    maskGraphs: function (x, y, w, h) {
        var _this = this;
        var selectedGraph = _this.selectedGraph;
        if (selectedGraph) {
            selectedGraph.set.clipRect(x, y, w, h);
        }
    },

    handleDragStart: function () {
        var _this = this;
        AmCharts.ChartScrollbar.base.handleDragStart.call(_this);
        _this.difference = _this.end - _this.start;
        _this.timeDifference = _this.endTime - _this.startTime;
        if (_this.timeDifference < 0) {
            _this.timeDifference = 0;
        }
    },

    handleBackgroundClick: function () {
        var _this = this;
        AmCharts.ChartScrollbar.base.handleBackgroundClick.call(_this);

        if (!_this.dragging) {
            _this.difference = _this.end - _this.start;
            _this.timeDifference = _this.endTime - _this.startTime;
            if (_this.timeDifference < 0) {
                _this.timeDifference = 0;
            }
        }
    }

});

// @tag amchart
AmCharts.SimpleChartScrollbar = AmCharts.Class({

    construct: function (theme) {
        var _this = this;

        _this.createEvents('zoomed');
        _this.backgroundColor = "#D4D4D4";
        _this.backgroundAlpha = 1;
        _this.selectedBackgroundColor = "#EFEFEF";
        _this.selectedBackgroundAlpha = 1;
        _this.scrollDuration = 1;
        _this.resizeEnabled = true;
        _this.hideResizeGrips = false;
        _this.scrollbarHeight = 20;

        _this.updateOnReleaseOnly = false;
        if (document.documentMode < 9) {
            _this.updateOnReleaseOnly = true;
        }
        _this.dragIconWidth = 18;
        _this.dragIconHeight = 25;

        AmCharts.applyTheme(_this, theme, "SimpleChartScrollbar");
    },

    draw: function () {
        var _this = this;
        _this.destroy();
        _this.interval = setInterval(function () {
            _this.updateScrollbar.call(_this);
        }, 40);

        var container = _this.chart.container;
        var rotate = _this.rotate;
        var chart = _this.chart;
        var set = container.set();
        _this.set = set;
        chart.scrollbarsSet.push(set);

        var width;
        var height;

        if (rotate) {
            width = _this.scrollbarHeight;
            height = chart.plotAreaHeight;
        } else {
            height = _this.scrollbarHeight;
            width = chart.plotAreaWidth;
        }

        _this.width = width;
        _this.height = height;

        if (height && width) {
            var bg = AmCharts.rect(container, width, height, _this.backgroundColor, _this.backgroundAlpha, 1, _this.backgroundColor, _this.backgroundAlpha);
            _this.bg = bg;
            set.push(bg);

            var invisibleBg = AmCharts.rect(container, width, height, "#000", 0.005);
            set.push(invisibleBg);
            _this.invisibleBg = invisibleBg;

            invisibleBg.click(function () {
                _this.handleBgClick();
            }).mouseover(function () {
                _this.handleMouseOver();
            }).mouseout(function () {
                _this.handleMouseOut();
            }).touchend(function () {
                _this.handleBgClick();
            });

            var selectedBG = AmCharts.rect(container, width, height, _this.selectedBackgroundColor, _this.selectedBackgroundAlpha);
            _this.selectedBG = selectedBG;
            set.push(selectedBG);

            var dragger = AmCharts.rect(container, width, height, "#000", 0.005);
            _this.dragger = dragger;
            set.push(dragger);

            dragger.mousedown(function (event) {
                _this.handleDragStart(event);
            }).mouseup(function () {
                _this.handleDragStop();
            }).mouseover(function () {
                _this.handleDraggerOver();
            }).mouseout(function () {
                _this.handleMouseOut();
            }).touchstart(function (event) {
                _this.handleDragStart(event);
            }).touchend(function () {
                _this.handleDragStop();
            });

            // drag icons
            var dragIconWidth;
            var dragIconHeight;
            var pathToImages = chart.pathToImages;

            var fileName;
            if (rotate) {
                fileName = pathToImages + "dragIconH.gif";
                dragIconHeight = _this.dragIconWidth;
                dragIconWidth = _this.dragIconHeight;
            } else {
                fileName = pathToImages + "dragIcon.gif";
                dragIconWidth = _this.dragIconWidth;
                dragIconHeight = _this.dragIconHeight;
            }

            var imgLeft = container.image(fileName, 0, 0, dragIconWidth, dragIconHeight);
            var imgRight = container.image(fileName, 0, 0, dragIconWidth, dragIconHeight);

            var iw = 10;
            var ih = 20;
            if (chart.panEventsEnabled) {
                iw = 25;
                ih = _this.scrollbarHeight;
            }

            var rectRight = AmCharts.rect(container, iw, ih, "#000", 0.005);
            var rectLeft = AmCharts.rect(container, iw, ih, "#000", 0.005);
            rectLeft.translate(-(iw - dragIconWidth) / 2, -(ih - dragIconHeight) / 2);
            rectRight.translate(-(iw - dragIconWidth) / 2, -(ih - dragIconHeight) / 2);

            var iconLeft = container.set([imgLeft, rectLeft]);
            var iconRight = container.set([imgRight, rectRight]);

            _this.iconLeft = iconLeft;
            //set.push(_this.iconLeft);  // 3.3.4 - this causes bullets not to export

            _this.iconRight = iconRight;
            //set.push(iconRight);  // 3.3.4 - this causes bullets not to export

            iconLeft.mousedown(function () {
                _this.leftDragStart();
            }).mouseup(function () {
                _this.leftDragStop();
            }).mouseover(function () {
                _this.iconRollOver();
            }).mouseout(function () {
                _this.iconRollOut();
            }).touchstart(function (event) {
                _this.leftDragStart();
            }).touchend(function () {
                _this.leftDragStop();
            });

            iconRight.mousedown(function () {
                _this.rightDragStart();
            }).mouseup(function () {
                _this.rightDragStop();
            }).mouseover(function () {
                _this.iconRollOver();
            }).mouseout(function () {
                _this.iconRollOut();
            }).touchstart(function (event) {
                _this.rightDragStart();
            }).touchend(function () {
                _this.rightDragStop();
            });

            if (AmCharts.ifArray(chart.chartData)) {
                set.show();
            } else {
                set.hide();
            }

            _this.hideDragIcons();
            _this.clipDragger(false);
        }
        set.translate(_this.x, _this.y);
    },


    updateScrollbarSize: function (pos0, pos1) {
        var _this = this;
        var dragger = _this.dragger;
        var clipX;
        var clipY;
        var clipW;
        var clipH;
        var draggerSize;

        if (_this.rotate) {
            clipX = 0;
            clipY = pos0;
            clipW = _this.width + 1;
            clipH = pos1 - pos0;
            draggerSize = pos1 - pos0;
            dragger.setAttr('height', draggerSize);
            dragger.setAttr('y', clipY);
        } else {
            clipX = pos0;
            clipY = 0;
            clipW = pos1 - pos0;
            clipH = _this.height + 1;
            draggerSize = pos1 - pos0;
            dragger.setAttr('width', draggerSize);
            dragger.setAttr('x', clipX);
        }
        _this.clipAndUpdate(clipX, clipY, clipW, clipH);
    },

    updateScrollbar: function () {
        var _this = this;
        var dragerWidth;
        var switchHands = false;
        var prevPos;
        var mousePos;
        var x = _this.x;
        var y = _this.y;
        var dragger = _this.dragger;
        var bbox = _this.getDBox();
        var bboxX = bbox.x + x;
        var bboxY = bbox.y + y;
        var bboxWidth = bbox.width;
        var bboxHeight = bbox.height;
        var rotate = _this.rotate;
        var chart = _this.chart;
        var width = _this.width;
        var height = _this.height;
        var mouseX = chart.mouseX;
        var mouseY = chart.mouseY;

        var initialMouse = _this.initialMouse;

        if (chart.mouseIsOver) {
            if (_this.dragging) {
                var initialCoord = _this.initialCoord;
                if (rotate) {
                    var newY = initialCoord + (mouseY - initialMouse);
                    if (newY < 0) {
                        newY = 0;
                    }
                    var bottomB = height - bboxHeight;

                    if (newY > bottomB) {
                        newY = bottomB;
                    }

                    dragger.setAttr("y", newY);
                } else {
                    var newX = initialCoord + (mouseX - initialMouse);
                    if (newX < 0) {
                        newX = 0;
                    }
                    var rightB = width - bboxWidth;

                    if (newX > rightB) {
                        newX = rightB;
                    }

                    dragger.setAttr("x", newX);
                }
            }



            if (_this.resizingRight) {
                if (rotate) {
                    dragerWidth = mouseY - bboxY;

                    if (dragerWidth + bboxY > height + y) {
                        dragerWidth = height - bboxY + y;
                    }

                    if (dragerWidth < 0) {
                        _this.resizingRight = false;
                        _this.resizingLeft = true;
                        switchHands = true;
                    } else {
                        if (dragerWidth === 0) {
                            dragerWidth = 0.1;
                        }
                        dragger.setAttr('height', dragerWidth);
                    }
                } else {
                    dragerWidth = mouseX - bboxX;

                    if (dragerWidth + bboxX > width + x) {
                        dragerWidth = width - bboxX + x;
                    }

                    if (dragerWidth < 0) {
                        _this.resizingRight = false;
                        _this.resizingLeft = true;
                        switchHands = true;
                    } else {
                        if (dragerWidth === 0) {
                            dragerWidth = 0.1;
                        }
                        dragger.setAttr('width', dragerWidth);
                    }
                }
            }

            if (_this.resizingLeft) {
                if (rotate) {
                    prevPos = bboxY;
                    mousePos = mouseY;

                    // if mouse is out to left
                    if (mousePos < y) {
                        mousePos = y;
                    }
                    //if mouse is out to right
                    if (mousePos > height + y) {
                        mousePos = height + y;
                    }
                    if (switchHands === true) {
                        dragerWidth = prevPos - mousePos;
                    } else {
                        dragerWidth = bboxHeight + prevPos - mousePos;
                    }

                    if (dragerWidth < 0) {
                        _this.resizingRight = true;
                        _this.resizingLeft = false;
                        dragger.setAttr('y', prevPos + bboxHeight - y);
                    } else {
                        if (dragerWidth === 0) {
                            dragerWidth = 0.1;
                        }
                        dragger.setAttr('y', mousePos - y);
                        dragger.setAttr('height', dragerWidth);
                    }
                } else {
                    prevPos = bboxX;
                    mousePos = mouseX;

                    // if mouse is out to left
                    if (mousePos < x) {
                        mousePos = x;
                    }

                    //if mouse is out to right
                    if (mousePos > width + x) {
                        mousePos = width + x;
                    }

                    if (switchHands === true) {
                        dragerWidth = prevPos - mousePos;
                    } else {
                        dragerWidth = bboxWidth + prevPos - mousePos;
                    }

                    if (dragerWidth < 0) {
                        _this.resizingRight = true;
                        _this.resizingLeft = false;
                        dragger.setAttr('x', prevPos + bboxWidth - x);
                    } else {
                        if (dragerWidth === 0) {
                            dragerWidth = 0.1;
                        }

                        dragger.setAttr('x', mousePos - x);
                        dragger.setAttr('width', dragerWidth);
                    }
                }
            }
            _this.clipDragger(true);
        }
    },

    clipDragger: function (dispatch) {
        var _this = this;
        var dragger = _this.dragger;
        var bbox = _this.getDBox();
        if(bbox){
            var bboxX = bbox.x;
            var bboxY = bbox.y;
            var bboxWidth = bbox.width;
            var bboxHeight = bbox.height;

            var update = false;

            if (_this.rotate) {
                bboxX = 0;
                bboxWidth = _this.width + 1;
                if (_this.clipY != bboxY || _this.clipH != bboxHeight) {
                    update = true;
                }
            } else {
                bboxY = 0;
                bboxHeight = _this.height + 1;
                if (_this.clipX != bboxX || _this.clipW != bboxWidth) {
                    update = true;
                }
            }

            if (update) {
                _this.clipAndUpdate(bboxX, bboxY, bboxWidth, bboxHeight);

                if (dispatch) {
                    if (!_this.updateOnReleaseOnly) {
                        _this.dispatchScrollbarEvent();
                    }
                }
            }
        }
    },


    maskGraphs: function () {
        //void
    },

    clipAndUpdate: function (x, y, w, h) {
        var _this = this;
        _this.clipX = x;
        _this.clipY = y;
        _this.clipW = w;
        _this.clipH = h;

        _this.selectedBG.clipRect(x, y, w, h);
        _this.updateDragIconPositions();
        _this.maskGraphs(x, y, w, h);
    },

    dispatchScrollbarEvent: function () {
        var _this = this;
        if (_this.skipEvent) {
            _this.skipEvent = false;
        } else {
            var chart = _this.chart;
            chart.hideBalloon();
            var dBBox = _this.getDBox();
            var xx = dBBox.x;
            var yy = dBBox.y;
            var ww = dBBox.width;
            var hh = dBBox.height;
            var draggerPos;
            var draggerSize;
            var multiplier;

            if (_this.rotate) {
                draggerPos = yy;
                draggerSize = hh;
                multiplier = _this.height / hh;
            } else {
                draggerPos = xx;
                draggerSize = ww;
                multiplier = _this.width / ww;
            }

            var event = {
                type: "zoomed",
                position: draggerPos,
                chart: chart,
                target: _this,
                multiplier: multiplier
            };
            _this.fire(event.type, event);
        }
    },

    updateDragIconPositions: function () {
        var _this = this;
        var bbox = _this.getDBox();
        var xx = bbox.x;
        var yy = bbox.y;
        var iconLeft = _this.iconLeft;
        var iconRight = _this.iconRight;
        var dragIconHeight;
        var dragIconWidth;
        var height = _this.scrollbarHeight;

        if (_this.rotate) {
            dragIconHeight = _this.dragIconWidth;
            dragIconWidth = _this.dragIconHeight;
            iconLeft.translate(_this.x + (height - dragIconWidth) / 2, _this.y + yy - (dragIconHeight) / 2);
            iconRight.translate(_this.x + (height - dragIconWidth) / 2, _this.y + yy + bbox.height - (dragIconHeight) / 2);
        } else {
            dragIconHeight = _this.dragIconHeight;
            dragIconWidth = _this.dragIconWidth;
            iconLeft.translate(_this.x + xx - dragIconWidth / 2,  _this.y + (height - dragIconHeight) / 2);
            iconRight.translate(_this.x + xx - dragIconWidth / 2 + bbox.width,  _this.y + (height - dragIconHeight) / 2);
        }
    },

    showDragIcons: function () {
        var _this = this;
        if (_this.resizeEnabled) {
            _this.iconLeft.show();
            _this.iconRight.show();
        }
    },

    hideDragIcons: function () {
        var _this = this;
        if (!_this.resizingLeft && !_this.resizingRight && !_this.dragging) {
            if (_this.hideResizeGrips || !_this.resizeEnabled) {
                _this.iconLeft.hide();
                _this.iconRight.hide();
            }
            _this.removeCursors();
        }
    },


    removeCursors: function () {
        this.chart.setMouseCursor('auto');
    },

    relativeZoom: function (multiplier, position) {
        var _this = this;
        _this.dragger.stop();
        _this.multiplier = multiplier;
        _this.position = position;

        var pos0 = position;
        var pos1;

        if (_this.rotate) {
            pos1 = pos0 + _this.height / multiplier;
        } else {
            pos1 = pos0 + _this.width / multiplier;
        }

        _this.updateScrollbarSize(pos0, pos1);
    },

    destroy: function () {
        var _this = this;
        _this.clear();
        AmCharts.remove(_this.set);
        AmCharts.remove(_this.iconRight);
        AmCharts.remove(_this.iconLeft);
    },

    clear: function () {
        var _this = this;
        clearInterval(_this.interval);
    },

    handleDragStart: function () {
        var _this = this;
        var chart = _this.chart;
        _this.dragger.stop();

        _this.removeCursors();
        _this.dragging = true;

        var bbox = _this.getDBox();
        if (_this.rotate) {
            _this.initialCoord = bbox.y;
            _this.initialMouse = chart.mouseY;
        } else {
            _this.initialCoord = bbox.x;
            _this.initialMouse = chart.mouseX;
        }
    },

    handleDragStop: function () {
        var _this = this;
        if (_this.updateOnReleaseOnly) {
            _this.updateScrollbar();
            _this.skipEvent = false;
            _this.dispatchScrollbarEvent();
        }

        _this.dragging = false;

        if (_this.mouseIsOver) {
            _this.removeCursors();
        }
        _this.updateScrollbar();
    },

    handleDraggerOver: function () {
        this.handleMouseOver();
    },

    leftDragStart: function () {
        var _this = this;
        _this.dragger.stop();
        _this.resizingLeft = true;
    },

    leftDragStop: function () {
        var _this = this;
        _this.resizingLeft = false;
        if (!_this.mouseIsOver) {
            _this.removeCursors();
        }
        _this.updateOnRelease();
    },

    rightDragStart: function () {
        var _this = this;
        _this.dragger.stop();
        _this.resizingRight = true;
    },


    rightDragStop: function () {
        var _this = this;
        _this.resizingRight = false;
        if (!_this.mouseIsOver) {
            _this.removeCursors();
        }
        _this.updateOnRelease();
    },

    iconRollOut: function () {
        this.removeCursors();
    },

    iconRollOver: function () {
        var _this = this;
        if (_this.rotate) {
            _this.chart.setMouseCursor("n-resize");
        } else {
            _this.chart.setMouseCursor("e-resize");
        }
        _this.handleMouseOver();
    },

    getDBox: function () {
        if(this.dragger){
            var bbox = this.dragger.getBBox();
            return bbox;
        }
    },

    handleBgClick: function () {
        var _this = this;
        if (!_this.resizingRight && !_this.resizingLeft) {
            _this.zooming = true;
            var property;
            var start;
            var end;
            var duration = _this.scrollDuration;
            var dragger = _this.dragger;
            var bbox = _this.getDBox();
            var bboxHeight = bbox.height;
            var bboxWidth = bbox.width;
            var chart = _this.chart;
            var y = _this.y;
            var x = _this.x;
            var rotate = _this.rotate;

            if (rotate) {
                property = "y";
                start = bbox.y;
                end = chart.mouseY - bboxHeight / 2 - y;
                end = AmCharts.fitToBounds(end, 0, _this.height - bboxHeight);
            } else {
                property = "x";
                start = bbox.x;
                end = chart.mouseX - bboxWidth / 2 - x;
                end = AmCharts.fitToBounds(end, 0, _this.width - bboxWidth);
            }
            if (_this.updateOnReleaseOnly) {
                _this.skipEvent = false;
                dragger.setAttr(property, end);
                _this.dispatchScrollbarEvent();
                _this.clipDragger();
            } else {
                end = Math.round(end);
                if (rotate) {
                    dragger.animate({
                        'y': end
                    }, duration, '>');
                } else {
                    dragger.animate({
                        'x': end
                    }, duration, '>');
                }
            }
        }
    },

    updateOnRelease: function () {
        var _this = this;
        if (_this.updateOnReleaseOnly) {
            _this.updateScrollbar();
            _this.skipEvent = false;
            _this.dispatchScrollbarEvent();
        }
    },

    handleReleaseOutside: function () {
        var _this = this;

        if (_this.set) {
            if (_this.resizingLeft || _this.resizingRight || _this.dragging) {
                _this.updateOnRelease();
                _this.removeCursors();
            }

            _this.resizingLeft = false;
            _this.resizingRight = false;
            _this.dragging = false;
            _this.mouseIsOver = false;

            _this.hideDragIcons();
            _this.updateScrollbar();
        }
    },

    handleMouseOver: function () {
        var _this = this;
        _this.mouseIsOver = true;
        _this.showDragIcons();
    },


    handleMouseOut: function () {
        var _this = this;
        _this.mouseIsOver = false;
        _this.hideDragIcons();
    }

});

// @tag amchart
AmCharts.TrendLine = AmCharts.Class({

    construct: function(theme) {
        var _this = this;
        _this.cname = "TrendLine";
        _this.createEvents('click');
        _this.isProtected = false;
        _this.dashLength = 0;
        _this.lineColor = "#00CC00";
        _this.lineAlpha = 1;
        _this.lineThickness = 1;

        AmCharts.applyTheme(_this, theme, _this.cname);
    },

    draw: function() {
        var _this = this;
        _this.destroy();
        var chart = _this.chart;
        var container = chart.container;

        var x1;
        var x2;
        var y1;
        var y2;

        var categoryAxis = _this.categoryAxis;
        var initialDate = _this.initialDate;
        var initialCategory = _this.initialCategory;
        var finalDate = _this.finalDate;
        var finalCategory = _this.finalCategory;
        var valueAxis = _this.valueAxis;
        var valueAxisX = _this.valueAxisX;
        var initialXValue = _this.initialXValue;
        var finalXValue = _this.finalXValue;
        var initialValue = _this.initialValue;
        var finalValue = _this.finalValue;

        var recalculateToPercents = valueAxis.recalculateToPercents;
        var dataDateFormat = chart.dataDateFormat;

        if (categoryAxis) {
            if (initialDate) {
                if (!(initialDate instanceof Date)) {
                    if (dataDateFormat) {
                        initialDate = AmCharts.stringToDate(initialDate, dataDateFormat);
                    } else {
                        initialDate = new Date(initialDate);
                    }
                }
                _this.initialDate = initialDate;
                x1 = categoryAxis.dateToCoordinate(initialDate);
            }
            if (initialCategory) {
                x1 = categoryAxis.categoryToCoordinate(initialCategory);
            }
            if (finalDate) {
                if (!(finalDate instanceof Date)) {
                    if (dataDateFormat) {
                        finalDate = AmCharts.stringToDate(finalDate, dataDateFormat);
                    } else {
                        finalDate = new Date(finalDate);
                    }
                }
                _this.finalDate = finalDate;
                x2 = categoryAxis.dateToCoordinate(finalDate);
            }
            if (finalCategory) {
                x2 = categoryAxis.categoryToCoordinate(finalCategory);
            }
        }

        if (valueAxisX) {
            if (!recalculateToPercents) {
                if (!isNaN(initialXValue)) {
                    x1 = valueAxisX.getCoordinate(initialXValue);
                }
                if (!isNaN(finalXValue)) {
                    x2 = valueAxisX.getCoordinate(finalXValue);
                }
            }
        }

        if (valueAxis) {
            if (!recalculateToPercents) {
                if (!isNaN(initialValue)) {
                    y1 = valueAxis.getCoordinate(initialValue);
                }
                if (!isNaN(finalValue)) {
                    y2 = valueAxis.getCoordinate(finalValue);
                }
            }
        }

        if (!isNaN(x1) && !isNaN(x2) && !isNaN(y1) && !isNaN(y1)) {
            var rotate = chart.rotate;
            var xa;
            var ya;

            if (rotate) {
                xa = [y1, y2];
                ya = [x1, x2];
            } else {
                xa = [x1, x2];
                ya = [y1, y2];
            }

            var lineColor = _this.lineColor;
            var line = AmCharts.line(container, xa, ya, lineColor, _this.lineAlpha, _this.lineThickness, _this.dashLength);

            var xArray = xa;
            var yArray = ya;

            var a = (xa[1] - xa[0]);
            var b = (ya[1] - ya[0]);
            if(a === 0){
                a = 0.01;
            }

            if(b === 0){
                b = 0.01;
            }

            var signX = a / Math.abs(a);
            var signY = b / Math.abs(b);

            var sign = (a * b) / Math.abs(a * b);

            var c = sign * Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));

            var delta = 5;

            var angle1 = Math.asin(a / c);
            var angle2 = 90 * Math.PI / 180 - angle1;

            var dy = Math.abs(Math.cos(angle2) * delta);
            var dx = Math.abs(Math.sin(angle2) * delta);


            xArray.push(xa[1] - signX * dx, xa[0] - signX * dx);
            yArray.push(ya[1] + signY * dy, ya[0] + signY * dy);

            var hoverLine = AmCharts.polygon(container, xArray, yArray, lineColor, 0.005, 0);

            var set = container.set([hoverLine, line]);
            set.translate(chart.marginLeftReal, chart.marginTopReal);
            chart.trendLinesSet.push(set);

            _this.line = line;
            _this.set = set;

            hoverLine.mouseup(function() {
                _this.handleLineClick();
            }).mouseover(function() {
                _this.handleLineOver();
            }).mouseout(function() {
                _this.handleLineOut();
            });

            if (hoverLine.touchend) {
                hoverLine.touchend(function() {
                    _this.handleLineClick();
                });
            }
        }
    },

    handleLineClick: function() {
        var _this = this;
        var event = {
            type: "click",
            trendLine: this,
            chart: _this.chart
        };
        _this.fire(event.type, event);
    },

    handleLineOver: function() {
        var _this = this;
        var rollOverColor = _this.rollOverColor;
        if (rollOverColor !== undefined) {
            _this.line.attr({
                stroke: rollOverColor
            });
        }
    },

    handleLineOut: function() {
        var _this = this;
        _this.line.attr({
            stroke: _this.lineColor
        });
    },

    destroy: function() {
        AmCharts.remove(this.set);
    }
});

// @tag amchart
AmCharts.AmDObject = AmCharts.Class({
    construct: function (name, amDraw) {
        var _this = this;
        _this.D = amDraw;
        _this.R = amDraw.R;
        var node = _this.R.create(this, name);
        _this.node = node;
        _this.x = 0;
        _this.y = 0;
        _this.scale = 1;
    },

    attr: function (attributes) {
        this.R.attr(this, attributes);
        return this;
    },

    getAttr: function (attr) {
        return this.node.getAttribute(attr);
    },

    setAttr: function (attr, value) {
        this.R.setAttr(this, attr, value);
        return this;
    },

    clipRect: function (x, y, w, h) {
        this.R.clipRect(this, x, y, w, h);
    },

    translate: function (x, y, scale, noRound) {
        var _this = this;

        if (!noRound) {
            x = Math.round(x);
            y = Math.round(y);
        }

        this.R.move(this, x, y, scale);
        _this.x = x;
        _this.y = y;

        _this.scale = scale;
        if (_this.angle) {
            _this.rotate(_this.angle);
        }
    },

    rotate: function (angle, bgColor) {
        this.R.rotate(this, angle, bgColor);
        this.angle = angle;
    },

    animate: function (attributes, time, effect) {
        var a;
        for (a in attributes) {
            if (attributes.hasOwnProperty(a)) {
                var attribute = a;
                var to = attributes[a];

                effect = AmCharts.getEffect(effect);

                this.R.animate(this, attribute, to, time, effect);
            }
        }
    },

    push: function (obj) {
        if (obj) {
            var node = this.node;

            node.appendChild(obj.node);

            var clipPath = obj.clipPath;
            if (clipPath) {
                node.appendChild(clipPath);
            }

            var grad = obj.grad;
            if (grad) {
                node.appendChild(grad);
            }
        }
    },

    text: function (str) {
        this.R.setText(this, str);
    },

    remove: function () {
        this.R.remove(this);
    },

    clear: function () {
        var node = this.node;
        if (node.hasChildNodes()) {
            while (node.childNodes.length >= 1) {
                node.removeChild(node.firstChild);
            }
        }
    },

    hide: function () {
        this.setAttr("visibility", "hidden");
    },

    show: function () {
        this.setAttr("visibility", "visible");
    },

    getBBox: function () {
        return this.R.getBBox(this);
    },

    toFront: function () {
        var node = this.node;

        if (node) {
            this.prevNextNode = node.nextSibling;
            var parent = node.parentNode;

            if (parent) {
                parent.appendChild(node);
            }
        }

    },

    toPrevious: function () {
        var node = this.node;
        if (node) {
            if (this.prevNextNode) {
                var parent = node.parentNode;

                if (parent) {
                    parent.insertBefore(this.prevNextNode, null);
                }
            }
        }
    },

    toBack: function () {
        var node = this.node;
        if (node) {
            this.prevNextNode = node.nextSibling;
            var parent = node.parentNode;
            if (parent) {
                var firstChild = parent.firstChild;
                if (firstChild) {
                    parent.insertBefore(node, firstChild);
                }
            }
        }
    },

    mouseover: function (f) {
        this.R.addListener(this, "mouseover", f);
        return this;
    },

    mouseout: function (f) {
        this.R.addListener(this, "mouseout", f);
        return this;
    },

    click: function (f) {
        this.R.addListener(this, "click", f);
        return this;
    },

    dblclick: function (f) {
        this.R.addListener(this, "dblclick", f);
        return this;
    },

    mousedown: function (f) {
        this.R.addListener(this, "mousedown", f);
        return this;
    },

    mouseup: function (f) {
        this.R.addListener(this, "mouseup", f);
        return this;
    },


    touchstart: function (f) {
        this.R.addListener(this, "touchstart", f);
        return this;
    },

    touchend: function (f) {
        this.R.addListener(this, "touchend", f);
        return this;
    },

    contextmenu: function (f) {
        if (this.node.addEventListener) {
            this.node.addEventListener("contextmenu", f, true);
        } else {
            this.R.addListener(this, "contextmenu", f);
        }
        return this;
    },

    stop: function (f) {
        var _this = this;
        var animationX = _this.animationX;

        if (animationX) {
            AmCharts.removeFromArray(_this.R.animations, animationX);
        }

        var animationY = _this.animationY;

        if (animationY) {
            AmCharts.removeFromArray(_this.R.animations, animationY);
        }
    },


    length: function () {
        return this.node.childNodes.length;
    },

    gradient: function (type, colors, rotation) {
        this.R.gradient(this, type, colors, rotation);
    },

    pattern: function (patternURL, scale) {
        if(patternURL){
            this.R.pattern(this, patternURL, scale);
        }
    }

});

// @tag amchart
AmCharts.AmDSet = AmCharts.Class({
    construct: function (arr) {
        var _this = this;
        var group = _this.create("g");
    },

    attr: function (attributes) {
        this.R.attr(this.node, attributes);
    },

    move: function (x, y) {
        this.R.move(this.node, x, y);
    }
});

// @tag amchart
AmCharts.AmDraw = AmCharts.Class({
    construct: function (div, w, h, chart) {
        AmCharts.SVG_NS = "http://www.w3.org/2000/svg";
        AmCharts.SVG_XLINK = 'http://www.w3.org/1999/xlink';
        AmCharts.hasSVG = !! document.createElementNS && !! document.createElementNS(AmCharts.SVG_NS, 'svg').createSVGRect;

        if (w < 1) {
            w = 10;
        }

        if (h < 1) {
            h = 10;
        }

        var _this = this;
        _this.div = div;
        _this.width = w;
        _this.height = h;
        _this.rBin = document.createElement("div");

        if (AmCharts.hasSVG) {
            AmCharts.SVG = true;
            var svg = _this.createSvgElement("svg");
            svg.style.position = "absolute";
            svg.style.width = w + "px";
            svg.style.height = h + "px";

            var desc = _this.createSvgElement("desc");
            desc.appendChild(document.createTextNode('JavaScript chart by amCharts ' + chart.version));
            svg.appendChild(desc);


            if (AmCharts.rtl) {
                svg.setAttribute("direction", "rtl");
                svg.style.left = "auto";
                svg.style.right = "0px";
            }

            svg.setAttribute("version", "1.1");
            div.appendChild(svg);

            _this.container = svg;
            _this.R = new AmCharts.SVGRenderer(_this);
        } else if (AmCharts.isIE) {
            if (AmCharts.VMLRenderer) {
                AmCharts.VML = true;
                if (!AmCharts.vmlStyleSheet) {
                    document.namespaces.add('amvml', 'urn:schemas-microsoft-com:vml');
                    var rule = "behavior:url(#default#VML); display:inline-block; antialias:true";

                    if (document.styleSheets.length < 31) {
                        var ss = document.createStyleSheet();
                        ss.addRule(".amvml", rule);
                        AmCharts.vmlStyleSheet = ss;
                    } else {
                        document.styleSheets[0].addRule(".amvml", rule);
                    }
                }

                _this.container = div;
                _this.R = new AmCharts.VMLRenderer(_this, chart);
                _this.R.disableSelection(div);
            }
        }
    },

    createSvgElement: function (name) {
        return document.createElementNS(AmCharts.SVG_NS, name);
    },

    circle: function (x, y, r, container) {
        var _this = this;

        var c = new AmCharts.AmDObject("circle", _this);
        c.attr({
            r: r,
            cx: x,
            cy: y
        });

        _this.addToContainer(c.node, container);

        return c;
    },

    setSize: function (w, h) {
        if (w > 0 && h > 0) {
            this.container.style.width = w + "px";
            this.container.style.height = h + "px";
        }
    },

    rect: function (x, y, w, h, cr, bw, container) {
        var _this = this;

        var r = new AmCharts.AmDObject("rect", _this);

        if (AmCharts.VML) {
            cr = cr * 100 / Math.min(w, h);
            w += bw * 2;
            h += bw * 2;
            r.bw = bw;
            r.node.style.marginLeft = -bw;
            r.node.style.marginTop = -bw;
        }
        if (w < 1) {
            w = 1;
        }

        if (h < 1) {
            h = 1;
        }

        r.attr({
            x: x,
            y: y,
            width: w,
            height: h,
            rx: cr,
            ry: cr,
            'stroke-width': bw
        });
        _this.addToContainer(r.node, container);
        return r;
    },

    image: function (path, x, y, w, h, container) {
        var _this = this;
        var i = new AmCharts.AmDObject("image", _this);
        i.attr({
            x: x,
            y: y,
            width: w,
            height: h
        });
        _this.R.path(i, path);
        _this.addToContainer(i.node, container);
        return i;
    },

    addToContainer: function (node, container) {
        if (!container) {
            container = this.container;
        }
        container.appendChild(node);
    },

    text: function (text, attr, container) {
        return this.R.text(text, attr, container);
    },

    path: function (pathStr, container, parsed, cs) {
        var _this = this;

        var p = new AmCharts.AmDObject("path", _this);

        if (!cs) {
            cs = "100,100";
        }

        p.attr({
            "cs": cs
        });

        if (parsed) {
            p.attr({
                "dd": pathStr
            });
        } else {
            p.attr({
                "d": pathStr
            });
        }

        _this.addToContainer(p.node, container);

        return p;
    },

    set: function (arr) {
        return this.R.set(arr);
    },

    remove: function (node) {
        if (node) {
            var rBin = this.rBin;
            rBin.appendChild(node);
            rBin.innerHTML = "";
        }
    },

    renderFix: function () {
        var container = this.container;
        var style = container.style;
        var position;

        try {
            position = container.getScreenCTM() || container.createSVGMatrix();
        } catch (e) {
            position = container.createSVGMatrix();
        }
        var left = 1 - position.e % 1;
        var top = 1 - position.f % 1;

        if (left > 0.5) {
            left -= 1;
        }

        if (top > 0.5) {
            top -= 1;
        }

        if (left) {
            style.left = left + "px";
        }
        if (top) {
            style.top = top + "px";
        }
    },

    update: function (){
        this.R.update();
    }



});

// @tag amchart
AmCharts.SVGRenderer = AmCharts.Class({
    construct: function (amDraw) {
        var _this = this;
        _this.D = amDraw;
        _this.animations = [];
    },

    create: function (obj, name) {
        return document.createElementNS(AmCharts.SVG_NS, name);
    },

    attr: function (obj, attributes) {
        var a;
        for (a in attributes) {
            if (attributes.hasOwnProperty(a)) {
                this.setAttr(obj, a, attributes[a]);
            }
        }
    },

    setAttr: function (obj, attr, value) {
        if (value !== undefined) {
            obj.node.setAttribute(attr, value);
        }
    },

    animate: function (obj, attribute, to, time, effect) {
        
        var _this = this;
        var node = obj.node;
        var from;
        
        if (obj["an_" + attribute]) {
            AmCharts.removeFromArray(_this.animations, obj["an_" + attribute]);
        }        

        if (attribute == "translate") {

            from = node.getAttribute("transform");

            if (!from) {
                from = "0,0";
            } else {
                from = String(from).substring(10, from.length - 1);
            }

            from = from.split(", ").join(" ");
            from = from.split(" ").join(",");

            if (from === 0) {
                from = "0,0";
            }
        } else {
            from = Number(node.getAttribute(attribute));            
        }
        
        var animationObj = {
            obj: obj,
            frame: 0,
            attribute: attribute,
            from: from,
            to: to,
            time: time,
            effect: effect
        };        
        
        _this.animations.push(animationObj);

        obj["an_" + attribute] = animationObj;
    },

    update: function () {
        var _this = this;
        var i;       
        var animations = _this.animations;
        var count = animations.length - 1;                
        for (i = count; i >= 0; i--) {
            var animation = animations[i];
            
            var totalCount = animation.time * 1000 / AmCharts.updateRate;
            var frame = animation.frame + 1;
            var obj = animation.obj;
            var attribute = animation.attribute;

            var fromXY;
            var fromX;
            var fromY;
            var toXY;
            var toX;
            var toY;
            var to;

            if (frame <= totalCount) {
                var value;
                animation.frame++;
                if (attribute == "translate") {
                    fromXY = animation.from.split(",");
                    fromX = Number(fromXY[0]);
                    fromY = Number(fromXY[1]);
                    
                    if(isNaN(fromY)){
                        fromY = 0;
                    }

                    toXY = animation.to.split(",");
                    toX = Number(toXY[0]);
                    toY = Number(toXY[1]);

                    var valueX;
                    if (toX - fromX === 0) {
                        valueX = toX;
                    } else {
                        valueX = Math.round(AmCharts[animation.effect](0, frame, fromX, toX - fromX, totalCount));
                    }

                    var valueY;
                    if (toY - fromY === 0) {
                        valueY = toY;
                    } else {
                        valueY = Math.round(AmCharts[animation.effect](0, frame, fromY, toY - fromY, totalCount));
                    }                    
                    attribute = "transform";
                    value = "translate(" + valueX + "," + valueY + ")";
                    
                    
                } else {
                    var from = Number(animation.from);
                    to = Number(animation.to);
                    var change = to - from;

                    value = AmCharts[animation.effect](0, frame, from, change, totalCount);
                    
                    if(isNaN(value)){
                        value = to;
                    }

                    if (change === 0) {
                        _this.animations.splice(i, 1);
                    }
                }

                _this.setAttr(obj, attribute, value);
            } else {
                if (attribute == "translate") {
                    toXY = animation.to.split(",");
                    toX = Number(toXY[0]);
                    toY = Number(toXY[1]);

                    obj.translate(toX, toY);
                } else {
                    to = Number(animation.to);
                    _this.setAttr(obj, attribute, to);
                }

                _this.animations.splice(i, 1);
            }
        }
    },

    getBBox: function (obj) {
        var node = obj.node;
        var bbox = {
            width: 0,
            height: 0,
            x: 0,
            y: 0
        };
        if (node) {
            try {
                return node.getBBox();
            } catch (err) {

            }
        }

        return bbox;
    },

    path: function (obj, p) {
        obj.node.setAttributeNS(AmCharts.SVG_XLINK, "xlink:href", p);
    },

    clipRect: function (obj, x, y, w, h) {
        var _this = this;
        var node = obj.node;

        var old = obj.clipPath;
        if (old) {
            _this.D.remove(old);
        }

        var parent = node.parentNode;
        if (parent) {
            var clipPath = document.createElementNS(AmCharts.SVG_NS, "clipPath");
            var uniqueId = AmCharts.getUniqueId();
            clipPath.setAttribute("id", uniqueId);

            var rect = _this.D.rect(x, y, w, h, 0, 0, clipPath);

            parent.appendChild(clipPath);
            var url = "#";
            if (AmCharts.baseHref && !AmCharts.isIE) {
                url = window.location.href + url;
            }
            _this.setAttr(obj, "clip-path", "url(" + url + uniqueId + ")");
            _this.clipPathC++;

            // save reference in order not to get by id when removing
            obj.clipPath = clipPath;
        }
    },

    text: function (text, attr, container) {
        var _this = this;
        var t = new AmCharts.AmDObject("text", _this.D);

        var textArray = String(text).split("\n");
        var fontSize = attr['font-size'];
        var i;
        for (i = 0; i < textArray.length; i++) {
            var tspan = _this.create(null, "tspan");
            tspan.appendChild(document.createTextNode(textArray[i]));
            tspan.setAttribute("y", (fontSize + 2) * i + Math.round(fontSize / 2));
            tspan.setAttribute("x", 0);
            t.node.appendChild(tspan);
        }
        t.node.setAttribute("y", Math.round(fontSize / 2));


        _this.attr(t, attr);
        _this.D.addToContainer(t.node, container);

        return t;
    },


    setText: function (obj, str) {
        var node = obj.node;
        if (node) {
            node.removeChild(node.firstChild);
            node.appendChild(document.createTextNode(str));
        }
    },

    move: function (obj, x, y, scale) {
        var val = "translate(" + x + "," + y + ")";
        if (scale) {
            val = val + " scale(" + scale + ")";
        }

        this.setAttr(obj, "transform", val);
    },


    rotate: function (obj, angle) {
        var node = obj.node;
        var transform = node.getAttribute("transform");
        var val = "rotate(" + angle + ")";
        if (transform) {
            val = transform + " " + val;
        }
        this.setAttr(obj, "transform", val);
    },

    set: function (arr) {
        var _this = this;
        var s = new AmCharts.AmDObject("g", _this.D);
        _this.D.container.appendChild(s.node);

        if (arr) {
            var i;
            for (i = 0; i < arr.length; i++) {
                s.push(arr[i]);
            }
        }
        return s;
    },

    addListener: function (obj, event, f) {
        obj.node["on" + event] = f;
    },

    gradient: function (obj, type, colors, rotation) {
        var _this = this;
        var node = obj.node;

        var old = obj.grad;
        if (old) {
            _this.D.remove(old);
        }

        var gradient = document.createElementNS(AmCharts.SVG_NS, type);
        var uniqueId = AmCharts.getUniqueId();
        gradient.setAttribute("id", uniqueId);

        if (!isNaN(rotation)) {
            var x1 = 0;
            var x2 = 0;
            var y1 = 0;
            var y2 = 0;

            if (rotation == 90) {
                y1 = 100;
            } else if (rotation == 270) {
                y2 = 100;
            } else if (rotation == 180) {
                x1 = 100;
            } else if (rotation === 0) {
                x2 = 100;
            }

            var p = "%";

            gradient.setAttribute("x1", x1 + p);
            gradient.setAttribute("x2", x2 + p);
            gradient.setAttribute("y1", y1 + p);
            gradient.setAttribute("y2", y2 + p);
        }
        var i;
        for (i = 0; i < colors.length; i++) {
            var stop = document.createElementNS(AmCharts.SVG_NS, "stop");
            var offset = 100 * i / (colors.length - 1);
            if (i === 0) {
                offset = 0;
            }
            stop.setAttribute("offset", offset + "%");
            stop.setAttribute("stop-color", colors[i]);
            gradient.appendChild(stop);
        }
        node.parentNode.appendChild(gradient);        

        var url = "#";
        if (AmCharts.baseHref && !AmCharts.isIE) {
            url = window.location.href + url;
        }

        node.setAttribute("fill", "url(" + url + uniqueId + ")");

        obj.grad = gradient;
    },
    
    
    pattern: function (obj, pattern, scale) {
        var _this = this;
        var node = obj.node;
        
        if(isNaN(scale)){
            scale = 1;
        }
        
        var old = obj.patternNode;
        if (old) {
            _this.D.remove(old);
        }
        
        var patternNode = document.createElementNS(AmCharts.SVG_NS, "pattern");
        var uniqueId = AmCharts.getUniqueId();
        var url = pattern;
        if(pattern.url){
            url = pattern.url;
        }
        
        
        var width = Number(pattern.width);
        if(isNaN(width)){
            width = 4;
        }
        
        var height = Number(pattern.height);
        if(isNaN(height)){
            height = 4;
        }
        
        width = width / scale;
        height = height / scale;
        
        var x = pattern.x;        
        if(isNaN(x)){
            x = 0;
        }
        var randomX = -Math.random() * Number(pattern.randomX);
        if(!isNaN(randomX)){
            x = randomX;
        }
        
        var y = pattern.y;        
        if(isNaN(y)){
            y = 0;
        }
        var randomY = -Math.random() * Number(pattern.randomY);
        if(!isNaN(randomY)){
            y = randomY;
        }        
        
        patternNode.setAttribute("id", uniqueId);
        patternNode.setAttribute("width", width);
        patternNode.setAttribute("height", height);
        patternNode.setAttribute('patternUnits','userSpaceOnUse');
        patternNode.setAttribute("xlink:href", url);
        
        var image = _this.D.image(url, 0, 0, width, height, patternNode);
        image.translate(x, y)
        
       
        var url = "#";
        if (AmCharts.baseHref && !AmCharts.isIE) {
            url = window.location.href + url;
        }

        node.setAttribute("fill", "url(" + url + uniqueId + ")");

        obj.patternNode = patternNode;
        node.parentNode.appendChild(patternNode);
    },    
    

    remove: function (obj) {
        var _this = this;

        if (obj.clipPath) {
            _this.D.remove(obj.clipPath);
        }

        if (obj.grad) {
            _this.D.remove(obj.grad);
        }
        
        if (obj.patternNode) {
            _this.D.remove(obj.patternNode);
        }
        
        _this.D.remove(obj.node);
    }

});

// @tag amchart
AmCharts.VMLRenderer = AmCharts.Class({
    construct: function (amDraw, chart) {
        var _this = this;
        _this.chart = chart;
        _this.D = amDraw;
        _this.cNames = {
            circle: "oval",
            rect: "roundrect",
            path: "shape"
        };
        _this.styleMap = {
            "x": "left",
                "y": "top",
                "width": "width",
                "height": "height",
                "font-family": "fontFamily",
                "font-size": "fontSize",
                "visibility": "visibility"
        };
    },

    create: function (obj, name) {
        var node;
        if (name == "group") {
            node = document.createElement("div");
            obj.type = "div";
        } else if (name == "text") {
            node = document.createElement("div");
            obj.type = "text";
        } else if (name == "image") {
            node = document.createElement("img");
            obj.type = "image";
        } else {
            obj.type = "shape";
            obj.shapeType = this.cNames[name];

            node = document.createElement("amvml:" + this.cNames[name]);
            var stroke = document.createElement("amvml:stroke");
            node.appendChild(stroke);
            obj.stroke = stroke;

            var fill = document.createElement("amvml:fill");
            node.appendChild(fill);
            obj.fill = fill;
            fill.className = "amvml";
            stroke.className = "amvml";
            node.className = "amvml";
        }

        node.style.position = "absolute";
        node.style.top = 0;
        node.style.left = 0;

        return node;
    },

    path: function (obj, p) {
        obj.node.setAttribute("src", p);
    },


    setAttr: function (obj, attr, value) {
        if (value !== undefined) {
            var mode8;
            if (document.documentMode === 8) {
                mode8 = true;
            }

            var node = obj.node;

            var _this = this;
            var type = obj.type;
            var shapeType = obj.shapeType;
            var nodeStyle = node.style;


            // circle radius
            if (attr == "r") {
                nodeStyle.width = value * 2;
                nodeStyle.height = value * 2;
            }

            if (obj.shapeType == "roundrect") {
                if (attr == "width" || attr == "height") {
                    value -= 1;
                }
            }

            if (attr == "cursor") {
                nodeStyle.cursor = value;
            }

            // circle x
            if (attr == "cx") {
                nodeStyle.left = value - AmCharts.removePx(nodeStyle.width) / 2;
            }
            // circle y
            if (attr == "cy") {
                nodeStyle.top = value - AmCharts.removePx(nodeStyle.height) / 2;
            }

            var styleName = _this.styleMap[attr];
            if (styleName !== undefined) {
                nodeStyle[styleName] = value;
            }

            if (type == "text") {
                if (attr == "text-anchor") {
                    var px = "px";
                    obj.anchor = value;

                    var textWidth = node.clientWidth;

                    if (value == "end") {
                        nodeStyle.marginLeft = -textWidth + px;
                    }
                    if (value == "middle") {
                        nodeStyle.marginLeft = -(textWidth / 2) + px;
                        nodeStyle.textAlign = "center";
                    }
                    if (value == "start") {
                        nodeStyle.marginLeft = 0 + px;
                    }
                }
                if (attr == "fill") {
                    nodeStyle.color = value;
                }
                if (attr == "font-weight") {
                    nodeStyle.fontWeight = value;
                }
            }

            var children = obj.children;
            if (children) {
                var i;
                for (i = 0; i < children.length; i++) {
                    children[i].setAttr(attr, value);
                }
            }

            // path
            if (type == "shape") {
                if (attr == "cs") {
                    node.style.width = "100px";
                    node.style.height = "100px";
                    node.setAttribute("coordsize", value);
                }

                if (attr == "d") {
                    node.setAttribute("path", _this.svgPathToVml(value));
                }

                if (attr == "dd") {
                    node.setAttribute("path", value);
                }

                var stroke = obj.stroke;
                var fill = obj.fill;

                if (attr == "stroke") {
                    if (mode8) {
                        stroke.color = value;
                    } else {
                        stroke.setAttribute("color", value);
                    }
                }

                if (attr == "stroke-width") {
                    if (mode8) {
                        stroke.weight = value;
                    } else {
                        stroke.setAttribute("weight", value);
                    }
                }

                if (attr == "stroke-opacity") {
                    if (mode8) {
                        stroke.opacity = value;
                    } else {
                        stroke.setAttribute("opacity", value);
                    }
                }
                if (attr == "stroke-dasharray") {
                    var val = "solid";
                    if (value > 0 && value < 3) {
                        val = "dot";
                    }
                    if (value >= 3 && value <= 6) {
                        val = "dash";
                    }
                    if (value > 6) {
                        val = "longdash";
                    }
                    if (mode8) {
                        stroke.dashstyle = val;
                    } else {
                        stroke.setAttribute("dashstyle", val);
                    }
                }
                if (attr == "fill-opacity" || attr == "opacity") {
                    if (value === 0) {
                        if (mode8) {
                            fill.on = false;
                        } else {
                            fill.setAttribute("on", false);
                        }
                    } else {
                        if (mode8) {
                            fill.opacity = value;
                        } else {
                            fill.setAttribute("opacity", value);
                        }
                    }

                }

                if (attr == "fill") {
                    if (mode8) {
                        fill.color = value;
                    } else {
                        fill.setAttribute("color", value);
                    }
                }

                if (attr == "rx") {
                    if (mode8) {
                        node.arcSize = value + "%";
                    } else {
                        node.setAttribute("arcsize", value + "%");
                    }
                }
            }
        }
    },

    attr: function (obj, attributes) {
        var _this = this;
        var a;
        for (a in attributes) {
            if (attributes.hasOwnProperty(a)) {
                _this.setAttr(obj, a, attributes[a]);
            }
        }
    },

    text: function (text, attr, container) {
        var _this = this;

        var t = new AmCharts.AmDObject("text", _this.D);
        var node = t.node;
        node.style.whiteSpace = "pre";
        //var txt = document.createTextNode(text);

        node.innerHTML = text;
        _this.D.addToContainer(node, container);
        _this.attr(t, attr);

        return t;
    },

    getBBox: function (obj) {
        var node = obj.node;
        var box = this.getBox(node);
        return box;
    },

    getBox: function (node) {
        var x = node.offsetLeft;
        var y = node.offsetTop;

        var width = node.offsetWidth;
        var height = node.offsetHeight;

        var bbox;

        if (node.hasChildNodes()) {
            var xs;
            var ys;
            var i;
            for (i = 0; i < node.childNodes.length; i++) {
                var childNode = node.childNodes[i];
                bbox = this.getBox(childNode);
                var xx = bbox.x;

                if (!isNaN(xx)) {
                    if (isNaN(xs)) {
                        xs = xx;
                    } else if (xx < xs) {
                        xs = xx;
                    }
                }

                var yy = bbox.y;

                if (!isNaN(yy)) {
                    if (isNaN(ys)) {
                        ys = yy;
                    } else if (yy < ys) {
                        ys = yy;
                    }
                }


                var ww = bbox.width + xx;

                if (!isNaN(ww)) {
                    width = Math.max(width, ww);
                }

                var hh = bbox.height + yy;

                if (!isNaN(hh)) {
                    height = Math.max(height, hh);
                }
            }

            if (xs < 0) {
                x += xs;
            }
            if (ys < 0) {
                y += ys;
            }
        }

        return ({
            x: x,
            y: y,
            width: width,
            height: height
        });
    },

    setText: function (obj, str) {
        var node = obj.node;
        if (node) {
            node.innerHTML = str;
        }
        this.setAttr(obj, "text-anchor", obj.anchor);
    },

    addListener: function (obj, event, f) {
        obj.node["on" + event] = f;
    },

    move: function (obj, x, y) {
        var _this = this;
        var node = obj.node;
        var nodeStyle = node.style;

        if (obj.type == "text") {
            y -= AmCharts.removePx(nodeStyle.fontSize) / 2 - 1;
        }

        if (obj.shapeType == "oval") {
            x -= AmCharts.removePx(nodeStyle.width) / 2;
            y -= AmCharts.removePx(nodeStyle.height) / 2;
        }

        var bw = obj.bw;

        if (!isNaN(bw)) {
            x -= bw;
            y -= bw;
        }

        var px = "px";
        if (!isNaN(x) && !isNaN(y)) {
            node.style.left = x + px;
            node.style.top = y + px;
        }
    },

    svgPathToVml: function (path) {
        var pathArray = path.split(" ");
        path = "";
        var previousArray;
        var round = Math.round;
        var comma = ",";
        var i;
        for (i = 0; i < pathArray.length; i++) {
            var el = pathArray[i];
            var letter = el.substring(0, 1);
            var numbers = el.substring(1);
            var numbersArray = numbers.split(",");

            var rounded = round(numbersArray[0]) + comma + round(numbersArray[1]);

            if (letter == "M") {
                path += " m " + rounded;
            }
            if (letter == "L") {
                path += " l " + rounded;
            }
            if (letter == "Z") {
                path += " x e";
            }
            if (letter == "Q") {
                var length = previousArray.length;
                var qp0x = previousArray[length - 2];
                var qp0y = previousArray[length - 1];

                var qp1x = numbersArray[0];
                var qp1y = numbersArray[1];

                var qp2x = numbersArray[2];
                var qp2y = numbersArray[3];

                var cp1x = round(qp0x / 3 + 2 / 3 * qp1x);
                var cp1y = round(qp0y / 3 + 2 / 3 * qp1y);

                var cp2x = round(2 / 3 * qp1x + qp2x / 3);
                var cp2y = round(2 / 3 * qp1y + qp2y / 3);

                path += " c " + cp1x + comma + cp1y + comma + cp2x + comma + cp2y + comma + qp2x + comma + qp2y;
            }

            if (letter == "A") {
                path += " wa " + numbers;
            }

            if (letter == "B") {
                path += " at " + numbers;
            }

            previousArray = numbersArray;
        }

        return path;
    },


    animate: function (obj, attribute, to, time, effect) {
        var _this = this;
        var node = obj.node;
        var nodeStyle = node.style;
        var from;
        var chart = _this.chart;

        if (attribute == "translate") {
            var toA = to.split(",");
            var toX = toA[0];
            var toY = toA[1];

            var fromX = node.offsetLeft;
            var fromY = node.offsetTop;

            chart.animate(obj, "left", fromX, toX, time, effect, "px");
            chart.animate(obj, "top", fromY, toY, time, effect, "px");
        }
    },



    clipRect: function (obj, x, y, w, h) {
        var node = obj.node;
        var PX = "px";
        if (x === 0 && y === 0) {
            node.style.width = w + PX;
            node.style.height = h + PX;
            node.style.overflow = "hidden";
        } else {
            node.style.clip = "rect(" + y + "px " + (x + w) + "px " + (y + h) + "px " + x + "px)";
        }
    },

    rotate: function (obj, deg, bgColor) {
        if (Number(deg) !== 0) {
            var node = obj.node;
            var style = node.style;

            if(!bgColor){
                bgColor = this.getBGColor(node.parentNode);
            }

            style.backgroundColor = bgColor;
            style.paddingLeft = 1;

            var rad = deg * Math.PI / 180;
            var costheta = Math.cos(rad);
            var sintheta = Math.sin(rad);

            var left = AmCharts.removePx(style.left);
            var top = AmCharts.removePx(style.top);
            var width = node.offsetWidth;
            var height = node.offsetHeight;

            var sign = deg / Math.abs(deg);

            style.left = left + width / 2 - width / 2 * Math.cos(rad) - sign * height / 2 * Math.sin(rad) + 3;
            style.top = top - sign * width / 2 * Math.sin(rad) + sign * height / 2 * Math.sin(rad);

            style.cssText = style.cssText + "; filter:progid:DXImageTransform.Microsoft.Matrix(M11='" + costheta + "', M12='" + -sintheta + "', M21='" + sintheta + "', M22='" + costheta + "', sizingmethod='auto expand');";
        }
    },


    getBGColor: function (node) {
        var style = node.style;
        var bgColor = "#FFFFFF";

        if (style) {
            var color = node.style.backgroundColor;
            if (color !== "") {
                bgColor = color;
            } else if (node.parentNode) {
                bgColor = this.getBGColor(node.parentNode);
            }
        }
        return bgColor;
    },

    set: function (arr) {
        var _this = this;
        var s = new AmCharts.AmDObject("group", _this.D);
        _this.D.container.appendChild(s.node);

        if (arr) {
            var i;
            for (i = 0; i < arr.length; i++) {
                s.push(arr[i]);
            }
        }
        return s;
    },

    gradient: function (obj, type, colors, rotation) {
        var _this = this;

        var c = "";

        if (type == "radialGradient") {
            type = "gradientradial";
            colors.reverse();
        }

        if (type == "linearGradient") {
            type = "gradient";
        }
        var i;
        for (i = 0; i < colors.length; i++) {
            var offset = Math.round(i * 100 / (colors.length - 1));

            c += offset + "% " + colors[i];
            if (i < colors.length - 1) {
                c += ",";
            }
        }

        var fill = obj.fill;

        if (rotation == 90) {
            rotation = 0;
        } else if (rotation == 270) {
            rotation = 180;
        } else if (rotation == 180) {
            rotation = 90;
        } else if (rotation === 0) {
            rotation = 270;
        }

        if (document.documentMode === 8) {
            fill.type = type;
            fill.angle = rotation;
        } else {
            fill.setAttribute("type", type);
            fill.setAttribute("angle", rotation);
        }
        if (c) {
            fill.colors.value = c;
        }
    },

    remove: function (obj) {
        var _this = this;

        if (obj.clipPath) {
            _this.D.remove(obj.clipPath);
        }
        _this.D.remove(obj.node);
    },

    disableSelection: function (target) {
        if (typeof target.onselectstart !== undefined) {
            target.onselectstart = function () {
                return false;
            };
        }
        target.style.cursor = "default";
    },

    pattern: function (obj, pattern) {
        var _this = this;
        var node = obj.node;

        var fill = obj.fill;
        var type = "tile";

        node.fillColor = "none";
        if (document.documentMode === 8) {
            fill.type = type;
            fill.src = pattern.url;
        } else {
            fill.setAttribute("type", type);
            fill.setAttribute("src", pattern.url);
        }
    },

    update: function () {
        // void
    }


});

// @tag amchart
AmCharts.AmExport = AmCharts.Class({
	construct: function(chart, cfg) {
		var _this		= this;
		_this.DEBUG		= false;
		_this.chart		= chart;
		_this.canvas	= null;
		_this.svgs		= [];
		_this.cfg		= {
			menuTop					: 'auto',
			menuLeft				: 'auto',
			menuRight				: '0px',
			menuBottom				: '0px',
			menuItems				: [{
				textAlign				: 'center',
				icon					: _this.chart.pathToImages + 'export.png',
				iconTitle				: 'Save chart as an image',
				format					: 'png'
			}],
			menuItemStyle			: {
			backgroundColor			: 'transparent',
			rollOverBackgroundColor	: '#EFEFEF',
			color					: '#000000',
			rollOverColor			: '#CC0000',
			paddingTop				: '6px',
			paddingRight			: '6px',
			paddingBottom			: '6px',
			paddingLeft				: '6px',
			marginTop				: '0px',
			marginRight				: '0px',
			marginBottom			: '0px',
			marginLeft				: '0px',
			textAlign				: 'left',
			textDecoration			: 'none',
			fontFamily				: _this.chart.fontFamily,
			fontSize				: _this.chart.fontSize + 'px'
			},
			menuItemOutput			: {
				backgroundColor			: '#FFFFFF',
				fileName				: 'amChart',
				format					: 'png',
				output					: 'dataurlnewwindow',
				render					: 'browser',
				dpi						: 90,
				onclick					: function(instance, config, event) {
					event.preventDefault();
					// Polify SVG; needs to wait
					instance.polifySVG();
					instance.output(config);
				}
			},
			removeImagery: false
		};
		_this.processing = {
			buffer: [],
			drawn: 0,
			timer: 0
		};

		// Config dependency adaption
		if (typeof(window.canvg) != 'undefined' && typeof(window.RGBColor) != 'undefined') {
			_this.cfg.menuItemOutput.render = 'canvg';
		}
		if (typeof(window.saveAs) != 'undefined') {
			_this.cfg.menuItemOutput.output = 'save';
		}
		if (AmCharts.isIE && AmCharts.IEversion < 10) {
			_this.cfg.menuItemOutput.output = 'dataurlnewwindow';
		}

		// Merge given configs
		if (cfg) {
			cfg.menuItemOutput = AmCharts.extend(_this.cfg.menuItemOutput, cfg.menuItemOutput || {});
			cfg.menuItemStyle = AmCharts.extend(_this.cfg.menuItemStyle, cfg.menuItemStyle || {});
			_this.cfg = AmCharts.extend(_this.cfg, cfg);
		}

		// Add reference to chart
		_this.chart.AmExport = _this;

		// Listen to the drawer
		_this.chart.addListener('rendered', function() {
			_this.setup();
		});

		// DEBUG; Public reference
		if (_this.DEBUG) {
			window.AmExport = _this;
		}
	},

	/*
	Simple log function for internal purpose
	@param **args
	*/
	log: function() {
		console.log('AmExport: ', arguments);
	},

	/* PUBLIC
	Prepares everything to get exported
	@param none
	*/
	setup: function() {
		var _this = this;

		if (_this.DEBUG == 10) {
			_this.log('SETUP START');
		} // DEBUG


		if (!AmCharts.isIE || (AmCharts.isIE && AmCharts.IEversion > 9)) {
			// Build Buttons
			_this.generateButtons();
			if (_this.DEBUG == 10) {
				_this.log('SETUP END');
			} // DEBUG
		} else {
			if (_this.DEBUG == 10) {
				_this.log('< IE10 NOT SUPPORTED');
			} // DEBUG
		}
	},

	/* PUBLIC
	Decodes base64 string to binary array
	@param base64_string
	@copyright Eli Grey, http://eligrey.com and Devin Samarin, https://github.com/eboyjr
	*/
	generateBinaryArray: function(base64_string) {
		var
		len = base64_string.length,
			buffer = new Uint8Array(len / 4 * 3 | 0),
			i = 0,
			outptr = 0,
			last = [0, 0],
			state = 0,
			save = 0,
			rank, code, undef, base64_ranks = new Uint8Array([
				62, -1, -1, -1, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, 0, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51
			]);
		while (len--) {
			code = base64_string.charCodeAt(i++);
			rank = base64_ranks[code - 43];
			if (rank !== 255 && rank !== undef) {
				last[1] = last[0];
				last[0] = code;
				save = (save << 6) | rank;
				state++;
				if (state === 4) {
					buffer[outptr++] = save >>> 16;
					if (last[1] !== 61 /* padding character */ ) {
						buffer[outptr++] = save >>> 8;
					}
					if (last[0] !== 61 /* padding character */ ) {
						buffer[outptr++] = save;
					}
					state = 0;
				}
			}
		}
		// 2/3 chance there's going to be some null bytes at the end, but that
		// doesn't really matter with most image formats.
		// If it somehow matters for you, truncate the buffer up outptr.
		return buffer;
	},

	/*
	Creates blob object
	@param base64_datastring string
	@param type string
	*/
	generateBlob: function(datastring, type) {
		var _this = this,
			header_end = datastring.indexOf(',') + 1,
			header = datastring.substring(0, header_end),
			data = datastring,
			blob = new Blob();

		if (header.indexOf('base64') != -1) {
			data = _this.generateBinaryArray(datastring.substring(header_end));
		}

		// Fake blob for IE
		if (AmCharts.isIE && AmCharts.IEversion < 10) {
			blob.data = data;
			blob.size = data.length;
			blob.type = type;
			blob.encoding = 'base64';
		} else {
			blob = new Blob([data], {
				type: type
			});
		}
		return blob;
	},

	/*
	Creates PDF object
	@param config object
	*/
	generatePDF: function(cfg) {
		var _this = this,
			pdf = {
				output: function() {
					return '';
				}
			},
			data = _this.canvas.toDataURL('image/jpeg'), // JSPDF ONLY SUPPORTS JPG
			width = (_this.canvas.width * 25.4) / cfg.dpi,
			height = (_this.canvas.height * 25.4) / cfg.dpi;

		// Check
		if (window.jsPDF) {
			pdf = new jsPDF();
			if (pdf.addImage) {
				pdf.addImage(data, 'JPEG', 0, 0, width, height);
			} else {
				alert("Missing jsPDF plugin; Please add the 'addImage' plugin.");
			}
		} else {
			alert("Missing jsPDF lib; Don't forget to add the addImage plugin.");
		}

		return pdf;
	},

	/*
	Creates the CANVAS to receive the image data
	@param format void()
	@param callback; given callback function which returns the blob or datastring of the configured ouput type
	*/
	output: function(cfg, externalCallback) {
		var _this = this;
		cfg = AmCharts.extend(AmCharts.extend({}, _this.cfg.menuItemOutput), cfg || {});

		/* PRIVATE
		Callback function which gets called after the drawing process is done
		@param none
		*/
		function internalCallback() {
			var data = null;
			var blob;
			if (_this.DEBUG == 10) {
				_this.log('OUTPUT', format);
			} // DEBUG

			// SVG
			if (cfg.format == 'image/svg+xml' || cfg.format == 'svg') {
				for (var i = 0; i < _this.processing.buffer.length; i++) {
					data = new XMLSerializer().serializeToString(_this.processing.buffer[i][0]);
					blob = _this.generateBlob(data, 'image/svg+xml');

					if (cfg.output == 'save') {
						saveAs(blob, cfg.fileName + '.svg');
					} else if (cfg.output == 'datastring' || cfg.output == 'datauristring' || cfg.output == 'dataurlstring') {
						blob = 'data:image/svg+xml;base64,' + btoa(data);
					} else if (cfg.output == 'dataurlnewwindow') {
						window.open('data:image/svg+xml;base64,' + btoa(data));
					} else if (cfg.output == 'datauri' || cfg.output == 'dataurl') {
						location.href = 'data:image/svg+xml;base64,' + btoa(data);
					} else if (cfg.output == 'datastream') {
						location.href = 'data:image/octet-stream;base64,' + btoa(data);
					}

					if (externalCallback)
						externalCallback.apply(_this, [blob]);
				}
				// PDF
			} else if (cfg.format == 'application/pdf' || cfg.format == 'pdf') {
				data = _this.generatePDF(cfg).output('dataurlstring');
				blob = _this.generateBlob(data, 'application/pdf');

				if (cfg.output == 'save') {
					saveAs(blob, cfg.fileName + '.pdf');
				} else if (cfg.output == 'datastring' || cfg.output == 'datauristring' || cfg.output == 'dataurlstring') {
					blob = data;
				} else if (cfg.output == 'dataurlnewwindow') {
					window.open(data);
				} else if (cfg.output == 'datauri' || cfg.output == 'dataurl') {
					location.href = data;
				} else if (cfg.output == 'datastream') {
					location.href = data.replace('application/pdf', 'application/octet-stream');
				}

				if (externalCallback)
					externalCallback.apply(_this, [blob]);

				// PNG
			} else if (cfg.format == 'image/png' || cfg.format == 'png') {
				data = _this.canvas.toDataURL('image/png');
				blob = _this.generateBlob(data, 'image/png');

				if (cfg.output == 'save') {
					saveAs(blob, cfg.fileName + '.png');
				} else if (cfg.output == 'datastring' || cfg.output == 'datauristring' || cfg.output == 'dataurlstring') {
					blob = data;
				} else if (cfg.output == 'dataurlnewwindow') {
					window.open(data);
				} else if (cfg.output == 'datauri' || cfg.output == 'dataurl') {
					location.href = data;
				} else if (cfg.output == 'datastream') {
					location.href = data.replace('image/png', 'image/octet-stream');
				}

				if (externalCallback)
					externalCallback.apply(_this, [blob]);

				// JPG
			} else if (cfg.format == 'image/jpeg' || cfg.format == 'jpeg' || cfg.format == 'jpg') {
				data = _this.canvas.toDataURL('image/jpeg');
				blob = _this.generateBlob(data, 'image/jpeg');

				if (cfg.output == 'save') {
					saveAs(blob, cfg.fileName + '.jpg');
				} else if (cfg.output == 'datastring' || cfg.output == 'datauristring' || cfg.output == 'dataurlstring') {
					blob = data;
				} else if (cfg.output == 'dataurlnewwindow') {
					window.open(data);
				} else if (cfg.output == 'datauri' || cfg.output == 'dataurl') {
					location.href = data;
				} else if (cfg.output == 'datastream') {
					location.href = data.replace('image/jpeg', 'image/octet-stream');
				}

				if (externalCallback)
					externalCallback.apply(_this, [blob]);
			}

		}

		return _this.generateOutput(cfg, internalCallback);
	},

	/* PUBLIC
	Polifies missing attributes to the SVG and replaces images to embedded base64 images
	@param none
	*/
	polifySVG: function() {
		var _this = this;
		var svgs = _this.chart.div.getElementsByTagName('svg');

		// Recursive function to force the attributes
		function recursiveChange(svg, tag) {
			var items = svg.getElementsByTagName(tag);

			for (var i = 0; i < items.length; i++) {

				if ( _this.cfg.removeImagery ) {
					items[i].parentNode.removeChild(items[i]);

				} else {
					var image		= document.createElement('img');
					var canvas		= document.createElement('canvas');
					var ctx			= canvas.getContext('2d');

					canvas.width	= items[i].getAttribute('width');
					canvas.height	= items[i].getAttribute('height');
					image.src		= items[i].getAttribute('xlink:href');
					image.width		= items[i].getAttribute('width');
					image.height	= items[i].getAttribute('height');

					try {
						ctx.drawImage(image, 0, 0, image.width, image.height);
						datastring = canvas.toDataURL(); // image.src; // canvas.toDataURL(); //
					} catch (err) {
						datastring = image.src; // image.src; // canvas.toDataURL(); //

						_this.log('Tainted canvas, reached browser CORS security; origin from imagery must be equal to the server!');
						throw new Error(err);
					}

					items[i].setAttribute('xlink:href', datastring);
				}

				if (_this.DEBUG == 10) {
					_this.log('POLIFIED', items[i]);
				} // DEBUG
			}
		}

		// Loop through svgs to add some standardization
		for (var i = 0; i < svgs.length; i++) {
			var parent = svgs[i].parentNode;

			// Put some attrs to it; fixed 20/03/14 xmlns is required to produce a valid svg file
			if ( !AmCharts.isIE ) {
				svgs[i].setAttribute('xmlns','http://www.w3.org/2000/svg');
				//svgs[i].setAttribute('xmlns:xlink','http://www.w3.org/1999/xlink');
			}
			//svgs[i].setAttribute('width',parent.style.width);
			//svgs[i].setAttribute('height',parent.style.height);

			// DEBUG
			if (_this.DEBUG == 10) {
				_this.log('POLIFIED', svgs[i]);
			}

			// Force link adaption
			recursiveChange(svgs[i], 'pattern');
			recursiveChange(svgs[i], 'image');

			_this.svgs.push(svgs[i]);
		}

		return svgs;
	},

	/* PUBLIC
	Generates the canvas with the given SVGs and configured renderer
	@param callback; function(); gets called after drawing process on the canvas has been finished
	*/
	generateOutput: function(cfg, callback) {
		var _this = this,
			svgs = _this.chart.div.getElementsByTagName('svg'),
			canvas = document.createElement('canvas'),
			context = canvas.getContext('2d'),
			offset = {
				y: 0,
				x: 0
			},
			tmp = {};

		// Reset
		_this.processing.buffer = [];
		_this.processing.drawn = 0;
		_this.canvas = canvas;

		// Walkthroug SVGs
		if (_this.DEBUG == 10) {
			_this.log('START EXPORT');
		} // DEBUG
		if (_this.DEBUG == 10) {
			_this.log('START BUFFERING');
		} // DEBUG
		for (var i = 0; i < svgs.length; i++) {
			var parent = svgs[i].parentNode,
				svgX = Number(parent.style.left.slice(0, -2)),
				svgY = Number(parent.style.top.slice(0, -2));
			tmp = AmCharts.extend({}, offset);

			// Overtake parent position if given; fixed 20/03/14 distinguish between relativ and others
			if ( parent.style.position == 'relative' ) {
				offset.x = svgX? svgX : offset.x;
				offset.y = svgY? svgY : offset.y;
			} else {
				offset.x = svgX;
				offset.y = svgY;
			}

			_this.processing.buffer.push([svgs[i], AmCharts.extend({}, offset)]);

			// Put back from "cache"
			if (svgY && svgX) {
				offset = tmp;

				// New offset for next one
			} else {
				offset.y += svgY ? 0 : parent.offsetHeight;
			}

			if (_this.DEBUG == 10) {
				_this.log('BUFFERED', svgs[i], offset);
			} // DEBUG
		}
		if (_this.DEBUG == 10) {
			_this.log('END BUFFERING');
		} // DEBUG

		// Apply background
		if (_this.DEBUG == 10) {
			_this.log('START DRAWING', cfg.render);
		} // DEBUG
		if (_this.DEBUG == 10) {
			_this.log('FILL BACKGROUND');
		} // DEBUG
		canvas.id = AmCharts.getUniqueId();
		canvas.width = _this.chart.divRealWidth;
		canvas.height = _this.chart.divRealHeight;

		// Set given background; jpeg default
		if (cfg.backgroundColor || format == 'image/jpeg') {
			context.fillStyle = cfg.backgroundColor || '#FFFFFF';
			context.fillRect(0, 0, canvas.width, canvas.height);
		}

		/* PRIVATE
		Recursive function to draw the images to the canvas;
		@param none;
		*/
		function drawItWhenItsLoaded() {
			var img, buffer, offset, source;

			// DRAWING PROCESS DONE
			if (_this.processing.buffer.length == _this.processing.drawn) {
				if (_this.DEBUG == 10) {
					_this.log('END DRAWING');
				} // DEBUG
				return callback();

				// LOOPING LUI
			} else {
				if (_this.DEBUG == 10) {
					_this.log('DRAW', _this.processing.drawn + 1, 'OF', _this.processing.buffer.length);
				} // DEBUG

				buffer = _this.processing.buffer[_this.processing.drawn];
				source = new XMLSerializer().serializeToString(buffer[0]); //source = 'data:image/svg+xml;base64,' + btoa();
				offset = buffer[1];

				if (_this.DEBUG == 10) {
					_this.log('SOURCE', source);
				} // DEBUG

				// NATIVE
				if (cfg.render == 'browser') {
					img = new Image();
					img.id = AmCharts.getUniqueId();
					source = 'data:image/svg+xml;base64,' + btoa(source);

					//img.crossOrigin	= "Anonymous";
					img.onload = function() {
						context.drawImage(this, buffer[1].x, buffer[1].y);
						_this.processing.drawn++;

						if (_this.DEBUG == 10) {
							_this.log('ONLOAD', this);
						} // DEBUG
						drawItWhenItsLoaded();
					};
					img.onerror = function() {
						if (_this.DEBUG == 10) {
							_this.log('ONERROR', this);
						} // DEBUG
						context.drawImage(this, buffer[1].x, buffer[1].y);
						_this.processing.drawn++;
						drawItWhenItsLoaded();
					};
					img.src = source;

					if (_this.DEBUG == 10) {
						_this.log('ADD', img);
					} // DEBUG
					if (img.complete || typeof(img.complete) == 'undefined' || img.complete === undefined) {
						if (_this.DEBUG == 10) {
							_this.log('FORCE ONLOAD', img);
						} // DEBUG
						img.src = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==";
						img.src = source;
					}

					// CANVG
				} else if (cfg.render == 'canvg') {
					canvg(canvas, source, {
						offsetX: offset.x,
						offsetY: offset.y,
						ignoreMouse: true,
						ignoreAnimation: true,
						ignoreDimensions: true,
						ignoreClear: true,
						renderCallback: function() {
							_this.processing.drawn++;
							drawItWhenItsLoaded();
						}
					});
				}
			}
		}
		return drawItWhenItsLoaded();
	},

	/*
	Generates the export menu to trigger the exportation
	@param none;
	*/
	generateButtons: function() {
		var _this = this,
			div = document.createElement('div'),
			lvl = 0;

		// Push sublings
		function createList(items) {
			var ul = document.createElement('ul');

			ul.setAttribute('style', 'list-style: none; margin: 0; padding: 0;');

			// Walkthrough items
			for (var i = 0; i < items.length; i++) {
				var li = document.createElement('li'),
					img = document.createElement('img'),
					a = document.createElement('a'),
					item = items[i],
					children = null,
					itemStyle = AmCharts.extend(AmCharts.extend({}, _this.cfg.menuItemStyle), items[i]);

				// MERGE CFG
				item = AmCharts.extend(AmCharts.extend({}, _this.cfg.menuItemOutput), item);

				// ICON
				if (item['icon']) {
					img.alt = '';
					img.src = item['icon'];
					img.setAttribute('style', 'margin: 0 auto;border: none;outline: none');
					if (item['iconTitle']) {
						img.title = item['iconTitle'];
					}
					a.appendChild(img);
				}

				// TITLE; STYLING
				a.href = '#';
				if (item['title']) {
					img.setAttribute('style', 'margin-right: 5px;');
					a.innerHTML += item.title;
				}
				a.setAttribute('style', 'display: block;');
				AmCharts.extend(a.style, itemStyle);

				// ONCLICK
				a.onclick = item.onclick.bind(a, _this, item);
				li.appendChild(a);

				// APPEND SIBLINGS
				if (item.items) {
					children = createList(item.items);
					li.appendChild(children);

					li.onmouseover = function() {
						children.style.display = 'block';
					};
					li.onmouseout = function() {
						children.style.display = 'none';
					};
					children.style.display = 'none';
				}

				// Append to parent
				ul.appendChild(li);

				// Apply hover
				a.onmouseover = function() {
					this.style.backgroundColor = itemStyle.rollOverBackgroundColor;
					this.style.color = itemStyle.rollOverColor;
					this.style.borderColor = itemStyle.rollOverBorderColor;
				};
				a.onmouseout = function() {
					this.style.backgroundColor = itemStyle.backgroundColor;
					this.style.color = itemStyle.color;
					this.style.borderColor = itemStyle.borderColor;
				};
			}
			lvl++;

			if (_this.DEBUG == 10) {
				_this.log('MENU', ul);
			} // DEBUG

			return ul;
		}

		// Style wrapper; Push into chart div
		div.setAttribute('style', 'width:39px; height:28px; position: absolute;top:' + _this.cfg.menuTop + ';right:' + _this.cfg.menuRight + ';bottom:' + _this.cfg.menuBottom + ';left:' + _this.cfg.menuLeft + ';box-shadow:0px 0px 1px 0px rgba(0,0,0,0);');
		div.setAttribute('class', 'amExportButton');
		div.appendChild(createList(_this.cfg.menuItems));
		//_this.chart.div.style.position = 'relative';
		_this.chart.containerDiv.appendChild(div);
	}
});

// @tag amchart
/*
 * canvg.js - Javascript SVG parser and renderer on Canvas
 * MIT Licensed 
 * Gabe Lerner (gabelerner@gmail.com)
 * http://code.google.com/p/canvg/
 *
 * Requires: rgbcolor.js - http://www.phpied.com/rgb-color-parser-in-javascript/
 */
(function(){
	// canvg(target, s)
	// empty parameters: replace all 'svg' elements on page with 'canvas' elements
	// target: canvas element or the id of a canvas element
	// s: svg string, url to svg file, or xml document
	// opts: optional hash of options
	//		 ignoreMouse: true => ignore mouse events
	//		 ignoreAnimation: true => ignore animations
	//		 ignoreDimensions: true => does not try to resize canvas
	//		 ignoreClear: true => does not clear canvas
	//		 offsetX: int => draws at a x offset
	//		 offsetY: int => draws at a y offset
	//		 scaleWidth: int => scales horizontally to width
	//		 scaleHeight: int => scales vertically to height
	//		 renderCallback: function => will call the function after the first render is completed
	//		 forceRedraw: function => will call the function on every frame, if it returns true, will redraw
	this.canvg = function (target, s, opts) {
		// no parameters
		if (target == null && s == null && opts == null) {
			var svgTags = document.getElementsByTagName('svg');
			for (var i=0; i<svgTags.length; i++) {
				var svgTag = svgTags[i];
				var c = document.createElement('canvas');
				c.width = svgTag.clientWidth;
				c.height = svgTag.clientHeight;
				svgTag.parentNode.insertBefore(c, svgTag);
				svgTag.parentNode.removeChild(svgTag);
				var div = document.createElement('div');
				div.appendChild(svgTag);
				canvg(c, div.innerHTML);
			}
			return;
		}	
		opts = opts || {};
	
		if (typeof target == 'string') {
			target = document.getElementById(target);
		}
		
		// store class on canvas
		if (target.svg != null) target.svg.stop();
		var svg = build();
		// on i.e. 8 for flash canvas, we can't assign the property so check for it
		if (!(target.childNodes.length == 1 && target.childNodes[0].nodeName == 'OBJECT')) target.svg = svg;
		svg.opts = opts;
		
		var ctx = target.getContext('2d');
		if (typeof(s.documentElement) != 'undefined') {
			// load from xml doc
			svg.loadXmlDoc(ctx, s);
		}
		else if (s.substr(0,1) == '<') {
			// load from xml string
			svg.loadXml(ctx, s);
		}
		else {
			// load from url
			svg.load(ctx, s);
		}
	}

	function build() {
		var svg = { };
		
		svg.FRAMERATE = 30;
		svg.MAX_VIRTUAL_PIXELS = 30000;
		
		// globals
		svg.init = function(ctx) {
			var uniqueId = 0;
			svg.UniqueId = function () { uniqueId++; return 'canvg' + uniqueId;	};
			svg.Definitions = {};
			svg.Styles = {};
			svg.Animations = [];
			svg.Images = [];
			svg.ctx = ctx;
			svg.ViewPort = new (function () {
				this.viewPorts = [];
				this.Clear = function() { this.viewPorts = []; }
				this.SetCurrent = function(width, height) { this.viewPorts.push({ width: width, height: height }); }
				this.RemoveCurrent = function() { this.viewPorts.pop(); }
				this.Current = function() { return this.viewPorts[this.viewPorts.length - 1]; }
				this.width = function() { return this.Current().width; }
				this.height = function() { return this.Current().height; }
				this.ComputeSize = function(d) {
					if (d != null && typeof(d) == 'number') return d;
					if (d == 'x') return this.width();
					if (d == 'y') return this.height();
					return Math.sqrt(Math.pow(this.width(), 2) + Math.pow(this.height(), 2)) / Math.sqrt(2);			
				}
			});
		}
		svg.init();
		
		// images loaded
		svg.ImagesLoaded = function() { 
			for (var i=0; i<svg.Images.length; i++) {
				if (!svg.Images[i].loaded) return false;
			}
			return true;
		}

		// trim
		svg.trim = function(s) { return s.replace(/^\s+|\s+$/g, ''); }
		
		// compress spaces
		svg.compressSpaces = function(s) { return s.replace(/[\s\r\t\n]+/gm,' '); }
		
		// ajax
		svg.ajax = function(url) {
			var AJAX;
			if(window.XMLHttpRequest){AJAX=new XMLHttpRequest();}
			else{AJAX=new ActiveXObject('Microsoft.XMLHTTP');}
			if(AJAX){
			   AJAX.open('GET',url,false);
			   AJAX.send(null);
			   return AJAX.responseText;
			}
			return null;
		} 
		
		// parse xml
		
		svg.parseXml = function(xml) {			
			if (window.DOMParser)
			{
				var parser = new DOMParser();
				return parser.parseFromString(xml, 'text/xml');
			}
			else 
			{
				xml = xml.replace(/<!DOCTYPE svg[^>]*>/, '');
				var xmlDoc = new ActiveXObject('Microsoft.XMLDOM');
				xmlDoc.async = 'false';
				xmlDoc.loadXML(xml); 
				return xmlDoc;
			}		
		}
		
		svg.Property = function(name, value) {
			this.name = name;
			this.value = value;
		}	
			svg.Property.prototype.getValue = function() {
				return this.value;
			}
		
			svg.Property.prototype.hasValue = function() {
				return (this.value != null && this.value !== '');
			}
							
			// return the numerical value of the property
			svg.Property.prototype.numValue = function() {
				if (!this.hasValue()) return 0;
				
				var n = parseFloat(this.value);
				if ((this.value + '').match(/%$/)) {
					n = n / 100.0;
				}
				return n;
			}
			
			svg.Property.prototype.valueOrDefault = function(def) {
				if (this.hasValue()) return this.value;
				return def;
			}
			
			svg.Property.prototype.numValueOrDefault = function(def) {
				if (this.hasValue()) return this.numValue();
				return def;
			}
			
			// color extensions
				// augment the current color value with the opacity
				svg.Property.prototype.addOpacity = function(opacity) {
					var newValue = this.value;
					if (opacity != null && opacity != '' && typeof(this.value)=='string') { // can only add opacity to colors, not patterns
						var color = new RGBColor(this.value);
						if (color.ok) {
							newValue = 'rgba(' + color.r + ', ' + color.g + ', ' + color.b + ', ' + opacity + ')';
						}
					}
					return new svg.Property(this.name, newValue);
				}
			
			// definition extensions
				// get the definition from the definitions table
				svg.Property.prototype.getDefinition = function() {
					var name = this.value.match(/#([^\)'"]+)/);
					if (name) { name = name[1]; }
					if (!name) { name = this.value; }
					return svg.Definitions[name];
				}
				
				svg.Property.prototype.isUrlDefinition = function() {
					return this.value.indexOf('url(') == 0
				}
				
				svg.Property.prototype.getFillStyleDefinition = function(e, opacityProp) {
					var def = this.getDefinition();
					
					// gradient
					if (def != null && def.createGradient) {
						return def.createGradient(svg.ctx, e, opacityProp);
					}
					
					// pattern
					if (def != null && def.createPattern) {
						if (def.getHrefAttribute().hasValue()) {
							var pt = def.attribute('patternTransform');
							def = def.getHrefAttribute().getDefinition();
							if (pt.hasValue()) { def.attribute('patternTransform', true).value = pt.value; }
						}
						return def.createPattern(svg.ctx, e);
					}
					
					return null;
				}
			
			// length extensions
				svg.Property.prototype.getDPI = function(viewPort) {
					return 96.0; // TODO: compute?
				}
				
				svg.Property.prototype.getEM = function(viewPort) {
					var em = 12;
					
					var fontSize = new svg.Property('fontSize', svg.Font.Parse(svg.ctx.font).fontSize);
					if (fontSize.hasValue()) em = fontSize.toPixels(viewPort);
					
					return em;
				}
				
				svg.Property.prototype.getUnits = function() {
					var s = this.value+'';
					return s.replace(/[0-9\.\-]/g,'');
				}
			
				// get the length as pixels
				svg.Property.prototype.toPixels = function(viewPort, processPercent) {
					if (!this.hasValue()) return 0;
					var s = this.value+'';
					if (s.match(/em$/)) return this.numValue() * this.getEM(viewPort);
					if (s.match(/ex$/)) return this.numValue() * this.getEM(viewPort) / 2.0;
					if (s.match(/px$/)) return this.numValue();
					if (s.match(/pt$/)) return this.numValue() * this.getDPI(viewPort) * (1.0 / 72.0);
					if (s.match(/pc$/)) return this.numValue() * 15;
					if (s.match(/cm$/)) return this.numValue() * this.getDPI(viewPort) / 2.54;
					if (s.match(/mm$/)) return this.numValue() * this.getDPI(viewPort) / 25.4;
					if (s.match(/in$/)) return this.numValue() * this.getDPI(viewPort);
					if (s.match(/%$/)) return this.numValue() * svg.ViewPort.ComputeSize(viewPort);
					var n = this.numValue();
					if (processPercent && n < 1.0) return n * svg.ViewPort.ComputeSize(viewPort);
					return n;
				}

			// time extensions
				// get the time as milliseconds
				svg.Property.prototype.toMilliseconds = function() {
					if (!this.hasValue()) return 0;
					var s = this.value+'';
					if (s.match(/s$/)) return this.numValue() * 1000;
					if (s.match(/ms$/)) return this.numValue();
					return this.numValue();
				}
			
			// angle extensions
				// get the angle as radians
				svg.Property.prototype.toRadians = function() {
					if (!this.hasValue()) return 0;
					var s = this.value+'';
					if (s.match(/deg$/)) return this.numValue() * (Math.PI / 180.0);
					if (s.match(/grad$/)) return this.numValue() * (Math.PI / 200.0);
					if (s.match(/rad$/)) return this.numValue();
					return this.numValue() * (Math.PI / 180.0);
				}
		
		// fonts
		svg.Font = new (function() {
			this.Styles = 'normal|italic|oblique|inherit';
			this.Variants = 'normal|small-caps|inherit';
			this.Weights = 'normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900|inherit';
			
			this.CreateFont = function(fontStyle, fontVariant, fontWeight, fontSize, fontFamily, inherit) { 
				var f = inherit != null ? this.Parse(inherit) : this.CreateFont('', '', '', '', '', svg.ctx.font);
				return { 
					fontFamily: fontFamily || f.fontFamily, 
					fontSize: fontSize || f.fontSize, 
					fontStyle: fontStyle || f.fontStyle, 
					fontWeight: fontWeight || f.fontWeight, 
					fontVariant: fontVariant || f.fontVariant,
					toString: function () { return [this.fontStyle, this.fontVariant, this.fontWeight, this.fontSize, this.fontFamily].join(' ') } 
				} 
			}
			
			var that = this;
			this.Parse = function(s) {
				var f = {};
				var d = svg.trim(svg.compressSpaces(s || '')).split(' ');
				var set = { fontSize: false, fontStyle: false, fontWeight: false, fontVariant: false }
				var ff = '';
				for (var i=0; i<d.length; i++) {
					if (!set.fontStyle && that.Styles.indexOf(d[i]) != -1) { if (d[i] != 'inherit') f.fontStyle = d[i]; set.fontStyle = true; }
					else if (!set.fontVariant && that.Variants.indexOf(d[i]) != -1) { if (d[i] != 'inherit') f.fontVariant = d[i]; set.fontStyle = set.fontVariant = true;	}
					else if (!set.fontWeight && that.Weights.indexOf(d[i]) != -1) {	if (d[i] != 'inherit') f.fontWeight = d[i]; set.fontStyle = set.fontVariant = set.fontWeight = true; }
					else if (!set.fontSize) { if (d[i] != 'inherit') f.fontSize = d[i].split('/')[0]; set.fontStyle = set.fontVariant = set.fontWeight = set.fontSize = true; }
					else { if (d[i] != 'inherit') ff += d[i]; }
				} if (ff != '') f.fontFamily = ff;
				return f;
			}
		});
		
		// points and paths
		svg.ToNumberArray = function(s) {
			var a = svg.trim(svg.compressSpaces((s || '').replace(/,/g, ' '))).split(' ');
			for (var i=0; i<a.length; i++) {
				a[i] = parseFloat(a[i]);
			}
			return a;
		}		
		svg.Point = function(x, y) {
			this.x = x;
			this.y = y;
		}	
			svg.Point.prototype.angleTo = function(p) {
				return Math.atan2(p.y - this.y, p.x - this.x);
			}
			
			svg.Point.prototype.applyTransform = function(v) {
				var xp = this.x * v[0] + this.y * v[2] + v[4];
				var yp = this.x * v[1] + this.y * v[3] + v[5];
				this.x = xp;
				this.y = yp;
			}

		svg.CreatePoint = function(s) {
			var a = svg.ToNumberArray(s);
			return new svg.Point(a[0], a[1]);
		}
		svg.CreatePath = function(s) {
			var a = svg.ToNumberArray(s);
			var path = [];
			for (var i=0; i<a.length; i+=2) {
				path.push(new svg.Point(a[i], a[i+1]));
			}
			return path;
		}
		
		// bounding box
		svg.BoundingBox = function(x1, y1, x2, y2) { // pass in initial points if you want
			this.x1 = Number.NaN;
			this.y1 = Number.NaN;
			this.x2 = Number.NaN;
			this.y2 = Number.NaN;
			
			this.x = function() { return this.x1; }
			this.y = function() { return this.y1; }
			this.width = function() { return this.x2 - this.x1; }
			this.height = function() { return this.y2 - this.y1; }
			
			this.addPoint = function(x, y) {	
				if (x != null) {
					if (isNaN(this.x1) || isNaN(this.x2)) {
						this.x1 = x;
						this.x2 = x;
					}
					if (x < this.x1) this.x1 = x;
					if (x > this.x2) this.x2 = x;
				}
			
				if (y != null) {
					if (isNaN(this.y1) || isNaN(this.y2)) {
						this.y1 = y;
						this.y2 = y;
					}
					if (y < this.y1) this.y1 = y;
					if (y > this.y2) this.y2 = y;
				}
			}			
			this.addX = function(x) { this.addPoint(x, null); }
			this.addY = function(y) { this.addPoint(null, y); }
			
			this.addBoundingBox = function(bb) {
				this.addPoint(bb.x1, bb.y1);
				this.addPoint(bb.x2, bb.y2);
			}
			
			this.addQuadraticCurve = function(p0x, p0y, p1x, p1y, p2x, p2y) {
				var cp1x = p0x + 2/3 * (p1x - p0x); // CP1 = QP0 + 2/3 *(QP1-QP0)
				var cp1y = p0y + 2/3 * (p1y - p0y); // CP1 = QP0 + 2/3 *(QP1-QP0)
				var cp2x = cp1x + 1/3 * (p2x - p0x); // CP2 = CP1 + 1/3 *(QP2-QP0)
				var cp2y = cp1y + 1/3 * (p2y - p0y); // CP2 = CP1 + 1/3 *(QP2-QP0)
				this.addBezierCurve(p0x, p0y, cp1x, cp2x, cp1y,	cp2y, p2x, p2y);
			}
			
			this.addBezierCurve = function(p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y) {
				// from http://blog.hackers-cafe.net/2009/06/how-to-calculate-bezier-curves-bounding.html
				var p0 = [p0x, p0y], p1 = [p1x, p1y], p2 = [p2x, p2y], p3 = [p3x, p3y];
				this.addPoint(p0[0], p0[1]);
				this.addPoint(p3[0], p3[1]);
				
				for (i=0; i<=1; i++) {
					var f = function(t) { 
						return Math.pow(1-t, 3) * p0[i]
						+ 3 * Math.pow(1-t, 2) * t * p1[i]
						+ 3 * (1-t) * Math.pow(t, 2) * p2[i]
						+ Math.pow(t, 3) * p3[i];
					}
					
					var b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];
					var a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];
					var c = 3 * p1[i] - 3 * p0[i];
					
					if (a == 0) {
						if (b == 0) continue;
						var t = -c / b;
						if (0 < t && t < 1) {
							if (i == 0) this.addX(f(t));
							if (i == 1) this.addY(f(t));
						}
						continue;
					}
					
					var b2ac = Math.pow(b, 2) - 4 * c * a;
					if (b2ac < 0) continue;
					var t1 = (-b + Math.sqrt(b2ac)) / (2 * a);
					if (0 < t1 && t1 < 1) {
						if (i == 0) this.addX(f(t1));
						if (i == 1) this.addY(f(t1));
					}
					var t2 = (-b - Math.sqrt(b2ac)) / (2 * a);
					if (0 < t2 && t2 < 1) {
						if (i == 0) this.addX(f(t2));
						if (i == 1) this.addY(f(t2));
					}
				}
			}
			
			this.isPointInBox = function(x, y) {
				return (this.x1 <= x && x <= this.x2 && this.y1 <= y && y <= this.y2);
			}
			
			this.addPoint(x1, y1);
			this.addPoint(x2, y2);
		}
		
		// transforms
		svg.Transform = function(v) {	
			var that = this;
			this.Type = {}
		
			// translate
			this.Type.translate = function(s) {
				this.p = svg.CreatePoint(s);			
				this.apply = function(ctx) {
					ctx.translate(this.p.x || 0.0, this.p.y || 0.0);
				}
				this.unapply = function(ctx) {
					ctx.translate(-1.0 * this.p.x || 0.0, -1.0 * this.p.y || 0.0);
				}
				this.applyToPoint = function(p) {
					p.applyTransform([1, 0, 0, 1, this.p.x || 0.0, this.p.y || 0.0]);
				}
			}
			
			// rotate
			this.Type.rotate = function(s) {
				var a = svg.ToNumberArray(s);
				this.angle = new svg.Property('angle', a[0]);
				this.cx = a[1] || 0;
				this.cy = a[2] || 0;
				this.apply = function(ctx) {
					ctx.translate(this.cx, this.cy);
					ctx.rotate(this.angle.toRadians());
					ctx.translate(-this.cx, -this.cy);
				}
				this.unapply = function(ctx) {
					ctx.translate(this.cx, this.cy);
					ctx.rotate(-1.0 * this.angle.toRadians());
					ctx.translate(-this.cx, -this.cy);
				}
				this.applyToPoint = function(p) {
					var a = this.angle.toRadians();
					p.applyTransform([1, 0, 0, 1, this.p.x || 0.0, this.p.y || 0.0]);
					p.applyTransform([Math.cos(a), Math.sin(a), -Math.sin(a), Math.cos(a), 0, 0]);
					p.applyTransform([1, 0, 0, 1, -this.p.x || 0.0, -this.p.y || 0.0]);
				}			
			}
			
			this.Type.scale = function(s) {
				this.p = svg.CreatePoint(s);
				this.apply = function(ctx) {
					ctx.scale(this.p.x || 1.0, this.p.y || this.p.x || 1.0);
				}
				this.unapply = function(ctx) {
					ctx.scale(1.0 / this.p.x || 1.0, 1.0 / this.p.y || this.p.x || 1.0);
				}
				this.applyToPoint = function(p) {
					p.applyTransform([this.p.x || 0.0, 0, 0, this.p.y || 0.0, 0, 0]);
				}				
			}
			
			this.Type.matrix = function(s) {
				this.m = svg.ToNumberArray(s);
				this.apply = function(ctx) {
					ctx.transform(this.m[0], this.m[1], this.m[2], this.m[3], this.m[4], this.m[5]);
				}
				this.applyToPoint = function(p) {
					p.applyTransform(this.m);
				}					
			}
			
			this.Type.SkewBase = function(s) {
				this.base = that.Type.matrix;
				this.base(s);
				this.angle = new svg.Property('angle', s);
			}
			this.Type.SkewBase.prototype = new this.Type.matrix;
			
			this.Type.skewX = function(s) {
				this.base = that.Type.SkewBase;
				this.base(s);
				this.m = [1, 0, Math.tan(this.angle.toRadians()), 1, 0, 0];
			}
			this.Type.skewX.prototype = new this.Type.SkewBase;
			
			this.Type.skewY = function(s) {
				this.base = that.Type.SkewBase;
				this.base(s);
				this.m = [1, Math.tan(this.angle.toRadians()), 0, 1, 0, 0];
			}
			this.Type.skewY.prototype = new this.Type.SkewBase;
		
			this.transforms = [];
			
			this.apply = function(ctx) {
				for (var i=0; i<this.transforms.length; i++) {
					this.transforms[i].apply(ctx);
				}
			}
			
			this.unapply = function(ctx) {
				for (var i=this.transforms.length-1; i>=0; i--) {
					this.transforms[i].unapply(ctx);
				}
			}
			
			this.applyToPoint = function(p) {
				for (var i=0; i<this.transforms.length; i++) {
					this.transforms[i].applyToPoint(p);
				}
			}
			
			var data = svg.trim(svg.compressSpaces(v)).replace(/\)(\s?,\s?)/g,') ').split(/\s(?=[a-z])/);
			for (var i=0; i<data.length; i++) {
				var type = svg.trim(data[i].split('(')[0]);
				var s = data[i].split('(')[1].replace(')','');
				var transform = new this.Type[type](s);
				transform.type = type;
				this.transforms.push(transform);
			}
		}
		
		// aspect ratio
		svg.AspectRatio = function(ctx, aspectRatio, width, desiredWidth, height, desiredHeight, minX, minY, refX, refY) {
			// aspect ratio - http://www.w3.org/TR/SVG/coords.html#PreserveAspectRatioAttribute
			aspectRatio = svg.compressSpaces(aspectRatio);
			aspectRatio = aspectRatio.replace(/^defer\s/,''); // ignore defer
			var align = aspectRatio.split(' ')[0] || 'xMidYMid';
			var meetOrSlice = aspectRatio.split(' ')[1] || 'meet';					
	
			// calculate scale
			var scaleX = width / desiredWidth;
			var scaleY = height / desiredHeight;
			var scaleMin = Math.min(scaleX, scaleY);
			var scaleMax = Math.max(scaleX, scaleY);
			if (meetOrSlice == 'meet') { desiredWidth *= scaleMin; desiredHeight *= scaleMin; }
			if (meetOrSlice == 'slice') { desiredWidth *= scaleMax; desiredHeight *= scaleMax; }	
			
			refX = new svg.Property('refX', refX);
			refY = new svg.Property('refY', refY);
			if (refX.hasValue() && refY.hasValue()) {				
				ctx.translate(-scaleMin * refX.toPixels('x'), -scaleMin * refY.toPixels('y'));
			} 
			else {					
				// align
				if (align.match(/^xMid/) && ((meetOrSlice == 'meet' && scaleMin == scaleY) || (meetOrSlice == 'slice' && scaleMax == scaleY))) ctx.translate(width / 2.0 - desiredWidth / 2.0, 0); 
				if (align.match(/YMid$/) && ((meetOrSlice == 'meet' && scaleMin == scaleX) || (meetOrSlice == 'slice' && scaleMax == scaleX))) ctx.translate(0, height / 2.0 - desiredHeight / 2.0); 
				if (align.match(/^xMax/) && ((meetOrSlice == 'meet' && scaleMin == scaleY) || (meetOrSlice == 'slice' && scaleMax == scaleY))) ctx.translate(width - desiredWidth, 0); 
				if (align.match(/YMax$/) && ((meetOrSlice == 'meet' && scaleMin == scaleX) || (meetOrSlice == 'slice' && scaleMax == scaleX))) ctx.translate(0, height - desiredHeight); 
			}
			
			// scale
			if (align == 'none') ctx.scale(scaleX, scaleY);
			else if (meetOrSlice == 'meet') ctx.scale(scaleMin, scaleMin); 
			else if (meetOrSlice == 'slice') ctx.scale(scaleMax, scaleMax); 	
			
			// translate
			ctx.translate(minX == null ? 0 : -minX, minY == null ? 0 : -minY);			
		}
		
		// elements
		svg.Element = {}
		
		svg.EmptyProperty = new svg.Property('EMPTY', '');
		
		svg.Element.ElementBase = function(node) {	
			this.attributes = {};
			this.styles = {};
			this.children = [];
			
			// get or create attribute
			this.attribute = function(name, createIfNotExists) {
				var a = this.attributes[name];
				if (a != null) return a;
							
				if (createIfNotExists == true) { a = new svg.Property(name, ''); this.attributes[name] = a; }
				return a || svg.EmptyProperty;
			}
			
			this.getHrefAttribute = function() {
				for (var a in this.attributes) { 
					if (a.match(/:href$/)) { 
						return this.attributes[a]; 
					} 
				}
				return svg.EmptyProperty;
			}
			
			// get or create style, crawls up node tree
			this.style = function(name, createIfNotExists) {
				var s = this.styles[name];
				if (s != null) return s;
				
				var a = this.attribute(name);
				if (a != null && a.hasValue()) {
					this.styles[name] = a; // move up to me to cache
					return a;
				}
				
				var p = this.parent;
				if (p != null) {
					var ps = p.style(name);
					if (ps != null && ps.hasValue()) {
						return ps;
					}
				}
					
				if (createIfNotExists == true) { s = new svg.Property(name, ''); this.styles[name] = s; }
				return s || svg.EmptyProperty;
			}
			
			// base render
			this.render = function(ctx) {
				// don't render display=none
				if (this.style('display').value == 'none') return;
				
				// don't render visibility=hidden
				if (this.attribute('visibility').value == 'hidden') return;
			
				ctx.save();
				if (this.attribute('mask').hasValue()) { // mask
					var mask = this.attribute('mask').getDefinition();
					if (mask != null) mask.apply(ctx, this);
				}
				else if (this.style('filter').hasValue()) { // filter
					var filter = this.style('filter').getDefinition();
					if (filter != null) filter.apply(ctx, this);
				}
				else {	
					this.setContext(ctx);
					this.renderChildren(ctx);	
					this.clearContext(ctx);							
				}
				ctx.restore();
			}
			
			// base set context
			this.setContext = function(ctx) {
				// OVERRIDE ME!
			}
			
			// base clear context
			this.clearContext = function(ctx) {
				// OVERRIDE ME!
			}			
			
			// base render children
			this.renderChildren = function(ctx) {
				for (var i=0; i<this.children.length; i++) {
					this.children[i].render(ctx);
				}
			}
			
			this.addChild = function(childNode, create) {
				var child = childNode;
				if (create) child = svg.CreateElement(childNode);
				child.parent = this;
				this.children.push(child);			
			}
				
			if (node != null && node.nodeType == 1) { //ELEMENT_NODE
				// add children
				for (var i=0; i<node.childNodes.length; i++) {
					var childNode = node.childNodes[i];
					if (childNode.nodeType == 1) this.addChild(childNode, true); //ELEMENT_NODE
					if (this.captureTextNodes && childNode.nodeType == 3) {
						var text = childNode.nodeValue || childNode.text || '';
						if (svg.trim(svg.compressSpaces(text)) != '') {
							this.addChild(new svg.Element.tspan(childNode), false); // TEXT_NODE
						}
					}
				}
				
				// add attributes
				for (var i=0; i<node.attributes.length; i++) {
					var attribute = node.attributes[i];
					this.attributes[attribute.nodeName] = new svg.Property(attribute.nodeName, attribute.nodeValue);
				}
										
				// add tag styles
				var styles = svg.Styles[node.nodeName];
				if (styles != null) {
					for (var name in styles) {
						this.styles[name] = styles[name];
					}
				}					
				
				// add class styles
				if (this.attribute('class').hasValue()) {
					var classes = svg.compressSpaces(this.attribute('class').value).split(' ');
					for (var j=0; j<classes.length; j++) {
						styles = svg.Styles['.'+classes[j]];
						if (styles != null) {
							for (var name in styles) {
								this.styles[name] = styles[name];
							}
						}
						styles = svg.Styles[node.nodeName+'.'+classes[j]];
						if (styles != null) {
							for (var name in styles) {
								this.styles[name] = styles[name];
							}
						}
					}
				}
				
				// add id styles
				if (this.attribute('id').hasValue()) {
					var styles = svg.Styles['#' + this.attribute('id').value];
					if (styles != null) {
						for (var name in styles) {
							this.styles[name] = styles[name];
						}
					}
				}
				
				// add inline styles
				if (this.attribute('style').hasValue()) {
					var styles = this.attribute('style').value.split(';');
					for (var i=0; i<styles.length; i++) {
						if (svg.trim(styles[i]) != '') {
							var style = styles[i].split(':');
							var name = svg.trim(style[0]);
							var value = svg.trim(style[1]);
							this.styles[name] = new svg.Property(name, value);
						}
					}
				}	

				// add id
				if (this.attribute('id').hasValue()) {
					if (svg.Definitions[this.attribute('id').value] == null) {
						svg.Definitions[this.attribute('id').value] = this;
					}
				}
			}
		}
		
		svg.Element.RenderedElementBase = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);
			
			this.setContext = function(ctx) {
				// fill
				if (this.style('fill').isUrlDefinition()) {
					var fs = this.style('fill').getFillStyleDefinition(this, this.style('fill-opacity'));
					if (fs != null) ctx.fillStyle = fs;
				}
				else if (this.style('fill').hasValue()) {
					var fillStyle = this.style('fill');
					if (fillStyle.value == 'currentColor') fillStyle.value = this.style('color').value;
					ctx.fillStyle = (fillStyle.value == 'none' ? 'rgba(0,0,0,0)' : fillStyle.value);
				}
				if (this.style('fill-opacity').hasValue()) {
					var fillStyle = new svg.Property('fill', ctx.fillStyle);
					fillStyle = fillStyle.addOpacity(this.style('fill-opacity').value);
					ctx.fillStyle = fillStyle.value;
				}
									
				// stroke
				if (this.style('stroke').isUrlDefinition()) {
					var fs = this.style('stroke').getFillStyleDefinition(this, this.style('stroke-opacity'));
					if (fs != null) ctx.strokeStyle = fs;
				}
				else if (this.style('stroke').hasValue()) {
					var strokeStyle = this.style('stroke');
					if (strokeStyle.value == 'currentColor') strokeStyle.value = this.style('color').value;
					ctx.strokeStyle = (strokeStyle.value == 'none' ? 'rgba(0,0,0,0)' : strokeStyle.value);
				}
				if (this.style('stroke-opacity').hasValue()) {
					var strokeStyle = new svg.Property('stroke', ctx.strokeStyle);
					strokeStyle = strokeStyle.addOpacity(this.style('stroke-opacity').value);
					ctx.strokeStyle = strokeStyle.value;
				}
				if (this.style('stroke-width').hasValue()) {
					var newLineWidth = this.style('stroke-width').toPixels();
					ctx.lineWidth = newLineWidth == 0 ? 0.001 : newLineWidth; // browsers don't respect 0
			    }
				if (this.style('stroke-linecap').hasValue()) ctx.lineCap = this.style('stroke-linecap').value;
				if (this.style('stroke-linejoin').hasValue()) ctx.lineJoin = this.style('stroke-linejoin').value;
				if (this.style('stroke-miterlimit').hasValue()) ctx.miterLimit = this.style('stroke-miterlimit').value;
				if (this.style('stroke-dasharray').hasValue()) {
					var gaps = svg.ToNumberArray(this.style('stroke-dasharray').value);
					if (typeof(ctx.setLineDash) != 'undefined') { ctx.setLineDash(gaps); }
					else if (typeof(ctx.webkitLineDash) != 'undefined') { ctx.webkitLineDash = gaps; }
					else if (typeof(ctx.mozDash ) != 'undefined') { ctx.mozDash  = gaps; }
					
					var offset = this.style('stroke-dashoffset').numValueOrDefault(1);
					if (typeof(ctx.lineDashOffset) != 'undefined') { ctx.lineDashOffset = offset; }
					else if (typeof(ctx.webkitLineDashOffset) != 'undefined') { ctx.webkitLineDashOffset = offset; }
					else if (typeof(ctx.mozDashOffset) != 'undefined') { ctx.mozDashOffset = offset; }
				}

				// font
				if (typeof(ctx.font) != 'undefined') {
					ctx.font = svg.Font.CreateFont( 
						this.style('font-style').value, 
						this.style('font-variant').value, 
						this.style('font-weight').value, 
						this.style('font-size').hasValue() ? this.style('font-size').toPixels() + 'px' : '', 
						this.style('font-family').value).toString();
				}
				
				// transform
				if (this.attribute('transform').hasValue()) { 
					var transform = new svg.Transform(this.attribute('transform').value);
					transform.apply(ctx);
				}
				
				// clip
				if (this.style('clip-path').hasValue()) {
					var clip = this.style('clip-path').getDefinition();
					if (clip != null) clip.apply(ctx);
				}
				
				// opacity
				if (this.style('opacity').hasValue()) {
					ctx.globalAlpha = this.style('opacity').numValue();
				}
			}		
		}
		svg.Element.RenderedElementBase.prototype = new svg.Element.ElementBase;
		
		svg.Element.PathElementBase = function(node) {
			this.base = svg.Element.RenderedElementBase;
			this.base(node);
			
			this.path = function(ctx) {
				if (ctx != null) ctx.beginPath();
				return new svg.BoundingBox();
			}
			
			this.renderChildren = function(ctx) {
				this.path(ctx);
				svg.Mouse.checkPath(this, ctx);
				if (ctx.fillStyle != '') {
					if (this.attribute('fill-rule').hasValue()) { ctx.fill(this.attribute('fill-rule').value); }
					else { ctx.fill(); }
				}
				if (ctx.strokeStyle != '') ctx.stroke();
				
				var markers = this.getMarkers();
				if (markers != null) {
					if (this.style('marker-start').isUrlDefinition()) {
						var marker = this.style('marker-start').getDefinition();
						marker.render(ctx, markers[0][0], markers[0][1]);
					}
					if (this.style('marker-mid').isUrlDefinition()) {
						var marker = this.style('marker-mid').getDefinition();
						for (var i=1;i<markers.length-1;i++) {
							marker.render(ctx, markers[i][0], markers[i][1]);
						}
					}
					if (this.style('marker-end').isUrlDefinition()) {
						var marker = this.style('marker-end').getDefinition();
						marker.render(ctx, markers[markers.length-1][0], markers[markers.length-1][1]);
					}
				}					
			}
			
			this.getBoundingBox = function() {
				return this.path();
			}
			
			this.getMarkers = function() {
				return null;
			}
		}
		svg.Element.PathElementBase.prototype = new svg.Element.RenderedElementBase;
		
		// svg element
		svg.Element.svg = function(node) {
			this.base = svg.Element.RenderedElementBase;
			this.base(node);
			
			this.baseClearContext = this.clearContext;
			this.clearContext = function(ctx) {
				this.baseClearContext(ctx);
				svg.ViewPort.RemoveCurrent();
			}
			
			this.baseSetContext = this.setContext;
			this.setContext = function(ctx) {
				// initial values
				ctx.strokeStyle = 'rgba(0,0,0,0)';
				ctx.lineCap = 'butt';
				ctx.lineJoin = 'miter';
				ctx.miterLimit = 4;			
			
				this.baseSetContext(ctx);
				
				// create new view port
				if (!this.attribute('x').hasValue()) this.attribute('x', true).value = 0;
				if (!this.attribute('y').hasValue()) this.attribute('y', true).value = 0;
				ctx.translate(this.attribute('x').toPixels('x'), this.attribute('y').toPixels('y'));
				
				var width = svg.ViewPort.width();
				var height = svg.ViewPort.height();
				
				if (!this.attribute('width').hasValue()) this.attribute('width', true).value = '100%';
				if (!this.attribute('height').hasValue()) this.attribute('height', true).value = '100%';
				if (typeof(this.root) == 'undefined') {
					width = this.attribute('width').toPixels('x');
					height = this.attribute('height').toPixels('y');
					
					var x = 0;
					var y = 0;
					if (this.attribute('refX').hasValue() && this.attribute('refY').hasValue()) {
						x = -this.attribute('refX').toPixels('x');
						y = -this.attribute('refY').toPixels('y');
					}
					
					ctx.beginPath();
					ctx.moveTo(x, y);
					ctx.lineTo(width, y);
					ctx.lineTo(width, height);
					ctx.lineTo(x, height);
					ctx.closePath();
					ctx.clip();
				}
				svg.ViewPort.SetCurrent(width, height);	
						
				// viewbox
				if (this.attribute('viewBox').hasValue()) {				
					var viewBox = svg.ToNumberArray(this.attribute('viewBox').value);
					var minX = viewBox[0];
					var minY = viewBox[1];
					width = viewBox[2];
					height = viewBox[3];
					
					svg.AspectRatio(ctx,
									this.attribute('preserveAspectRatio').value, 
									svg.ViewPort.width(), 
									width,
									svg.ViewPort.height(),
									height,
									minX,
									minY,
									this.attribute('refX').value,
									this.attribute('refY').value);
										
					svg.ViewPort.RemoveCurrent();	
					svg.ViewPort.SetCurrent(viewBox[2], viewBox[3]);						
				}				
			}
		}
		svg.Element.svg.prototype = new svg.Element.RenderedElementBase;

		// rect element
		svg.Element.rect = function(node) {
			this.base = svg.Element.PathElementBase;
			this.base(node);
			
			this.path = function(ctx) {
				var x = this.attribute('x').toPixels('x');
				var y = this.attribute('y').toPixels('y');
				var width = this.attribute('width').toPixels('x');
				var height = this.attribute('height').toPixels('y');
				var rx = this.attribute('rx').toPixels('x');
				var ry = this.attribute('ry').toPixels('y');
				if (this.attribute('rx').hasValue() && !this.attribute('ry').hasValue()) ry = rx;
				if (this.attribute('ry').hasValue() && !this.attribute('rx').hasValue()) rx = ry;
				rx = Math.min(rx, width / 2.0);
				ry = Math.min(ry, height / 2.0);
				if (ctx != null) {
					ctx.beginPath();
					ctx.moveTo(x + rx, y);
					ctx.lineTo(x + width - rx, y);
					ctx.quadraticCurveTo(x + width, y, x + width, y + ry)
					ctx.lineTo(x + width, y + height - ry);
					ctx.quadraticCurveTo(x + width, y + height, x + width - rx, y + height)
					ctx.lineTo(x + rx, y + height);
					ctx.quadraticCurveTo(x, y + height, x, y + height - ry)
					ctx.lineTo(x, y + ry);
					ctx.quadraticCurveTo(x, y, x + rx, y)
					ctx.closePath();
				}
				
				return new svg.BoundingBox(x, y, x + width, y + height);
			}
		}
		svg.Element.rect.prototype = new svg.Element.PathElementBase;
		
		// circle element
		svg.Element.circle = function(node) {
			this.base = svg.Element.PathElementBase;
			this.base(node);
			
			this.path = function(ctx) {
				var cx = this.attribute('cx').toPixels('x');
				var cy = this.attribute('cy').toPixels('y');
				var r = this.attribute('r').toPixels();
			
				if (ctx != null) {
					ctx.beginPath();
					ctx.arc(cx, cy, r, 0, Math.PI * 2, true); 
					ctx.closePath();
				}
				
				return new svg.BoundingBox(cx - r, cy - r, cx + r, cy + r);
			}
		}
		svg.Element.circle.prototype = new svg.Element.PathElementBase;	

		// ellipse element
		svg.Element.ellipse = function(node) {
			this.base = svg.Element.PathElementBase;
			this.base(node);
			
			this.path = function(ctx) {
				var KAPPA = 4 * ((Math.sqrt(2) - 1) / 3);
				var rx = this.attribute('rx').toPixels('x');
				var ry = this.attribute('ry').toPixels('y');
				var cx = this.attribute('cx').toPixels('x');
				var cy = this.attribute('cy').toPixels('y');
				
				if (ctx != null) {
					ctx.beginPath();
					ctx.moveTo(cx, cy - ry);
					ctx.bezierCurveTo(cx + (KAPPA * rx), cy - ry,  cx + rx, cy - (KAPPA * ry), cx + rx, cy);
					ctx.bezierCurveTo(cx + rx, cy + (KAPPA * ry), cx + (KAPPA * rx), cy + ry, cx, cy + ry);
					ctx.bezierCurveTo(cx - (KAPPA * rx), cy + ry, cx - rx, cy + (KAPPA * ry), cx - rx, cy);
					ctx.bezierCurveTo(cx - rx, cy - (KAPPA * ry), cx - (KAPPA * rx), cy - ry, cx, cy - ry);
					ctx.closePath();
				}
				
				return new svg.BoundingBox(cx - rx, cy - ry, cx + rx, cy + ry);
			}
		}
		svg.Element.ellipse.prototype = new svg.Element.PathElementBase;			
		
		// line element
		svg.Element.line = function(node) {
			this.base = svg.Element.PathElementBase;
			this.base(node);
			
			this.getPoints = function() {
				return [
					new svg.Point(this.attribute('x1').toPixels('x'), this.attribute('y1').toPixels('y')),
					new svg.Point(this.attribute('x2').toPixels('x'), this.attribute('y2').toPixels('y'))];
			}
								
			this.path = function(ctx) {
				var points = this.getPoints();
				
				if (ctx != null) {
					ctx.beginPath();
					ctx.moveTo(points[0].x, points[0].y);
					ctx.lineTo(points[1].x, points[1].y);
				}
				
				return new svg.BoundingBox(points[0].x, points[0].y, points[1].x, points[1].y);
			}
			
			this.getMarkers = function() {
				var points = this.getPoints();	
				var a = points[0].angleTo(points[1]);
				return [[points[0], a], [points[1], a]];
			}
		}
		svg.Element.line.prototype = new svg.Element.PathElementBase;		
				
		// polyline element
		svg.Element.polyline = function(node) {
			this.base = svg.Element.PathElementBase;
			this.base(node);
			
			this.points = svg.CreatePath(this.attribute('points').value);
			this.path = function(ctx) {
				var bb = new svg.BoundingBox(this.points[0].x, this.points[0].y);
				if (ctx != null) {
					ctx.beginPath();
					ctx.moveTo(this.points[0].x, this.points[0].y);
				}
				for (var i=1; i<this.points.length; i++) {
					bb.addPoint(this.points[i].x, this.points[i].y);
					if (ctx != null) ctx.lineTo(this.points[i].x, this.points[i].y);
				}
				return bb;
			}
			
			this.getMarkers = function() {
				var markers = [];
				for (var i=0; i<this.points.length - 1; i++) {
					markers.push([this.points[i], this.points[i].angleTo(this.points[i+1])]);
				}
				markers.push([this.points[this.points.length-1], markers[markers.length-1][1]]);
				return markers;
			}			
		}
		svg.Element.polyline.prototype = new svg.Element.PathElementBase;				
				
		// polygon element
		svg.Element.polygon = function(node) {
			this.base = svg.Element.polyline;
			this.base(node);
			
			this.basePath = this.path;
			this.path = function(ctx) {
				var bb = this.basePath(ctx);
				if (ctx != null) {
					ctx.lineTo(this.points[0].x, this.points[0].y);
					ctx.closePath();
				}
				return bb;
			}
		}
		svg.Element.polygon.prototype = new svg.Element.polyline;

		// path element
		svg.Element.path = function(node) {
			this.base = svg.Element.PathElementBase;
			this.base(node);
					
			var d = this.attribute('d').value;
			// TODO: convert to real lexer based on http://www.w3.org/TR/SVG11/paths.html#PathDataBNF
			d = d.replace(/,/gm,' '); // get rid of all commas
			d = d.replace(/([MmZzLlHhVvCcSsQqTtAa])([MmZzLlHhVvCcSsQqTtAa])/gm,'$1 $2'); // separate commands from commands
			d = d.replace(/([MmZzLlHhVvCcSsQqTtAa])([MmZzLlHhVvCcSsQqTtAa])/gm,'$1 $2'); // separate commands from commands
			d = d.replace(/([MmZzLlHhVvCcSsQqTtAa])([^\s])/gm,'$1 $2'); // separate commands from points
			d = d.replace(/([^\s])([MmZzLlHhVvCcSsQqTtAa])/gm,'$1 $2'); // separate commands from points
			d = d.replace(/([0-9])([+\-])/gm,'$1 $2'); // separate digits when no comma
			d = d.replace(/(\.[0-9]*)(\.)/gm,'$1 $2'); // separate digits when no comma
			d = d.replace(/([Aa](\s+[0-9]+){3})\s+([01])\s*([01])/gm,'$1 $3 $4 '); // shorthand elliptical arc path syntax
			d = svg.compressSpaces(d); // compress multiple spaces
			d = svg.trim(d);
			this.PathParser = new (function(d) {
				this.tokens = d.split(' ');
				
				this.reset = function() {
					this.i = -1;
					this.command = '';
					this.previousCommand = '';
					this.start = new svg.Point(0, 0);
					this.control = new svg.Point(0, 0);
					this.current = new svg.Point(0, 0);
					this.points = [];
					this.angles = [];
				}
								
				this.isEnd = function() {
					return this.i >= this.tokens.length - 1;
				}
				
				this.isCommandOrEnd = function() {
					if (this.isEnd()) return true;
					return this.tokens[this.i + 1].match(/^[A-Za-z]$/) != null;
				}
				
				this.isRelativeCommand = function() {
					switch(this.command)
					{
						case 'm':
						case 'l':
						case 'h':
						case 'v':
						case 'c':
						case 's':
						case 'q':
						case 't':
						case 'a':
						case 'z':
							return true;
							break;
					}
					return false;
				}
							
				this.getToken = function() {
					this.i++;
					return this.tokens[this.i];
				}
				
				this.getScalar = function() {
					return parseFloat(this.getToken());
				}
				
				this.nextCommand = function() {
					this.previousCommand = this.command;
					this.command = this.getToken();
				}				
				
				this.getPoint = function() {
					var p = new svg.Point(this.getScalar(), this.getScalar());
					return this.makeAbsolute(p);
				}
				
				this.getAsControlPoint = function() {
					var p = this.getPoint();
					this.control = p;
					return p;
				}
				
				this.getAsCurrentPoint = function() {
					var p = this.getPoint();
					this.current = p;
					return p;	
				}
				
				this.getReflectedControlPoint = function() {
					if (this.previousCommand.toLowerCase() != 'c' && 
					    this.previousCommand.toLowerCase() != 's' &&
						this.previousCommand.toLowerCase() != 'q' && 
						this.previousCommand.toLowerCase() != 't' ){
						return this.current;
					}
					
					// reflect point
					var p = new svg.Point(2 * this.current.x - this.control.x, 2 * this.current.y - this.control.y);					
					return p;
				}
				
				this.makeAbsolute = function(p) {
					if (this.isRelativeCommand()) {
						p.x += this.current.x;
						p.y += this.current.y;
					}
					return p;
				}
				
				this.addMarker = function(p, from, priorTo) {
					// if the last angle isn't filled in because we didn't have this point yet ...
					if (priorTo != null && this.angles.length > 0 && this.angles[this.angles.length-1] == null) {
						this.angles[this.angles.length-1] = this.points[this.points.length-1].angleTo(priorTo);
					}
					this.addMarkerAngle(p, from == null ? null : from.angleTo(p));
				}
				
				this.addMarkerAngle = function(p, a) {
					this.points.push(p);
					this.angles.push(a);
				}				
				
				this.getMarkerPoints = function() { return this.points; }
				this.getMarkerAngles = function() {
					for (var i=0; i<this.angles.length; i++) {
						if (this.angles[i] == null) {
							for (var j=i+1; j<this.angles.length; j++) {
								if (this.angles[j] != null) {
									this.angles[i] = this.angles[j];
									break;
								}
							}
						}
					}
					return this.angles;
				}
			})(d);

			this.path = function(ctx) {
				var pp = this.PathParser;
				pp.reset();

				var bb = new svg.BoundingBox();
				if (ctx != null) ctx.beginPath();
				while (!pp.isEnd()) {
					pp.nextCommand();
					switch (pp.command) {
					case 'M':
					case 'm':
						var p = pp.getAsCurrentPoint();
						pp.addMarker(p);
						bb.addPoint(p.x, p.y);
						if (ctx != null) ctx.moveTo(p.x, p.y);
						pp.start = pp.current;
						while (!pp.isCommandOrEnd()) {
							var p = pp.getAsCurrentPoint();
							pp.addMarker(p, pp.start);
							bb.addPoint(p.x, p.y);
							if (ctx != null) ctx.lineTo(p.x, p.y);
						}
						break;
					case 'L':
					case 'l':
						while (!pp.isCommandOrEnd()) {
							var c = pp.current;
							var p = pp.getAsCurrentPoint();
							pp.addMarker(p, c);
							bb.addPoint(p.x, p.y);
							if (ctx != null) ctx.lineTo(p.x, p.y);
						}
						break;
					case 'H':
					case 'h':
						while (!pp.isCommandOrEnd()) {
							var newP = new svg.Point((pp.isRelativeCommand() ? pp.current.x : 0) + pp.getScalar(), pp.current.y);
							pp.addMarker(newP, pp.current);
							pp.current = newP;
							bb.addPoint(pp.current.x, pp.current.y);
							if (ctx != null) ctx.lineTo(pp.current.x, pp.current.y);
						}
						break;
					case 'V':
					case 'v':
						while (!pp.isCommandOrEnd()) {
							var newP = new svg.Point(pp.current.x, (pp.isRelativeCommand() ? pp.current.y : 0) + pp.getScalar());
							pp.addMarker(newP, pp.current);
							pp.current = newP;
							bb.addPoint(pp.current.x, pp.current.y);
							if (ctx != null) ctx.lineTo(pp.current.x, pp.current.y);
						}
						break;
					case 'C':
					case 'c':
						while (!pp.isCommandOrEnd()) {
							var curr = pp.current;
							var p1 = pp.getPoint();
							var cntrl = pp.getAsControlPoint();
							var cp = pp.getAsCurrentPoint();
							pp.addMarker(cp, cntrl, p1);
							bb.addBezierCurve(curr.x, curr.y, p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y);
							if (ctx != null) ctx.bezierCurveTo(p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y);
						}
						break;
					case 'S':
					case 's':
						while (!pp.isCommandOrEnd()) {
							var curr = pp.current;
							var p1 = pp.getReflectedControlPoint();
							var cntrl = pp.getAsControlPoint();
							var cp = pp.getAsCurrentPoint();
							pp.addMarker(cp, cntrl, p1);
							bb.addBezierCurve(curr.x, curr.y, p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y);
							if (ctx != null) ctx.bezierCurveTo(p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y);
						}
						break;
					case 'Q':
					case 'q':
						while (!pp.isCommandOrEnd()) {
							var curr = pp.current;
							var cntrl = pp.getAsControlPoint();
							var cp = pp.getAsCurrentPoint();
							pp.addMarker(cp, cntrl, cntrl);
							bb.addQuadraticCurve(curr.x, curr.y, cntrl.x, cntrl.y, cp.x, cp.y);
							if (ctx != null) ctx.quadraticCurveTo(cntrl.x, cntrl.y, cp.x, cp.y);
						}
						break;
					case 'T':
					case 't':
						while (!pp.isCommandOrEnd()) {
							var curr = pp.current;
							var cntrl = pp.getReflectedControlPoint();
							pp.control = cntrl;
							var cp = pp.getAsCurrentPoint();
							pp.addMarker(cp, cntrl, cntrl);
							bb.addQuadraticCurve(curr.x, curr.y, cntrl.x, cntrl.y, cp.x, cp.y);
							if (ctx != null) ctx.quadraticCurveTo(cntrl.x, cntrl.y, cp.x, cp.y);
						}
						break;
					case 'A':
					case 'a':
						while (!pp.isCommandOrEnd()) {
						    var curr = pp.current;
							var rx = pp.getScalar();
							var ry = pp.getScalar();
							var xAxisRotation = pp.getScalar() * (Math.PI / 180.0);
							var largeArcFlag = pp.getScalar();
							var sweepFlag = pp.getScalar();
							var cp = pp.getAsCurrentPoint();

							// Conversion from endpoint to center parameterization
							// http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
							// x1', y1'
							var currp = new svg.Point(
								Math.cos(xAxisRotation) * (curr.x - cp.x) / 2.0 + Math.sin(xAxisRotation) * (curr.y - cp.y) / 2.0,
								-Math.sin(xAxisRotation) * (curr.x - cp.x) / 2.0 + Math.cos(xAxisRotation) * (curr.y - cp.y) / 2.0
							);
							// adjust radii
							var l = Math.pow(currp.x,2)/Math.pow(rx,2)+Math.pow(currp.y,2)/Math.pow(ry,2);
							if (l > 1) {
								rx *= Math.sqrt(l);
								ry *= Math.sqrt(l);
							}
							// cx', cy'
							var s = (largeArcFlag == sweepFlag ? -1 : 1) * Math.sqrt(
								((Math.pow(rx,2)*Math.pow(ry,2))-(Math.pow(rx,2)*Math.pow(currp.y,2))-(Math.pow(ry,2)*Math.pow(currp.x,2))) /
								(Math.pow(rx,2)*Math.pow(currp.y,2)+Math.pow(ry,2)*Math.pow(currp.x,2))
							);
							if (isNaN(s)) s = 0;
							var cpp = new svg.Point(s * rx * currp.y / ry, s * -ry * currp.x / rx);
							// cx, cy
							var centp = new svg.Point(
								(curr.x + cp.x) / 2.0 + Math.cos(xAxisRotation) * cpp.x - Math.sin(xAxisRotation) * cpp.y,
								(curr.y + cp.y) / 2.0 + Math.sin(xAxisRotation) * cpp.x + Math.cos(xAxisRotation) * cpp.y
							);
							// vector magnitude
							var m = function(v) { return Math.sqrt(Math.pow(v[0],2) + Math.pow(v[1],2)); }
							// ratio between two vectors
							var r = function(u, v) { return (u[0]*v[0]+u[1]*v[1]) / (m(u)*m(v)) }
							// angle between two vectors
							var a = function(u, v) { return (u[0]*v[1] < u[1]*v[0] ? -1 : 1) * Math.acos(r(u,v)); }
							// initial angle
							var a1 = a([1,0], [(currp.x-cpp.x)/rx,(currp.y-cpp.y)/ry]);
							// angle delta
							var u = [(currp.x-cpp.x)/rx,(currp.y-cpp.y)/ry];
							var v = [(-currp.x-cpp.x)/rx,(-currp.y-cpp.y)/ry];
							var ad = a(u, v);
							if (r(u,v) <= -1) ad = Math.PI;
							if (r(u,v) >= 1) ad = 0;

							// for markers
							var dir = 1 - sweepFlag ? 1.0 : -1.0;
							var ah = a1 + dir * (ad / 2.0);
							var halfWay = new svg.Point(
								centp.x + rx * Math.cos(ah),
								centp.y + ry * Math.sin(ah)
							);
							pp.addMarkerAngle(halfWay, ah - dir * Math.PI / 2);
							pp.addMarkerAngle(cp, ah - dir * Math.PI);

							bb.addPoint(cp.x, cp.y); // TODO: this is too naive, make it better
							if (ctx != null) {
								var r = rx > ry ? rx : ry;
								var sx = rx > ry ? 1 : rx / ry;
								var sy = rx > ry ? ry / rx : 1;

								ctx.translate(centp.x, centp.y);
								ctx.rotate(xAxisRotation);
								ctx.scale(sx, sy);
								ctx.arc(0, 0, r, a1, a1 + ad, 1 - sweepFlag);
								ctx.scale(1/sx, 1/sy);
								ctx.rotate(-xAxisRotation);
								ctx.translate(-centp.x, -centp.y);
							}
						}
						break;
					case 'Z':
					case 'z':
						if (ctx != null) ctx.closePath();
						pp.current = pp.start;
					}
				}

				return bb;
			}

			this.getMarkers = function() {
				var points = this.PathParser.getMarkerPoints();
				var angles = this.PathParser.getMarkerAngles();
				
				var markers = [];
				for (var i=0; i<points.length; i++) {
					markers.push([points[i], angles[i]]);
				}
				return markers;
			}
		}
		svg.Element.path.prototype = new svg.Element.PathElementBase;
		
		// pattern element
		svg.Element.pattern = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);
			
			this.createPattern = function(ctx, element) {
				var width = this.attribute('width').toPixels('x', true);
				var height = this.attribute('height').toPixels('y', true);
			
				// render me using a temporary svg element
				var tempSvg = new svg.Element.svg();
				tempSvg.attributes['viewBox'] = new svg.Property('viewBox', this.attribute('viewBox').value);
				tempSvg.attributes['width'] = new svg.Property('width', width + 'px');
				tempSvg.attributes['height'] = new svg.Property('height', height + 'px');
				tempSvg.attributes['transform'] = new svg.Property('transform', this.attribute('patternTransform').value);
				tempSvg.children = this.children;
				
				var c = document.createElement('canvas');
				c.width = width;
				c.height = height;
				var cctx = c.getContext('2d');
				if (this.attribute('x').hasValue() && this.attribute('y').hasValue()) {
					cctx.translate(this.attribute('x').toPixels('x', true), this.attribute('y').toPixels('y', true));
				}
				// render 3x3 grid so when we transform there's no white space on edges
				for (var x=-1; x<=1; x++) {
					for (var y=-1; y<=1; y++) {
						cctx.save();
						cctx.translate(x * c.width, y * c.height);
						tempSvg.render(cctx);
						cctx.restore();
					}
				}
				var pattern = ctx.createPattern(c, 'repeat');
				return pattern;
			}
		}
		svg.Element.pattern.prototype = new svg.Element.ElementBase;
		
		// marker element
		svg.Element.marker = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);
			
			this.baseRender = this.render;
			this.render = function(ctx, point, angle) {
				ctx.translate(point.x, point.y);
				if (this.attribute('orient').valueOrDefault('auto') == 'auto') ctx.rotate(angle);
				if (this.attribute('markerUnits').valueOrDefault('strokeWidth') == 'strokeWidth') ctx.scale(ctx.lineWidth, ctx.lineWidth);
				ctx.save();
							
				// render me using a temporary svg element
				var tempSvg = new svg.Element.svg();
				tempSvg.attributes['viewBox'] = new svg.Property('viewBox', this.attribute('viewBox').value);
				tempSvg.attributes['refX'] = new svg.Property('refX', this.attribute('refX').value);
				tempSvg.attributes['refY'] = new svg.Property('refY', this.attribute('refY').value);
				tempSvg.attributes['width'] = new svg.Property('width', this.attribute('markerWidth').value);
				tempSvg.attributes['height'] = new svg.Property('height', this.attribute('markerHeight').value);
				tempSvg.attributes['fill'] = new svg.Property('fill', this.attribute('fill').valueOrDefault('black'));
				tempSvg.attributes['stroke'] = new svg.Property('stroke', this.attribute('stroke').valueOrDefault('none'));
				tempSvg.children = this.children;
				tempSvg.render(ctx);
				
				ctx.restore();
				if (this.attribute('markerUnits').valueOrDefault('strokeWidth') == 'strokeWidth') ctx.scale(1/ctx.lineWidth, 1/ctx.lineWidth);
				if (this.attribute('orient').valueOrDefault('auto') == 'auto') ctx.rotate(-angle);
				ctx.translate(-point.x, -point.y);
			}
		}
		svg.Element.marker.prototype = new svg.Element.ElementBase;
		
		// definitions element
		svg.Element.defs = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);	
			
			this.render = function(ctx) {
				// NOOP
			}
		}
		svg.Element.defs.prototype = new svg.Element.ElementBase;
		
		// base for gradients
		svg.Element.GradientBase = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);
			
			this.gradientUnits = this.attribute('gradientUnits').valueOrDefault('objectBoundingBox');
			
			this.stops = [];			
			for (var i=0; i<this.children.length; i++) {
				var child = this.children[i];
				if (child.type == 'stop') this.stops.push(child);
			}	
			
			this.getGradient = function() {
				// OVERRIDE ME!
			}			

			this.createGradient = function(ctx, element, parentOpacityProp) {
				var stopsContainer = this;
				if (this.getHrefAttribute().hasValue()) {
					stopsContainer = this.getHrefAttribute().getDefinition();
				}
				
				var addParentOpacity = function (color) {
					if (parentOpacityProp.hasValue()) {
						var p = new svg.Property('color', color);
						return p.addOpacity(parentOpacityProp.value).value;
					}
					return color;
				};
			
				var g = this.getGradient(ctx, element);
				if (g == null) return addParentOpacity(stopsContainer.stops[stopsContainer.stops.length - 1].color);
				for (var i=0; i<stopsContainer.stops.length; i++) {
					g.addColorStop(stopsContainer.stops[i].offset, addParentOpacity(stopsContainer.stops[i].color));
				}
				
				if (this.attribute('gradientTransform').hasValue()) {
					// render as transformed pattern on temporary canvas
					var rootView = svg.ViewPort.viewPorts[0];
					
					var rect = new svg.Element.rect();
					rect.attributes['x'] = new svg.Property('x', -svg.MAX_VIRTUAL_PIXELS/3.0);
					rect.attributes['y'] = new svg.Property('y', -svg.MAX_VIRTUAL_PIXELS/3.0);
					rect.attributes['width'] = new svg.Property('width', svg.MAX_VIRTUAL_PIXELS);
					rect.attributes['height'] = new svg.Property('height', svg.MAX_VIRTUAL_PIXELS);
					
					var group = new svg.Element.g();
					group.attributes['transform'] = new svg.Property('transform', this.attribute('gradientTransform').value);
					group.children = [ rect ];
					
					var tempSvg = new svg.Element.svg();
					tempSvg.attributes['x'] = new svg.Property('x', 0);
					tempSvg.attributes['y'] = new svg.Property('y', 0);
					tempSvg.attributes['width'] = new svg.Property('width', rootView.width);
					tempSvg.attributes['height'] = new svg.Property('height', rootView.height);
					tempSvg.children = [ group ];
					
					var c = document.createElement('canvas');
					c.width = rootView.width;
					c.height = rootView.height;
					var tempCtx = c.getContext('2d');
					tempCtx.fillStyle = g;
					tempSvg.render(tempCtx);		
					return tempCtx.createPattern(c, 'no-repeat');
				}
				
				return g;				
			}
		}
		svg.Element.GradientBase.prototype = new svg.Element.ElementBase;
		
		// linear gradient element
		svg.Element.linearGradient = function(node) {
			this.base = svg.Element.GradientBase;
			this.base(node);
			
			this.getGradient = function(ctx, element) {
				var bb = element.getBoundingBox();
				
				if (!this.attribute('x1').hasValue()
				 && !this.attribute('y1').hasValue()
				 && !this.attribute('x2').hasValue()
				 && !this.attribute('y2').hasValue()) {
					this.attribute('x1', true).value = 0;
					this.attribute('y1', true).value = 0;
					this.attribute('x2', true).value = 1;
					this.attribute('y2', true).value = 0;
				 }
				
				var x1 = (this.gradientUnits == 'objectBoundingBox' 
					? bb.x() + bb.width() * this.attribute('x1').numValue() 
					: this.attribute('x1').toPixels('x'));
				var y1 = (this.gradientUnits == 'objectBoundingBox' 
					? bb.y() + bb.height() * this.attribute('y1').numValue()
					: this.attribute('y1').toPixels('y'));
				var x2 = (this.gradientUnits == 'objectBoundingBox' 
					? bb.x() + bb.width() * this.attribute('x2').numValue()
					: this.attribute('x2').toPixels('x'));
				var y2 = (this.gradientUnits == 'objectBoundingBox' 
					? bb.y() + bb.height() * this.attribute('y2').numValue()
					: this.attribute('y2').toPixels('y'));

				if (x1 == x2 && y1 == y2) return null;
				return ctx.createLinearGradient(x1, y1, x2, y2);
			}
		}
		svg.Element.linearGradient.prototype = new svg.Element.GradientBase;
		
		// radial gradient element
		svg.Element.radialGradient = function(node) {
			this.base = svg.Element.GradientBase;
			this.base(node);
			
			this.getGradient = function(ctx, element) {
				var bb = element.getBoundingBox();
				
				if (!this.attribute('cx').hasValue()) this.attribute('cx', true).value = '50%';
				if (!this.attribute('cy').hasValue()) this.attribute('cy', true).value = '50%';
				if (!this.attribute('r').hasValue()) this.attribute('r', true).value = '50%';
				
				var cx = (this.gradientUnits == 'objectBoundingBox' 
					? bb.x() + bb.width() * this.attribute('cx').numValue() 
					: this.attribute('cx').toPixels('x'));
				var cy = (this.gradientUnits == 'objectBoundingBox' 
					? bb.y() + bb.height() * this.attribute('cy').numValue() 
					: this.attribute('cy').toPixels('y'));
				
				var fx = cx;
				var fy = cy;
				if (this.attribute('fx').hasValue()) {
					fx = (this.gradientUnits == 'objectBoundingBox' 
					? bb.x() + bb.width() * this.attribute('fx').numValue() 
					: this.attribute('fx').toPixels('x'));
				}
				if (this.attribute('fy').hasValue()) {
					fy = (this.gradientUnits == 'objectBoundingBox' 
					? bb.y() + bb.height() * this.attribute('fy').numValue() 
					: this.attribute('fy').toPixels('y'));
				}
				
				var r = (this.gradientUnits == 'objectBoundingBox' 
					? (bb.width() + bb.height()) / 2.0 * this.attribute('r').numValue()
					: this.attribute('r').toPixels());
				
				return ctx.createRadialGradient(fx, fy, 0, cx, cy, r);
			}
		}
		svg.Element.radialGradient.prototype = new svg.Element.GradientBase;
		
		// gradient stop element
		svg.Element.stop = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);
			
			this.offset = this.attribute('offset').numValue();
			if (this.offset < 0) this.offset = 0;
			if (this.offset > 1) this.offset = 1;
			
			var stopColor = this.style('stop-color');
			if (this.style('stop-opacity').hasValue()) stopColor = stopColor.addOpacity(this.style('stop-opacity').value);
			this.color = stopColor.value;
		}
		svg.Element.stop.prototype = new svg.Element.ElementBase;
		
		// animation base element
		svg.Element.AnimateBase = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);
			
			svg.Animations.push(this);
			
			this.duration = 0.0;
			this.begin = this.attribute('begin').toMilliseconds();
			this.maxDuration = this.begin + this.attribute('dur').toMilliseconds();
			
			this.getProperty = function() {
				var attributeType = this.attribute('attributeType').value;
				var attributeName = this.attribute('attributeName').value;
				
				if (attributeType == 'CSS') {
					return this.parent.style(attributeName, true);
				}
				return this.parent.attribute(attributeName, true);			
			};
			
			this.initialValue = null;
			this.initialUnits = '';
			this.removed = false;			

			this.calcValue = function() {
				// OVERRIDE ME!
				return '';
			}
					
			this.update = function(delta) {	
				// set initial value
				if (this.initialValue == null) {
					this.initialValue = this.getProperty().value;
					this.initialUnits = this.getProperty().getUnits();
				}
			
				// if we're past the end time
				if (this.duration > this.maxDuration) {
					// loop for indefinitely repeating animations
					if (this.attribute('repeatCount').value == 'indefinite'
					 || this.attribute('repeatDur').value == 'indefinite') {
						this.duration = 0.0
					}
					else if (this.attribute('fill').valueOrDefault('remove') == 'remove' && !this.removed) {
						this.removed = true;
						this.getProperty().value = this.initialValue;
						return true;
					}
					else {
						return false; // no updates made
					}
				}			
				this.duration = this.duration + delta;
			
				// if we're past the begin time
				var updated = false;
				if (this.begin < this.duration) {
					var newValue = this.calcValue(); // tween
					
					if (this.attribute('type').hasValue()) {
						// for transform, etc.
						var type = this.attribute('type').value;
						newValue = type + '(' + newValue + ')';
					}
					
					this.getProperty().value = newValue;
					updated = true;
				}
				
				return updated;
			}
			
			this.from = this.attribute('from');
			this.to = this.attribute('to');
			this.values = this.attribute('values');
			if (this.values.hasValue()) this.values.value = this.values.value.split(';');
			
			// fraction of duration we've covered
			this.progress = function() {
				var ret = { progress: (this.duration - this.begin) / (this.maxDuration - this.begin) };
				if (this.values.hasValue()) {
					var p = ret.progress * (this.values.value.length - 1);
					var lb = Math.floor(p), ub = Math.ceil(p);
					ret.from = new svg.Property('from', parseFloat(this.values.value[lb]));
					ret.to = new svg.Property('to', parseFloat(this.values.value[ub]));
					ret.progress = (p - lb) / (ub - lb);
				}
				else {
					ret.from = this.from;
					ret.to = this.to;
				}
				return ret;
			}			
		}
		svg.Element.AnimateBase.prototype = new svg.Element.ElementBase;
		
		// animate element
		svg.Element.animate = function(node) {
			this.base = svg.Element.AnimateBase;
			this.base(node);
			
			this.calcValue = function() {
				var p = this.progress();
				
				// tween value linearly
				var newValue = p.from.numValue() + (p.to.numValue() - p.from.numValue()) * p.progress; 
				return newValue + this.initialUnits;
			};
		}
		svg.Element.animate.prototype = new svg.Element.AnimateBase;
			
		// animate color element
		svg.Element.animateColor = function(node) {
			this.base = svg.Element.AnimateBase;
			this.base(node);

			this.calcValue = function() {
				var p = this.progress();
				var from = new RGBColor(p.from.value);
				var to = new RGBColor(p.to.value);
				
				if (from.ok && to.ok) {
					// tween color linearly
					var r = from.r + (to.r - from.r) * p.progress;
					var g = from.g + (to.g - from.g) * p.progress;
					var b = from.b + (to.b - from.b) * p.progress;
					return 'rgb('+parseInt(r,10)+','+parseInt(g,10)+','+parseInt(b,10)+')';
				}
				return this.attribute('from').value;
			};
		}
		svg.Element.animateColor.prototype = new svg.Element.AnimateBase;
		
		// animate transform element
		svg.Element.animateTransform = function(node) {
			this.base = svg.Element.AnimateBase;
			this.base(node);
			
			this.calcValue = function() {
				var p = this.progress();
				
				// tween value linearly
				var from = svg.ToNumberArray(p.from.value);
				var to = svg.ToNumberArray(p.to.value);
				var newValue = '';
				for (var i=0; i<from.length; i++) {
					newValue += from[i] + (to[i] - from[i]) * p.progress + ' ';
				}
				return newValue;
			};
		}
		svg.Element.animateTransform.prototype = new svg.Element.animate;
		
		// font element
		svg.Element.font = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			this.horizAdvX = this.attribute('horiz-adv-x').numValue();			
			
			this.isRTL = false;
			this.isArabic = false;
			this.fontFace = null;
			this.missingGlyph = null;
			this.glyphs = [];			
			for (var i=0; i<this.children.length; i++) {
				var child = this.children[i];
				if (child.type == 'font-face') {
					this.fontFace = child;
					if (child.style('font-family').hasValue()) {
						svg.Definitions[child.style('font-family').value] = this;
					}
				}
				else if (child.type == 'missing-glyph') this.missingGlyph = child;
				else if (child.type == 'glyph') {
					if (child.arabicForm != '') {
						this.isRTL = true;
						this.isArabic = true;
						if (typeof(this.glyphs[child.unicode]) == 'undefined') this.glyphs[child.unicode] = [];
						this.glyphs[child.unicode][child.arabicForm] = child;
					}
					else {
						this.glyphs[child.unicode] = child;
					}
				}
			}	
		}
		svg.Element.font.prototype = new svg.Element.ElementBase;
		
		// font-face element
		svg.Element.fontface = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);	
			
			this.ascent = this.attribute('ascent').value;
			this.descent = this.attribute('descent').value;
			this.unitsPerEm = this.attribute('units-per-em').numValue();				
		}
		svg.Element.fontface.prototype = new svg.Element.ElementBase;
		
		// missing-glyph element
		svg.Element.missingglyph = function(node) {
			this.base = svg.Element.path;
			this.base(node);	
			
			this.horizAdvX = 0;
		}
		svg.Element.missingglyph.prototype = new svg.Element.path;
		
		// glyph element
		svg.Element.glyph = function(node) {
			this.base = svg.Element.path;
			this.base(node);	
			
			this.horizAdvX = this.attribute('horiz-adv-x').numValue();
			this.unicode = this.attribute('unicode').value;
			this.arabicForm = this.attribute('arabic-form').value;
		}
		svg.Element.glyph.prototype = new svg.Element.path;
		
		// text element
		svg.Element.text = function(node) {
			this.captureTextNodes = true;
			this.base = svg.Element.RenderedElementBase;
			this.base(node);
			
			this.baseSetContext = this.setContext;
			this.setContext = function(ctx) {
				this.baseSetContext(ctx);
				if (this.style('dominant-baseline').hasValue()) ctx.textBaseline = this.style('dominant-baseline').value;
				if (this.style('alignment-baseline').hasValue()) ctx.textBaseline = this.style('alignment-baseline').value;
			}
			
			this.getBoundingBox = function () {
				// TODO: implement
				return new svg.BoundingBox(this.attribute('x').toPixels('x'), this.attribute('y').toPixels('y'), 0, 0);
			}
			
			this.renderChildren = function(ctx) {
				this.x = this.attribute('x').toPixels('x');
				this.y = this.attribute('y').toPixels('y');
				this.x += this.getAnchorDelta(ctx, this, 0);
				for (var i=0; i<this.children.length; i++) {
					this.renderChild(ctx, this, i);
				}
			}
			
			this.getAnchorDelta = function (ctx, parent, startI) {
				var textAnchor = this.style('text-anchor').valueOrDefault('start');
				if (textAnchor != 'start') {
					var width = 0;
					for (var i=startI; i<parent.children.length; i++) {
						var child = parent.children[i];
						if (i > startI && child.attribute('x').hasValue()) break; // new group
						width += child.measureTextRecursive(ctx);
					}
					return -1 * (textAnchor == 'end' ? width : width / 2.0);
				}
				return 0;
			}
			
			this.renderChild = function(ctx, parent, i) {
				var child = parent.children[i];
				if (child.attribute('x').hasValue()) {
					child.x = child.attribute('x').toPixels('x') + this.getAnchorDelta(ctx, parent, i);
				}
				else {
					if (this.attribute('dx').hasValue()) this.x += this.attribute('dx').toPixels('x');
					if (child.attribute('dx').hasValue()) this.x += child.attribute('dx').toPixels('x');
					child.x = this.x;
				}
				this.x = child.x + child.measureText(ctx);
				
				if (child.attribute('y').hasValue()) {
					child.y = child.attribute('y').toPixels('y');
				}
				else {
					if (this.attribute('dy').hasValue()) this.y += this.attribute('dy').toPixels('y');
					if (child.attribute('dy').hasValue()) this.y += child.attribute('dy').toPixels('y');
					child.y = this.y;
				}
				this.y = child.y;
				
				child.render(ctx);
				
				for (var i=0; i<child.children.length; i++) {
					this.renderChild(ctx, child, i);
				}
			}
		}
		svg.Element.text.prototype = new svg.Element.RenderedElementBase;
		
		// text base
		svg.Element.TextElementBase = function(node) {
			this.base = svg.Element.RenderedElementBase;
			this.base(node);
			
			this.getGlyph = function(font, text, i) {
				var c = text[i];
				var glyph = null;
				if (font.isArabic) {
					var arabicForm = 'isolated';
					if ((i==0 || text[i-1]==' ') && i<text.length-2 && text[i+1]!=' ') arabicForm = 'terminal'; 
					if (i>0 && text[i-1]!=' ' && i<text.length-2 && text[i+1]!=' ') arabicForm = 'medial';
					if (i>0 && text[i-1]!=' ' && (i == text.length-1 || text[i+1]==' ')) arabicForm = 'initial';
					if (typeof(font.glyphs[c]) != 'undefined') {
						glyph = font.glyphs[c][arabicForm];
						if (glyph == null && font.glyphs[c].type == 'glyph') glyph = font.glyphs[c];
					}
				}
				else {
					glyph = font.glyphs[c];
				}
				if (glyph == null) glyph = font.missingGlyph;
				return glyph;
			}
			
			this.renderChildren = function(ctx) {
				var customFont = this.parent.style('font-family').getDefinition();
				if (customFont != null) {
					var fontSize = this.parent.style('font-size').numValueOrDefault(svg.Font.Parse(svg.ctx.font).fontSize);
					var fontStyle = this.parent.style('font-style').valueOrDefault(svg.Font.Parse(svg.ctx.font).fontStyle);
					var text = this.getText();
					if (customFont.isRTL) text = text.split("").reverse().join("");
					
					var dx = svg.ToNumberArray(this.parent.attribute('dx').value);
					for (var i=0; i<text.length; i++) {
						var glyph = this.getGlyph(customFont, text, i);
						var scale = fontSize / customFont.fontFace.unitsPerEm;
						ctx.translate(this.x, this.y);
						ctx.scale(scale, -scale);
						var lw = ctx.lineWidth;
						ctx.lineWidth = ctx.lineWidth * customFont.fontFace.unitsPerEm / fontSize;
						if (fontStyle == 'italic') ctx.transform(1, 0, .4, 1, 0, 0);
						glyph.render(ctx);
						if (fontStyle == 'italic') ctx.transform(1, 0, -.4, 1, 0, 0);
						ctx.lineWidth = lw;
						ctx.scale(1/scale, -1/scale);
						ctx.translate(-this.x, -this.y);	
						
						this.x += fontSize * (glyph.horizAdvX || customFont.horizAdvX) / customFont.fontFace.unitsPerEm;
						if (typeof(dx[i]) != 'undefined' && !isNaN(dx[i])) {
							this.x += dx[i];
						}
					}
					return;
				}
			
				if (ctx.fillStyle != '') ctx.fillText(svg.compressSpaces(this.getText()), this.x, this.y);
				if (ctx.strokeStyle != '') ctx.strokeText(svg.compressSpaces(this.getText()), this.x, this.y);
			}
			
			this.getText = function() {
				// OVERRIDE ME
			}
			
			this.measureTextRecursive = function(ctx) {
				var width = this.measureText(ctx);
				for (var i=0; i<this.children.length; i++) {
					width += this.children[i].measureTextRecursive(ctx);
				}
				return width;
			}
			
			this.measureText = function(ctx) {
				var customFont = this.parent.style('font-family').getDefinition();
				if (customFont != null) {
					var fontSize = this.parent.style('font-size').numValueOrDefault(svg.Font.Parse(svg.ctx.font).fontSize);
					var measure = 0;
					var text = this.getText();
					if (customFont.isRTL) text = text.split("").reverse().join("");
					var dx = svg.ToNumberArray(this.parent.attribute('dx').value);
					for (var i=0; i<text.length; i++) {
						var glyph = this.getGlyph(customFont, text, i);
						measure += (glyph.horizAdvX || customFont.horizAdvX) * fontSize / customFont.fontFace.unitsPerEm;
						if (typeof(dx[i]) != 'undefined' && !isNaN(dx[i])) {
							measure += dx[i];
						}
					}
					return measure;
				}
			
				var textToMeasure = svg.compressSpaces(this.getText());
				if (!ctx.measureText) return textToMeasure.length * 10;
				
				ctx.save();
				this.setContext(ctx);
				var width = ctx.measureText(textToMeasure).width;
				ctx.restore();
				return width;
			}
		}
		svg.Element.TextElementBase.prototype = new svg.Element.RenderedElementBase;
		
		// tspan 
		svg.Element.tspan = function(node) {
			this.captureTextNodes = true;
			this.base = svg.Element.TextElementBase;
			this.base(node);
			
			this.text = node.nodeValue || node.text || '';
			this.getText = function() {
				return this.text;
			}
		}
		svg.Element.tspan.prototype = new svg.Element.TextElementBase;
		
		// tref
		svg.Element.tref = function(node) {
			this.base = svg.Element.TextElementBase;
			this.base(node);
			
			this.getText = function() {
				var element = this.getHrefAttribute().getDefinition();
				if (element != null) return element.children[0].getText();
			}
		}
		svg.Element.tref.prototype = new svg.Element.TextElementBase;		
		
		// a element
		svg.Element.a = function(node) {
			this.base = svg.Element.TextElementBase;
			this.base(node);
			
			this.hasText = true;
			for (var i=0; i<node.childNodes.length; i++) {
				if (node.childNodes[i].nodeType != 3) this.hasText = false;
			}
			
			// this might contain text
			this.text = this.hasText ? node.childNodes[0].nodeValue : '';
			this.getText = function() {
				return this.text;
			}		

			this.baseRenderChildren = this.renderChildren;
			this.renderChildren = function(ctx) {
				if (this.hasText) {
					// render as text element
					this.baseRenderChildren(ctx);
					var fontSize = new svg.Property('fontSize', svg.Font.Parse(svg.ctx.font).fontSize);
					svg.Mouse.checkBoundingBox(this, new svg.BoundingBox(this.x, this.y - fontSize.toPixels('y'), this.x + this.measureText(ctx), this.y));					
				}
				else {
					// render as temporary group
					var g = new svg.Element.g();
					g.children = this.children;
					g.parent = this;
					g.render(ctx);
				}
			}
			
			this.onclick = function() {
				window.open(this.getHrefAttribute().value);
			}
			
			this.onmousemove = function() {
				svg.ctx.canvas.style.cursor = 'pointer';
			}
		}
		svg.Element.a.prototype = new svg.Element.TextElementBase;		
		
		// image element
		svg.Element.image = function(node) {
			this.base = svg.Element.RenderedElementBase;
			this.base(node);
			
			var href = this.getHrefAttribute().value;
			var isSvg = href.match(/\.svg$/)
			
			svg.Images.push(this);
			this.loaded = false;
			if (!isSvg) {
				this.img = document.createElement('img');
				var self = this;
				this.img.onload = function() { self.loaded = true; }
				this.img.onerror = function() { if (typeof(console) != 'undefined') { console.log('ERROR: image "' + href + '" not found'); self.loaded = true; } }
				this.img.src = href;
			}
			else {
				this.img = svg.ajax(href);
				this.loaded = true;
			}
			
			this.renderChildren = function(ctx) {
				var x = this.attribute('x').toPixels('x');
				var y = this.attribute('y').toPixels('y');
				
				var width = this.attribute('width').toPixels('x');
				var height = this.attribute('height').toPixels('y');			
				if (width == 0 || height == 0) return;
			
				ctx.save();
				if (isSvg) {
					ctx.drawSvg(this.img, x, y, width, height);
				}
				else {
					ctx.translate(x, y);
					svg.AspectRatio(ctx,
									this.attribute('preserveAspectRatio').value,
									width,
									this.img.width,
									height,
									this.img.height,
									0,
									0);	
					ctx.drawImage(this.img, 0, 0);		
				}
				ctx.restore();
			}
			
			this.getBoundingBox = function() {
				var x = this.attribute('x').toPixels('x');
				var y = this.attribute('y').toPixels('y');
				var width = this.attribute('width').toPixels('x');
				var height = this.attribute('height').toPixels('y');
				return new svg.BoundingBox(x, y, x + width, y + height);
			}
		}
		svg.Element.image.prototype = new svg.Element.RenderedElementBase;
		
		// group element
		svg.Element.g = function(node) {
			this.base = svg.Element.RenderedElementBase;
			this.base(node);
			
			this.getBoundingBox = function() {
				var bb = new svg.BoundingBox();
				for (var i=0; i<this.children.length; i++) {
					bb.addBoundingBox(this.children[i].getBoundingBox());
				}
				return bb;
			};
		}
		svg.Element.g.prototype = new svg.Element.RenderedElementBase;

		// symbol element
		svg.Element.symbol = function(node) {
			this.base = svg.Element.RenderedElementBase;
			this.base(node);
			
			this.baseSetContext = this.setContext;
			this.setContext = function(ctx) {		
				this.baseSetContext(ctx);
				
				// viewbox
				if (this.attribute('viewBox').hasValue()) {				
					var viewBox = svg.ToNumberArray(this.attribute('viewBox').value);
					var minX = viewBox[0];
					var minY = viewBox[1];
					width = viewBox[2];
					height = viewBox[3];
					
					svg.AspectRatio(ctx,
									this.attribute('preserveAspectRatio').value, 
									this.attribute('width').toPixels('x'),
									width,
									this.attribute('height').toPixels('y'),
									height,
									minX,
									minY);

					svg.ViewPort.SetCurrent(viewBox[2], viewBox[3]);						
				}
			}			
		}
		svg.Element.symbol.prototype = new svg.Element.RenderedElementBase;		
			
		// style element
		svg.Element.style = function(node) { 
			this.base = svg.Element.ElementBase;
			this.base(node);
			
			// text, or spaces then CDATA
			var css = ''
			for (var i=0; i<node.childNodes.length; i++) {
			  css += node.childNodes[i].nodeValue;
			}
			css = css.replace(/(\/\*([^*]|[\r\n]|(\*+([^*\/]|[\r\n])))*\*+\/)|(^[\s]*\/\/.*)/gm, ''); // remove comments
			css = svg.compressSpaces(css); // replace whitespace
			var cssDefs = css.split('}');
			for (var i=0; i<cssDefs.length; i++) {
				if (svg.trim(cssDefs[i]) != '') {
					var cssDef = cssDefs[i].split('{');
					var cssClasses = cssDef[0].split(',');
					var cssProps = cssDef[1].split(';');
					for (var j=0; j<cssClasses.length; j++) {
						var cssClass = svg.trim(cssClasses[j]);
						if (cssClass != '') {
							var props = {};
							for (var k=0; k<cssProps.length; k++) {
								var prop = cssProps[k].indexOf(':');
								var name = cssProps[k].substr(0, prop);
								var value = cssProps[k].substr(prop + 1, cssProps[k].length - prop);
								if (name != null && value != null) {
									props[svg.trim(name)] = new svg.Property(svg.trim(name), svg.trim(value));
								}
							}
							svg.Styles[cssClass] = props;
							if (cssClass == '@font-face') {
								var fontFamily = props['font-family'].value.replace(/"/g,'');
								var srcs = props['src'].value.split(',');
								for (var s=0; s<srcs.length; s++) {
									if (srcs[s].indexOf('format("svg")') > 0) {
										var urlStart = srcs[s].indexOf('url');
										var urlEnd = srcs[s].indexOf(')', urlStart);
										var url = srcs[s].substr(urlStart + 5, urlEnd - urlStart - 6);
										var doc = svg.parseXml(svg.ajax(url));
										var fonts = doc.getElementsByTagName('font');
										for (var f=0; f<fonts.length; f++) {
											var font = svg.CreateElement(fonts[f]);
											svg.Definitions[fontFamily] = font;
										}
									}
								}
							}
						}
					}
				}
			}
		}
		svg.Element.style.prototype = new svg.Element.ElementBase;
		
		// use element 
		svg.Element.use = function(node) {
			this.base = svg.Element.RenderedElementBase;
			this.base(node);
			
			this.baseSetContext = this.setContext;
			this.setContext = function(ctx) {
				this.baseSetContext(ctx);
				if (this.attribute('x').hasValue()) ctx.translate(this.attribute('x').toPixels('x'), 0);
				if (this.attribute('y').hasValue()) ctx.translate(0, this.attribute('y').toPixels('y'));
			}
			
			this.getDefinition = function() {
				var element = this.getHrefAttribute().getDefinition();
				if (this.attribute('width').hasValue()) element.attribute('width', true).value = this.attribute('width').value;
				if (this.attribute('height').hasValue()) element.attribute('height', true).value = this.attribute('height').value;
				return element;
			}
			
			this.path = function(ctx) {
				var element = this.getDefinition();
				if (element != null) element.path(ctx);
			}
			
			this.getBoundingBox = function() {
				var element = this.getDefinition();
				if (element != null) return element.getBoundingBox();
			}
			
			this.renderChildren = function(ctx) {
				var element = this.getDefinition();
				if (element != null) {
					// temporarily detach from parent and render
					var oldParent = element.parent;
					element.parent = null;
					element.render(ctx);
					element.parent = oldParent;
				}
			}
		}
		svg.Element.use.prototype = new svg.Element.RenderedElementBase;
		
		// mask element
		svg.Element.mask = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);
						
			this.apply = function(ctx, element) {
				// render as temp svg	
				var x = this.attribute('x').toPixels('x');
				var y = this.attribute('y').toPixels('y');
				var width = this.attribute('width').toPixels('x');
				var height = this.attribute('height').toPixels('y');
				
				if (width == 0 && height == 0) {
					var bb = new svg.BoundingBox();
					for (var i=0; i<this.children.length; i++) {
						bb.addBoundingBox(this.children[i].getBoundingBox());
					}
					var x = Math.floor(bb.x1);
					var y = Math.floor(bb.y1);
					var width = Math.floor(bb.width());
					var	height = Math.floor(bb.height());
				}
				
				// temporarily remove mask to avoid recursion
				var mask = element.attribute('mask').value;
				element.attribute('mask').value = '';
				
					var cMask = document.createElement('canvas');
					cMask.width = x + width;
					cMask.height = y + height;
					var maskCtx = cMask.getContext('2d');
					this.renderChildren(maskCtx);
				
					var c = document.createElement('canvas');
					c.width = x + width;
					c.height = y + height;
					var tempCtx = c.getContext('2d');
					element.render(tempCtx);
					tempCtx.globalCompositeOperation = 'destination-in';
					tempCtx.fillStyle = maskCtx.createPattern(cMask, 'no-repeat');
					tempCtx.fillRect(0, 0, x + width, y + height);
					
					ctx.fillStyle = tempCtx.createPattern(c, 'no-repeat');
					ctx.fillRect(0, 0, x + width, y + height);
					
				// reassign mask
				element.attribute('mask').value = mask;	
			}
			
			this.render = function(ctx) {
				// NO RENDER
			}
		}
		svg.Element.mask.prototype = new svg.Element.ElementBase;
		
		// clip element
		svg.Element.clipPath = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);
			
			this.apply = function(ctx) {
				for (var i=0; i<this.children.length; i++) {
					var child = this.children[i];
					if (typeof(child.path) != 'undefined') {
						var transform = null;
						if (child.attribute('transform').hasValue()) { 
							transform = new svg.Transform(child.attribute('transform').value);
							transform.apply(ctx);
						}
						child.path(ctx);
						ctx.clip();
						if (transform) { transform.unapply(ctx); }
					}
				}
			}
			
			this.render = function(ctx) {
				// NO RENDER
			}
		}
		svg.Element.clipPath.prototype = new svg.Element.ElementBase;

		// filters
		svg.Element.filter = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);
						
			this.apply = function(ctx, element) {
				// render as temp svg	
				var bb = element.getBoundingBox();
				var x = Math.floor(bb.x1);
				var y = Math.floor(bb.y1);
				var width = Math.floor(bb.width());
				var	height = Math.floor(bb.height());

				// temporarily remove filter to avoid recursion
				var filter = element.style('filter').value;
				element.style('filter').value = '';
				
				var px = 0, py = 0;
				for (var i=0; i<this.children.length; i++) {
					var efd = this.children[i].extraFilterDistance || 0;
					px = Math.max(px, efd);
					py = Math.max(py, efd);
				}
				
				var c = document.createElement('canvas');
				c.width = width + 2*px;
				c.height = height + 2*py;
				var tempCtx = c.getContext('2d');
				tempCtx.translate(-x + px, -y + py);
				element.render(tempCtx);
			
				// apply filters
				for (var i=0; i<this.children.length; i++) {
					this.children[i].apply(tempCtx, 0, 0, width + 2*px, height + 2*py);
				}
				
				// render on me
				ctx.drawImage(c, 0, 0, width + 2*px, height + 2*py, x - px, y - py, width + 2*px, height + 2*py);
				
				// reassign filter
				element.style('filter', true).value = filter;	
			}
			
			this.render = function(ctx) {
				// NO RENDER
			}		
		}
		svg.Element.filter.prototype = new svg.Element.ElementBase;
		
		svg.Element.feMorphology = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);
			
			this.apply = function(ctx, x, y, width, height) {
				// TODO: implement
			}
		}
		svg.Element.feMorphology.prototype = new svg.Element.ElementBase;
		
		svg.Element.feColorMatrix = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);
			
			function imGet(img, x, y, width, height, rgba) {
				return img[y*width*4 + x*4 + rgba];
			}
			
			function imSet(img, x, y, width, height, rgba, val) {
				img[y*width*4 + x*4 + rgba] = val;
			}
			
			this.apply = function(ctx, x, y, width, height) {
				// only supporting grayscale for now per Issue 195, need to extend to all matrix
				// assuming x==0 && y==0 for now
				var srcData = ctx.getImageData(0, 0, width, height);
				for (var y = 0; y < height; y++) {
					for (var x = 0; x < width; x++) {
						var r = imGet(srcData.data, x, y, width, height, 0);
						var g = imGet(srcData.data, x, y, width, height, 1);
						var b = imGet(srcData.data, x, y, width, height, 2);
						var gray = (r + g + b) / 3;
						imSet(srcData.data, x, y, width, height, 0, gray);
						imSet(srcData.data, x, y, width, height, 1, gray);
						imSet(srcData.data, x, y, width, height, 2, gray);
					}
				}
				ctx.clearRect(0, 0, width, height);
				ctx.putImageData(srcData, 0, 0);
			}
		}
		svg.Element.feColorMatrix.prototype = new svg.Element.ElementBase;
		
		svg.Element.feGaussianBlur = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			this.blurRadius = Math.floor(this.attribute('stdDeviation').numValue());
			this.extraFilterDistance = this.blurRadius;
			
			this.apply = function(ctx, x, y, width, height) {
				if (typeof(stackBlurCanvasRGBA) == 'undefined') {
					if (typeof(console) != 'undefined') { console.log('ERROR: StackBlur.js must be included for blur to work'); }
					return;
				}
				
				// StackBlur requires canvas be on document
				ctx.canvas.id = svg.UniqueId();
				ctx.canvas.style.display = 'none';
				document.body.appendChild(ctx.canvas);
				stackBlurCanvasRGBA(ctx.canvas.id, x, y, width, height, this.blurRadius);
				document.body.removeChild(ctx.canvas);
			}
		}
		svg.Element.feGaussianBlur.prototype = new svg.Element.ElementBase;
		
		// title element, do nothing
		svg.Element.title = function(node) {
		}
		svg.Element.title.prototype = new svg.Element.ElementBase;

		// desc element, do nothing
		svg.Element.desc = function(node) {
		}
		svg.Element.desc.prototype = new svg.Element.ElementBase;		
		
		svg.Element.MISSING = function(node) {
			if (typeof(console) != 'undefined') { console.log('ERROR: Element \'' + node.nodeName + '\' not yet implemented.'); }
		}
		svg.Element.MISSING.prototype = new svg.Element.ElementBase;
		
		// element factory
		svg.CreateElement = function(node) {	
			var className = node.nodeName.replace(/^[^:]+:/,''); // remove namespace
			className = className.replace(/\-/g,''); // remove dashes
			var e = null;
			if (typeof(svg.Element[className]) != 'undefined') {
				e = new svg.Element[className](node);
			}
			else {
				e = new svg.Element.MISSING(node);
			}

			e.type = node.nodeName;
			return e;
		}
				
		// load from url
		svg.load = function(ctx, url) {
			svg.loadXml(ctx, svg.ajax(url));
		}
		
		// load from xml
		svg.loadXml = function(ctx, xml) {
			svg.loadXmlDoc(ctx, svg.parseXml(xml));
		}
		
		svg.loadXmlDoc = function(ctx, dom) {
			svg.init(ctx);
			
			var mapXY = function(p) {
				var e = ctx.canvas;
				while (e) {
					p.x -= e.offsetLeft;
					p.y -= e.offsetTop;
					e = e.offsetParent;
				}
				if (window.scrollX) p.x += window.scrollX;
				if (window.scrollY) p.y += window.scrollY;
				return p;
			}
			
			// bind mouse
			if (svg.opts['ignoreMouse'] != true) {
				ctx.canvas.onclick = function(e) {
					var p = mapXY(new svg.Point(e != null ? e.clientX : event.clientX, e != null ? e.clientY : event.clientY));
					svg.Mouse.onclick(p.x, p.y);
				};
				ctx.canvas.onmousemove = function(e) {
					var p = mapXY(new svg.Point(e != null ? e.clientX : event.clientX, e != null ? e.clientY : event.clientY));
					svg.Mouse.onmousemove(p.x, p.y);
				};
			}
		
			var e = svg.CreateElement(dom.documentElement);
			e.root = true;
					
			// render loop
			var isFirstRender = true;
			var draw = function() {
				svg.ViewPort.Clear();
				if (ctx.canvas.parentNode) svg.ViewPort.SetCurrent(ctx.canvas.parentNode.clientWidth, ctx.canvas.parentNode.clientHeight);
			
				if (svg.opts['ignoreDimensions'] != true) {
					// set canvas size
					if (e.style('width').hasValue()) {
						ctx.canvas.width = e.style('width').toPixels('x');
						ctx.canvas.style.width = ctx.canvas.width + 'px';
					}
					if (e.style('height').hasValue()) {
						ctx.canvas.height = e.style('height').toPixels('y');
						ctx.canvas.style.height = ctx.canvas.height + 'px';
					}
				}
				var cWidth = ctx.canvas.clientWidth || ctx.canvas.width;
				var cHeight = ctx.canvas.clientHeight || ctx.canvas.height;
				if (svg.opts['ignoreDimensions'] == true && e.style('width').hasValue() && e.style('height').hasValue()) {
					cWidth = e.style('width').toPixels('x');
					cHeight = e.style('height').toPixels('y');
				}
				svg.ViewPort.SetCurrent(cWidth, cHeight);		
				
				if (svg.opts['offsetX'] != null) e.attribute('x', true).value = svg.opts['offsetX'];
				if (svg.opts['offsetY'] != null) e.attribute('y', true).value = svg.opts['offsetY'];
				if (svg.opts['scaleWidth'] != null && svg.opts['scaleHeight'] != null) {
					var xRatio = 1, yRatio = 1, viewBox = svg.ToNumberArray(e.attribute('viewBox').value);
					if (e.attribute('width').hasValue()) xRatio = e.attribute('width').toPixels('x') / svg.opts['scaleWidth'];
					else if (!isNaN(viewBox[2])) xRatio = viewBox[2] / svg.opts['scaleWidth'];
					if (e.attribute('height').hasValue()) yRatio = e.attribute('height').toPixels('y') / svg.opts['scaleHeight'];
					else if (!isNaN(viewBox[3])) yRatio = viewBox[3] / svg.opts['scaleHeight'];
					
					e.attribute('width', true).value = svg.opts['scaleWidth'];
					e.attribute('height', true).value = svg.opts['scaleHeight'];			
					e.attribute('viewBox', true).value = '0 0 ' + (cWidth * xRatio) + ' ' + (cHeight * yRatio);
					e.attribute('preserveAspectRatio', true).value = 'none';
				}
			
				// clear and render
				if (svg.opts['ignoreClear'] != true) {
					ctx.clearRect(0, 0, cWidth, cHeight);
				}
				e.render(ctx);
				if (isFirstRender) {
					isFirstRender = false;
					if (typeof(svg.opts['renderCallback']) == 'function') svg.opts['renderCallback'](dom);
				}			
			}
			
			var waitingForImages = true;
			if (svg.ImagesLoaded()) {
				waitingForImages = false;
				draw();
			}
			svg.intervalID = setInterval(function() { 
				var needUpdate = false;
				
				if (waitingForImages && svg.ImagesLoaded()) {
					waitingForImages = false;
					needUpdate = true;
				}
			
				// need update from mouse events?
				if (svg.opts['ignoreMouse'] != true) {
					needUpdate = needUpdate | svg.Mouse.hasEvents();
				}
			
				// need update from animations?
				if (svg.opts['ignoreAnimation'] != true) {
					for (var i=0; i<svg.Animations.length; i++) {
						needUpdate = needUpdate | svg.Animations[i].update(1000 / svg.FRAMERATE);
					}
				}
				
				// need update from redraw?
				if (typeof(svg.opts['forceRedraw']) == 'function') {
					if (svg.opts['forceRedraw']() == true) needUpdate = true;
				}
				
				// render if needed
				if (needUpdate) {
					draw();				
					svg.Mouse.runEvents(); // run and clear our events
				}
			}, 1000 / svg.FRAMERATE);
		}
		
		svg.stop = function() {
			if (svg.intervalID) {
				clearInterval(svg.intervalID);
			}
		}
		
		svg.Mouse = new (function() {
			this.events = [];
			this.hasEvents = function() { return this.events.length != 0; }
		
			this.onclick = function(x, y) {
				this.events.push({ type: 'onclick', x: x, y: y, 
					run: function(e) { if (e.onclick) e.onclick(); }
				});
			}
			
			this.onmousemove = function(x, y) {
				this.events.push({ type: 'onmousemove', x: x, y: y,
					run: function(e) { if (e.onmousemove) e.onmousemove(); }
				});
			}			
			
			this.eventElements = [];
			
			this.checkPath = function(element, ctx) {
				for (var i=0; i<this.events.length; i++) {
					var e = this.events[i];
					if (ctx.isPointInPath && ctx.isPointInPath(e.x, e.y)) this.eventElements[i] = element;
				}
			}
			
			this.checkBoundingBox = function(element, bb) {
				for (var i=0; i<this.events.length; i++) {
					var e = this.events[i];
					if (bb.isPointInBox(e.x, e.y)) this.eventElements[i] = element;
				}			
			}
			
			this.runEvents = function() {
				svg.ctx.canvas.style.cursor = '';
				
				for (var i=0; i<this.events.length; i++) {
					var e = this.events[i];
					var element = this.eventElements[i];
					while (element) {
						e.run(element);
						element = element.parent;
					}
				}		
			
				// done running, clear
				this.events = []; 
				this.eventElements = [];
			}
		});
		
		return svg;
	}
})();

if (typeof(CanvasRenderingContext2D) != 'undefined') {
	CanvasRenderingContext2D.prototype.drawSvg = function(s, dx, dy, dw, dh) {
		canvg(this.canvas, s, { 
			ignoreMouse: true, 
			ignoreAnimation: true, 
			ignoreDimensions: true, 
			ignoreClear: true, 
			offsetX: dx, 
			offsetY: dy, 
			scaleWidth: dw, 
			scaleHeight: dh
		});
	}
}

// @tag amchart
/* FileSaver.js
 * A saveAs() FileSaver implementation.
 * 2013-10-21
 *
 * By Eli Grey, http://eligrey.com
 * License: X11/MIT
 *   See LICENSE.md
 */

/*global self */
/*jslint bitwise: true, regexp: true, confusion: true, es5: true, vars: true, white: true,
  plusplus: true */

/*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js */
if(AmCharts.isModern){ /// added by AmCharts to avoid old IE problems if this file is included
var saveAs = saveAs
  || (typeof navigator !== 'undefined' && navigator.msSaveOrOpenBlob && navigator.msSaveOrOpenBlob.bind(navigator))
  || (function(view) {
	"use strict";
	var
		  doc = view.document
		  // only get URL when necessary in case BlobBuilder.js hasn't overridden it yet
		, get_URL = function() {
			return view.URL || view.webkitURL || view;
		}
		, URL = view.URL || view.webkitURL || view
		, save_link = doc.createElementNS("http://www.w3.org/1999/xhtml", "a")
		, can_use_save_link =  !view.externalHost && "download" in save_link
		, click = function(node) {
			var event = doc.createEvent("MouseEvents");
			event.initMouseEvent(
				"click", true, false, view, 0, 0, 0, 0, 0
				, false, false, false, false, 0, null
			);
			node.dispatchEvent(event);
		}
		, webkit_req_fs = view.webkitRequestFileSystem
		, req_fs = view.requestFileSystem || webkit_req_fs || view.mozRequestFileSystem
		, throw_outside = function (ex) {
			(view.setImmediate || view.setTimeout)(function() {
				throw ex;
			}, 0);
		}
		, force_saveable_type = "application/octet-stream"
		, fs_min_size = 0
		, deletion_queue = []
		, process_deletion_queue = function() {
			var i = deletion_queue.length;
			while (i--) {
				var file = deletion_queue[i];
				if (typeof file === "string") { // file is an object URL
					URL.revokeObjectURL(file);
				} else { // file is a File
					file.remove();
				}
			}
			deletion_queue.length = 0; // clear queue
		}
		, dispatch = function(filesaver, event_types, event) {
			event_types = [].concat(event_types);
			var i = event_types.length;
			while (i--) {
				var listener = filesaver["on" + event_types[i]];
				if (typeof listener === "function") {
					try {
						listener.call(filesaver, event || filesaver);
					} catch (ex) {
						throw_outside(ex);
					}
				}
			}
		}
		, FileSaver = function(blob, name) {
			// First try a.download, then web filesystem, then object URLs
			var
				  filesaver = this
				, type = blob.type
				, blob_changed = false
				, object_url
				, target_view
				, get_object_url = function() {
					var object_url = get_URL().createObjectURL(blob);
					deletion_queue.push(object_url);
					return object_url;
				}
				, dispatch_all = function() {
					dispatch(filesaver, "writestart progress write writeend".split(" "));
				}
				// on any filesys errors revert to saving with object URLs
				, fs_error = function() {
					// don't create more object URLs than needed
					if (blob_changed || !object_url) {
						object_url = get_object_url(blob);
					}
					if (target_view) {
						target_view.location.href = object_url;
					} else {
                        window.open(object_url, "_blank");
                    }
					filesaver.readyState = filesaver.DONE;
					dispatch_all();
				}
				, abortable = function(func) {
					return function() {
						if (filesaver.readyState !== filesaver.DONE) {
							return func.apply(this, arguments);
						}
					};
				}
				, create_if_not_found = {create: true, exclusive: false}
				, slice
			;
			filesaver.readyState = filesaver.INIT;
			if (!name) {
				name = "download";
			}
			if (can_use_save_link) {
				object_url = get_object_url(blob);
				// FF for Android has a nasty garbage collection mechanism
				// that turns all objects that are not pure javascript into 'deadObject'
				// this means `doc` and `save_link` are unusable and need to be recreated
				// `view` is usable though:
				doc = view.document;
				save_link = doc.createElementNS("http://www.w3.org/1999/xhtml", "a");
				save_link.href = object_url;
				save_link.download = name;
				var event = doc.createEvent("MouseEvents");
				event.initMouseEvent(
					"click", true, false, view, 0, 0, 0, 0, 0
					, false, false, false, false, 0, null
				);
				save_link.dispatchEvent(event);
				filesaver.readyState = filesaver.DONE;
				dispatch_all();
				return;
			}
			// Object and web filesystem URLs have a problem saving in Google Chrome when
			// viewed in a tab, so I force save with application/octet-stream
			// http://code.google.com/p/chromium/issues/detail?id=91158
			if (view.chrome && type && type !== force_saveable_type) {
				slice = blob.slice || blob.webkitSlice;
				blob = slice.call(blob, 0, blob.size, force_saveable_type);
				blob_changed = true;
			}
			// Since I can't be sure that the guessed media type will trigger a download
			// in WebKit, I append .download to the filename.
			// https://bugs.webkit.org/show_bug.cgi?id=65440
			if (webkit_req_fs && name !== "download") {
				name += ".download";
			}
			if (type === force_saveable_type || webkit_req_fs) {
				target_view = view;
			}
			if (!req_fs) {
				fs_error();
				return;
			}
			fs_min_size += blob.size;
			req_fs(view.TEMPORARY, fs_min_size, abortable(function(fs) {
				fs.root.getDirectory("saved", create_if_not_found, abortable(function(dir) {
					var save = function() {
						dir.getFile(name, create_if_not_found, abortable(function(file) {
							file.createWriter(abortable(function(writer) {
								writer.onwriteend = function(event) {
									target_view.location.href = file.toURL();
									deletion_queue.push(file);
									filesaver.readyState = filesaver.DONE;
									dispatch(filesaver, "writeend", event);
								};
								writer.onerror = function() {
									var error = writer.error;
									if (error.code !== error.ABORT_ERR) {
										fs_error();
									}
								};
								"writestart progress write abort".split(" ").forEach(function(event) {
									writer["on" + event] = filesaver["on" + event];
								});
								writer.write(blob);
								filesaver.abort = function() {
									writer.abort();
									filesaver.readyState = filesaver.DONE;
								};
								filesaver.readyState = filesaver.WRITING;
							}), fs_error);
						}), fs_error);
					};
					dir.getFile(name, {create: false}, abortable(function(file) {
						// delete file if it already exists
						file.remove();
						save();
					}), abortable(function(ex) {
						if (ex.code === ex.NOT_FOUND_ERR) {
							save();
						} else {
							fs_error();
						}
					}));
				}), fs_error);
			}), fs_error);
		}
		, FS_proto = FileSaver.prototype
		, saveAs = function(blob, name) {
			return new FileSaver(blob, name);
		}
	;
	FS_proto.abort = function() {
		var filesaver = this;
		filesaver.readyState = filesaver.DONE;
		dispatch(filesaver, "abort");
	};
	FS_proto.readyState = FS_proto.INIT = 0;
	FS_proto.WRITING = 1;
	FS_proto.DONE = 2;

	FS_proto.error =
	FS_proto.onwritestart =
	FS_proto.onprogress =
	FS_proto.onwrite =
	FS_proto.onabort =
	FS_proto.onerror =
	FS_proto.onwriteend =
		null;

	view.addEventListener("unload", process_deletion_queue, false);
	return saveAs;
}(this.self || this.window || this.content));
// `self` is undefined in Firefox for Android content script context
// while `this` is nsIContentFrameMessageManager
// with an attribute `content` that corresponds to the window

if (typeof module !== 'undefined') module.exports = saveAs;
}/// added by AmCharts to avoid old IE problems if this file is included

// @tag amchart
/** @preserve jsPDF 0.9.0rc2 ( ${buildDate} ${commitID} )
Copyright (c) 2010-2012 James Hall, james@snapshotmedia.co.uk, https://github.com/MrRio/jsPDF
Copyright (c) 2012 Willow Systems Corporation, willow-systems.com
MIT license.
*/

/*
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * ====================================================================
 */


/**
Creates new jsPDF document object instance
@class
@param orientation One of "portrait" or "landscape" (or shortcuts "p" (Default), "l")
@param unit Measurement unit to be used when coordinates are specified. One of "pt" (points), "mm" (Default), "cm", "in"
@param format One of 'a0', 'a1', 'a2', 'a3', 'a4' (Default) etc to 'a10', 'b0' to 'b10', 'c0' to 'c10', 'letter', 'government-letter', 'legal', 'junior-legal', 'ledger' or 'tabloid'
@returns {jsPDF}
@name jsPDF
*/
var jsPDF = (function () {
    'use strict';
    /*jslint browser:true, plusplus: true, bitwise: true, nomen: true */
    /*global document: false, btoa, atob, zpipe, Uint8Array, ArrayBuffer, Blob, saveAs, adler32cs, Deflater */

// this will run on <=IE9, possibly some niche browsers
// new webkit-based, FireFox, IE10 already have native version of this.
    if (typeof btoa === 'undefined') {
        window.btoa = function (data) {
        // DO NOT ADD UTF8 ENCODING CODE HERE!!!!

        // UTF8 encoding encodes bytes over char code 128
        // and, essentially, turns an 8-bit binary streams
        // (that base64 can deal with) into 7-bit binary streams.
        // (by default server does not know that and does not recode the data back to 8bit)
        // You destroy your data.

        // binary streams like jpeg image data etc, while stored in JavaScript strings,
        // (which are 16bit arrays) are in 8bit format already.
        // You do NOT need to char-encode that before base64 encoding.

        // if you, by act of fate
        // have string which has individual characters with code
        // above 255 (pure unicode chars), encode that BEFORE you base64 here.
        // you can use absolutely any approch there, as long as in the end,
        // base64 gets an 8bit (char codes 0 - 255) stream.
        // when you get it on the server after un-base64, you must
        // UNencode it too, to get back to 16, 32bit or whatever original bin stream.

        // Note, Yes, JavaScript strings are, in most cases UCS-2 -
        // 16-bit character arrays. This does not mean, however,
        // that you always have to UTF8 it before base64.
        // it means that if you have actual characters anywhere in
        // that string that have char code above 255, you need to
        // recode *entire* string from 16-bit (or 32bit) to 8-bit array.
        // You can do binary split to UTF16 (BE or LE)
        // you can do utf8, you can split the thing by hand and prepend BOM to it,
        // but whatever you do, make sure you mirror the opposite on
        // the server. If server does not expect to post-process un-base64
        // 8-bit binary stream, think very very hard about messing around with encoding.

        // so, long story short:
        // DO NOT ADD UTF8 ENCODING CODE HERE!!!!

        /* @preserve
        ====================================================================
        base64 encoder
        MIT, GPL

        version: 1109.2015
        discuss at: http://phpjs.org/functions/base64_encode
        +   original by: Tyler Akins (http://rumkin.com)
        +   improved by: Bayron Guevara
        +   improved by: Thunder.m
        +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
        +   bugfixed by: Pellentesque Malesuada
        +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
        +   improved by: Rafal Kukawski (http://kukawski.pl)
        +                Daniel Dotsenko, Willow Systems Corp, willow-systems.com
        ====================================================================
        */

            var b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
                b64a = b64.split(''),
                o1,
                o2,
                o3,
                h1,
                h2,
                h3,
                h4,
                bits,
                i = 0,
                ac = 0,
                enc = "",
                tmp_arr = [],
                r;

            do { // pack three octets into four hexets
                o1 = data.charCodeAt(i++);
                o2 = data.charCodeAt(i++);
                o3 = data.charCodeAt(i++);

                bits = o1 << 16 | o2 << 8 | o3;

                h1 = bits >> 18 & 0x3f;
                h2 = bits >> 12 & 0x3f;
                h3 = bits >> 6 & 0x3f;
                h4 = bits & 0x3f;

                // use hexets to index into b64, and append result to encoded string
                tmp_arr[ac++] = b64a[h1] + b64a[h2] + b64a[h3] + b64a[h4];
            } while (i < data.length);

            enc = tmp_arr.join('');
            r = data.length % 3;
            return (r ? enc.slice(0, r - 3) : enc) + '==='.slice(r || 3);
            // end of base64 encoder MIT, GPL
        };
    }

    if (typeof atob === 'undefined') {
        window.atob = function (data) {
        // http://kevin.vanzonneveld.net
        // +   original by: Tyler Akins (http://rumkin.com)
        // +   improved by: Thunder.m
        // +      input by: Aman Gupta
        // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
        // +   bugfixed by: Onno Marsman
        // +   bugfixed by: Pellentesque Malesuada
        // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
        // +      input by: Brett Zamir (http://brett-zamir.me)
        // +   bugfixed by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
        // *     example 1: base64_decode('S2V2aW4gdmFuIFpvbm5ldmVsZA==');
        // *     returns 1: 'Kevin van Zonneveld'
        // mozilla has this native
        // - but breaks in 2.0.0.12!
        //if (typeof this.window['atob'] == 'function') {
        //    return atob(data);
        //}
            var b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
                o1,
                o2,
                o3,
                h1,
                h2,
                h3,
                h4,
                bits,
                i = 0,
                ac = 0,
                dec = "",
                tmp_arr = [];

            if (!data) {
                return data;
            }

            data += '';

            do { // unpack four hexets into three octets using index points in b64
                h1 = b64.indexOf(data.charAt(i++));
                h2 = b64.indexOf(data.charAt(i++));
                h3 = b64.indexOf(data.charAt(i++));
                h4 = b64.indexOf(data.charAt(i++));

                bits = h1 << 18 | h2 << 12 | h3 << 6 | h4;

                o1 = bits >> 16 & 0xff;
                o2 = bits >> 8 & 0xff;
                o3 = bits & 0xff;

                if (h3 === 64) {
                    tmp_arr[ac++] = String.fromCharCode(o1);
                } else if (h4 === 64) {
                    tmp_arr[ac++] = String.fromCharCode(o1, o2);
                } else {
                    tmp_arr[ac++] = String.fromCharCode(o1, o2, o3);
                }
            } while (i < data.length);
            dec = tmp_arr.join('');
            return dec;
        };
    }

    var getObjectLength = typeof Object.keys === 'function' ?
                function (object) {
                    return Object.keys(object).length;
                } :
                function (object) {
                    var i = 0, e;
                    for (e in object) {
                        if (object.hasOwnProperty(e)) {
                            i++;
                        }
                    }
                    return i;
                },

/**
PubSub implementation

@class
@name PubSub
*/
        PubSub = function (context) {
            /**  @preserve
            -----------------------------------------------------------------------------------------------
            JavaScript PubSub library
            2012 (c) ddotsenko@willowsystems.com
            based on Peter Higgins (dante@dojotoolkit.org)
            Loosely based on Dojo publish/subscribe API, limited in scope. Rewritten blindly.
            Original is (c) Dojo Foundation 2004-2010. Released under either AFL or new BSD, see:
            http://dojofoundation.org/license for more information.
            -----------------------------------------------------------------------------------------------
            */
            /**
            @private
            @fieldOf PubSub
            */
            this.topics = {};
            /**
            Stores what will be `this` within the callback functions.

            @private
            @fieldOf PubSub#
            */
            this.context = context;
            /**
            Allows caller to emit an event and pass arguments to event listeners.
            @public
            @function
            @param topic {String} Name of the channel on which to voice this event
            @param args Any number of arguments you want to pass to the listeners of this event.
            @methodOf PubSub#
            @name publish
            */
            this.publish = function (topic, args) {
                if (this.topics[topic]) {
                    var currentTopic = this.topics[topic],
                        toremove = [],
                        fn,
                        i,
                        l,
                        pair,
                        emptyFunc = function () {};
                    args = Array.prototype.slice.call(arguments, 1);
                    for (i = 0, l = currentTopic.length; i < l; i++) {
                        pair = currentTopic[i]; // this is a [function, once_flag] array
                        fn = pair[0];
                        if (pair[1]) { /* 'run once' flag set */
                            pair[0] = emptyFunc;
                            toremove.push(i);
                        }
                        fn.apply(this.context, args);
                    }
                    for (i = 0, l = toremove.length; i < l; i++) {
                        currentTopic.splice(toremove[i], 1);
                    }
                }
            };
            /**
            Allows listener code to subscribe to channel and be called when data is available
            @public
            @function
            @param topic {String} Name of the channel on which to voice this event
            @param callback {Function} Executable (function pointer) that will be ran when event is voiced on this channel.
            @param once {Boolean} (optional. False by default) Flag indicating if the function is to be triggered only once.
            @returns {Object} A token object that cen be used for unsubscribing.
            @methodOf PubSub#
            @name subscribe
            */
            this.subscribe = function (topic, callback, once) {
                if (!this.topics[topic]) {
                    this.topics[topic] = [[callback, once]];
                } else {
                    this.topics[topic].push([callback, once]);
                }
                return {
                    "topic": topic,
                    "callback": callback
                };
            };
            /**
            Allows listener code to unsubscribe from a channel
            @public
            @function
            @param token {Object} A token object that was returned by `subscribe` method
            @methodOf PubSub#
            @name unsubscribe
            */
            this.unsubscribe = function (token) {
                if (this.topics[token.topic]) {
                    var currentTopic = this.topics[token.topic], i, l;

                    for (i = 0, l = currentTopic.length; i < l; i++) {
                        if (currentTopic[i][0] === token.callback) {
                            currentTopic.splice(i, 1);
                        }
                    }
                }
            };
        };


/**
@constructor
@private
*/
    function jsPDF(orientation, unit, format, compressPdf) { /** String orientation, String unit, String format, Boolean compressed */

        // Default parameter values
        if (typeof orientation === 'undefined') {
            orientation = 'p';
        } else {
            orientation = orientation.toString().toLowerCase();
        }
        if (typeof unit === 'undefined') { unit = 'mm'; }
        if (typeof format === 'undefined') { format = 'a4'; }
        if (typeof compressPdf === 'undefined' && typeof zpipe === 'undefined') { compressPdf = false; }

        var format_as_string = format.toString().toLowerCase(),
            version = '0.9.0rc2',
            content = [],
            content_length = 0,
            compress = compressPdf,
            pdfVersion = '1.3', // PDF Version
            pageFormats = { // Size in pt of various paper formats
                'a0': [2383.94, 3370.39],
                'a1': [1683.78, 2383.94],
                'a2': [1190.55, 1683.78],
                'a3': [841.89,  1190.55],
                'a4': [595.28,  841.89],
                'a5': [419.53,  595.28],
                'a6': [297.64,  419.53],
                'a7': [209.76,  297.64],
                'a8': [147.4 ,  209.76],
                'a9': [104.88,  147.4],
                'a10': [73.7,  104.88],
                'b0': [2834.65, 4008.19],
                'b1': [2004.09, 2834.65],
                'b2': [1417.32, 2004.09],
                'b3': [1000.63, 1417.32],
                'b4': [708.66,  1000.63],
                'b5': [498.9,  708.66],
                'b6': [354.33,  498.9],
                'b7': [249.45,  354.33],
                'b8': [175.75,  249.45],
                'b9': [124.72,  175.75],
                'b10': [87.87,  124.72],
                'c0': [2599.37, 3676.54],
                'c1': [1836.85, 2599.37],
                'c2': [1298.27, 1836.85],
                'c3': [918.43,  1298.27],
                'c4': [649.13,  918.43],
                'c5': [459.21,  649.13],
                'c6': [323.15,  459.21],
                'c7': [229.61,  323.15],
                'c8': [161.57,  229.61],
                'c9': [113.39,  161.57],
                'c10': [79.37,   113.39],
                'letter': [612, 792],
                'government-letter': [576, 756],
                'legal': [612, 1008],
                'junior-legal': [576, 360],
                'ledger': [1224, 792],
                'tabloid': [792, 1224]
            },
            textColor = '0 g',
            drawColor = '0 G',
            page = 0,
            pages = [],
            objectNumber = 2, // 'n' Current object number
            outToPages = false, // switches where out() prints. outToPages true = push to pages obj. outToPages false = doc builder content
            offsets = [], // List of offsets. Activated and reset by buildDocument(). Pupulated by various calls buildDocument makes.
            fonts = {}, // collection of font objects, where key is fontKey - a dynamically created label for a given font.
            fontmap = {}, // mapping structure fontName > fontStyle > font key - performance layer. See addFont()
            activeFontSize = 16,
            activeFontKey, // will be string representing the KEY of the font as combination of fontName + fontStyle
            lineWidth = 0.200025, // 2mm
            lineHeightProportion = 1.15,
            pageHeight,
            pageWidth,
            k, // Scale factor
            documentProperties = {'title': '', 'subject': '', 'author': '', 'keywords': '', 'creator': ''},
            lineCapID = 0,
            lineJoinID = 0,
            API = {},
            events = new PubSub(API),
            tmp,
            plugin,
            /////////////////////
            // Private functions
            /////////////////////
            // simplified (speedier) replacement for sprintf's %.2f conversion
            f2 = function (number) {
                return number.toFixed(2);
            },
            // simplified (speedier) replacement for sprintf's %.3f conversion
            f3 = function (number) {
                return number.toFixed(3);
            },
            // simplified (speedier) replacement for sprintf's %02d
            padd2 = function (number) {
                var n = (number).toFixed(0);
                if (number < 10) {
                    return '0' + n;
                } else {
                    return n;
                }
            },
            // simplified (speedier) replacement for sprintf's %02d
            padd10 = function (number) {
                var n = (number).toFixed(0);
                if (n.length < 10) {
                    return new Array( 11 - n.length ).join('0') + n;
                } else {
                    return n;
                }
            },
            out = function (string) {
                if (outToPages) { /* set by beginPage */
                    pages[page].push(string);
                } else {
                    content.push(string);
                    content_length += string.length + 1; // +1 is for '\n' that will be used to join contents of content
                }
            },
            newObject = function () {
                // Begin a new object
                objectNumber++;
                offsets[objectNumber] = content_length;
                out(objectNumber + ' 0 obj');
                return objectNumber;
            },
            putStream = function (str) {
                out('stream');
                out(str);
                out('endstream');
            },
            wPt,
            hPt,
            kids,
            i,
            putPages = function () {
                wPt = pageWidth * k;
                hPt = pageHeight * k;

                // outToPages = false as set in endDocument(). out() writes to content.

                var n, p, arr, uint, i, deflater, adler32;
                for (n = 1; n <= page; n++) {
                    newObject();
                    out('<</Type /Page');
                    out('/Parent 1 0 R');
                    out('/Resources 2 0 R');
                    out('/Contents ' + (objectNumber + 1) + ' 0 R>>');
                    out('endobj');

                    // Page content
                    p = pages[n].join('\n');
                    newObject();
                    if (compress) {
                        arr = [];
                        for (i = 0; i < p.length; ++i) {
                            arr[i] = p.charCodeAt(i);
                        }
                        adler32 = adler32cs.from(p);
                        deflater = new Deflater(6);
                        deflater.append(new Uint8Array(arr));
                        p = deflater.flush();
                        arr = [new Uint8Array([120, 156]), new Uint8Array(p),
                               new Uint8Array([adler32 & 0xFF, (adler32 >> 8) & 0xFF, (adler32 >> 16) & 0xFF, (adler32 >> 24) & 0xFF])];
                        p = '';
                        for (i in arr) {
                            if (arr.hasOwnProperty(i)) {
                                p += String.fromCharCode.apply(null, arr[i]);
                            }
                        }
                        out('<</Length ' + p.length  + ' /Filter [/FlateDecode]>>');
                    } else {
                        out('<</Length ' + p.length  + '>>');
                    }
                    putStream(p);
                    out('endobj');
                }
                offsets[1] = content_length;
                out('1 0 obj');
                out('<</Type /Pages');
                kids = '/Kids [';
                for (i = 0; i < page; i++) {
                    kids += (3 + 2 * i) + ' 0 R ';
                }
                out(kids + ']');
                out('/Count ' + page);
                out('/MediaBox [0 0 ' + f2(wPt) + ' ' + f2(hPt) + ']');
                out('>>');
                out('endobj');
            },
            putFont = function (font) {
                font.objectNumber = newObject();
                out('<</BaseFont/' + font.PostScriptName + '/Type/Font');
                if (typeof font.encoding === 'string') {
                    out('/Encoding/' + font.encoding);
                }
                out('/Subtype/Type1>>');
                out('endobj');
            },
            putFonts = function () {
                var fontKey;
                for (fontKey in fonts) {
                    if (fonts.hasOwnProperty(fontKey)) {
                        putFont(fonts[fontKey]);
                    }
                }
            },
            putXobjectDict = function () {
                // Loop through images, or other data objects
                events.publish('putXobjectDict');
            },
            putResourceDictionary = function () {
                out('/ProcSet [/PDF /Text /ImageB /ImageC /ImageI]');
                out('/Font <<');
                // Do this for each font, the '1' bit is the index of the font
                var fontKey;
                for (fontKey in fonts) {
                    if (fonts.hasOwnProperty(fontKey)) {
                        out('/' + fontKey + ' ' + fonts[fontKey].objectNumber + ' 0 R');
                    }
                }
                out('>>');
                out('/XObject <<');
                putXobjectDict();
                out('>>');
            },
            putResources = function () {
                putFonts();
                events.publish('putResources');
                // Resource dictionary
                offsets[2] = content_length;
                out('2 0 obj');
                out('<<');
                putResourceDictionary();
                out('>>');
                out('endobj');
                events.publish('postPutResources');
            },
            addToFontDictionary = function (fontKey, fontName, fontStyle) {
                // this is mapping structure for quick font key lookup.
                // returns the KEY of the font (ex: "F1") for a given pair of font name and type (ex: "Arial". "Italic")
                var undef;
                if (fontmap[fontName] === undef) {
                    fontmap[fontName] = {}; // fontStyle is a var interpreted and converted to appropriate string. don't wrap in quotes.
                }
                fontmap[fontName][fontStyle] = fontKey;
            },
            /**
            FontObject describes a particular font as member of an instnace of jsPDF

            It's a collection of properties like 'id' (to be used in PDF stream),
            'fontName' (font's family name), 'fontStyle' (font's style variant label)

            @class
            @public
            @property id {String} PDF-document-instance-specific label assinged to the font.
            @property PostScriptName {String} PDF specification full name for the font
            @property encoding {Object} Encoding_name-to-Font_metrics_object mapping.
            @name FontObject
            */
            FontObject = {},
            addFont = function (PostScriptName, fontName, fontStyle, encoding) {
                var fontKey = 'F' + (getObjectLength(fonts) + 1).toString(10),
                    // This is FontObject
                    font = fonts[fontKey] = {
                        'id': fontKey,
                        // , 'objectNumber':   will be set by putFont()
                        'PostScriptName': PostScriptName,
                        'fontName': fontName,
                        'fontStyle': fontStyle,
                        'encoding': encoding,
                        'metadata': {}
                    };

                addToFontDictionary(fontKey, fontName, fontStyle);

                events.publish('addFont', font);

                return fontKey;
            },
            addFonts = function () {

                var HELVETICA = "helvetica",
                    TIMES = "times",
                    COURIER = "courier",
                    NORMAL = "normal",
                    BOLD = "bold",
                    ITALIC = "italic",
                    BOLD_ITALIC = "bolditalic",
                    encoding = 'StandardEncoding',
                    standardFonts = [
                        ['Helvetica', HELVETICA, NORMAL],
                        ['Helvetica-Bold', HELVETICA, BOLD],
                        ['Helvetica-Oblique', HELVETICA, ITALIC],
                        ['Helvetica-BoldOblique', HELVETICA, BOLD_ITALIC],
                        ['Courier', COURIER, NORMAL],
                        ['Courier-Bold', COURIER, BOLD],
                        ['Courier-Oblique', COURIER, ITALIC],
                        ['Courier-BoldOblique', COURIER, BOLD_ITALIC],
                        ['Times-Roman', TIMES, NORMAL],
                        ['Times-Bold', TIMES, BOLD],
                        ['Times-Italic', TIMES, ITALIC],
                        ['Times-BoldItalic', TIMES, BOLD_ITALIC]
                    ],
                    i,
                    l,
                    fontKey,
                    parts;
                for (i = 0, l = standardFonts.length; i < l; i++) {
                    fontKey = addFont(
                        standardFonts[i][0],
                        standardFonts[i][1],
                        standardFonts[i][2],
                        encoding
                    );

                    // adding aliases for standard fonts, this time matching the capitalization
                    parts = standardFonts[i][0].split('-');
                    addToFontDictionary(fontKey, parts[0], parts[1] || '');
                }

                events.publish('addFonts', {'fonts': fonts, 'dictionary': fontmap});
            },
            /**

            @public
            @function
            @param text {String}
            @param flags {Object} Encoding flags.
            @returns {String} Encoded string
            */
            to8bitStream = function (text, flags) {
                /* PDF 1.3 spec:
                "For text strings encoded in Unicode, the first two bytes must be 254 followed by
                255, representing the Unicode byte order marker, U+FEFF. (This sequence conflicts
                with the PDFDocEncoding character sequence thorn ydieresis, which is unlikely
                to be a meaningful beginning of a word or phrase.) The remainder of the
                string consists of Unicode character codes, according to the UTF-16 encoding
                specified in the Unicode standard, version 2.0. Commonly used Unicode values
                are represented as 2 bytes per character, with the high-order byte appearing first
                in the string."

                In other words, if there are chars in a string with char code above 255, we
                recode the string to UCS2 BE - string doubles in length and BOM is prepended.

                HOWEVER!
                Actual *content* (body) text (as opposed to strings used in document properties etc)
                does NOT expect BOM. There, it is treated as a literal GID (Glyph ID)

                Because of Adobe's focus on "you subset your fonts!" you are not supposed to have
                a font that maps directly Unicode (UCS2 / UTF16BE) code to font GID, but you could
                fudge it with "Identity-H" encoding and custom CIDtoGID map that mimics Unicode
                code page. There, however, all characters in the stream are treated as GIDs,
                including BOM, which is the reason we need to skip BOM in content text (i.e. that
                that is tied to a font).

                To signal this "special" PDFEscape / to8bitStream handling mode,
                API.text() function sets (unless you overwrite it with manual values
                given to API.text(.., flags) )
                    flags.autoencode = true
                    flags.noBOM = true

                */

                /*
                `flags` properties relied upon:
                .sourceEncoding = string with encoding label.
                    "Unicode" by default. = encoding of the incoming text.
                    pass some non-existing encoding name
                    (ex: 'Do not touch my strings! I know what I am doing.')
                    to make encoding code skip the encoding step.
                .outputEncoding = Either valid PDF encoding name
                    (must be supported by jsPDF font metrics, otherwise no encoding)
                    or a JS object, where key = sourceCharCode, value = outputCharCode
                    missing keys will be treated as: sourceCharCode === outputCharCode
                .noBOM
                    See comment higher above for explanation for why this is important
                .autoencode
                    See comment higher above for explanation for why this is important
                */

                var i, l, undef, sourceEncoding, encodingBlock, outputEncoding, newtext, isUnicode, ch, bch;

                if (flags === undef) {
                    flags = {};
                }

                sourceEncoding = flags.sourceEncoding ? sourceEncoding : 'Unicode';

                outputEncoding = flags.outputEncoding;

                // This 'encoding' section relies on font metrics format
                // attached to font objects by, among others,
                // "Willow Systems' standard_font_metrics plugin"
                // see jspdf.plugin.standard_font_metrics.js for format
                // of the font.metadata.encoding Object.
                // It should be something like
                //   .encoding = {'codePages':['WinANSI....'], 'WinANSI...':{code:code, ...}}
                //   .widths = {0:width, code:width, ..., 'fof':divisor}
                //   .kerning = {code:{previous_char_code:shift, ..., 'fof':-divisor},...}
                if ((flags.autoencode || outputEncoding) &&
                        fonts[activeFontKey].metadata &&
                        fonts[activeFontKey].metadata[sourceEncoding] &&
                        fonts[activeFontKey].metadata[sourceEncoding].encoding
                        ) {
                    encodingBlock = fonts[activeFontKey].metadata[sourceEncoding].encoding;

                    // each font has default encoding. Some have it clearly defined.
                    if (!outputEncoding && fonts[activeFontKey].encoding) {
                        outputEncoding = fonts[activeFontKey].encoding;
                    }

                    // Hmmm, the above did not work? Let's try again, in different place.
                    if (!outputEncoding && encodingBlock.codePages) {
                        outputEncoding = encodingBlock.codePages[0]; // let's say, first one is the default
                    }

                    if (typeof outputEncoding === 'string') {
                        outputEncoding = encodingBlock[outputEncoding];
                    }
                    // we want output encoding to be a JS Object, where
                    // key = sourceEncoding's character code and
                    // value = outputEncoding's character code.
                    if (outputEncoding) {
                        isUnicode = false;
                        newtext = [];
                        for (i = 0, l = text.length; i < l; i++) {
                            ch = outputEncoding[text.charCodeAt(i)];
                            if (ch) {
                                newtext.push(
                                    String.fromCharCode(ch)
                                );
                            } else {
                                newtext.push(
                                    text[i]
                                );
                            }

                            // since we are looping over chars anyway, might as well
                            // check for residual unicodeness
                            if (newtext[i].charCodeAt(0) >> 8) { /* more than 255 */
                                isUnicode = true;
                            }
                        }
                        text = newtext.join('');
                    }
                }

                i = text.length;
                // isUnicode may be set to false above. Hence the triple-equal to undefined
                while (isUnicode === undef && i !== 0) {
                    if (text.charCodeAt(i - 1) >> 8) { /* more than 255 */
                        isUnicode = true;
                    }
                    i--;
                }
                if (!isUnicode) {
                    return text;
                } else {
                    newtext = flags.noBOM ? [] : [254, 255];
                    for (i = 0, l = text.length; i < l; i++) {
                        ch = text.charCodeAt(i);
                        bch = ch >> 8; // divide by 256
                        if (bch >> 8) { /* something left after dividing by 256 second time */
                            throw new Error("Character at position " + i.toString(10) + " of string '" + text + "' exceeds 16bits. Cannot be encoded into UCS-2 BE");
                        }
                        newtext.push(bch);
                        newtext.push(ch - (bch << 8));
                    }
                    return String.fromCharCode.apply(undef, newtext);
                }
            },
            // Replace '/', '(', and ')' with pdf-safe versions
            pdfEscape = function (text, flags) {
                // doing to8bitStream does NOT make this PDF display unicode text. For that
                // we also need to reference a unicode font and embed it - royal pain in the rear.

                // There is still a benefit to to8bitStream - PDF simply cannot handle 16bit chars,
                // which JavaScript Strings are happy to provide. So, while we still cannot display
                // 2-byte characters property, at least CONDITIONALLY converting (entire string containing)
                // 16bit chars to (USC-2-BE) 2-bytes per char + BOM streams we ensure that entire PDF
                // is still parseable.
                // This will allow immediate support for unicode in document properties strings.
                return to8bitStream(text, flags).replace(/\\/g, '\\\\').replace(/\(/g, '\\(').replace(/\)/g, '\\)');
            },
            putInfo = function () {
                out('/Producer (jsPDF ' + version + ')');
                if (documentProperties.title) {
                    out('/Title (' + pdfEscape(documentProperties.title) + ')');
                }
                if (documentProperties.subject) {
                    out('/Subject (' + pdfEscape(documentProperties.subject) + ')');
                }
                if (documentProperties.author) {
                    out('/Author (' + pdfEscape(documentProperties.author) + ')');
                }
                if (documentProperties.keywords) {
                    out('/Keywords (' + pdfEscape(documentProperties.keywords) + ')');
                }
                if (documentProperties.creator) {
                    out('/Creator (' + pdfEscape(documentProperties.creator) + ')');
                }
                var created = new Date();
                out('/CreationDate (D:' +
                    [
                        created.getFullYear(),
                        padd2(created.getMonth() + 1),
                        padd2(created.getDate()),
                        padd2(created.getHours()),
                        padd2(created.getMinutes()),
                        padd2(created.getSeconds())
                    ].join('') +
                    ')'
                    );
            },
            putCatalog = function () {
                out('/Type /Catalog');
                out('/Pages 1 0 R');
                // @TODO: Add zoom and layout modes
                out('/OpenAction [3 0 R /FitH null]');
                out('/PageLayout /OneColumn');
                events.publish('putCatalog');
            },
            putTrailer = function () {
                out('/Size ' + (objectNumber + 1));
                out('/Root ' + objectNumber + ' 0 R');
                out('/Info ' + (objectNumber - 1) + ' 0 R');
            },
            beginPage = function () {
                page++;
                // Do dimension stuff
                outToPages = true;
                pages[page] = [];
            },
            _addPage = function () {
                beginPage();
                // Set line width
                out(f2(lineWidth * k) + ' w');
                // Set draw color
                out(drawColor);
                // resurrecting non-default line caps, joins
                if (lineCapID !== 0) {
                    out(lineCapID.toString(10) + ' J');
                }
                if (lineJoinID !== 0) {
                    out(lineJoinID.toString(10) + ' j');
                }
                events.publish('addPage', {'pageNumber': page});
            },
            /**
            Returns a document-specific font key - a label assigned to a
            font name + font type combination at the time the font was added
            to the font inventory.

            Font key is used as label for the desired font for a block of text
            to be added to the PDF document stream.
            @private
            @function
            @param fontName {String} can be undefined on "falthy" to indicate "use current"
            @param fontStyle {String} can be undefined on "falthy" to indicate "use current"
            @returns {String} Font key.
            */
            getFont = function (fontName, fontStyle) {
                var key, undef;

                if (fontName === undef) {
                    fontName = fonts[activeFontKey].fontName;
                }
                if (fontStyle === undef) {
                    fontStyle = fonts[activeFontKey].fontStyle;
                }

                try {
                    key = fontmap[fontName][fontStyle]; // returns a string like 'F3' - the KEY corresponding tot he font + type combination.
                } catch (e) {
                    key = undef;
                }
                if (!key) {
                    throw new Error("Unable to look up font label for font '" + fontName + "', '" + fontStyle + "'. Refer to getFontList() for available fonts.");
                }

                return key;
            },
            buildDocument = function () {

                outToPages = false; // switches out() to content
                content = [];
                offsets = [];

                // putHeader()
                out('%PDF-' + pdfVersion);

                putPages();

                putResources();

                // Info
                newObject();
                out('<<');
                putInfo();
                out('>>');
                out('endobj');

                // Catalog
                newObject();
                out('<<');
                putCatalog();
                out('>>');
                out('endobj');

                // Cross-ref
                var o = content_length, i;
                out('xref');
                out('0 ' + (objectNumber + 1));
                out('0000000000 65535 f ');
                for (i = 1; i <= objectNumber; i++) {
                    out(padd10(offsets[i]) + ' 00000 n ');
                }
                // Trailer
                out('trailer');
                out('<<');
                putTrailer();
                out('>>');
                out('startxref');
                out(o);
                out('%%EOF');

                outToPages = true;

                return content.join('\n');
            },
            getStyle = function (style) {
                // see Path-Painting Operators of PDF spec
                var op = 'S'; // stroke
                if (style === 'F') {
                    op = 'f'; // fill
                } else if (style === 'FD' || style === 'DF') {
                    op = 'B'; // both
                }
                return op;
            },

            /**
            Generates the PDF document.
            Possible values:
                datauristring (alias dataurlstring) - Data-Url-formatted data returned as string.
                datauri (alias datauri) - Data-Url-formatted data pushed into current window's location (effectively reloading the window with contents of the PDF).

            If `type` argument is undefined, output is raw body of resulting PDF returned as a string.

            @param {String} type A string identifying one of the possible output types.
            @param {Object} options An object providing some additional signalling to PDF generator.
            @function
            @returns {jsPDF}
            @methodOf jsPDF#
            @name output
            */
            output = function (type, options) {
                var undef, data, length, array, i, blob;
                switch (type) {
                case undef:
                    return buildDocument();
                case 'save':
                    if (navigator.getUserMedia) {
                        if (window.URL === undefined) {
                            return API.output('dataurlnewwindow');
                        } else if (window.URL.createObjectURL === undefined) {
                            return API.output('dataurlnewwindow');
                        }
                    }
                    data = buildDocument();

                    // Need to add the file to BlobBuilder as a Uint8Array
                    length = data.length;
                    array = new Uint8Array(new ArrayBuffer(length));

                    for (i = 0; i < length; i++) {
                        array[i] = data.charCodeAt(i);
                    }

                    blob = new Blob([array], {type: "application/pdf"});

                    saveAs(blob, options);
                    break;
                case 'datauristring':
                case 'dataurlstring':
                    return 'data:application/pdf;base64,' + btoa(buildDocument());
                case 'datauri':
                case 'dataurl':
                    document.location.href = 'data:application/pdf;base64,' + btoa(buildDocument());
                    break;
                case 'dataurlnewwindow':
                    window.open('data:application/pdf;base64,' + btoa(buildDocument()));
                    break;
                default:
                    throw new Error('Output type "' + type + '" is not supported.');
                }
                // @TODO: Add different output options
            };

        if (unit === 'pt') {
            k = 1;
        } else if (unit === 'mm') {
            k = 72 / 25.4;
        } else if (unit === 'cm') {
            k = 72 / 2.54;
        } else if (unit === 'in') {
            k = 72;
        } else {
            throw ('Invalid unit: ' + unit);
        }

        // Dimensions are stored as user units and converted to points on output
        if (pageFormats.hasOwnProperty(format_as_string)) {
            pageHeight = pageFormats[format_as_string][1] / k;
            pageWidth = pageFormats[format_as_string][0] / k;
        } else {
            try {
                pageHeight = format[1];
                pageWidth = format[0];
            } catch (err) {
                throw ('Invalid format: ' + format);
            }
        }

        if (orientation === 'p' || orientation === 'portrait') {
            orientation = 'p';
            if (pageWidth > pageHeight) {
                tmp = pageWidth;
                pageWidth = pageHeight;
                pageHeight = tmp;
            }
        } else if (orientation === 'l' || orientation === 'landscape') {
            orientation = 'l';
            if (pageHeight > pageWidth) {
                tmp = pageWidth;
                pageWidth = pageHeight;
                pageHeight = tmp;
            }
        } else {
            throw ('Invalid orientation: ' + orientation);
        }



        //---------------------------------------
        // Public API

        /*
        Object exposing internal API to plugins
        @public
        */
        API.internal = {
            'pdfEscape': pdfEscape,
            'getStyle': getStyle,
            /**
            Returns {FontObject} describing a particular font.
            @public
            @function
            @param fontName {String} (Optional) Font's family name
            @param fontStyle {String} (Optional) Font's style variation name (Example:"Italic")
            @returns {FontObject}
            */
            'getFont': function () { return fonts[getFont.apply(API, arguments)]; },
            'getFontSize': function () { return activeFontSize;    },
            'getLineHeight': function () { return activeFontSize * lineHeightProportion;    },
            'btoa': btoa,
            'write': function (string1, string2, string3, etc) {
                out(
                    arguments.length === 1 ? string1 : Array.prototype.join.call(arguments, ' ')
                );
            },
            'getCoordinateString': function (value) {
                return f2(value * k);
            },
            'getVerticalCoordinateString': function (value) {
                return f2((pageHeight - value) * k);
            },
            'collections': {},
            'newObject': newObject,
            'putStream': putStream,
            'events': events,
            // ratio that you use in multiplication of a given "size" number to arrive to 'point'
            // units of measurement.
            // scaleFactor is set at initialization of the document and calculated against the stated
            // default measurement units for the document.
            // If default is "mm", k is the number that will turn number in 'mm' into 'points' number.
            // through multiplication.
            'scaleFactor': k,
            'pageSize': {'width': pageWidth, 'height': pageHeight},
            'output': function (type, options) {
                return output(type, options);
            },
            'getNumberOfPages': function () {return pages.length - 1; },
            'pages': pages
        };

        /**
        Adds (and transfers the focus to) new page to the PDF document.
        @function
        @returns {jsPDF}

        @methodOf jsPDF#
        @name addPage
         */
        API.addPage = function () {
            _addPage();
            return this;
        };

        /**
        Adds text to page. Supports adding multiline text when 'text' argument is an Array of Strings.
        @function
        @param {String|Array} text String or array of strings to be added to the page. Each line is shifted one line down per font, spacing settings declared before this call.
        @param {Number} x Coordinate (in units declared at inception of PDF document) against left edge of the page
        @param {Number} y Coordinate (in units declared at inception of PDF document) against upper edge of the page
        @param {Object} flags Collection of settings signalling how the text must be encoded. Defaults are sane. If you think you want to pass some flags, you likely can read the source.
        @returns {jsPDF}
        @methodOf jsPDF#
        @name text
         */
        API.text = function (text, x, y, flags) {
            /**
             * Inserts something like this into PDF
                BT
                /F1 16 Tf  % Font name + size
                16 TL % How many units down for next line in multiline text
                0 g % color
                28.35 813.54 Td % position
                (line one) Tj
                T* (line two) Tj
                T* (line three) Tj
                ET
            */

            var undef, _first, _second, _third, newtext, str, i;
            // Pre-August-2012 the order of arguments was function(x, y, text, flags)
            // in effort to make all calls have similar signature like
            //   function(data, coordinates... , miscellaneous)
            // this method had its args flipped.
            // code below allows backward compatibility with old arg order.
            if (typeof text === 'number') {
                _first = y;
                _second = text;
                _third = x;

                text = _first;
                x = _second;
                y = _third;
            }

            // If there are any newlines in text, we assume
            // the user wanted to print multiple lines, so break the
            // text up into an array.  If the text is already an array,
            // we assume the user knows what they are doing.
            if (typeof text === 'string' && text.match(/[\n\r]/)) {
                text = text.split(/\r\n|\r|\n/g);
            }

            if (typeof flags === 'undefined') {
                flags = {'noBOM': true, 'autoencode': true};
            } else {

                if (flags.noBOM === undef) {
                    flags.noBOM = true;
                }

                if (flags.autoencode === undef) {
                    flags.autoencode = true;
                }

            }

            if (typeof text === 'string') {
                str = pdfEscape(text, flags);
            } else if (text instanceof Array) {  /* Array */
                // we don't want to destroy  original text array, so cloning it
                newtext = text.concat();
                // we do array.join('text that must not be PDFescaped")
                // thus, pdfEscape each component separately
                for (i = newtext.length - 1; i !== -1; i--) {
                    newtext[i] = pdfEscape(newtext[i], flags);
                }
                str = newtext.join(") Tj\nT* (");
            } else {
                throw new Error('Type of text must be string or Array. "' + text + '" is not recognized.');
            }
            // Using "'" ("go next line and render text" mark) would save space but would complicate our rendering code, templates

            // BT .. ET does NOT have default settings for Tf. You must state that explicitely every time for BT .. ET
            // if you want text transformation matrix (+ multiline) to work reliably (which reads sizes of things from font declarations)
            // Thus, there is NO useful, *reliable* concept of "default" font for a page.
            // The fact that "default" (reuse font used before) font worked before in basic cases is an accident
            // - readers dealing smartly with brokenness of jsPDF's markup.
            out(
                'BT\n/' +
                    activeFontKey + ' ' + activeFontSize + ' Tf\n' + // font face, style, size
                    (activeFontSize * lineHeightProportion) + ' TL\n' + // line spacing
                    textColor +
                    '\n' + f2(x * k) + ' ' + f2((pageHeight - y) * k) + ' Td\n(' +
                    str +
                    ') Tj\nET'
            );
            return this;
        };

        API.line = function (x1, y1, x2, y2) {
            out(
                f2(x1 * k) + ' ' + f2((pageHeight - y1) * k) + ' m ' +
                    f2(x2 * k) + ' ' + f2((pageHeight - y2) * k) + ' l S'
            );
            return this;
        };

        /**
        Adds series of curves (straight lines or cubic bezier curves) to canvas, starting at `x`, `y` coordinates.
        All data points in `lines` are relative to last line origin.
        `x`, `y` become x1,y1 for first line / curve in the set.
        For lines you only need to specify [x2, y2] - (ending point) vector against x1, y1 starting point.
        For bezier curves you need to specify [x2,y2,x3,y3,x4,y4] - vectors to control points 1, 2, ending point. All vectors are against the start of the curve - x1,y1.

        @example .lines([[2,2],[-2,2],[1,1,2,2,3,3],[2,1]], 212,110, 10) // line, line, bezier curve, line
        @param {Array} lines Array of *vector* shifts as pairs (lines) or sextets (cubic bezier curves).
        @param {Number} x Coordinate (in units declared at inception of PDF document) against left edge of the page
        @param {Number} y Coordinate (in units declared at inception of PDF document) against upper edge of the page
        @param {Number} scale (Defaults to [1.0,1.0]) x,y Scaling factor for all vectors. Elements can be any floating number Sub-one makes drawing smaller. Over-one grows the drawing. Negative flips the direction.
        @param {String} style One of 'S' (the default), 'F', 'FD' or 'DF'.  'S' draws just the curve. 'F' fills the region defined by the curves. 'DF' or 'FD' draws the curves and fills the region. 
        @param {Boolean} closed If true, the path is closed with a straight line from the end of the last curve to the starting point. 
        @function
        @returns {jsPDF}
        @methodOf jsPDF#
        @name lines
         */
        API.lines = function (lines, x, y, scale, style, closed) {
            var undef, _first, _second, _third, scalex, scaley, i, l, leg, x2, y2, x3, y3, x4, y4;

            // Pre-August-2012 the order of arguments was function(x, y, lines, scale, style)
            // in effort to make all calls have similar signature like
            //   function(content, coordinateX, coordinateY , miscellaneous)
            // this method had its args flipped.
            // code below allows backward compatibility with old arg order.
            if (typeof lines === 'number') {
                _first = y;
                _second = lines;
                _third = x;

                lines = _first;
                x = _second;
                y = _third;
            }

            style = getStyle(style);
            scale = scale === undef ? [1, 1] : scale;

            // starting point
            out(f3(x * k) + ' ' + f3((pageHeight - y) * k) + ' m ');

            scalex = scale[0];
            scaley = scale[1];
            l = lines.length;
            //, x2, y2 // bezier only. In page default measurement "units", *after* scaling
            //, x3, y3 // bezier only. In page default measurement "units", *after* scaling
            // ending point for all, lines and bezier. . In page default measurement "units", *after* scaling
            x4 = x; // last / ending point = starting point for first item.
            y4 = y; // last / ending point = starting point for first item.

            for (i = 0; i < l; i++) {
                leg = lines[i];
                if (leg.length === 2) {
                    // simple line
                    x4 = leg[0] * scalex + x4; // here last x4 was prior ending point
                    y4 = leg[1] * scaley + y4; // here last y4 was prior ending point
                    out(f3(x4 * k) + ' ' + f3((pageHeight - y4) * k) + ' l');
                } else {
                    // bezier curve
                    x2 = leg[0] * scalex + x4; // here last x4 is prior ending point
                    y2 = leg[1] * scaley + y4; // here last y4 is prior ending point
                    x3 = leg[2] * scalex + x4; // here last x4 is prior ending point
                    y3 = leg[3] * scaley + y4; // here last y4 is prior ending point
                    x4 = leg[4] * scalex + x4; // here last x4 was prior ending point
                    y4 = leg[5] * scaley + y4; // here last y4 was prior ending point
                    out(
                        f3(x2 * k) + ' ' +
                            f3((pageHeight - y2) * k) + ' ' +
                            f3(x3 * k) + ' ' +
                            f3((pageHeight - y3) * k) + ' ' +
                            f3(x4 * k) + ' ' +
                            f3((pageHeight - y4) * k) + ' c'
                    );
                }
            }

            if (closed == true) {
                out(' h');
            }

            // stroking / filling / both the path
            out(style);
            return this;
        };

        /**
        Adds a rectangle to PDF

        @param {Number} x Coordinate (in units declared at inception of PDF document) against left edge of the page
        @param {Number} y Coordinate (in units declared at inception of PDF document) against upper edge of the page
        @param {Number} w Width (in units declared at inception of PDF document)
        @param {Number} h Height (in units declared at inception of PDF document)
        @param {String} style (Defaults to active fill/stroke style) A string signalling if stroke, fill or both are to be applied.
        @function
        @returns {jsPDF}
        @methodOf jsPDF#
        @name rect
         */
        API.rect = function (x, y, w, h, style) {
            var op = getStyle(style);
            out([
                f2(x * k),
                f2((pageHeight - y) * k),
                f2(w * k),
                f2(-h * k),
                're',
                op
            ].join(' '));
            return this;
        };

        /**
        Adds a triangle to PDF

        @param {Number} x1 Coordinate (in units declared at inception of PDF document) against left edge of the page
        @param {Number} y1 Coordinate (in units declared at inception of PDF document) against upper edge of the page
        @param {Number} x2 Coordinate (in units declared at inception of PDF document) against left edge of the page
        @param {Number} y2 Coordinate (in units declared at inception of PDF document) against upper edge of the page
        @param {Number} x3 Coordinate (in units declared at inception of PDF document) against left edge of the page
        @param {Number} y3 Coordinate (in units declared at inception of PDF document) against upper edge of the page
        @param {String} style (Defaults to active fill/stroke style) A string signalling if stroke, fill or both are to be applied.
        @function
        @returns {jsPDF}
        @methodOf jsPDF#
        @name triangle
         */
        API.triangle = function (x1, y1, x2, y2, x3, y3, style) {
            this.lines(
                [
                    [ x2 - x1, y2 - y1 ], // vector to point 2
                    [ x3 - x2, y3 - y2 ], // vector to point 3
                    [ x1 - x3, y1 - y3 ] // closing vector back to point 1
                ],
                x1,
                y1, // start of path
                [1, 1],
                style,
                true
            );
            return this;
        };

        /**
        Adds a rectangle with rounded corners to PDF

        @param {Number} x Coordinate (in units declared at inception of PDF document) against left edge of the page
        @param {Number} y Coordinate (in units declared at inception of PDF document) against upper edge of the page
        @param {Number} w Width (in units declared at inception of PDF document)
        @param {Number} h Height (in units declared at inception of PDF document)
        @param {Number} rx Radius along x axis (in units declared at inception of PDF document)
        @param {Number} rx Radius along y axis (in units declared at inception of PDF document)
        @param {String} style (Defaults to active fill/stroke style) A string signalling if stroke, fill or both are to be applied.
        @function
        @returns {jsPDF}
        @methodOf jsPDF#
        @name roundedRect
        */
        API.roundedRect = function (x, y, w, h, rx, ry, style) {
            var MyArc = 4 / 3 * (Math.SQRT2 - 1);
            this.lines(
                [
                    [ (w - 2 * rx), 0 ],
                    [ (rx * MyArc), 0, rx, ry - (ry * MyArc), rx, ry ],
                    [ 0, (h - 2 * ry) ],
                    [ 0, (ry * MyArc), -(rx * MyArc), ry, -rx, ry],
                    [ (-w + 2 * rx), 0],
                    [ -(rx * MyArc), 0, -rx, -(ry * MyArc), -rx, -ry],
                    [ 0, (-h + 2 * ry)],
                    [ 0, -(ry * MyArc), (rx * MyArc), -ry, rx, -ry]
                ],
                x + rx,
                y, // start of path
                [1, 1],
                style
            );
            return this;
        };

        /**
        Adds an ellipse to PDF

        @param {Number} x Coordinate (in units declared at inception of PDF document) against left edge of the page
        @param {Number} y Coordinate (in units declared at inception of PDF document) against upper edge of the page
        @param {Number} rx Radius along x axis (in units declared at inception of PDF document)
        @param {Number} rx Radius along y axis (in units declared at inception of PDF document)
        @param {String} style (Defaults to active fill/stroke style) A string signalling if stroke, fill or both are to be applied.
        @function
        @returns {jsPDF}
        @methodOf jsPDF#
        @name ellipse
         */
        API.ellipse = function (x, y, rx, ry, style) {
            var op = getStyle(style),
                lx = 4 / 3 * (Math.SQRT2 - 1) * rx,
                ly = 4 / 3 * (Math.SQRT2 - 1) * ry;

            out([
                f2((x + rx) * k),
                f2((pageHeight - y) * k),
                'm',
                f2((x + rx) * k),
                f2((pageHeight - (y - ly)) * k),
                f2((x + lx) * k),
                f2((pageHeight - (y - ry)) * k),
                f2(x * k),
                f2((pageHeight - (y - ry)) * k),
                'c'
            ].join(' '));
            out([
                f2((x - lx) * k),
                f2((pageHeight - (y - ry)) * k),
                f2((x - rx) * k),
                f2((pageHeight - (y - ly)) * k),
                f2((x - rx) * k),
                f2((pageHeight - y) * k),
                'c'
            ].join(' '));
            out([
                f2((x - rx) * k),
                f2((pageHeight - (y + ly)) * k),
                f2((x - lx) * k),
                f2((pageHeight - (y + ry)) * k),
                f2(x * k),
                f2((pageHeight - (y + ry)) * k),
                'c'
            ].join(' '));
            out([
                f2((x + lx) * k),
                f2((pageHeight - (y + ry)) * k),
                f2((x + rx) * k),
                f2((pageHeight - (y + ly)) * k),
                f2((x + rx) * k),
                f2((pageHeight - y) * k),
                'c',
                op
            ].join(' '));
            return this;
        };

        /**
        Adds an circle to PDF

        @param {Number} x Coordinate (in units declared at inception of PDF document) against left edge of the page
        @param {Number} y Coordinate (in units declared at inception of PDF document) against upper edge of the page
        @param {Number} r Radius (in units declared at inception of PDF document)
        @param {String} style (Defaults to active fill/stroke style) A string signalling if stroke, fill or both are to be applied.
        @function
        @returns {jsPDF}
        @methodOf jsPDF#
        @name circle
         */
        API.circle = function (x, y, r, style) {
            return this.ellipse(x, y, r, r, style);
        };

        /**
        Adds a properties to the PDF document

        @param {Object} A property_name-to-property_value object structure.
        @function
        @returns {jsPDF}
        @methodOf jsPDF#
        @name setProperties
         */
        API.setProperties = function (properties) {
            // copying only those properties we can render.
            var property;
            for (property in documentProperties) {
                if (documentProperties.hasOwnProperty(property) && properties[property]) {
                    documentProperties[property] = properties[property];
                }
            }
            return this;
        };

        /**
        Sets font size for upcoming text elements.

        @param {Number} size Font size in points.
        @function
        @returns {jsPDF}
        @methodOf jsPDF#
        @name setFontSize
         */
        API.setFontSize = function (size) {
            activeFontSize = size;
            return this;
        };

        /**
        Sets text font face, variant for upcoming text elements.
        See output of jsPDF.getFontList() for possible font names, styles.

        @param {String} fontName Font name or family. Example: "times"
        @param {String} fontStyle Font style or variant. Example: "italic"
        @function
        @returns {jsPDF}
        @methodOf jsPDF#
        @name setFont
         */
        API.setFont = function (fontName, fontStyle) {
            activeFontKey = getFont(fontName, fontStyle);
            // if font is not found, the above line blows up and we never go further
            return this;
        };

        /**
        Switches font style or variant for upcoming text elements,
        while keeping the font face or family same.
        See output of jsPDF.getFontList() for possible font names, styles.

        @param {String} style Font style or variant. Example: "italic"
        @function
        @returns {jsPDF}
        @methodOf jsPDF#
        @name setFontStyle
         */
        API.setFontStyle = API.setFontType = function (style) {
            var undef;
            activeFontKey = getFont(undef, style);
            // if font is not found, the above line blows up and we never go further
            return this;
        };

        /**
        Returns an object - a tree of fontName to fontStyle relationships available to
        active PDF document.

        @public
        @function
        @returns {Object} Like {'times':['normal', 'italic', ... ], 'arial':['normal', 'bold', ... ], ... }
        @methodOf jsPDF#
        @name getFontList
        */
        API.getFontList = function () {
            // TODO: iterate over fonts array or return copy of fontmap instead in case more are ever added.
            var list = {},
                fontName,
                fontStyle,
                tmp;

            for (fontName in fontmap) {
                if (fontmap.hasOwnProperty(fontName)) {
                    list[fontName] = tmp = [];
                    for (fontStyle in fontmap[fontName]) {
                        if (fontmap[fontName].hasOwnProperty(fontStyle)) {
                            tmp.push(fontStyle);
                        }
                    }
                }
            }

            return list;
        };

        /**
        Sets line width for upcoming lines.

        @param {Number} width Line width (in units declared at inception of PDF document)
        @function
        @returns {jsPDF}
        @methodOf jsPDF#
        @name setLineWidth
         */
        API.setLineWidth = function (width) {
            out((width * k).toFixed(2) + ' w');
            return this;
        };

        /**
        Sets the stroke color for upcoming elements.

        Depending on the number of arguments given, Gray, RGB, or CMYK
        color space is implied.

        When only ch1 is given, "Gray" color space is implied and it
        must be a value in the range from 0.00 (solid black) to to 1.00 (white)
        if values are communicated as String types, or in range from 0 (black)
        to 255 (white) if communicated as Number type.
        The RGB-like 0-255 range is provided for backward compatibility.

        When only ch1,ch2,ch3 are given, "RGB" color space is implied and each
        value must be in the range from 0.00 (minimum intensity) to to 1.00
        (max intensity) if values are communicated as String types, or
        from 0 (min intensity) to to 255 (max intensity) if values are communicated
        as Number types.
        The RGB-like 0-255 range is provided for backward compatibility.

        When ch1,ch2,ch3,ch4 are given, "CMYK" color space is implied and each
        value must be a in the range from 0.00 (0% concentration) to to
        1.00 (100% concentration)

        Because JavaScript treats fixed point numbers badly (rounds to
        floating point nearest to binary representation) it is highly advised to
        communicate the fractional numbers as String types, not JavaScript Number type.

        @param {Number|String} ch1 Color channel value
        @param {Number|String} ch2 Color channel value
        @param {Number|String} ch3 Color channel value
        @param {Number|String} ch4 Color channel value

        @function
        @returns {jsPDF}
        @methodOf jsPDF#
        @name setDrawColor
         */
        API.setDrawColor = function (ch1, ch2, ch3, ch4) {
            var color;
            if (ch2 === undefined || (ch4 === undefined && ch1 === ch2 === ch3)) {
                // Gray color space.
                if (typeof ch1 === 'string') {
                    color = ch1 + ' G';
                } else {
                    color = f2(ch1 / 255) + ' G';
                }
            } else if (ch4 === undefined) {
                // RGB
                if (typeof ch1 === 'string') {
                    color = [ch1, ch2, ch3, 'RG'].join(' ');
                } else {
                    color = [f2(ch1 / 255), f2(ch2 / 255), f2(ch3 / 255), 'RG'].join(' ');
                }
            } else {
                // CMYK
                if (typeof ch1 === 'string') {
                    color = [ch1, ch2, ch3, ch4, 'K'].join(' ');
                } else {
                    color = [f2(ch1), f2(ch2), f2(ch3), f2(ch4), 'K'].join(' ');
                }
            }

            out(color);
            return this;
        };

        /**
        Sets the fill color for upcoming elements.

        Depending on the number of arguments given, Gray, RGB, or CMYK
        color space is implied.

        When only ch1 is given, "Gray" color space is implied and it
        must be a value in the range from 0.00 (solid black) to to 1.00 (white)
        if values are communicated as String types, or in range from 0 (black)
        to 255 (white) if communicated as Number type.
        The RGB-like 0-255 range is provided for backward compatibility.

        When only ch1,ch2,ch3 are given, "RGB" color space is implied and each
        value must be in the range from 0.00 (minimum intensity) to to 1.00
        (max intensity) if values are communicated as String types, or
        from 0 (min intensity) to to 255 (max intensity) if values are communicated
        as Number types.
        The RGB-like 0-255 range is provided for backward compatibility.

        When ch1,ch2,ch3,ch4 are given, "CMYK" color space is implied and each
        value must be a in the range from 0.00 (0% concentration) to to
        1.00 (100% concentration)

        Because JavaScript treats fixed point numbers badly (rounds to
        floating point nearest to binary representation) it is highly advised to
        communicate the fractional numbers as String types, not JavaScript Number type.

        @param {Number|String} ch1 Color channel value
        @param {Number|String} ch2 Color channel value
        @param {Number|String} ch3 Color channel value
        @param {Number|String} ch4 Color channel value

        @function
        @returns {jsPDF}
        @methodOf jsPDF#
        @name setFillColor
         */
        API.setFillColor = function (ch1, ch2, ch3, ch4) {
            var color;

            if (ch2 === undefined || (ch4 === undefined && ch1 === ch2 === ch3)) {
                // Gray color space.
                if (typeof ch1 === 'string') {
                    color = ch1 + ' g';
                } else {
                    color = f2(ch1 / 255) + ' g';
                }
            } else if (ch4 === undefined) {
                // RGB
                if (typeof ch1 === 'string') {
                    color = [ch1, ch2, ch3, 'rg'].join(' ');
                } else {
                    color = [f2(ch1 / 255), f2(ch2 / 255), f2(ch3 / 255), 'rg'].join(' ');
                }
            } else {
                // CMYK
                if (typeof ch1 === 'string') {
                    color = [ch1, ch2, ch3, ch4, 'k'].join(' ');
                } else {
                    color = [f2(ch1), f2(ch2), f2(ch3), f2(ch4), 'k'].join(' ');
                }
            }

            out(color);
            return this;
        };

        /**
        Sets the text color for upcoming elements.
        If only one, first argument is given,
        treats the value as gray-scale color value.

        @param {Number} r Red channel color value in range 0-255 or {String} r color value in hexadecimal, example: '#FFFFFF'
        @param {Number} g Green channel color value in range 0-255
        @param {Number} b Blue channel color value in range 0-255
        @function
        @returns {jsPDF}
        @methodOf jsPDF#
        @name setTextColor
        */
        API.setTextColor = function (r, g, b) {
            var patt = /#[0-9A-Fa-f]{6}/;
            if ((typeof r == 'string') && patt.test(r)) {
                var hex = r.replace('#','');
                var bigint = parseInt(hex, 16);
                r = (bigint >> 16) & 255;
                g = (bigint >> 8) & 255;
                b = bigint & 255;
            }

            if ((r === 0 && g === 0 && b === 0) || (typeof g === 'undefined')) {
                textColor = f3(r / 255) + ' g';
            } else {
                textColor = [f3(r / 255), f3(g / 255), f3(b / 255), 'rg'].join(' ');
            }
            return this;
        };

        /**
        Is an Object providing a mapping from human-readable to
        integer flag values designating the varieties of line cap
        and join styles.

        @returns {Object}
        @fieldOf jsPDF#
        @name CapJoinStyles
        */
        API.CapJoinStyles = {
            0: 0,
            'butt': 0,
            'but': 0,
            'miter': 0,
            1: 1,
            'round': 1,
            'rounded': 1,
            'circle': 1,
            2: 2,
            'projecting': 2,
            'project': 2,
            'square': 2,
            'bevel': 2
        };

        /**
        Sets the line cap styles
        See {jsPDF.CapJoinStyles} for variants

        @param {String|Number} style A string or number identifying the type of line cap
        @function
        @returns {jsPDF}
        @methodOf jsPDF#
        @name setLineCap
        */
        API.setLineCap = function (style) {
            var id = this.CapJoinStyles[style];
            if (id === undefined) {
                throw new Error("Line cap style of '" + style + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
            }
            lineCapID = id;
            out(id.toString(10) + ' J');

            return this;
        };

        /**
        Sets the line join styles
        See {jsPDF.CapJoinStyles} for variants

        @param {String|Number} style A string or number identifying the type of line join
        @function
        @returns {jsPDF}
        @methodOf jsPDF#
        @name setLineJoin
        */
        API.setLineJoin = function (style) {
            var id = this.CapJoinStyles[style];
            if (id === undefined) {
                throw new Error("Line join style of '" + style + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
            }
            lineJoinID = id;
            out(id.toString(10) + ' j');

            return this;
        };

        // Output is both an internal (for plugins) and external function
        API.output = output;

        /**
         * Saves as PDF document. An alias of jsPDF.output('save', 'filename.pdf')
         * @param  {String} filename The filename including extension.
         *
         * @function
         * @returns {jsPDF}
         * @methodOf jsPDF#
         * @name save
         */
        API.save = function (filename) {
            API.output('save', filename);
        };

        // applying plugins (more methods) ON TOP of built-in API.
        // this is intentional as we allow plugins to override
        // built-ins
        for (plugin in jsPDF.API) {
            if (jsPDF.API.hasOwnProperty(plugin)) {
                if (plugin === 'events' && jsPDF.API.events.length) {
                    (function (events, newEvents) {

                        // jsPDF.API.events is a JS Array of Arrays
                        // where each Array is a pair of event name, handler
                        // Events were added by plugins to the jsPDF instantiator.
                        // These are always added to the new instance and some ran
                        // during instantiation.

                        var eventname, handler_and_args, i;

                        for (i = newEvents.length - 1; i !== -1; i--) {
                            // subscribe takes 3 args: 'topic', function, runonce_flag
                            // if undefined, runonce is false.
                            // users can attach callback directly,
                            // or they can attach an array with [callback, runonce_flag]
                            // that's what the "apply" magic is for below.
                            eventname = newEvents[i][0];
                            handler_and_args = newEvents[i][1];
                            events.subscribe.apply(
                                events,
                                [eventname].concat(
                                    typeof handler_and_args === 'function' ?
                                            [ handler_and_args ] :
                                            handler_and_args
                                )
                            );
                        }
                    }(events, jsPDF.API.events));
                } else {
                    API[plugin] = jsPDF.API[plugin];
                }
            }
        }

        /////////////////////////////////////////
        // continuing initilisation of jsPDF Document object
        /////////////////////////////////////////


        // Add the first page automatically
        addFonts();
        activeFontKey = 'F1';
        _addPage();

        events.publish('initialized');

        return API;
    }

/**
jsPDF.API is a STATIC property of jsPDF class.
jsPDF.API is an object you can add methods and properties to.
The methods / properties you add will show up in new jsPDF objects.

One property is prepopulated. It is the 'events' Object. Plugin authors can add topics, callbacks to this object. These will be reassigned to all new instances of jsPDF.
Examples:
    jsPDF.API.events['initialized'] = function(){ 'this' is API object }
    jsPDF.API.events['addFont'] = function(added_font_object){ 'this' is API object }

@static
@public
@memberOf jsPDF
@name API

@example
    jsPDF.API.mymethod = function(){
        // 'this' will be ref to internal API object. see jsPDF source
        // , so you can refer to built-in methods like so:
        //     this.line(....)
        //     this.text(....)
    }
    var pdfdoc = new jsPDF()
    pdfdoc.mymethod() // <- !!!!!!
*/
    jsPDF.API = {'events': []};

    return jsPDF;
}());

// @tag amchart
/** @preserve 
jsPDF addImage plugin (JPEG only at this time)
Copyright (c) 2012 https://github.com/siefkenj/
*/

/**
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * ====================================================================
 */

;(function(jsPDFAPI) {
'use strict'

var namespace = 'addImage_'

// takes a string imgData containing the raw bytes of
// a jpeg image and returns [width, height]
// Algorithm from: http://www.64lines.com/jpeg-width-height
var getJpegSize = function(imgData) {
	'use strict'
	var width, height;
	// Verify we have a valid jpeg header 0xff,0xd8,0xff,0xe0,?,?,'J','F','I','F',0x00
	if (!imgData.charCodeAt(0) === 0xff ||
		!imgData.charCodeAt(1) === 0xd8 ||
		!imgData.charCodeAt(2) === 0xff ||
		!imgData.charCodeAt(3) === 0xe0 ||
		!imgData.charCodeAt(6) === 'J'.charCodeAt(0) ||
		!imgData.charCodeAt(7) === 'F'.charCodeAt(0) ||
		!imgData.charCodeAt(8) === 'I'.charCodeAt(0) ||
		!imgData.charCodeAt(9) === 'F'.charCodeAt(0) ||
		!imgData.charCodeAt(10) === 0x00) {
			throw new Error('getJpegSize requires a binary jpeg file')
	}
	var blockLength = imgData.charCodeAt(4)*256 + imgData.charCodeAt(5);
	var i = 4, len = imgData.length;
	while ( i < len ) {
		i += blockLength;
		if (imgData.charCodeAt(i) !== 0xff) {
			throw new Error('getJpegSize could not find the size of the image');
		}
		if (imgData.charCodeAt(i+1) === 0xc0 || //(SOF) Huffman  - Baseline DCT
		    imgData.charCodeAt(i+1) === 0xc1 || //(SOF) Huffman  - Extended sequential DCT 
		    imgData.charCodeAt(i+1) === 0xc2 || // Progressive DCT (SOF2)
		    imgData.charCodeAt(i+1) === 0xc3 || // Spatial (sequential) lossless (SOF3)
		    imgData.charCodeAt(i+1) === 0xc4 || // Differential sequential DCT (SOF5)
		    imgData.charCodeAt(i+1) === 0xc5 || // Differential progressive DCT (SOF6)
		    imgData.charCodeAt(i+1) === 0xc6 || // Differential spatial (SOF7)
		    imgData.charCodeAt(i+1) === 0xc7) {
			height = imgData.charCodeAt(i+5)*256 + imgData.charCodeAt(i+6);
			width = imgData.charCodeAt(i+7)*256 + imgData.charCodeAt(i+8);
			return [width, height];
		} else {
			i += 2;
			blockLength = imgData.charCodeAt(i)*256 + imgData.charCodeAt(i+1)
		}
	}
}
// Image functionality ported from pdf.js
, putImage = function(img) {
	var objectNumber = this.internal.newObject()
	, out = this.internal.write
	, putStream = this.internal.putStream

	img['n'] = objectNumber

	out('<</Type /XObject')
	out('/Subtype /Image')
	out('/Width ' + img['w'])
	out('/Height ' + img['h'])
	if (img['cs'] === 'Indexed') {
		out('/ColorSpace [/Indexed /DeviceRGB '
				+ (img['pal'].length / 3 - 1) + ' ' + (objectNumber + 1)
				+ ' 0 R]');
	} else {
		out('/ColorSpace /' + img['cs']);
		if (img['cs'] === 'DeviceCMYK') {
			out('/Decode [1 0 1 0 1 0 1 0]');
		}
	}
	out('/BitsPerComponent ' + img['bpc']);
	if ('f' in img) {
		out('/Filter /' + img['f']);
	}
	if ('dp' in img) {
		out('/DecodeParms <<' + img['dp'] + '>>');
	}
	if ('trns' in img && img['trns'].constructor == Array) {
		var trns = '';
		for ( var i = 0; i < img['trns'].length; i++) {
			trns += (img[trns][i] + ' ' + img['trns'][i] + ' ');
			out('/Mask [' + trns + ']');
		}
	}
	if ('smask' in img) {
		out('/SMask ' + (objectNumber + 1) + ' 0 R');
	}
	out('/Length ' + img['data'].length + '>>');

	putStream(img['data']);

	out('endobj');
}
, putResourcesCallback = function() {
	var images = this.internal.collections[namespace + 'images']
	for ( var i in images ) {
		putImage.call(this, images[i])
	}
}
, putXObjectsDictCallback = function(){
	var images = this.internal.collections[namespace + 'images']
	, out = this.internal.write
	, image
	for (var i in images) {
		image = images[i]
		out(
			'/I' + image['i']
			, image['n']
			, '0'
			, 'R'
		)
	}
}

jsPDFAPI.addImage = function(imageData, format, x, y, w, h) {
	'use strict'
	if (typeof imageData === 'object' && imageData.nodeType === 1) {
        var canvas = document.createElement('canvas');
        canvas.width = imageData.clientWidth;
	    canvas.height = imageData.clientHeight;

        var ctx = canvas.getContext('2d');
        if (!ctx) {
            throw ('addImage requires canvas to be supported by browser.');
        }
        ctx.drawImage(imageData, 0, 0, canvas.width, canvas.height);
        imageData = canvas.toDataURL('image/jpeg');
	    format = "JPEG";
	}
	if (format.toUpperCase() !== 'JPEG') {
		throw new Error('addImage currently only supports format \'JPEG\', not \''+format+'\'');
	}

	var imageIndex
	, images = this.internal.collections[namespace + 'images']
	, coord = this.internal.getCoordinateString
	, vcoord = this.internal.getVerticalCoordinateString;

	// Detect if the imageData is raw binary or Data URL
	if (imageData.substring(0, 23) === 'data:image/jpeg;base64,') {
		imageData = atob(imageData.replace('data:image/jpeg;base64,', ''));
	}

	if (images){
		// this is NOT the first time this method is ran on this instance of jsPDF object.
		imageIndex = Object.keys ? 
		Object.keys(images).length :
		(function(o){
			var i = 0
			for (var e in o){if(o.hasOwnProperty(e)){ i++ }}
			return i
		})(images)
	} else {
		// this is the first time this method is ran on this instance of jsPDF object.
		imageIndex = 0
		this.internal.collections[namespace + 'images'] = images = {}
		this.internal.events.subscribe('putResources', putResourcesCallback)
		this.internal.events.subscribe('putXobjectDict', putXObjectsDictCallback)
	}

	var dims = getJpegSize(imageData);
	var info = {
		w : dims[0],
		h : dims[1],
		cs : 'DeviceRGB',
		bpc : 8,
		f : 'DCTDecode',
		i : imageIndex,
		data : imageData
		// n: objectNumber will be added by putImage code

	};
	images[imageIndex] = info
	if (!w && !h) {
		w = -96;
		h = -96;
	}
	if (w < 0) {
		w = (-1) * info['w'] * 72 / w / this.internal.scaleFactor;
	}
	if (h < 0) {
		h = (-1) * info['h'] * 72 / h / this.internal.scaleFactor;
	}
	if (w === 0) {
		w = h * info['w'] / info['h'];
	}
	if (h === 0) {
		h = w * info['h'] / info['w'];
	}

	this.internal.write(
		'q'
		, coord(w)
		, '0 0'
		, coord(h) // TODO: check if this should be shifted by vcoord
		, coord(x)
		, vcoord(y + h)
		, 'cm /I'+info['i']
		, 'Do Q'
	)

	return this 
}
})(jsPDF.API)

// @tag amchart
/**
 * A class to parse color values
 * @author Stoyan Stefanov <sstoo@gmail.com>
 * @link   http://www.phpied.com/rgb-color-parser-in-javascript/
 * @license Use it if you like it
 */
function RGBColor(color_string)
{
    this.ok = false;

    // strip any leading #
    if (color_string.charAt(0) == '#') { // remove # if any
        color_string = color_string.substr(1,6);
    }

    color_string = color_string.replace(/ /g,'');
    color_string = color_string.toLowerCase();

    // before getting into regexps, try simple matches
    // and overwrite the input
    var simple_colors = {
        aliceblue: 'f0f8ff',
        antiquewhite: 'faebd7',
        aqua: '00ffff',
        aquamarine: '7fffd4',
        azure: 'f0ffff',
        beige: 'f5f5dc',
        bisque: 'ffe4c4',
        black: '000000',
        blanchedalmond: 'ffebcd',
        blue: '0000ff',
        blueviolet: '8a2be2',
        brown: 'a52a2a',
        burlywood: 'deb887',
        cadetblue: '5f9ea0',
        chartreuse: '7fff00',
        chocolate: 'd2691e',
        coral: 'ff7f50',
        cornflowerblue: '6495ed',
        cornsilk: 'fff8dc',
        crimson: 'dc143c',
        cyan: '00ffff',
        darkblue: '00008b',
        darkcyan: '008b8b',
        darkgoldenrod: 'b8860b',
        darkgray: 'a9a9a9',
        darkgreen: '006400',
        darkkhaki: 'bdb76b',
        darkmagenta: '8b008b',
        darkolivegreen: '556b2f',
        darkorange: 'ff8c00',
        darkorchid: '9932cc',
        darkred: '8b0000',
        darksalmon: 'e9967a',
        darkseagreen: '8fbc8f',
        darkslateblue: '483d8b',
        darkslategray: '2f4f4f',
        darkturquoise: '00ced1',
        darkviolet: '9400d3',
        deeppink: 'ff1493',
        deepskyblue: '00bfff',
        dimgray: '696969',
        dodgerblue: '1e90ff',
        feldspar: 'd19275',
        firebrick: 'b22222',
        floralwhite: 'fffaf0',
        forestgreen: '228b22',
        fuchsia: 'ff00ff',
        gainsboro: 'dcdcdc',
        ghostwhite: 'f8f8ff',
        gold: 'ffd700',
        goldenrod: 'daa520',
        gray: '808080',
        green: '008000',
        greenyellow: 'adff2f',
        honeydew: 'f0fff0',
        hotpink: 'ff69b4',
        indianred : 'cd5c5c',
        indigo : '4b0082',
        ivory: 'fffff0',
        khaki: 'f0e68c',
        lavender: 'e6e6fa',
        lavenderblush: 'fff0f5',
        lawngreen: '7cfc00',
        lemonchiffon: 'fffacd',
        lightblue: 'add8e6',
        lightcoral: 'f08080',
        lightcyan: 'e0ffff',
        lightgoldenrodyellow: 'fafad2',
        lightgrey: 'd3d3d3',
        lightgreen: '90ee90',
        lightpink: 'ffb6c1',
        lightsalmon: 'ffa07a',
        lightseagreen: '20b2aa',
        lightskyblue: '87cefa',
        lightslateblue: '8470ff',
        lightslategray: '778899',
        lightsteelblue: 'b0c4de',
        lightyellow: 'ffffe0',
        lime: '00ff00',
        limegreen: '32cd32',
        linen: 'faf0e6',
        magenta: 'ff00ff',
        maroon: '800000',
        mediumaquamarine: '66cdaa',
        mediumblue: '0000cd',
        mediumorchid: 'ba55d3',
        mediumpurple: '9370d8',
        mediumseagreen: '3cb371',
        mediumslateblue: '7b68ee',
        mediumspringgreen: '00fa9a',
        mediumturquoise: '48d1cc',
        mediumvioletred: 'c71585',
        midnightblue: '191970',
        mintcream: 'f5fffa',
        mistyrose: 'ffe4e1',
        moccasin: 'ffe4b5',
        navajowhite: 'ffdead',
        navy: '000080',
        oldlace: 'fdf5e6',
        olive: '808000',
        olivedrab: '6b8e23',
        orange: 'ffa500',
        orangered: 'ff4500',
        orchid: 'da70d6',
        palegoldenrod: 'eee8aa',
        palegreen: '98fb98',
        paleturquoise: 'afeeee',
        palevioletred: 'd87093',
        papayawhip: 'ffefd5',
        peachpuff: 'ffdab9',
        peru: 'cd853f',
        pink: 'ffc0cb',
        plum: 'dda0dd',
        powderblue: 'b0e0e6',
        purple: '800080',
        red: 'ff0000',
        rosybrown: 'bc8f8f',
        royalblue: '4169e1',
        saddlebrown: '8b4513',
        salmon: 'fa8072',
        sandybrown: 'f4a460',
        seagreen: '2e8b57',
        seashell: 'fff5ee',
        sienna: 'a0522d',
        silver: 'c0c0c0',
        skyblue: '87ceeb',
        slateblue: '6a5acd',
        slategray: '708090',
        snow: 'fffafa',
        springgreen: '00ff7f',
        steelblue: '4682b4',
        tan: 'd2b48c',
        teal: '008080',
        thistle: 'd8bfd8',
        tomato: 'ff6347',
        turquoise: '40e0d0',
        violet: 'ee82ee',
        violetred: 'd02090',
        wheat: 'f5deb3',
        white: 'ffffff',
        whitesmoke: 'f5f5f5',
        yellow: 'ffff00',
        yellowgreen: '9acd32'
    };
    for (var key in simple_colors) {
        if (color_string == key) {
            color_string = simple_colors[key];
        }
    }
    // emd of simple type-in colors

    // array of color definition objects
    var color_defs = [
        {
            re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
            example: ['rgb(123, 234, 45)', 'rgb(255,234,245)'],
            process: function (bits){
                return [
                    parseInt(bits[1]),
                    parseInt(bits[2]),
                    parseInt(bits[3])
                ];
            }
        },
        {
            re: /^(\w{2})(\w{2})(\w{2})$/,
            example: ['#00ff00', '336699'],
            process: function (bits){
                return [
                    parseInt(bits[1], 16),
                    parseInt(bits[2], 16),
                    parseInt(bits[3], 16)
                ];
            }
        },
        {
            re: /^(\w{1})(\w{1})(\w{1})$/,
            example: ['#fb0', 'f0f'],
            process: function (bits){
                return [
                    parseInt(bits[1] + bits[1], 16),
                    parseInt(bits[2] + bits[2], 16),
                    parseInt(bits[3] + bits[3], 16)
                ];
            }
        }
    ];

    // search through the definitions to find a match
    for (var i = 0; i < color_defs.length; i++) {
        var re = color_defs[i].re;
        var processor = color_defs[i].process;
        var bits = re.exec(color_string);
        if (bits) {
            channels = processor(bits);
            this.r = channels[0];
            this.g = channels[1];
            this.b = channels[2];
            this.ok = true;
        }

    }

    // validate/cleanup values
    this.r = (this.r < 0 || isNaN(this.r)) ? 0 : ((this.r > 255) ? 255 : this.r);
    this.g = (this.g < 0 || isNaN(this.g)) ? 0 : ((this.g > 255) ? 255 : this.g);
    this.b = (this.b < 0 || isNaN(this.b)) ? 0 : ((this.b > 255) ? 255 : this.b);

    // some getters
    this.toRGB = function () {
        return 'rgb(' + this.r + ', ' + this.g + ', ' + this.b + ')';
    }
    this.toHex = function () {
        var r = this.r.toString(16);
        var g = this.g.toString(16);
        var b = this.b.toString(16);
        if (r.length == 1) r = '0' + r;
        if (g.length == 1) g = '0' + g;
        if (b.length == 1) b = '0' + b;
        return '#' + r + g + b;
    }

    // help
    this.getHelpXML = function () {

        var examples = new Array();
        // add regexps
        for (var i = 0; i < color_defs.length; i++) {
            var example = color_defs[i].example;
            for (var j = 0; j < example.length; j++) {
                examples[examples.length] = example[j];
            }
        }
        // add type-in colors
        for (var sc in simple_colors) {
            examples[examples.length] = sc;
        }

        var xml = document.createElement('ul');
        xml.setAttribute('id', 'rgbcolor-examples');
        for (var i = 0; i < examples.length; i++) {
            try {
                var list_item = document.createElement('li');
                var list_color = new RGBColor(examples[i]);
                var example_div = document.createElement('div');
                example_div.style.cssText =
                        'margin: 3px; '
                        + 'border: 1px solid black; '
                        + 'background:' + list_color.toHex() + '; '
                        + 'color:' + list_color.toHex()
                ;
                example_div.appendChild(document.createTextNode('test'));
                var list_item_value = document.createTextNode(
                    ' ' + examples[i] + ' -> ' + list_color.toRGB() + ' -> ' + list_color.toHex()
                );
                list_item.appendChild(example_div);
                list_item.appendChild(list_item_value);
                xml.appendChild(list_item);

            } catch(e){}
        }
        return xml;

    }

}


// @tag amchart
AmCharts.Bezier = AmCharts.Class({
    construct: function (container, x, y, color, alpha, thickness, fillColor, fillAlpha, dashLength, endStr) {
        var _this = this;

        if (typeof (fillColor) == 'object') {
            fillColor = fillColor[0];
        }
        if (typeof (fillAlpha) == 'object') {
            fillAlpha = fillAlpha[0];
        }

        var attr = {
            'fill': fillColor,
                'fill-opacity': fillAlpha,
                'stroke-width': thickness
        };

        if (dashLength !== undefined && dashLength > 0) {
            attr['stroke-dasharray'] = dashLength;
        }

        if (!isNaN(alpha)) {
            attr['stroke-opacity'] = alpha;
        }

        if (color) {
            attr.stroke = color;
        }

        var letter = "L";
        var lineStr = "M" + Math.round(x[0]) + "," + Math.round(y[0]);
        var points = [];

        var i;
        for (i = 0; i < x.length; i++) {
            points.push({
                x: Number(x[i]),
                y: Number(y[i])
            });
        }

        if (points.length > 1) {
            var interpolatedPoints = _this.interpolate(points);
            lineStr += _this.drawBeziers(interpolatedPoints);
        }

        if (endStr) {
            lineStr += endStr;
        } else {
            if (!AmCharts.VML) {
                // end string is to create area
                // this is the fix to solve straight line in chrome problem
                lineStr += "M0,0 L0,0";
            }
        }

        _this.path = container.path(lineStr).attr(attr);
    },


    interpolate: function (points) {
        var interpolatedPoints = [];
        interpolatedPoints.push({
            x: points[0].x,
            y: points[0].y
        });

        var slope_x = points[1].x - points[0].x;
        var slope_y = points[1].y - points[0].y;

        var dal_x = AmCharts.bezierX;
        var dal_y = AmCharts.bezierY;

        interpolatedPoints.push({
            x: points[0].x + slope_x / dal_x,
            y: points[0].y + slope_y / dal_y
        });
        var i;

        for (i = 1; i < points.length - 1; i++) {


            var point1 = points[i - 1];
            var point2 = points[i];
            var point3 = points[i + 1];

            if(isNaN(point3.x)){
                point3 = point2;
            }

            if(isNaN(point2.x)){
                point2 = point1;
            }

            if(isNaN(point1.x)){
                point1 = point2;
            }

            slope_x = point3.x - point2.x;
            slope_y = point3.y - point1.y;

            var slope_x0 = point2.x - point1.x;

            if (slope_x0 > slope_x) {
                slope_x0 = slope_x;
            }

            interpolatedPoints.push({
                x: point2.x - slope_x0 / dal_x,
                y: point2.y - slope_y / dal_y
            });
            interpolatedPoints.push({
                x: point2.x,
                y: point2.y
            });
            interpolatedPoints.push({
                x: point2.x + slope_x0 / dal_x,
                y: point2.y + slope_y / dal_y
            });
        }

        slope_y = points[points.length - 1].y - points[points.length - 2].y;
        slope_x = points[points.length - 1].x - points[points.length - 2].x;

        interpolatedPoints.push({
            x: points[points.length - 1].x - slope_x / dal_x,
            y: points[points.length - 1].y - slope_y / dal_y
        });
        interpolatedPoints.push({
            x: points[points.length - 1].x,
            y: points[points.length - 1].y
        });

        return interpolatedPoints;
    },

    drawBeziers: function (interpolatedPoints) {
        var str = "";
        var j;
        for (j = 0; j < (interpolatedPoints.length - 1) / 3; j++) {
            str += this.drawBezierMidpoint(interpolatedPoints[3 * j], interpolatedPoints[3 * j + 1], interpolatedPoints[3 * j + 2], interpolatedPoints[3 * j + 3]);
        }
        return str;
    },


    drawBezierMidpoint: function (P0, P1, P2, P3) {
        var round = Math.round;
        // calculates the useful base points
        var PA = this.getPointOnSegment(P0, P1, 3 / 4);
        var PB = this.getPointOnSegment(P3, P2, 3 / 4);

        // get 1/16 of the [P3, P0] segment
        var dx = (P3.x - P0.x) / 16;
        var dy = (P3.y - P0.y) / 16;

        // calculates control point 1
        var Pc_1 = this.getPointOnSegment(P0, P1, 3 / 8);

        // calculates control point 2
        var Pc_2 = this.getPointOnSegment(PA, PB, 3 / 8);
        Pc_2.x -= dx;
        Pc_2.y -= dy;

        // calculates control point 3
        var Pc_3 = this.getPointOnSegment(PB, PA, 3 / 8);
        Pc_3.x += dx;
        Pc_3.y += dy;

        // calculates control point 4
        var Pc_4 = this.getPointOnSegment(P3, P2, 3 / 8);

        // calculates the 3 anchor points
        var Pa_1 = this.getMiddle(Pc_1, Pc_2);
        var Pa_2 = this.getMiddle(PA, PB);
        var Pa_3 = this.getMiddle(Pc_3, Pc_4);

        // draw the four quadratic subsegments
        var comma = ",";

        var str = " Q" + round(Pc_1.x) + comma + round(Pc_1.y) + comma + round(Pa_1.x) + comma + round(Pa_1.y);
        str += " Q" + round(Pc_2.x) + comma + round(Pc_2.y) + comma + round(Pa_2.x) + comma + round(Pa_2.y);
        str += " Q" + round(Pc_3.x) + comma + round(Pc_3.y) + comma + round(Pa_3.x) + comma + round(Pa_3.y);
        str += " Q" + round(Pc_4.x) + comma + round(Pc_4.y) + comma + round(P3.x) + comma + round(P3.y);

        return str;
    },


    getMiddle: function (P0, P1) {
        var point = {
            x: (P0.x + P1.x) / 2,
            y: (P0.y + P1.y) / 2
        };
        return point;
    },

    getPointOnSegment: function (P0, P1, ratio) {
        var point = {
            x: P0.x + (P1.x - P0.x) * ratio,
            y: P0.y + (P1.y - P0.y) * ratio
        };
        return point;
    }

});

// @tag amchart
AmCharts.Cuboid = AmCharts.Class({
    construct: function (container, width, height, dx, dy, colors, alpha, bwidth, bcolor, balpha, gradientRotation, cornerRadius, rotate, dashLength, pattern) {
        var _this = this;
        _this.set = container.set();
        _this.container = container;
        _this.h = Math.round(height);
        _this.w = Math.round(width);
        _this.dx = dx;
        _this.dy = dy;
        _this.colors = colors;
        _this.alpha = alpha;
        _this.bwidth = bwidth;
        _this.bcolor = bcolor;
        _this.balpha = balpha;
        _this.colors = colors;
        _this.dashLength = dashLength;
        _this.pattern = pattern;

        if (rotate) {
            if (width < 0 && gradientRotation === 0) {
                gradientRotation = 180;
            }
        } else {
            if (height < 0) {
                if (gradientRotation == 270) {
                    gradientRotation = 90;
                }
            }
        }
        _this.gradientRotation = gradientRotation;

        if (dx === 0 && dy === 0) {
            _this.cornerRadius = cornerRadius;
        }
        _this.draw();
    },

    draw: function () {
        var _this = this;
        var set = _this.set;
        set.clear();

        var container = _this.container;
        var deltaY = 0;

        var w = _this.w;
        var h = _this.h;
        var dx = _this.dx;
        var dy = _this.dy;
        var colors = _this.colors;
        var alpha = _this.alpha;
        var bwidth = _this.bwidth;
        var bcolor = _this.bcolor;
        var balpha = _this.balpha;
        var gradientRotation = _this.gradientRotation;
        var cornerRadius = _this.cornerRadius;
        var dashLength = _this.dashLength;
        var pattern = _this.pattern;

        // bot
        var firstColor = colors;
        var lastColor = colors;

        if (typeof (colors) == "object") {
            firstColor = colors[0];
            lastColor = colors[colors.length - 1];
        }

        var bottom;
        var back;
        var backBorders;
        var lside;
        var rside;
        var rsideBorders;
        var top;
        var topBorders;
        var bottomBorders;

        // if dx or dx > 0, draw other sides
        var tempAlpha = alpha;
        if(pattern){
            alpha = 0;
        }
        if (dx > 0 || dy > 0) {

            var bc = lastColor;
            var ccc = AmCharts.adjustLuminosity(firstColor, -0.2);
            var tc = firstColor;
            var ta = alpha;

            ccc = AmCharts.adjustLuminosity(tc, -0.2);
            bottom = AmCharts.polygon(container, [0, dx, w + dx, w, 0], [0, dy, dy, 0, 0], ccc, alpha, 1, bcolor, 0, gradientRotation);

            if (balpha > 0) {
                bottomBorders = AmCharts.line(container, [0, dx, w + dx], [0, dy, dy], bcolor, balpha, bwidth, dashLength);
            }

            // back
            back = AmCharts.polygon(container, [0, 0, w, w, 0], [0, h, h, 0, 0], ccc, alpha, 1, bcolor, 0, gradientRotation);
            back.translate(dx, dy);

            // back borders
            if (balpha > 0) {
                backBorders = AmCharts.line(container, [dx, dx], [dy, dy + h], bcolor, balpha, bwidth, dashLength);
            }

            // left side
            lside = AmCharts.polygon(container, [0, 0, dx, dx, 0], [0, h, h + dy, dy, 0], ccc, alpha, 1, bcolor, 0, gradientRotation);

            // right side
            rside = AmCharts.polygon(container, [w, w, w + dx, w + dx, w], [0, h, h + dy, dy, 0], ccc, alpha, 1, bcolor, 0, gradientRotation);

            // right side borders
            if (balpha > 0) {
                rsideBorders = AmCharts.line(container, [w, w + dx, w + dx, w], [0, dy, h + dy, h], bcolor, balpha, bwidth, dashLength);
            }
            //}
            ccc = AmCharts.adjustLuminosity(bc, 0.2);
            top = AmCharts.polygon(container, [0, dx, w + dx, w, 0], [h, h + dy, h + dy, h, h], ccc, alpha, 1, bcolor, 0, gradientRotation);

            // bot borders
            if (balpha > 0) {
                topBorders = AmCharts.line(container, [0, dx, w + dx], [h, h + dy, h + dy], bcolor, balpha, bwidth, dashLength);
            }
        }

        alpha = tempAlpha;

        if (Math.abs(h) < 1) {
            h = 0;
        }

        if (Math.abs(w) < 1) {
            w = 0;
        }

        var front;
        if (h === 0) {
            front = AmCharts.line(container, [0, w], [0, 0], bcolor, balpha, bwidth, dashLength);
        } else if (w === 0) {
            front = AmCharts.line(container, [0, 0], [0, h], bcolor, balpha, bwidth, dashLength);
        } else {
            if (cornerRadius > 0) {
                front = AmCharts.rect(container, w, h, colors, alpha, bwidth, bcolor, balpha, cornerRadius, gradientRotation, dashLength);
            } else {
                front = AmCharts.polygon(container, [0, 0, w, w, 0], [0, h, h, 0, 0], colors, alpha, bwidth, bcolor, balpha, gradientRotation, false, dashLength);
            }
        }

        var elements;
        if (h < 0) {
            elements = [bottom, bottomBorders, back, backBorders, lside, rside, rsideBorders, top, topBorders, front];
        } else {
            elements = [top, topBorders, back, backBorders, lside, rside, bottom, bottomBorders, rsideBorders, front];
        }
        var i;
        for (i = 0; i < elements.length; i++) {
            var el = elements[i];
            if (el) {
                set.push(el);
            }
        }

        if(pattern){
            front.pattern(pattern);
        }
    },

    width: function (v) {
        var _this = this;
        _this.w = v;
        _this.draw();
    },

    height: function (v) {
        var _this = this;
        _this.h = v;
        _this.draw();
    },

    animateHeight: function (duration, easingFunction) {
        var _this = this;
        _this.easing = easingFunction;
        _this.totalFrames = 1000 * duration / AmCharts.updateRate;
        _this.rh = _this.h;
        _this.frame = 0;
        _this.height(1);
        setTimeout(function () {
            _this.updateHeight.call(_this);
        }, AmCharts.updateRate);
    },

    updateHeight: function () {
        var _this = this;
        _this.frame++;
        var totalFrames = _this.totalFrames;

        if (_this.frame <= totalFrames) {
            var value = _this.easing(0, _this.frame, 1, _this.rh - 1, totalFrames);
            _this.height(value);
            setTimeout(function () {
                _this.updateHeight.call(_this);
            }, AmCharts.updateRate);
        }
    },

    animateWidth: function (duration, easingFunction) {
        var _this = this;
        _this.easing = easingFunction;
        _this.totalFrames = 1000 * duration / AmCharts.updateRate;
        _this.rw = _this.w;
        _this.frame = 0;
        _this.width(1);
        setTimeout(function () {
            _this.updateWidth.call(_this);
        }, AmCharts.updateRate);
    },

    updateWidth: function () {
        var _this = this;
        _this.frame++;
        var totalFrames = _this.totalFrames;

        if (_this.frame <= totalFrames) {
            var value = _this.easing(0, _this.frame, 1, _this.rw - 1, totalFrames);
            _this.width(value);
            setTimeout(function () {
                _this.updateWidth.call(_this);
            }, AmCharts.updateRate);
        }
    }

});

// @tag amchart
AmCharts.circle = function (container, r, color, alpha, bwidth, bcolor, balpha, bubble) {
    var UNDEFINED;
    if (bwidth == UNDEFINED || bwidth === 0) {
        bwidth = 0.01;
    }
    if (bcolor === UNDEFINED) {
        bcolor = '#000000';
    }
    if (balpha === UNDEFINED) {
        balpha = 0;
    }

    var attr = {
        'fill': color,
            'stroke': bcolor,
            'fill-opacity': alpha,
            'stroke-width': bwidth,
            'stroke-opacity': balpha
    };

    var circle = container.circle(0, 0, r).attr(attr);

    if (bubble) {
        circle.gradient("radialGradient", [color, AmCharts.adjustLuminosity(color, -0.6)]);
    }

    return circle;
};

AmCharts.text = function (container, text, color, fontFamily, fontSize, anchor, bold, alpha) {
    if (!anchor) {
        anchor = "middle";
    }
    if (anchor == "right") {
        anchor = "end";
    }
    if(isNaN(alpha)){
        alpha = 1;
    }

    if (text !== undefined) {
        text = String(text);
        if (AmCharts.isIE) {
            if (!AmCharts.isModern) {
                text = text.replace("&amp;", "&");
                text = text.replace("&", "&amp;");
            }
        }
    }

    var attr = {
        'fill': color,
            'font-family': fontFamily,
            'font-size': fontSize,
            'opacity': alpha
    };

    if (bold === true) {
        attr['font-weight'] = 'bold';
    }

    // last as size depends on previous
    attr['text-anchor'] = anchor;

    var txt = container.text(text, attr);

    return txt;
};



AmCharts.polygon = function (container, x, y, colors, alpha, bwidth, bcolor, balpha, gradientRotation, noRound, dashLength) {
    if (isNaN(bwidth)) {
        bwidth = 0.01;
    }

    if (isNaN(balpha)) {
        balpha = alpha;
    }
    var color = colors;
    var gradient = false;

    if (typeof (color) == "object") {
        if (color.length > 1) {
            gradient = true;
            color = color[0];
        }
    }

    if (bcolor === undefined) {
        bcolor = color;
    }
    var attr = {
        'fill': color,
            'stroke': bcolor,
            'fill-opacity': alpha,
            'stroke-width': bwidth,
            'stroke-opacity': balpha
    };

    if (dashLength !== undefined && dashLength > 0) {
        attr['stroke-dasharray'] = dashLength;
    }

    var dx = AmCharts.dx;
    var dy = AmCharts.dy;

    if(container.handDrawn){
        var xy = AmCharts.makeHD(x, y, container.handDrawScatter);
        x = xy[0];
        y = xy[1];
    }

    var round = Math.round;
    if (noRound) {
        round = AmCharts.doNothing;
    }
    var str = "M" + (round(x[0]) + dx) + "," + (round(y[0]) + dy);

    for (var i = 1; i < x.length; i++) {
        str += " L" + (round(x[i]) + dx) + "," + (round(y[i]) + dy);
    }
    str += " Z";
    var p = container.path(str).attr(attr);

    if (gradient) {
        p.gradient("linearGradient", colors, gradientRotation);
    }

    return p;
};


AmCharts.rect = function (container, w, h, colors, alpha, bwidth, bcolor, balpha, cradius, gradientRotation, dashLength) {
    var UNDEFINED;

    if (isNaN(bwidth)) {
        bwidth = 0;
    }
    if (cradius === UNDEFINED) {
        cradius = 0;
    }
    if (gradientRotation === UNDEFINED) {
        gradientRotation = 270;
    }
    if (isNaN(alpha)) {
        alpha = 0;
    }
    var color = colors;
    var gradient = false;
    if (typeof (color) == "object") {
        color = color[0];
        gradient = true;
    }
    if (bcolor === UNDEFINED) {
        bcolor = color;
    }
    if (balpha === UNDEFINED) {
        balpha = alpha;
    }

    w = Math.round(w);
    h = Math.round(h);

    var x = 0;
    var y = 0;

    if (w < 0) {
        w = Math.abs(w);
        x = -w;
    }

    if (h < 0) {
        h = Math.abs(h);
        y = -h;
    }

    x += AmCharts.dx;
    y += AmCharts.dy;

    var attr = {
        'fill': color,
            'stroke': bcolor,
            'fill-opacity': alpha,
            'stroke-opacity': balpha
    };

    if (dashLength !== undefined && dashLength > 0) {
        attr['stroke-dasharray'] = dashLength;
    }


    var r = container.rect(x, y, w, h, cradius, bwidth).attr(attr);

    if (gradient) {
        r.gradient("linearGradient", colors, gradientRotation);
    }

    return r;
};


AmCharts.bullet = function (container, bulletType, bulletSize, bc, ba, bbt, bbc, bba, originalSize, gradientRotation, pattern) {
    var bullet;

    if(bulletType == "circle"){
        bulletType = "round";
    }

    switch (bulletType) {
        case "round":
            bullet = AmCharts.circle(container, bulletSize / 2, bc, ba, bbt, bbc, bba);
            break;
        case "square":
            bullet = AmCharts.polygon(container, [-bulletSize / 2, bulletSize / 2, bulletSize / 2, -bulletSize / 2], [bulletSize / 2, bulletSize / 2, -bulletSize / 2, -bulletSize / 2], bc, ba, bbt, bbc, bba, gradientRotation - 180);
            break;
        case "rectangle":
            bullet = AmCharts.polygon(container, [-bulletSize, bulletSize, bulletSize, -bulletSize], [bulletSize / 2, bulletSize / 2, -bulletSize / 2, -bulletSize / 2], bc, ba, bbt, bbc, bba, gradientRotation - 180);
            break;
        case "diamond":
            bullet = AmCharts.polygon(container, [-bulletSize / 2, 0, bulletSize / 2, 0], [0, -bulletSize / 2, 0, bulletSize / 2], bc, ba, bbt, bbc, bba);
            break;
        case "triangleUp":
            bullet = AmCharts.triangle(container, bulletSize, 0, bc, ba, bbt, bbc, bba);
            break;
        case "triangleDown":
            bullet = AmCharts.triangle(container, bulletSize, 180, bc, ba, bbt, bbc, bba);
            break;
        case "triangleLeft":
            bullet = AmCharts.triangle(container, bulletSize, 270, bc, ba, bbt, bbc, bba);
            break;
        case "triangleRight":
            bullet = AmCharts.triangle(container, bulletSize, 90, bc, ba, bbt, bbc, bba);
            break;
        case "bubble":
            bullet = AmCharts.circle(container, bulletSize / 2, bc, ba, bbt, bbc, bba, true);
            break;
        case "line":
            bullet = AmCharts.line(container, [- bulletSize / 2, bulletSize / 2], [0, 0], bc, ba, bbt, bbc, bba);
            break;
        case "yError":
            bullet = container.set();
            bullet.push(AmCharts.line(container, [0, 0], [-bulletSize / 2, bulletSize / 2], bc, ba, bbt));
            bullet.push(AmCharts.line(container, [-originalSize, originalSize], [-bulletSize / 2, -bulletSize / 2], bc, ba, bbt));
            bullet.push(AmCharts.line(container, [-originalSize, originalSize], [bulletSize / 2, bulletSize / 2], bc, ba, bbt));
            break;

        case "xError":
            bullet = container.set();
            bullet.push(AmCharts.line(container, [-bulletSize / 2, bulletSize / 2], [0, 0], bc, ba, bbt));
            bullet.push(AmCharts.line(container, [-bulletSize / 2, -bulletSize / 2], [-originalSize, originalSize], bc, ba, bbt));
            bullet.push(AmCharts.line(container, [bulletSize / 2, bulletSize / 2], [-originalSize, originalSize], bc, ba, bbt));
            break;
    }
    if(bullet){
        bullet.pattern(pattern);
    }
    return bullet;
};


AmCharts.triangle = function (container, w, rotation, color, alpha, bwidth, bcolor, balpha) {
    var UNDEFINED;

    if (bwidth === UNDEFINED || bwidth === 0) {
        bwidth = 1;
    }
    if (bcolor === UNDEFINED) {
        bcolor = '#000';
    }
    if (balpha === UNDEFINED) {
        balpha = 0;
    }

    var attr = {
        'fill': color,
            'stroke': bcolor,
            'fill-opacity': alpha,
            'stroke-width': bwidth,
            'stroke-opacity': balpha
    };

    var half = w / 2;
    var path;
    var comma = ",";
    var l = " L";
    var m = " M";
    var z = " Z";

    if (rotation === 0) {
        path = m + (-half) + comma + half + l + 0 + comma + (-half) + l + half + comma + half + z;
    }
    if (rotation == 180) {
        path = m + (-half) + comma + (-half) + l + 0 + comma + half + l + half + comma + (-half) + z;
    }
    if (rotation == 90) {
        path = m + (-half) + comma + (-half) + l + half + comma + 0 + l + (-half) + comma + half + z;
    }
    if (rotation == 270) {
        path = m + (-half) + comma + 0 + l + half + comma + half + l + half + comma + (-half) + z;
    }

    var triangle = container.path(path).attr(attr);

    return triangle;
};


AmCharts.line = function (container, x, y, color, alpha, thickness, dashLength, smoothed, doFix, noRound, noHand) {

    var none = "none";

    if(container.handDrawn && !noHand){
        return AmCharts.handDrawnLine(container, x, y, color, alpha, thickness, dashLength, smoothed, doFix, noRound, noHand);
    }
    else{
        var attr = {
            'fill': none,
                'stroke-width': thickness
        };

        if (dashLength !== undefined && dashLength > 0) {
            attr['stroke-dasharray'] = dashLength;
        }

        if (!isNaN(alpha)) {
            attr['stroke-opacity'] = alpha;
        }

        if (color) {
            attr.stroke = color;
        }

        var letter = "L";

        var round = Math.round;

        if (noRound) {
            round = AmCharts.doNothing;
        }

        var dx = AmCharts.dx;
        var dy = AmCharts.dy;
        var str = "M" + (round(x[0]) + dx) + "," + (round(y[0]) + dy);
        var i;
        for (i = 1; i < x.length; i++) {
            str += " " + letter + "" + (round(x[i]) + dx) + "," + (round(y[i]) + dy);
        }


        if (AmCharts.VML) {
            return container.path(str, undefined, true).attr(attr);
        } else {
            if (doFix) {
                str += " M0,0 L0,0";
            }
            return container.path(str).attr(attr);
        }
    }
};

AmCharts.makeHD = function(x, y, scatter){

    var stepSize = 50;

    var xa = [];
    var ya = [];

    for (var i = 1; i < x.length; i++) {

        var x0 = Number(x[i - 1]);
        var y0 = Number(y[i - 1]);
        var x1 = Number(x[i]);
        var y1 = Number(y[i]);

        var distance = Math.sqrt(Math.pow((x1-x0), 2) + Math.pow((y1-y0),2));
        var steps = Math.round(distance / stepSize) + 1;

        var stepX = (x1 - x0) / steps;
        var stepY = (y1 - y0) / steps;

        for(var s = 0; s <= steps; s++){

            var xx = x0 + s * stepX + Math.random() * scatter;
            var yy = y0 + s * stepY + Math.random() * scatter;

            xa.push(xx);
            ya.push(yy);
        }
    }

    return [xa, ya];
}


AmCharts.handDrawnLine = function(container, x, y, color, alpha, thickness, dashLength, smoothed, doFix, noRound, noHand){
    var i;
    var set = container.set();

    for (i = 1; i < x.length; i++) {

        var x0 = x[i - 1];
        var y0 = y[i - 1];
        var x1 = x[i];
        var y1 = y[i];

        var xa = [x0, x1];
        var ya = [y0, y1];

        var newXY = AmCharts.makeHD(xa, ya, container.handDrawScatter);
        xa = newXY[0];
        ya = newXY[1];

        for(var j = 1; j < xa.length; j++){
            set.push(AmCharts.line(container, [xa[j-1], xa[j]], [ya[j-1], ya[j]], color, alpha, thickness + Math.random() * container.handDrawThickness - container.handDrawThickness / 2, dashLength, smoothed, doFix, noRound, true));
        }
    }

    return set;
};

AmCharts.doNothing = function (value) {
    return value;
};

AmCharts.wedge = function (container, x, y, startAngle, arc, radius, yRadius, innerRadius, h, attributes, gradientRatio, pattern) {
    var rad = Math.PI / 180;
    var round = Math.round;

    radius = round(radius);
    yRadius = round(yRadius);

    innerRadius = round(innerRadius);
    var yInnerRadius = round((yRadius / radius) * innerRadius);

    var vml = AmCharts.VML;

    // FAILS IF BIGGER, and the smaller radius, the bigger corection
    var edge = 359.5 + radius / 100;
    if (edge > 359.94) {
        edge = 359.94;
    }

    if (arc >= edge) {
        arc = edge;
    }

    /* to understand what each letter means
     c-----------b
      \          /
       \        /
        \      /
         d----a
          \  /
           \/
           x
    */

    var degToRad = 1 / 180 * Math.PI;
    var ax = x + Math.sin(startAngle * degToRad) * innerRadius;
    var ay = y - Math.cos(startAngle * degToRad) * yInnerRadius;

    var bx = x + Math.sin(startAngle * degToRad) * radius;
    var by = y - Math.cos(startAngle * degToRad) * yRadius;

    var cx = x + Math.sin((startAngle + arc) * degToRad) * radius;
    var cy = y - Math.cos((startAngle + arc) * degToRad) * yRadius;

    var dx = x + Math.sin((startAngle + arc) * degToRad) * innerRadius;
    var dy = y - Math.cos((startAngle + arc) * degToRad) * yInnerRadius;

    var hsb = AmCharts.adjustLuminosity(attributes.fill, -0.2);

    var bparams = {
        'fill': hsb,
        'stroke-opacity': 0,
        'fill-opacity': attributes["fill-opacity"]
    };

    var lf = 0;
    var sf = 1;
    if (Math.abs(arc) > 180) {
        lf = 1;
    }

    var slice = container.set();
    var comma = ",";
    var L = " L";
    var A = " A";
    var Z = " Z";
    var M = " M";
    var B = " B";
    var UNDEFINED;
    var cs = "1000,1000";

    var wpath;
    var isSmall;
    var ten = 10;

    if (vml) {
        ax = round(ten * ax);
        bx = round(ten * bx);
        cx = round(ten * cx);
        dx = round(ten * dx);
        ay = round(ten * ay);
        by = round(ten * by);
        cy = round(ten * cy);
        dy = round(ten * dy);
        x = round(ten * x);
        h = round(ten * h);
        y = round(ten * y);
        radius = ten * radius;
        yRadius = ten * yRadius;
        innerRadius = ten * innerRadius;
        yInnerRadius = ten * yInnerRadius;

        if (Math.abs(arc) < 1 && Math.abs(cx - bx) <= 1 && Math.abs(cy - by) <= 1) {
            isSmall = true;
        }
    }
    var parc = "";
    var path;

    if(pattern){
        bparams["fill-opacity"] = 0;
        bparams['stroke-opacity'] = attributes['stroke-opacity'] / 2;
        bparams['stroke'] = attributes['stroke'];
    }

    if (h > 0) {
        if (vml) {
            path = M + ax + comma + (ay + h) + L + bx + comma + (by + h);

            if (!isSmall) {
                path += A + (x - radius) + comma + (h + y - yRadius) + comma + (x + radius) + comma + (h + y + yRadius) + comma + (bx) + comma + (by + h) + comma + (cx) + comma + (cy + h);
            }

            path += L + dx + comma + (dy + h);

            if (innerRadius > 0) {
                if (!isSmall) {
                    path += " B" + (x - innerRadius) + comma + (h + y - yInnerRadius) + comma + (x + innerRadius) + comma + (h + y + yInnerRadius) + comma + dx + comma + (h + dy) + comma + ax + comma + (h + ay);
                }
            }
        } else {
            path = M + ax + comma + (ay + h) + L + bx + comma + (by + h);
            path += A + radius + comma + yRadius + comma + 0 + comma + lf + comma + sf + comma + cx + comma + (cy + h) + L + dx + comma + (dy + h);

            if (innerRadius > 0) {
                path += A + innerRadius + comma + yInnerRadius + comma + 0 + comma + lf + comma + 0 + comma + ax + comma + (ay + h);
            }
        }

        path += Z;
        var c = container.path(path, UNDEFINED, UNDEFINED, cs).attr(bparams);
        slice.push(c);
        var b1 = container.path(M + ax + comma + ay + L + ax + comma + (ay + h) + L + bx + comma + (by + h) + L + bx + comma + by + L + ax + comma + ay + Z, UNDEFINED, UNDEFINED, cs).attr(bparams);
        var b2 = container.path(M + cx + comma + cy + L + cx + comma + (cy + h) + L + dx + comma + (dy + h) + L + dx + comma + dy + L + cx + comma + cy + Z, UNDEFINED, UNDEFINED, cs).attr(bparams);
        slice.push(b1);
        slice.push(b2);
    }

    if (vml) {
        if (!isSmall) {
            parc = A + round(x - radius) + comma + round(y - yRadius) + comma + round(x + radius) + comma + round(y + yRadius) + comma + round(bx) + comma + round(by) + comma + round(cx) + comma + round(cy);
        }
        wpath = M + round(ax) + comma + round(ay) + L + round(bx) + comma + round(by) + parc + L + round(dx) + comma + round(dy);
    } else {
        parc = A + radius + comma + yRadius + comma + 0 + comma + lf + comma + sf + comma + cx + comma + cy;
        wpath = M + ax + comma + ay + L + bx + comma + by + parc + L + dx + comma + dy;
    }


    if (innerRadius > 0) {
        if (vml) {
            if (!isSmall) {
                wpath += B + (x - innerRadius) + comma + (y - yInnerRadius) + comma + (x + innerRadius) + comma + (y + yInnerRadius) + comma + dx + comma + dy + comma + ax + comma + ay;
            }
        } else {
            wpath += A + innerRadius + comma + yInnerRadius + comma + 0 + comma + lf + comma + 0 + comma + ax + comma + ay;
        }
    }


    if(container.handDrawn){
        var hdLine = AmCharts.line(container, [ax, bx], [ay, by], attributes.stroke, attributes.thickness * Math.random() * container.handDrawThickness, attributes["stroke-opacity"]);
        slice.push(hdLine);
    }


    wpath += Z;

    var w = container.path(wpath, UNDEFINED, UNDEFINED, cs).attr(attributes);

    if (gradientRatio) {
        var gradient = [];
        var i;
        for (i = 0; i < gradientRatio.length; i++) {
            gradient.push(AmCharts.adjustLuminosity(attributes.fill, gradientRatio[i]));
        }
        if (gradient.length > 0) {
            w.gradient("linearGradient", gradient);
        }
    }

    w.pattern(pattern);

    slice.push(w);
    return slice;
};

// Thanks Craig Buckler for this method:
// http://www.sitepoint.com/javascript-generate-lighter-darker-color/
AmCharts.adjustLuminosity = function (hex, lum) {
    hex = String(hex).replace(/[^0-9a-f]/gi, '');
    if (hex.length < 6) {
        hex = String(hex[0]) + String(hex[0]) + String(hex[1]) + String(hex[1]) + String(hex[2]) + String(hex[2]);
    }

    lum = lum || 0;

    var rgb = "#";
    var c;
    var i;

    for (i = 0; i < 3; i++) {
        c = parseInt(hex.substr(i * 2, 2), 16);
        c = Math.round(Math.min(Math.max(0, c + (c * lum)), 255)).toString(16);
        rgb += ("00" + c).substr(c.length);
    }
    return rgb;
};

// @tag amchart
AmCharts.themes.black = {

	themeName: "black",

	AmChart: {
		color: "#e7e7e7", backgroundColor: "#222222"
	},

	AmCoordinateChart: {
		colors: ["#de4c4f", "#d8854f", "#eea638", "#a7a737", "#86a965", "#8aabb0", "#69c8ff", "#cfd27e", "#9d9888", "#916b8a", "#724887", "#7256bc"]
	},

	AmStockChart: {
		colors: ["#de4c4f", "#d8854f", "#eea638", "#a7a737", "#86a965", "#8aabb0", "#69c8ff", "#cfd27e", "#9d9888", "#916b8a", "#724887", "#7256bc"]
	},

	AmSlicedChart: {
		outlineAlpha: 1,
		outlineThickness: 2,
		labelTickColor: "#FFFFFF",
		labelTickAlpha: 0.3,
		colors: ["#de4c4f", "#d8854f", "#eea638", "#a7a737", "#86a965", "#8aabb0", "#69c8ff", "#cfd27e", "#9d9888", "#916b8a", "#724887", "#7256bc"]
	},

	AmRectangularChart: {
		zoomOutButtonColor: '#FFFFFF',
		zoomOutButtonRollOverAlpha: 0.15,
		zoomOutButtonImage: "lensWhite.png"
	},

	AxisBase: {
		axisColor: "#FFFFFF",
		axisAlpha: 0.3,
		gridAlpha: 0.1,
		gridColor: "#FFFFFF",
		dashLength: 3
	},

	ChartScrollbar: {
		backgroundColor: "#000000",
		backgroundAlpha: 0.2,
		graphFillAlpha: 0.2,
		graphLineAlpha: 0,
		graphFillColor: "#FFFFFF",
		selectedGraphFillColor: "#FFFFFF",
		selectedGraphFillAlpha: 0.4,
		selectedGraphLineColor: "#FFFFFF",
		selectedBackgroundColor: "#FFFFFF",
		selectedBackgroundAlpha: 0.09,
		gridAlpha: 0.15
	},

	ChartCursor: {
		cursorColor: "#FFFFFF",
		color: "#000000",
		cursorAlpha: 0.5
	},

	AmLegend: {
		color: "#e7e7e7"
	},

	AmGraph: {
		lineAlpha: 0.9
	},


	GaugeArrow: {
		color: "#FFFFFF",
		alpha: 0.8,
		nailAlpha: 0,
		innerRadius: "40%",
		nailRadius: 15,
		startWidth: 15,
		borderAlpha: 0.8,
		nailBorderAlpha: 0
	},

	GaugeAxis: {
		tickColor: "#FFFFFF",
		tickAlpha: 1,
		tickLength: 15,
		minorTickLength: 8,
		axisThickness: 3,
		axisColor: '#FFFFFF',
		axisAlpha: 1,
		bandAlpha: 0.8
	},

	TrendLine: {
		lineColor: "#c03246",
		lineAlpha: 0.8
	},

	// ammap
	AreasSettings: {
		alpha: 0.8,
		color: "#FFFFFF",
		colorSolid: "#000000",
		unlistedAreasAlpha: 0.4,
		unlistedAreasColor: "#FFFFFF",
		outlineColor: "#000000",
		outlineAlpha: 0.5,
		outlineThickness: 0.5,
		rollOverColor: "#3c5bdc",
		rollOverOutlineColor: "#000000",
		selectedOutlineColor: "#000000",
		selectedColor: "#f15135",
		unlistedAreasOutlineColor: "#000000",
		unlistedAreasOutlineAlpha: 0.5
	},

	LinesSettings: {
		color: "#FFFFFF",
		alpha: 0.8
	},

	ImagesSettings: {
		alpha: 0.8,
		labelColor: "#FFFFFF",
		color: "#FFFFFF",
		labelRollOverColor: "#3c5bdc"
	},

	ZoomControl: {
		buttonRollOverColor: "#3c5bdc",
		buttonFillColor: "#738f58",
		buttonBorderColor: "#738f58",
		buttonFillAlpha: 0.8,
		gridBackgroundColor: "#FFFFFF",
		buttonBorderAlpha:0,
		buttonCornerRadius:2,
		gridAlpha:0.5,
		gridBackgroundColor:"#FFFFFF",
		homeIconFile:"homeIconWhite.gif",
		buttonIconAlpha:0.6,
		gridAlpha: 0.2,
		buttonSize:20
	},

	SmallMap: {
		mapColor: "#FFFFFF",
		rectangleColor: "#FFFFFF",
		backgroundColor: "#000000",
		backgroundAlpha: 0.7,
		borderThickness: 1,
		borderAlpha: 0.8
	},

	// the defaults below are set using CSS syntax, you can use any existing css property
	// if you don't use Stock chart, you can delete lines below
	PeriodSelector: {
		color: "#e7e7e7"
	},

	PeriodButton: {
		color: "#e7e7e7",
		background: "transparent",
		opacity: 0.7,
		border: "1px solid rgba(255, 255, 255, .15)",
		MozBorderRadius: "5px",
		borderRadius: "5px",
		margin: "1px",
		outline: "none",
		boxSizing: "border-box"
	},

	PeriodButtonSelected: {
		color: "#e7e7e7",
		backgroundColor: "rgba(255, 255, 255, 0.1)",
		border: "1px solid rgba(255, 255, 255, .3)",
		MozBorderRadius: "5px",
		borderRadius: "5px",
		margin: "1px",
		outline: "none",
		opacity: 1,
		boxSizing: "border-box"
	},

	PeriodInputField: {
		color: "#e7e7e7",
		background: "transparent",
		border: "1px solid rgba(255, 255, 255, .15)",
		outline: "none"
	},

	DataSetSelector: {
		color: "#e7e7e7",
		selectedBackgroundColor: "rgba(255, 255, 255, .25)",
		rollOverBackgroundColor: "rgba(255, 255, 255, .15)"
	},

	DataSetCompareList: {
		color: "#e7e7e7",
		lineHeight: "100%",
		boxSizing: "initial",
		webkitBoxSizing: "initial",
		border: "1px solid rgba(255, 255, 255, .15)"
	},

	DataSetSelect: {
		border: "1px solid rgba(255, 255, 255, .15)",
		outline: "none"
	}

};

// @tag amchart
AmCharts.themes.chalk = {

	themeName: "chalk",

	AmChart: {
		color: "#e7e7e7",
		fontFamily: "Covered By Your Grace",
		fontSize: 18,
		handDrawn: true,
		backgroundColor: "#282828"
	},

	AmCoordinateChart: {
		colors: ["#FFFFFF", "#e384a6", "#f4d499", "#4d90d6", "#c7e38c", "#9986c8", "#edf28c", "#ffd1d4", "#5ee1dc", "#b0eead", "#fef85a", "#8badd2"]
	},

	AmSlicedChart: {
		outlineAlpha: 1,
		labelTickColor: "#FFFFFF",
		labelTickAlpha: 0.3,
		colors: ["#FFFFFF", "#e384a6", "#f4d499", "#4d90d6", "#c7e38c", "#9986c8", "#edf28c", "#ffd1d4", "#5ee1dc", "#b0eead", "#fef85a", "#8badd2"]
	},

	AmStockChart: {
		colors: ["#FFFFFF", "#e384a6", "#f4d499", "#4d90d6", "#c7e38c", "#9986c8", "#edf28c", "#ffd1d4", "#5ee1dc", "#b0eead", "#fef85a", "#8badd2"]
	},

	AmRectangularChart: {

		zoomOutButtonColor: '#FFFFFF',
		zoomOutButtonRollOverAlpha: 0.15,
		zoomOutButtonImage: "lensWhite.png"
	},

	AxisBase: {
		axisColor: "#FFFFFF",
		gridColor: "#FFFFFF"
	},

	ChartScrollbar: {
		backgroundColor: "#FFFFFF",
		backgroundAlpha: 0.2,
		graphFillAlpha: 0.5,
		graphLineAlpha: 0,
		selectedBackgroundColor: "#000000",
		selectedBackgroundAlpha: 0.25,
		fontSize: 15,
		gridAlpha: 0.15
	},

	ChartCursor: {
		cursorColor: "#FFFFFF",
		color: "#000000"
	},

	AmLegend: {
		color: "#e7e7e7",
		markerSize: 20
	},

	AmGraph: {
		lineAlpha: 0.8
	},


	GaugeArrow: {
		color: "#FFFFFF",
		alpha: 0.1,
		nailAlpha: 0,
		innerRadius: "40%",
		nailRadius: 15,
		startWidth: 15,
		borderAlpha: 0.8,
		nailBorderAlpha: 0
	},

	GaugeAxis: {
		tickColor: "#FFFFFF",
		tickAlpha: 0.8,
		tickLength: 15,
		minorTickLength: 8,
		axisThickness: 3,
		axisColor: '#FFFFFF',
		axisAlpha: 0.8,
		bandAlpha: 0.4
	},

	TrendLine: {
		lineColor: "#c03246",
		lineAlpha: 0.8
	},

	// ammap
	AmMap: {
		handDrawn: false
	},

	AreasSettings: {
		alpha: 0.8,
		color: "#FFFFFF",
		colorSolid: "#000000",
		unlistedAreasAlpha: 0.4,
		unlistedAreasColor: "#FFFFFF",
		outlineColor: "#000000",
		outlineAlpha: 0.5,
		outlineThickness: 0.5,
		rollOverColor: "#4d90d6",
		rollOverOutlineColor: "#000000",
		selectedOutlineColor: "#000000",
		selectedColor: "#e384a6",
		unlistedAreasOutlineColor: "#000000",
		unlistedAreasOutlineAlpha: 0.5
	},

	LinesSettings: {
		color: "#FFFFFF",
		alpha: 0.8
	},

	ImagesSettings: {
		alpha: 0.8,
		labelFontSize: 16,
		labelColor: "#FFFFFF",
		color: "#FFFFFF",
		labelRollOverColor: "#4d90d6"
	},

	ZoomControl: {
		buttonRollOverColor: "#4d90d6",
		buttonFillColor: "#e384a6",
		buttonFillAlpha: 0.8,
		buttonBorderColor: "#FFFFFF",
		gridBackgroundColor: "#FFFFFF",
		gridAlpha: 0.8
	},

	SmallMap: {
		mapColor: "#FFFFFF",
		rectangleColor: "#FFFFFF",
		backgroundColor: "#000000",
		backgroundAlpha: 0.7,
		borderThickness: 1,
		borderAlpha: 0.8
	},


	// the defaults below are set using CSS syntax, you can use any existing css property
	// if you don't use Stock chart, you can delete lines below
	PeriodSelector: {
		fontFamily: "Covered By Your Grace",
		fontSize:"16px",
		color: "#e7e7e7"
	},

	PeriodButton: {
		fontFamily: "Covered By Your Grace",
		fontSize:"16px",
		color: "#e7e7e7",
		background: "transparent",
		opacity: 0.7,
		border: "1px solid rgba(255, 255, 255, .15)",
		MozBorderRadius: "5px",
		borderRadius: "5px",
		margin: "1px",
		outline: "none",
		boxSizing: "border-box"
	},

	PeriodButtonSelected: {
		fontFamily: "Covered By Your Grace",
		fontSize:"16px",
		color: "#e7e7e7",
		backgroundColor: "rgba(255, 255, 255, 0.1)",
		border: "1px solid rgba(255, 255, 255, .3)",
		MozBorderRadius: "5px",
		borderRadius: "5px",
		margin: "1px",
		outline: "none",
		opacity: 1,
		boxSizing: "border-box"
	},

	PeriodInputField: {
		fontFamily: "Covered By Your Grace",
		fontSize:"16px",
		color: "#e7e7e7",
		background: "transparent",
		border: "1px solid rgba(255, 255, 255, .15)",
		outline: "none"
	},

	DataSetSelector: {
		fontFamily: "Covered By Your Grace",
		fontSize:"16px",
		color: "#e7e7e7",
		selectedBackgroundColor: "rgba(255, 255, 255, .25)",
		rollOverBackgroundColor: "rgba(255, 255, 255, .15)"
	},

	DataSetCompareList: {
		fontFamily: "Covered By Your Grace",
		fontSize:"16px",
		color: "#e7e7e7",
		lineHeight: "100%",
		boxSizing: "initial",
		webkitBoxSizing: "initial",
		border: "1px solid rgba(255, 255, 255, .15)"
	},

	DataSetSelect: {
		fontFamily: "Covered By Your Grace",
		fontSize:"16px",
		border: "1px solid rgba(255, 255, 255, .15)",
		outline: "none"
	}

};

// @tag amchart
AmCharts.themes.dark = {

	themeName: "dark",

	AmChart: {
		color: "#e7e7e7", backgroundColor: "#282828"
	},

	AmCoordinateChart: {
		colors: ["#ae85c9", "#aab9f7", "#b6d2ff", "#c9e6f2", "#c9f0e1", "#e8d685", "#e0ad63", "#d48652", "#d27362", "#495fba", "#7a629b", "#8881cc"]
	},

	AmStockChart: {
		colors: ["#639dbd", "#e8d685", "#ae85c9", "#c9f0e1", "#d48652", "#629b6d", "#719dc3", "#719dc3"]
	},

	AmSlicedChart: {
		outlineAlpha: 1,
		outlineThickness: 2,
		labelTickColor: "#FFFFFF",
		labelTickAlpha: 0.3,
		colors: ["#495fba", "#e8d685", "#ae85c9", "#c9f0e1", "#d48652", "#629b6d", "#719dc3", "#719dc3"]
	},

	AmRectangularChart: {
		zoomOutButtonColor: '#FFFFFF',
		zoomOutButtonRollOverAlpha: 0.15,
		zoomOutButtonImage: "lensWhite.png"
	},

	AxisBase: {
		axisColor: "#FFFFFF",
		axisAlpha: 0.3,
		gridAlpha: 0.1,
		gridColor: "#FFFFFF",
		dashLength: 3
	},

	ChartScrollbar: {
		backgroundColor: "#000000",
		backgroundAlpha: 0.2,
		graphFillAlpha: 0.2,
		graphLineAlpha: 0,
		graphFillColor: "#FFFFFF",
		selectedGraphFillColor: "#FFFFFF",
		selectedGraphFillAlpha: 0.4,
		selectedGraphLineColor: "#FFFFFF",
		selectedBackgroundColor: "#FFFFFF",
		selectedBackgroundAlpha: 0.09,
		gridAlpha: 0.15
	},

	ChartCursor: {
		cursorColor: "#FFFFFF",
		color: "#000000",
		cursorAlpha: 0.5
	},

	AmLegend: {
		color: "#e7e7e7"
	},

	AmGraph: {
		lineAlpha: 0.9
	},


	GaugeArrow: {
		color: "#FFFFFF",
		alpha: 0.8,
		nailAlpha: 0,
		innerRadius: "40%",
		nailRadius: 15,
		startWidth: 15,
		borderAlpha: 0.8,
		nailBorderAlpha: 0
	},

	GaugeAxis: {
		tickColor: "#FFFFFF",
		tickAlpha: 1,
		tickLength: 15,
		minorTickLength: 8,
		axisThickness: 3,
		axisColor: '#FFFFFF',
		axisAlpha: 1,
		bandAlpha: 0.8
	},

	TrendLine: {
		lineColor: "#c03246",
		lineAlpha: 0.8
	},

	// ammap
	AreasSettings: {
		alpha: 0.8,
		color: "#FFFFFF",
		colorSolid: "#000000",
		unlistedAreasAlpha: 0.4,
		unlistedAreasColor: "#FFFFFF",
		outlineColor: "#000000",
		outlineAlpha: 0.5,
		outlineThickness: 0.5,
		rollOverColor: "#3c5bdc",
		rollOverOutlineColor: "#000000",
		selectedOutlineColor: "#000000",
		selectedColor: "#f15135",
		unlistedAreasOutlineColor: "#000000",
		unlistedAreasOutlineAlpha: 0.5
	},

	LinesSettings: {
		color: "#FFFFFF",
		alpha: 0.8
	},

	ImagesSettings: {
		alpha: 0.8,
		labelColor: "#FFFFFF",
		color: "#FFFFFF",
		labelRollOverColor: "#3c5bdc"
	},

	ZoomControl: {
		buttonRollOverColor: "#3c5bdc",
		buttonFillColor: "#f15135",
		buttonFillAlpha: 0.8,
		gridBackgroundColor: "#FFFFFF",
		buttonBorderAlpha:0,
		buttonCornerRadius:2,
		gridAlpha:0.5,
		gridBackgroundColor:"#FFFFFF",
		homeIconFile:"homeIconWhite.gif",
		buttonIconAlpha:0.6,
		gridAlpha: 0.2,
		buttonSize:20
	},

	SmallMap: {
		mapColor: "#FFFFFF",
		rectangleColor: "#FFFFFF",
		backgroundColor: "#000000",
		backgroundAlpha: 0.7,
		borderThickness: 1,
		borderAlpha: 0.8
	},

	// the defaults below are set using CSS syntax, you can use any existing css property
	// if you don't use Stock chart, you can delete lines below
	PeriodSelector: {
		color: "#e7e7e7"
	},

	PeriodButton: {
		color: "#e7e7e7",
		background: "transparent",
		opacity: 0.7,
		border: "1px solid rgba(255, 255, 255, .15)",
		MozBorderRadius: "5px",
		borderRadius: "5px",
		margin: "1px",
		outline: "none",
		boxSizing: "border-box"
	},

	PeriodButtonSelected: {
		color: "#e7e7e7",
		backgroundColor: "rgba(255, 255, 255, 0.1)",
		border: "1px solid rgba(255, 255, 255, .3)",
		MozBorderRadius: "5px",
		borderRadius: "5px",
		margin: "1px",
		outline: "none",
		opacity: 1,
		boxSizing: "border-box"
	},

	PeriodInputField: {
		color: "#e7e7e7",
		background: "transparent",
		border: "1px solid rgba(255, 255, 255, .15)",
		outline: "none"
	},

	DataSetSelector: {
		color: "#e7e7e7",
		selectedBackgroundColor: "rgba(255, 255, 255, .25)",
		rollOverBackgroundColor: "rgba(255, 255, 255, .15)"
	},

	DataSetCompareList: {
		color: "#e7e7e7",
		lineHeight: "100%",
		boxSizing: "initial",
		webkitBoxSizing: "initial",
		border: "1px solid rgba(255, 255, 255, .15)"
	},

	DataSetSelect: {
		border: "1px solid rgba(255, 255, 255, .15)",
		outline: "none"
	}

};

// @tag amchart
AmCharts.themes.light = {

	themeName:"light",

	AmChart: {
		color: "#000000", backgroundColor: "#FFFFFF"
	},

	AmCoordinateChart: {
		colors: ["#67b7dc", "#fdd400", "#84b761", "#cc4748", "#cd82ad", "#2f4074", "#448e4d", "#b7b83f", "#b9783f", "#b93e3d", "#913167"]
	},

	AmStockChart: {
		colors: ["#67b7dc", "#fdd400", "#84b761", "#cc4748", "#cd82ad", "#2f4074", "#448e4d", "#b7b83f", "#b9783f", "#b93e3d", "#913167"]
	},

	AmSlicedChart: {
		colors: ["#67b7dc", "#fdd400", "#84b761", "#cc4748", "#cd82ad", "#2f4074", "#448e4d", "#b7b83f", "#b9783f", "#b93e3d", "#913167"],
		outlineAlpha: 1,
		outlineThickness: 2,
		labelTickColor: "#000000",
		labelTickAlpha: 0.3
	},

	AmRectangularChart: {
		zoomOutButtonColor: '#000000',
		zoomOutButtonRollOverAlpha: 0.15,
		zoomOutButtonImage: "lens.png"
	},

	AxisBase: {
		axisColor: "#000000",
		axisAlpha: 0.3,
		gridAlpha: 0.1,
		gridColor: "#000000"
	},

	ChartScrollbar: {
		backgroundColor: "#000000",
		backgroundAlpha: 0.12,
		graphFillAlpha: 0.5,
		graphLineAlpha: 0,
		selectedBackgroundColor: "#FFFFFF",
		selectedBackgroundAlpha: 0.4,
		gridAlpha: 0.15
	},

	ChartCursor: {
		cursorColor: "#000000",
		color: "#FFFFFF",
		cursorAlpha: 0.5
	},

	AmLegend: {
		color: "#000000"
	},

	AmGraph: {
		lineAlpha: 0.9
	},
	GaugeArrow: {
		color: "#000000",
		alpha: 0.8,
		nailAlpha: 0,
		innerRadius: "40%",
		nailRadius: 15,
		startWidth: 15,
		borderAlpha: 0.8,
		nailBorderAlpha: 0
	},

	GaugeAxis: {
		tickColor: "#000000",
		tickAlpha: 1,
		tickLength: 15,
		minorTickLength: 8,
		axisThickness: 3,
		axisColor: '#000000',
		axisAlpha: 1,
		bandAlpha: 0.8
	},

	TrendLine: {
		lineColor: "#c03246",
		lineAlpha: 0.8
	},

	// ammap
	AreasSettings: {
		alpha: 0.8,
		color: "#67b7dc",
		colorSolid: "#003767",
		unlistedAreasAlpha: 0.4,
		unlistedAreasColor: "#000000",
		outlineColor: "#FFFFFF",
		outlineAlpha: 0.5,
		outlineThickness: 0.5,
		rollOverColor: "#3c5bdc",
		rollOverOutlineColor: "#FFFFFF",
		selectedOutlineColor: "#FFFFFF",
		selectedColor: "#f15135",
		unlistedAreasOutlineColor: "#FFFFFF",
		unlistedAreasOutlineAlpha: 0.5
	},

	LinesSettings: {
		color: "#000000",
		alpha: 0.8
	},

	ImagesSettings: {
		alpha: 0.8,
		labelColor: "#000000",
		color: "#000000",
		labelRollOverColor: "#3c5bdc"
	},

	ZoomControl: {
		buttonRollOverColor: "#3c5bdc",
		buttonFillColor: "#3994e2",
		buttonBorderColor: "#3994e2",
		buttonFillAlpha: 0.8,
		gridBackgroundColor: "#FFFFFF",
		buttonBorderAlpha:0,
		buttonCornerRadius:2,
		gridColor:"#FFFFFF",
		gridBackgroundColor:"#000000",
		buttonIconAlpha:0.6,
		gridAlpha: 0.6,
		buttonSize:20
	},

	SmallMap: {
		mapColor: "#000000",
		rectangleColor: "#f15135",
		backgroundColor: "#FFFFFF",
		backgroundAlpha: 0.7,
		borderThickness: 1,
		borderAlpha: 0.8
	},

	// the defaults below are set using CSS syntax, you can use any existing css property
	// if you don't use Stock chart, you can delete lines below
	PeriodSelector: {
		color: "#000000"
	},

	PeriodButton: {
		color: "#000000",
		background: "transparent",
		opacity: 0.7,
		border: "1px solid rgba(0, 0, 0, .3)",
		MozBorderRadius: "5px",
		borderRadius: "5px",
		margin: "1px",
		outline: "none",
		boxSizing: "border-box"
	},

	PeriodButtonSelected: {
		color: "#000000",
		backgroundColor: "#b9cdf5",
		border: "1px solid rgba(0, 0, 0, .3)",
		MozBorderRadius: "5px",
		borderRadius: "5px",
		margin: "1px",
		outline: "none",
		opacity: 1,
		boxSizing: "border-box"
	},

	PeriodInputField: {
		color: "#000000",
		background: "transparent",
		border: "1px solid rgba(0, 0, 0, .3)",
		outline: "none"
	},

	DataSetSelector: {

		color: "#000000",
		selectedBackgroundColor: "#b9cdf5",
		rollOverBackgroundColor: "#a8b0e4"
	},

	DataSetCompareList: {
		color: "#000000",
		lineHeight: "100%",
		boxSizing: "initial",
		webkitBoxSizing: "initial",
		border: "1px solid rgba(0, 0, 0, .3)"
	},

	DataSetSelect: {
		border: "1px solid rgba(0, 0, 0, .3)",
		outline: "none"
	}

};

// @tag amchart
AmCharts.themes.patterns = {

	themeName:"patterns",

	AmChart: {
		color: "#000000", backgroundColor: "#FFFFFF"
	},

	AmCoordinateChart: {
		colors:["#000000","#000000","#000000","#000000","#000000","#000000","#000000","#000000","#000000","#000000","#000000","#000000","#000000","#000000","#000000","#000000","#000000","#000000","#000000","#000000","#000000"],
		patterns:[
		{"url":"../amcharts/patterns/black/pattern1.png", "width":4, "height":4},
		{"url":"../amcharts/patterns/black/pattern2.png", "width":4, "height":4},
		{"url":"../amcharts/patterns/black/pattern3.png", "width":4, "height":4},
		{"url":"../amcharts/patterns/black/pattern4.png", "width":4, "height":4},
		{"url":"../amcharts/patterns/black/pattern5.png", "width":4, "height":4},
		{"url":"../amcharts/patterns/black/pattern6.png", "width":4, "height":4},
		{"url":"../amcharts/patterns/black/pattern7.png", "width":4, "height":4},
		{"url":"../amcharts/patterns/black/pattern8.png", "width":4, "height":4},
		{"url":"../amcharts/patterns/black/pattern9.png", "width":4, "height":4},
		{"url":"../amcharts/patterns/black/pattern10.png", "width":4, "height":4},
		{"url":"../amcharts/patterns/black/pattern11.png", "width":4, "height":4},
		{"url":"../amcharts/patterns/black/pattern12.png", "width":4, "height":4},
		{"url":"../amcharts/patterns/black/pattern13.png", "width":4, "height":4},
		{"url":"../amcharts/patterns/black/pattern14.png", "width":4, "height":4},
		{"url":"../amcharts/patterns/black/pattern15.png", "width":4, "height":4},
		{"url":"../amcharts/patterns/black/pattern16.png", "width":4, "height":4},
		{"url":"../amcharts/patterns/black/pattern17.png", "width":4, "height":4},
		{"url":"../amcharts/patterns/black/pattern18.png", "width":4, "height":4},
		{"url":"../amcharts/patterns/black/pattern19.png", "width":4, "height":4},
		{"url":"../amcharts/patterns/black/pattern20.png", "width":4, "height":4},
		{"url":"../amcharts/patterns/black/pattern21.png", "width":4, "height":4}]
	},


	AmStockChart: {
		colors:["#000000","#000000","#000000","#000000","#000000","#000000","#000000","#000000","#000000","#000000","#000000","#000000","#000000","#000000","#000000","#000000","#000000","#000000","#000000","#000000","#000000"]
	},

	AmPieChart: {
		depth3D:0,
		angle:0,
		labelRadius:10
	},

	AmSlicedChart: {
		outlineAlpha: 0.3,
		colors:["#000000","#000000","#000000","#000000","#000000","#000000","#000000","#000000","#000000","#000000","#000000","#000000","#000000","#000000","#000000","#000000","#000000","#000000","#000000","#000000","#000000"],
		outlineThickness: 1,
		outlineColor:"#000000",
		labelTickColor: "#000000",
		labelTickAlpha: 0.3,
		patterns:[
		{"url":"../amcharts/patterns/black/pattern1.png", "width":4, "height":4},
		{"url":"../amcharts/patterns/black/pattern2.png", "width":4, "height":4},
		{"url":"../amcharts/patterns/black/pattern3.png", "width":4, "height":4},
		{"url":"../amcharts/patterns/black/pattern4.png", "width":4, "height":4},
		{"url":"../amcharts/patterns/black/pattern5.png", "width":4, "height":4},
		{"url":"../amcharts/patterns/black/pattern6.png", "width":4, "height":4},
		{"url":"../amcharts/patterns/black/pattern7.png", "width":4, "height":4},
		{"url":"../amcharts/patterns/black/pattern8.png", "width":4, "height":4},
		{"url":"../amcharts/patterns/black/pattern9.png", "width":4, "height":4},
		{"url":"../amcharts/patterns/black/pattern10.png", "width":4, "height":4},
		{"url":"../amcharts/patterns/black/pattern11.png", "width":4, "height":4},
		{"url":"../amcharts/patterns/black/pattern12.png", "width":4, "height":4},
		{"url":"../amcharts/patterns/black/pattern13.png", "width":4, "height":4},
		{"url":"../amcharts/patterns/black/pattern14.png", "width":4, "height":4},
		{"url":"../amcharts/patterns/black/pattern15.png", "width":4, "height":4},
		{"url":"../amcharts/patterns/black/pattern16.png", "width":4, "height":4},
		{"url":"../amcharts/patterns/black/pattern17.png", "width":4, "height":4},
		{"url":"../amcharts/patterns/black/pattern18.png", "width":4, "height":4},
		{"url":"../amcharts/patterns/black/pattern19.png", "width":4, "height":4},
		{"url":"../amcharts/patterns/black/pattern20.png", "width":4, "height":4},
		{"url":"../amcharts/patterns/black/pattern21.png", "width":4, "height":4}]
	},

	AmRectangularChart: {
		zoomOutButtonColor: '#000000',
		zoomOutButtonRollOverAlpha: 0.15,
		zoomOutButtonImage: "lens.png"
	},



	AxisBase: {
		axisColor: "#000000",
		axisAlpha: 0.3,
		gridAlpha: 0.05,
		gridColor: "#000000"
	},

	ChartScrollbar: {
		backgroundColor: "#000000",
		backgroundAlpha: 0.13,
		graphFillAlpha: 0.4,
		selectedGraphFillAlpha: 0.7,
		graphLineAlpha: 0,
		selectedBackgroundColor: "#FFFFFF",
		selectedBackgroundAlpha: 0.9,
		gridAlpha: 0.15
	},

	ChartCursor: {
		cursorColor: "#000000",
		color: "#FFFFFF",
		cursorAlpha: 0.5
	},

	AmLegend: {
		color: "#000000",
		markerBorderAlpha:0.1,
		markerSize:20,
		switchColor:"#000000"
	},

	AmGraph: {
		lineAlpha: 0.4,
		fillAlphas:0.5
	},

	AmAngularGauge:{
		faceAlpha:0.5,
		facePattern:{"url":"../amcharts/patterns/black/pattern1.png", "width":4, "height":4}
	},


	GaugeArrow: {
		color: "#000000",
		alpha: 1,
		nailAlpha: 1,
		innerRadius: "0%",
		nailRadius: 15,
		startWidth: 15,
		borderAlpha: 1,
		radius:"70%",
		nailBorderAlpha: 1
	},

	GaugeAxis: {
		tickColor: "#000000",
		tickAlpha: 1,
		tickLength: 15,
		minorTickLength: 8,
		axisThickness: 1,
		axisColor: '#000000',
		axisAlpha: 1,
		bandAlpha: 1
	},

	TrendLine: {
		lineColor: "#c03246",
		lineAlpha: 0.8
	},

	// ammap
	AreasSettings: {
		alpha: 0.8,
		color: "#000000",
		colorSolid: "#000000",
		unlistedAreasAlpha: 0.4,
		unlistedAreasColor: "#000000",
		outlineColor: "#FFFFFF",
		outlineAlpha: 0.5,
		outlineThickness: 0.5,
		rollOverColor: "#3c5bdc",
		rollOverOutlineColor: "#FFFFFF",
		selectedOutlineColor: "#FFFFFF",
		selectedColor: "#f15135",
		unlistedAreasOutlineColor: "#FFFFFF",
		unlistedAreasOutlineAlpha: 0.5
	},

	LinesSettings: {
		color: "#000000",
		alpha: 0.8
	},

	ImagesSettings: {
		alpha: 0.8,
		labelColor: "#000000",
		color: "#000000",
		labelRollOverColor: "#3c5bdc"
	},

	ZoomControl: {
		buttonRollOverColor: "#3c5bdc",
		buttonFillColor: "#f15135",
		buttonFillAlpha: 0.8,
		buttonBorderColor: "#000000",
		gridBackgroundColor: "#000000",
		gridAlpha: 0.8
	},

	SmallMap: {
		mapColor: "#000000",
		rectangleColor: "#FFFFFF",
		backgroundColor: "#FFFFFF",
		backgroundAlpha: 0.7,
		borderThickness: 1,
		borderAlpha: 0.8
	},

	// the defaults below are set using CSS syntax, you can use any existing css property
	// if you don't use Stock chart, you can delete lines below
	PeriodSelector: {
		color: "#000000"
	},

	PeriodButton: {
		color: "#000000",
		background: "transparent",
		opacity: 0.7,
		border: "1px solid rgba(0, 0, 0, .3)",
		MozBorderRadius: "5px",
		borderRadius: "5px",
		margin: "1px",
		outline: "none",
		boxSizing: "border-box"
	},

	PeriodButtonSelected: {
		color: "#000000",
		backgroundColor: "rgba(0, 0, 0, 0.1)",
		border: "1px solid rgba(0, 0, 0, .3)",
		MozBorderRadius: "5px",
		borderRadius: "5px",
		margin: "1px",
		outline: "none",
		opacity: 1,
		boxSizing: "border-box"
	},

	PeriodInputField: {
		color: "#000000",
		background: "transparent",
		border: "1px solid rgba(0, 0, 0, .3)",
		outline: "none"
	},

	DataSetSelector: {
		color: "#000000",
		selectedBackgroundColor: "rgba(0, 0, 0, .25)",
		rollOverBackgroundColor: "rgba(0, 0, 0, .15)"
	},

	DataSetCompareList: {
		color: "#000000",
		lineHeight: "100%",
		boxSizing: "initial",
		webkitBoxSizing: "initial",
		border: "1px solid rgba(0, 0, 0, .3)"
	},

	DataSetSelect: {
		border: "1px solid rgba(0, 0, 0, .3)",
		outline: "none"
	}

};

// @tag amchart
/**
 * Copyright (c) 2009 Jason S. Kerchner. All rights reserved.
 * Code released under the BSD license:
 * http://livingmachines.net/license
 * Redistribution must include this complete copyright notice.
 */



/**
 * Create a AmCharts namespace for our library.
 * @type object
 */
if (!AmCharts) {
    var AmCharts = {};
    AmCharts.themes = {};
    AmCharts.maps = {};
    AmCharts.inheriting = {};
    AmCharts.charts = [];
    AmCharts.onReadyArray = [];
    AmCharts.useUTC = false;
    AmCharts.updateRate = 40;
    AmCharts.uid = 0;
}

/**
 * Used to indicate that we are in the process of creating a new inherited class.
 * @type object
 */


/**
 * Creates a new constructor function based on the given initialization object.
 * Executing the constructor using the new keyword will create a new class
 * that supports inheritance, property and methods overrides, and the ability
 * to call base class methods.  The following is an example of how to use
 * the Class function.  In this example, we have an already existing class,
 * Person, and we are inheriting a new class from it, Employee.
 *
 * <pre>
 * Employee = Class({
 *
 *   // Inherits from person
 *   inherits: Person,
 *
 *   // This is the constructor
 *   construct: function(first, last, company) {
 *     // Calls base class constructor
 *     Employee.base.construct.call(this, first, last);
 *     this.company = company;
 *   },
 *
 *   // New method added to this class
 *   getWebSite: function() {
 *     return 'http://www.' + this.company + '.com';
 *   },
 *
 *   // Overrides method in Person (and calls base class method)
 *   getFullName: function(firstLastFormat) {
 *     if (firstLastFormat)
 *       return Employee.base.getFullName.call(this);
 *     else
 *       return this.lastName + ', ' + this.firstName;
 *     }
 *
 * });
 * </pre>
 *
 * @param {Object} init The initialization object.
 * @return {Function} Returns the new constructor function (e.g. the class)
 */
AmCharts.Class = function (init) {
    // Create constructor function that will check if we are inheriting,
    // then call real constructor
    var cstr = function () {
        if (arguments[0] === AmCharts.inheriting) return;
        this.events = {};
        this.construct.apply(this, arguments);
    };

    // If we are inheriting, copy the prototype, otherwise assign a new prototype
    if (init.inherits) {
        cstr.prototype = new init.inherits(AmCharts.inheriting);
        cstr.base = init.inherits.prototype;
        delete init.inherits; // Keeps it from being added to the prototype later
    } else {

        // Since we are not inheriting, then we must add event methods,
        // otherwise they will be included via inheritance.
        cstr.prototype.createEvents = function ( /* event */ ) {
            for (var i = 0, len = arguments.length; i < len; i++)
            this.events[arguments[i]] = [];
        };

        cstr.prototype.listenTo = function (obj, event, handler) {

            this.removeListener(obj, event, handler);

            obj.events[event].push({
                handler: handler,
                scope: this
            });
        };

        cstr.prototype.addListener = function (event, handler, obj) {

            this.removeListener(this, event, handler);

            this.events[event].push({
                handler: handler,
                scope: obj
            });
        };

        cstr.prototype.removeListener = function (obj, event, handler) {
            if(obj){
                if(obj.events){
                    var ev = obj.events[event];
                    // Loop down, just in case handler was added multiple times (and will be removed multiple times)
                    for (var i = ev.length - 1; i >= 0; i--) {
                        if (ev[i].handler === handler) ev.splice(i, 1); // Deletes one element starting at index i
                    }
                }
            }
        };

        cstr.prototype.fire = function (event, data) {
            var handlers = this.events[event];
            for (var i = 0, len = handlers.length; i < len; i++) {
                var h = handlers[i];
                h.handler.call(h.scope, data);
            }
        };
    }

    // Copy init properties to the prototype (adds/overrides base class methods)
    for (var p in init)
    cstr.prototype[p] = init[p];

    // Return the constructor function (this is the class)
    return cstr;

};



AmCharts.addChart = function (chart) {
    AmCharts.charts.push(chart);
};

AmCharts.removeChart = function (chart) {
    var charts = AmCharts.charts;
    for (var i = charts.length - 1; i >= 0; i--) {
        if (charts[i] == chart) {
            charts.splice(i, 1);
        }
    }
};


// check ie version
AmCharts.IEversion = 0;
AmCharts.isModern = true;

AmCharts.navigator = navigator.userAgent.toLowerCase();
if (AmCharts.navigator.indexOf("msie") != -1) {
    AmCharts.IEversion = parseInt(AmCharts.navigator.split('msie')[1]);

    if (document.documentMode) {
        AmCharts.IEversion = Number(document.documentMode);
    }
    if (AmCharts.IEversion < 9) {
        AmCharts.isModern = false;
    }
}

AmCharts.dx = 0;
AmCharts.dy = 0;

// check browser
if (document.addEventListener || window.opera) {
    AmCharts.isNN = true;
    AmCharts.isIE = false;
    AmCharts.dx = 0.5;
    AmCharts.dy = 0.5;
}

if (document.attachEvent) {
    AmCharts.isNN = false;
    AmCharts.isIE = true;
    if (!AmCharts.isModern) {
        AmCharts.dx = 0;
        AmCharts.dy = 0;
    }
}



if (window.chrome) {
    AmCharts.chrome = true;
}

// event handlers
AmCharts.handleResize = function () {
    var charts = AmCharts.charts;

    for (var i = 0; i < charts.length; i++) {
        var chart = charts[i];

        if (chart) {
            if (chart.div) {
                chart.handleResize();
            }
        }
    }
};

AmCharts.handleMouseUp = function (e) {
    var charts = AmCharts.charts;

    for (var i = 0; i < charts.length; i++) {
        var chart = charts[i];

        if (chart) {
            chart.handleReleaseOutside(e);
        }
    }
};

AmCharts.handleMouseMove = function (e) {
    var charts = AmCharts.charts;
    for (var i = 0; i < charts.length; i++) {
        var chart = charts[i];

        if (chart) {
            chart.handleMouseMove(e);
        }
    }
};

AmCharts.resetMouseOver = function () {
    var charts = AmCharts.charts;
    for (var i = 0; i < charts.length; i++) {
        var chart = charts[i];

        if (chart) {
            chart.mouseIsOver = false;
        }
    }
};


AmCharts.ready = function (value) {
    AmCharts.onReadyArray.push(value);
};

AmCharts.handleLoad = function () {
    AmCharts.isReady = true;
    var onReadyArray = AmCharts.onReadyArray;
    for (var i = 0; i < onReadyArray.length; i++) {
        var fnc = onReadyArray[i];
        if(isNaN(AmCharts.processDelay)){
            fnc();
        }
        else{
            setTimeout(fnc, AmCharts.processDelay * i);
        }
    }
};


AmCharts.getUniqueId = function () {
    AmCharts.uid++;
    return "AmChartsEl-" + AmCharts.uid;
};

// add events for NN/FF/etc
if (AmCharts.isNN) {
    document.addEventListener('mousemove', AmCharts.handleMouseMove, true);
    window.addEventListener('resize', AmCharts.handleResize, true);
    document.addEventListener("mouseup", AmCharts.handleMouseUp, true);
    window.addEventListener('load', AmCharts.handleLoad, true);
}

if (AmCharts.isIE) {
    document.attachEvent('onmousemove', AmCharts.handleMouseMove);
    window.attachEvent('onresize', AmCharts.handleResize);
    document.attachEvent("onmouseup", AmCharts.handleMouseUp);
    window.attachEvent('onload', AmCharts.handleLoad);
}

AmCharts.clear = function () {

    var charts = AmCharts.charts;
    if (charts) {
        for (var i = 0; i < charts.length; i++) {
            charts[i].clear();
        }
    }

    AmCharts.charts = null;

    if (AmCharts.isNN) {
        document.removeEventListener('mousemove', AmCharts.handleMouseMove, true);
        window.removeEventListener('resize', AmCharts.handleResize, true);
        document.removeEventListener("mouseup", AmCharts.handleMouseUp, true);
        window.removeEventListener('load', AmCharts.handleLoad, true);
    }

    if (AmCharts.isIE) {
        document.detachEvent('onmousemove', AmCharts.handleMouseMove);
        window.detachEvent('onresize', AmCharts.handleResize);
        document.detachEvent("onmouseup", AmCharts.handleMouseUp);
        window.detachEvent('onload', AmCharts.handleLoad);
    }
};


AmCharts.makeChart =  function(div, config, amDelay){
    var type = config.type;
    var theme = config.theme;

    if(AmCharts.isString(theme)){
        theme = AmCharts.themes[theme];
        config.theme = theme;
    }

    var chart;
    switch (type){
        case "serial":
            chart = new AmCharts.AmSerialChart(theme);
            break;
        case "xy":
            chart = new AmCharts.AmXYChart(theme);
            break;
        case "pie":
            chart = new AmCharts.AmPieChart(theme);
            break;
        case "radar":
            chart = new AmCharts.AmRadarChart(theme);
            break;
        case "gauge":
            chart = new AmCharts.AmAngularGauge(theme);
            break;
        case "funnel":
            chart = new AmCharts.AmFunnelChart(theme);
            break;
        case "map":
            chart = new AmCharts.AmMap(theme);
            break;
        case "stock":
            chart = new AmCharts.AmStockChart(theme);
            break;
    }

    AmCharts.extend(chart, config);

    if(AmCharts.isReady){
        if(isNaN(amDelay)){
            chart.write(div);
        }
        else{
            setTimeout(function() {
                AmCharts.realWrite(chart, div);
            }, amDelay);
        }
    }
    else{
        AmCharts.ready(function () {
            if(isNaN(amDelay)){
                chart.write(div);
            }
            else{
                setTimeout(function() {
                    AmCharts.realWrite(chart, div);
                }, amDelay);
            }
        });
    }
    return chart;
};

AmCharts.realWrite = function(chart, div){
    chart.write(div);
};

// @tag amchart
AmCharts.formatMilliseconds = function (string, date) {
    if (string.indexOf("fff") != -1) {
        var milliseconds = date.getMilliseconds();
        var mString = String(milliseconds);
        if (milliseconds < 10) {
            mString = "00" + milliseconds;
        }
        if (milliseconds >= 10 && milliseconds < 100) {
            mString = "0" + milliseconds;
        }

        string = string.replace(/fff/g, mString);
    }

    return string;
};

AmCharts.extractPeriod = function (period) {
    var cleanPeriod = AmCharts.stripNumbers(period);
    var count = 1;
    if (cleanPeriod != period) {
        count = Number(period.slice(0, period.indexOf(cleanPeriod)));
    }
    return {
        period: cleanPeriod,
        count: count
    };
};


// RESET DATE'S LOWER PERIODS TO MIN
AmCharts.resetDateToMin = function (date, period, count, firstDateOfWeek) {
    if (firstDateOfWeek === undefined) {
        firstDateOfWeek = 1;
    }

    var year;
    var month;
    var day;
    var hours;
    var minutes;
    var seconds;
    var milliseconds;
    var week_day;

    if (AmCharts.useUTC) {
        year = date.getUTCFullYear();
        month = date.getUTCMonth();
        day = date.getUTCDate();
        hours = date.getUTCHours();
        minutes = date.getUTCMinutes();
        seconds = date.getUTCSeconds();
        milliseconds = date.getUTCMilliseconds();
        week_day = date.getUTCDay();
    } else {
        year = date.getFullYear();
        month = date.getMonth();
        day = date.getDate();
        hours = date.getHours();
        minutes = date.getMinutes();
        seconds = date.getSeconds();
        milliseconds = date.getMilliseconds();
        week_day = date.getDay();
    }

    switch (period) {
        case "YYYY":
            year = Math.floor(year / count) * count;
            month = 0;
            day = 1;
            hours = 0;
            minutes = 0;
            seconds = 0;
            milliseconds = 0;
            break;

        case "MM":
            month = Math.floor(month / count) * count;
            day = 1;
            hours = 0;
            minutes = 0;
            seconds = 0;
            milliseconds = 0;
            break;

        case "WW":
            if (week_day === 0 && firstDateOfWeek > 0) {
                week_day = 7;
            }
            day = day - week_day + firstDateOfWeek;
            hours = 0;
            minutes = 0;
            seconds = 0;
            milliseconds = 0;
            break;

        case "DD":
            //day = Math.floor(day / count) * count;
            day = day;
            hours = 0;
            minutes = 0;
            seconds = 0;
            milliseconds = 0;
            break;

        case "hh":
            hours = Math.floor(hours / count) * count;
            minutes = 0;
            seconds = 0;
            milliseconds = 0;
            break;

        case "mm":
            minutes = Math.floor(minutes / count) * count;
            seconds = 0;
            milliseconds = 0;
            break;

        case "ss":
            seconds = Math.floor(seconds / count) * count;
            milliseconds = 0;
            break;

        case "fff":
            milliseconds = Math.floor(milliseconds / count) * count;
            break;
    }

    if (AmCharts.useUTC) {
        date = new Date();
        date.setUTCFullYear(year, month, day);
        //date.setUTCMonth(month);
        //date.setUTCDate(day);
        date.setUTCHours(hours, minutes, seconds, milliseconds);
        //date.setUTCMinutes(minutes);
        //date.setUTCSeconds(seconds);
        //date.setUTCMilliseconds(milliseconds);
    } else {
        date = new Date(year, month, day, hours, minutes, seconds, milliseconds);
    }


    return date;
};

AmCharts.getPeriodDuration = function (period, count) {
    if (count === undefined) {
        count = 1;
    }
    var duration;
    switch (period) {
        case "YYYY":
            duration = 31622400000;
            break;
        case "MM":
            duration = 2678400000;
            break;
        case "WW":
            duration = 604800000;
            break;
        case "DD":
            duration = 86400000;
            break;
        case "hh":
            duration = 3600000;
            break;
        case "mm":
            duration = 60000;
            break;
        case "ss":
            duration = 1000;
            break;
        case "fff":
            duration = 1;
            break;
    }
    return duration * count;
};


AmCharts.intervals = {
    s: {
        nextInterval: "ss",
        contains: 1000
    },
    ss: {
        nextInterval: "mm",
        contains: 60,
        count: 0
    },
    mm: {
        nextInterval: "hh",
        contains: 60,
        count: 1
    },
    hh: {
        nextInterval: "DD",
        contains: 24,
        count: 2
    },
    DD: {
        nextInterval: "",
        contains: Infinity,
        count: 3
    }
};

AmCharts.getMaxInterval = function (duration, interval) {
    var intervals = AmCharts.intervals;
    if (duration >= intervals[interval].contains) {
        duration = Math.round(duration / intervals[interval].contains);
        interval = intervals[interval].nextInterval;

        return AmCharts.getMaxInterval(duration, interval);
    } else {
        if (interval == "ss") {
            return intervals[interval].nextInterval;
        } else {
            return interval;
        }
    }
};


AmCharts.dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
AmCharts.shortDayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];

AmCharts.monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
AmCharts.shortMonthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];


AmCharts.getWeekNumber = function (d) {
    d = new Date(d);
    d.setHours(0, 0, 0);
    d.setDate(d.getDate() + 4 - (d.getDay() || 7));
    var yearStart = new Date(d.getFullYear(), 0, 1);
    var weekNo = Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
    return weekNo;
};


AmCharts.stringToDate = function (str, format) {
    var values = {};

    var patterns = [{
        pattern: "YYYY",
        period: "year"
    }, {
        pattern: "YY",
        period: "year"
    }, {
        pattern: "MM",
        period: "month"
    }, {
        pattern: "M",
        period: "month"
    },

    {
        pattern: "DD",
        period: "date"
    }, {
        pattern: "D",
        period: "date"
    },

    {
        pattern: "JJ",
        period: "hours"
    }, {
        pattern: "J",
        period: "hours"
    }, {
        pattern: "HH",
        period: "hours"
    }, {
        pattern: "H",
        period: "hours"
    }, {
        pattern: "KK",
        period: "hours"
    }, {
        pattern: "K",
        period: "hours"
    }, {
        pattern: "LL",
        period: "hours"
    }, {
        pattern: "L",
        period: "hours"
    },

    {
        pattern: "NN",
        period: "minutes"
    }, {
        pattern: "N",
        period: "minutes"
    },

    {
        pattern: "SS",
        period: "seconds"
    }, {
        pattern: "S",
        period: "seconds"
    },

    {
        pattern: "QQQ",
        period: "milliseconds"
    }, {
        pattern: "QQ",
        period: "milliseconds"
    }, {
        pattern: "Q",
        period: "milliseconds"
    }];

    var am = true;
    var amIndex = format.indexOf("AA");
    if (amIndex != -1) {
        str.substr(amIndex, 2);
        if (str.toLowerCase == "pm") {
            am = false;
        }
    }

    var realFormat = format;
    var pattern;
    var period;
    var i;
    for (i = 0; i < patterns.length; i++) {
        pattern = patterns[i].pattern;
        period = patterns[i].period;

        values[period] = 0;
        if (period == "date") {
            values[period] = 1;
        }
    }
    for (i = 0; i < patterns.length; i++) {
        pattern = patterns[i].pattern;
        period = patterns[i].period;

        if (format.indexOf(pattern) != -1) {
            var value = AmCharts.getFromDateString(pattern, str, realFormat);

            format = format.replace(pattern, "");

            if (pattern == "KK" || pattern == "K" || pattern == "LL" || pattern == "L") {
                if (!am) {
                    value += 12;
                }
            }
            values[period] = value;
        }
    }

    var date = new Date(values.year, values.month, values.date, values.hours, values.minutes, values.seconds, values.milliseconds);

    return date;
};

AmCharts.getFromDateString = function (what, date, format) {
    var i = format.indexOf(what);

    var valueStr = date.substr(i, what.length);

    if (valueStr.charAt(0) == "0") {
        valueStr = valueStr.substr(1, valueStr.length - 1);
    }

    var value = Number(valueStr);

    if (isNaN(value)) {
        value = 0;
    }

    if (what.indexOf("M") != -1) {
        value--;
    }

    return value;
};



AmCharts.formatDate = function (d, f) {
    var year;
    var month;
    var date;
    var day;
    var hours;
    var minutes;
    var seconds;
    var milliseconds;
    var weekNo = AmCharts.getWeekNumber(d);

    if (AmCharts.useUTC) {
        year = d.getUTCFullYear();
        month = d.getUTCMonth();
        date = d.getUTCDate();
        day = d.getUTCDay();
        hours = d.getUTCHours();
        minutes = d.getUTCMinutes();
        seconds = d.getUTCSeconds();
        milliseconds = d.getUTCMilliseconds();
    } else {
        year = d.getFullYear();
        month = d.getMonth();
        date = d.getDate();
        day = d.getDay();
        hours = d.getHours();
        minutes = d.getMinutes();
        seconds = d.getSeconds();
        milliseconds = d.getMilliseconds();
    }


    var shortYear = String(year).substr(2, 2);
    var monthStr = month + 1;

    if (month < 9) {
        monthStr = "0" + monthStr;
    }



    var dayStr = "0" + day;

    // WEAK NUMBER
    f = f.replace(/W/g, weekNo);

    // HOURS
    var jhours = hours;
    if (jhours == 24) {
        jhours = 0;
    }
    var jjhours = jhours;
    if (jjhours < 10) {
        jjhours = "0" + jjhours;
    }

    f = f.replace(/JJ/g, jjhours);
    f = f.replace(/J/g, jhours);

    var hhours = hours;
    if (hhours === 0) {
        hhours = 24;
        if(f.indexOf('H') != -1){
            date --;
        }
    }

    var dateStr = date;
    if (date < 10) {
        dateStr = "0" + date;
    }

    var hhhours = hhours;
    if (hhhours < 10) {
        hhhours = "0" + hhhours;
    }
    f = f.replace(/HH/g, hhhours);
    f = f.replace(/H/g, hhours);

    var khours = hours;
    if (khours > 11) {
        khours -= 12;
    }
    var kkhours = khours;
    if (kkhours < 10) {
        kkhours = "0" + kkhours;
    }
    f = f.replace(/KK/g, kkhours);
    f = f.replace(/K/g, khours);


    var lhours = hours;
    if (lhours === 0) {
        lhours = 12;
    }

    if (lhours > 12) {
        lhours -= 12;
    }
    var llhours = lhours;
    if (llhours < 10) {
        llhours = "0" + llhours;
    }
    f = f.replace(/LL/g, llhours);
    f = f.replace(/L/g, lhours);

    // MINUTES
    var nnminutes = minutes;
    if (nnminutes < 10) {
        nnminutes = "0" + nnminutes;
    }
    f = f.replace(/NN/g, nnminutes);
    f = f.replace(/N/g, minutes);

    var ssseconds = seconds;
    if (ssseconds < 10) {
        ssseconds = "0" + ssseconds;
    }
    f = f.replace(/SS/g, ssseconds);
    f = f.replace(/S/g, seconds);


    var qqqms = milliseconds;
    if (qqqms < 10) {
        qqqms = "00" + qqqms;
    }
    if (qqqms < 100) {
        qqqms = "0" + qqqms;
    }

    var qqms = milliseconds;
    if (qqms < 10) {
        qqms = "00" + qqms;
    }

    f = f.replace(/QQQ/g, qqqms);
    f = f.replace(/QQ/g, qqms);
    f = f.replace(/Q/g, milliseconds);

    if (hours < 12) {
        f = f.replace(/A/g, "am");
    } else {
        f = f.replace(/A/g, "pm");
    }


    f = f.replace(/YYYY/g, '@IIII@');
    f = f.replace(/YY/g, '@II@');

    f = f.replace(/MMMM/g, '@XXXX@');
    f = f.replace(/MMM/g, '@XXX@');
    f = f.replace(/MM/g, '@XX@');
    f = f.replace(/M/g, '@X@');

    f = f.replace(/DD/g, '@RR@');
    f = f.replace(/D/g, '@R@');

    f = f.replace(/EEEE/g, '@PPPP@');
    f = f.replace(/EEE/g, '@PPP@');
    f = f.replace(/EE/g, '@PP@');
    f = f.replace(/E/g, '@P@');

    f = f.replace(/@IIII@/g, year);
    f = f.replace(/@II@/g, shortYear);

    f = f.replace(/@XXXX@/g, AmCharts.monthNames[month]);
    f = f.replace(/@XXX@/g, AmCharts.shortMonthNames[month]);
    f = f.replace(/@XX@/g, monthStr);
    f = f.replace(/@X@/g, (month + 1));

    f = f.replace(/@RR@/g, dateStr);
    f = f.replace(/@R@/g, date);

    f = f.replace(/@PPPP@/g, AmCharts.dayNames[day]);
    f = f.replace(/@PPP@/g, AmCharts.shortDayNames[day]);
    f = f.replace(/@PP@/g, dayStr);
    f = f.replace(/@P@/g, day);

    return f;
};


AmCharts.changeDate = function (date, period, count, forward, full) {
    var k = -1;

    if (forward === undefined) {
        forward = true;
    }

    if (full === undefined) {
        full = false;
    }

    if (forward === true) {
        k = 1;
    }

    switch (period) {
        case "YYYY":
            date.setFullYear(date.getFullYear() + count * k);
            if (!forward && !full) {
                date.setDate(date.getDate() + 1);
            }
            break;

        case "MM":
            var previousMonth = date.getMonth();
            date.setMonth(date.getMonth() + count * k);
            if (date.getMonth() > previousMonth + count * k) {
                date.setDate(date.getDate() - 1);
            }
            if (!forward && !full) {
                date.setDate(date.getDate() + 1);
            }
            break;

        case "DD":
            date.setDate(date.getDate() + count * k);
            break;

        case "WW":
            //date.setDate(date.getDate() + count * k * 7 + 1); //3.1 - in case sunday, skips one week
            date.setDate(date.getDate() + count * k * 7);
            break;

        case "hh":
            date.setHours(date.getHours() + count * k);
            break;

        case "mm":
            date.setMinutes(date.getMinutes() + count * k);
            break;

        case "ss":
            date.setSeconds(date.getSeconds() + count * k);
            break;

        case "fff":
            date.setMilliseconds(date.getMilliseconds() + count * k);
            break;
    }
    return date;
};

// @tag amchart
AmCharts.toBoolean = function(str, ifUndefined) {
    if (str === undefined) {
        return ifUndefined;
    }
    switch (String(str).toLowerCase()) {
        case "true":
        case "yes":
        case "1":
            return true;
        case "false":
        case "no":
        case "0":
        case null:
            return false;
        default:
            return Boolean(str);
    }
};

AmCharts.removeFromArray = function(arr, el) {
    var i;
    for (i = arr.length - 1; i >= 0; i--) {
        if (arr[i] == el) {
            arr.splice(i, 1);
            continue;
        }
    }
};

AmCharts.getDecimals = function(val) {
    var numbersAfterDecimal = 0;
    if (!isNaN(val)) {
        var str = String(val);

        if (str.indexOf("e-") != -1) {
            numbersAfterDecimal = Number(str.split("-")[1]);
        } else if (str.indexOf(".") != -1) {
            numbersAfterDecimal = str.split(".")[1].length;
        }
    }
    return numbersAfterDecimal;
};

AmCharts.wrappedText = function(container, value, color, fontFamily, textSize, align, bold, textWidth, counter) {
    var text = AmCharts.text(container, value, color, fontFamily, textSize, align, bold);

    var separator = "\n";
    if(!AmCharts.isModern){
        separator = "<br>";
    }

    if(counter > 10){
        return text;
    }

    if(text){
        var bbox = text.getBBox();
        if (bbox.width > textWidth) {
            text.remove();
            var indices = [];
            var startIndex = 0;
            while ((index = value.indexOf(" ", startIndex)) > -1) {
                indices.push(index);
                startIndex = index + 1;
            }

            var middle = Math.round(value.length / 2);
            var smallestDif = 1000;
            var wrapAt;
            var i;

            for(i = 0; i < indices.length; i++){
                var diff = Math.abs(indices[i] - middle);
                if(diff < smallestDif){
                    wrapAt = indices[i];
                    smallestDif = diff;
                }
            }


            if(isNaN(wrapAt)){
                var wrappCount = Math.ceil(bbox.width / textWidth);

                for(i = 1; i < wrappCount; i++){
                    wrapAt = Math.round(value.length / wrappCount * i);
                    value = value.substr(0, wrapAt) + separator + value.substr(wrapAt);
                }
                return AmCharts.text(container, value, color, fontFamily, textSize, align, bold);
            }
            else{
                value = value.substr(0, wrapAt) + separator + value.substr(wrapAt + 1);
                return AmCharts.wrappedText(container, value, color, fontFamily, textSize, align, bold, textWidth, counter + 1);
            }



        } else {
            return text;
        }
    }
};

AmCharts.getStyle = function(oElm, strCssRule) {
    var strValue = "";
    if (document.defaultView && document.defaultView.getComputedStyle) {
        strValue = document.defaultView.getComputedStyle(oElm, "").getPropertyValue(strCssRule);
    } else if (oElm.currentStyle) {
        strCssRule = strCssRule.replace(/\-(\w)/g, function(strMatch, p1) {
            return p1.toUpperCase();
        });
        strValue = oElm.currentStyle[strCssRule];
    }
    return strValue;
};

AmCharts.removePx = function(value) {
    if(value != undefined){
        return Number(value.substring(0, value.length - 2));
    }
};

AmCharts.getURL = function(url, urlTarget) {
    if (url) {
        if (urlTarget == "_self" || !urlTarget) {
            window.location.href = url;
        } else if (urlTarget == "_top" && window.top) {
            window.top.location.href = url;
        } else if (urlTarget == "_parent" && window.parent) {
            window.parent.location.href = url;
        } else {
            var iFrame = document.getElementsByName(urlTarget)[0];

            if (iFrame) {
                iFrame.src = url;
            } else {
                window.open(url);
            }
        }
    }
};


AmCharts.ifArray = function(arr) {
    if (arr) {
        if (arr.length > 0) {
            return true;
        }
    }
    return false;
};


AmCharts.callMethod = function(method, arr) {
    var j;
    for (j = 0; j < arr.length; j++) {
        var object = arr[j];

        if (object) {
            if (object[method]) {
                object[method]();
            }
            var length = object.length;
            if (length > 0) {
                var i;
                for (i = 0; i < length; i++) {
                    var obj = object[i];
                    if (obj) {
                        if (obj[method]) {
                            obj[method]();
                        }
                    }
                }
            }
        }
    }
};


AmCharts.toNumber = function(val) {
    if (typeof(val) == 'number') {
        return val;
    } else {
        return Number(String(val).replace(/[^0-9\-.]+/g, ''));
    }
};

AmCharts.toColor = function(str) {
    if (str !== '' && str !== undefined) {
        if (str.indexOf(',') != -1) {
            var arr = str.split(',');
            var i;
            for (i = 0; i < arr.length; i++) {
                var cc = arr[i].substring(arr[i].length - 6, arr[i].length);
                arr[i] = '#' + cc;
            }
            str = arr;
        } else {
            str = str.substring(str.length - 6, str.length);
            str = '#' + str;
        }
    }
    return str;
};

AmCharts.toCoordinate = function(val, full, full2) {
    var coord;

    if (val !== undefined) {
        val = String(val);
        if (full2) {
            if (full2 < full) {
                full = full2;
            }
        }

        coord = Number(val);
        // if there is ! in the beginning, then calculate right or bottom
        if (val.indexOf("!") != -1) {
            coord = full - Number(val.substr(1));
        }
        // if values is set in percents, recalculate to pixels
        if (val.indexOf("%") != -1) {
            coord = full * Number(val.substr(0, val.length - 1)) / 100;
        }
    }
    return coord;
};

AmCharts.fitToBounds = function(number, min, max) {
    if (number < min) {
        number = min;
    }

    if (number > max) {
        number = max;
    }
    return number;
};

AmCharts.isDefined = function(value) {
    if (value === undefined) {
        return false;
    } else {
        return true;
    }
};

AmCharts.stripNumbers = function(str) {
    return str.replace(/[0-9]+/g, '');
};

AmCharts.roundTo = function(num, precision) {
    if (precision < 0) {
        return num;
    } else {
        var d = Math.pow(10, precision);
        return Math.round(num * d) / d;
    }
};

AmCharts.toFixed = function(number, precision) {
    var num = String(Math.round(number * Math.pow(10, precision)));

    if (precision > 0) {
        var length = num.length;

        if (length < precision) {
            var i;
            for (i = 0; i < precision - length; i++) {
                num = "0" + num;
            }
        }

        var base = num.substring(0, num.length - precision);
        if (base === "") {
            base = 0;
        }
        return base + "." + num.substring(num.length - precision, num.length);
    } else {
        return String(num);
    }
};

AmCharts.formatDuration = function(duration, interval, result, units, maxInterval, numberFormat) {
    var intervals = AmCharts.intervals;
    var decimalSeparator = numberFormat.decimalSeparator;
    if (duration >= intervals[interval].contains) {
        var value = duration - Math.floor(duration / intervals[interval].contains) * intervals[interval].contains;

        if (interval == "ss") {
            value = AmCharts.formatNumber(value, numberFormat);
            if (value.split(decimalSeparator)[0].length == 1) {
                value = "0" + value;
            }
        }

        if ((interval == "mm" || interval == "hh") && value < 10) {
            value = "0" + value;
        }

        result = value + "" + units[interval] + "" + result;

        duration = Math.floor(duration / intervals[interval].contains);
        interval = intervals[interval].nextInterval;

        return AmCharts.formatDuration(duration, interval, result, units, maxInterval, numberFormat);
    } else {
        if (interval == "ss") {
            duration = AmCharts.formatNumber(duration, numberFormat);

            if (duration.split(decimalSeparator)[0].length == 1) {
                duration = "0" + duration;
            }
        }

        if ((interval == "mm" || interval == "hh") && duration < 10) {
            duration = "0" + duration;
        }

        result = duration + "" + units[interval] + "" + result;

        if (intervals[maxInterval].count > intervals[interval].count) {
            var i;
            for (i = intervals[interval].count; i < intervals[maxInterval].count; i++) {
                interval = intervals[interval].nextInterval;

                if (interval == "ss" || interval == "mm" || interval == "hh") {
                    result = "00" + units[interval] + "" + result;
                } else if (interval == "DD") {
                    result = "0" + units[interval] + "" + result;
                }
            }
        }
        if (result.charAt(result.length - 1) == ":") {
            result = result.substring(0, result.length - 1);
        }
        return result;
    }
};


AmCharts.formatNumber = function(num, format, zeroCount, addPlus, addPercents) {
    num = AmCharts.roundTo(num, format.precision);


    if (isNaN(zeroCount)) {
        zeroCount = format.precision;
    }

    var dSep = format.decimalSeparator;
    var tSep = format.thousandsSeparator;

    // check if negative
    var negative;
    if (num < 0) {
        negative = "-";
    } else {
        negative = "";
    }

    num = Math.abs(num);

    var numStr = String(num);

    var exp = false;

    if (numStr.indexOf('e') != -1) {
        exp = true;
    }

    if (zeroCount >= 0 && !exp) {
        numStr = AmCharts.toFixed(num, zeroCount);
    }
    var formated = "";
    if (!exp) {
        var array = numStr.split(".");

        var string = String(array[0]);
        var i;
        for (i = string.length; i >= 0; i = i - 3) {
            if (i != string.length) {
                if (i !== 0) {
                    formated = string.substring(i - 3, i) + tSep + formated;
                } else {
                    formated = string.substring(i - 3, i) + formated;
                }
            } else {
                formated = string.substring(i - 3, i);
            }
        }

        if (array[1] !== undefined) {
            formated = formated + dSep + array[1];
        }
        if (zeroCount !== undefined && zeroCount > 0 && formated != "0") {
            formated = AmCharts.addZeroes(formated, dSep, zeroCount);
        }
    } else {
        formated = numStr;
    }

    formated = negative + formated;

    if (negative === "" && addPlus === true && num !== 0) {
        formated = "+" + formated;
    }

    if (addPercents === true) {
        formated = formated + "%";
    }

    return (formated);
};

AmCharts.addZeroes = function(number, dSep, count) {
    var array = number.split(dSep);

    if (array[1] === undefined && count > 0) {
        array[1] = "0";
    }
    if (array[1].length < count) {
        array[1] = array[1] + "0";
        return AmCharts.addZeroes(array[0] + dSep + array[1], dSep, count);
    } else {
        if (array[1] !== undefined) {
            return array[0] + dSep + array[1];
        } else {
            return array[0];
        }
    }
};

AmCharts.scientificToNormal = function(num) {
    var str = String(num);
    var newNumber;
    var arr = str.split("e");
    var i;
    // small numbers
    if (arr[1].substr(0, 1) == "-") {
        newNumber = "0.";

        for (i = 0; i < Math.abs(Number(arr[1])) - 1; i++) {
            newNumber += "0";
        }
        newNumber += arr[0].split(".").join("");
    } else {
        var digitsAfterDec = 0;
        var tmp = arr[0].split(".");
        if (tmp[1]) {
            digitsAfterDec = tmp[1].length;
        }

        newNumber = arr[0].split(".").join("");

        for (i = 0; i < Math.abs(Number(arr[1])) - digitsAfterDec; i++) {
            newNumber += "0";
        }
    }
    return newNumber;
};


AmCharts.toScientific = function(num, dSep) {
    if (num === 0) {
        return "0";
    }
    var exponent = Math.floor(Math.log(Math.abs(num)) * Math.LOG10E);
    var tenToPower = Math.pow(10, exponent);
    mantissa = String(mantissa).split(".").join(dSep);
    return String(mantissa) + "e" + exponent;
};


AmCharts.randomColor = function() {
    return '#' + ('00000' + (Math.random() * 16777216 << 0).toString(16)).substr(-6);
};

AmCharts.hitTest = function(bbox1, bbox2, abort) {
    var hit = false;

    var x1 = bbox1.x;
    var x2 = bbox1.x + bbox1.width;
    var y1 = bbox1.y;
    var y2 = bbox1.y + bbox1.height;
    var isInRectangle = AmCharts.isInRectangle;

    if (!hit) {
        hit = isInRectangle(x1, y1, bbox2);
    }
    if (!hit) {
        hit = isInRectangle(x1, y2, bbox2);
    }
    if (!hit) {
        hit = isInRectangle(x2, y1, bbox2);
    }
    if (!hit) {
        hit = isInRectangle(x2, y2, bbox2);
    }
    if (!hit && abort !== true) {
        hit = AmCharts.hitTest(bbox2, bbox1, true);
    }
    return hit;
};

AmCharts.isInRectangle = function(x, y, box) {
    if (x >= box.x - 5 && x <= box.x + box.width + 5 && y >= box.y - 5 && y <= box.y + box.height + 5) {
        return true;
    } else {
        return false;
    }
};

AmCharts.isPercents = function(s) {
    if (String(s).indexOf("%") != -1) {
        return true;
    }
};

AmCharts.findPosX = function(obj) {
    var tobj = obj;
    var pos = obj.offsetLeft;

    if (obj.offsetParent) {
        while ((obj = obj.offsetParent)) {
            pos += obj.offsetLeft;
        }

        while ((tobj = tobj.parentNode) && tobj != document.body) {
            pos -= tobj.scrollLeft || 0;
        }
    }
    return pos;
};

AmCharts.findPosY = function(obj) {
    var tobj = obj;
    var pos = obj.offsetTop;

    if (obj.offsetParent) {
        while ((obj = obj.offsetParent)) {
            pos += obj.offsetTop;
        }

        while ((tobj = tobj.parentNode) && tobj != document.body) {
            pos -= tobj.scrollTop || 0;
        }
    }

    return pos;
};

AmCharts.findIfFixed = function(obj) {
    if (obj.offsetParent) {
        while ((obj = obj.offsetParent)) {
            if (AmCharts.getStyle(obj, "position") == "fixed") {
                return true;
            }
        }
    }
    return false;
};

AmCharts.findIfAuto = function(obj) {
    if (obj.style) {
        if (AmCharts.getStyle(obj, "overflow") == "auto") {
            return true;
        }
    }
    if (obj.parentNode) {
        return AmCharts.findIfAuto(obj.parentNode);
    }

    return false;
};

AmCharts.findScrollLeft = function(obj, value) {
    if (obj.scrollLeft) {
        value += obj.scrollLeft;
    }
    if (obj.parentNode) {
        return AmCharts.findScrollLeft(obj.parentNode, value);
    }

    return value;
};

AmCharts.findScrollTop = function(obj, value) {
    if (obj.scrollTop) {
        value += obj.scrollTop;
    }
    if (obj.parentNode) {
        return AmCharts.findScrollTop(obj.parentNode, value);
    }

    return value;
};

AmCharts.formatValue = function(string, data, keys, numberFormatter, addString, usePrefixes, prefixesSmall, prefixesBig) {
    if (data) {
        if (addString === undefined) {
            addString = "";
        }
        var i;
        for (i = 0; i < keys.length; i++) {
            var key = keys[i];
            var value = data[key];
            if (value !== undefined) {
                var stringValue;
                if (usePrefixes) {
                    stringValue = AmCharts.addPrefix(value, prefixesBig, prefixesSmall, numberFormatter);
                } else {
                    stringValue = AmCharts.formatNumber(value, numberFormatter);
                }
                var regExp = new RegExp("\\[\\[" + addString + "" + key + "\\]\\]", "g");
                string = string.replace(regExp, stringValue);
            }
        }
    }
    return string;
};

AmCharts.formatDataContextValue = function(string, data) {
    if (string) {
        var items = string.match(/\[\[.*?\]\]/g);
        var i;
        for (i = 0; i < items.length; i++) {
            var item = items[i];
            var pureItem = item.substr(2, item.length - 4);

            if (data[pureItem] !== undefined) {
                var regExp = new RegExp("\\[\\[" + pureItem + "\\]\\]", "g");
                string = string.replace(regExp, data[pureItem]);
            }
        }
    }
    return string;
};

AmCharts.massReplace = function(string, replObj) {
    var key;
    for (key in replObj) {
        if (replObj.hasOwnProperty(key)) {
            var value = replObj[key];
            if (value === undefined) {
                value = "";
            }
            string = string.replace(key, value);
        }
    }

    return string;
};

AmCharts.cleanFromEmpty = function(str) {
    return str.replace(/\[\[[^\]]*\]\]/g, "");
};

AmCharts.addPrefix = function(value, prefixesOfBigNumbers, prefixesOfSmallNumbers, numberFormat, strict) {
    var str = AmCharts.formatNumber(value, numberFormat);
    var sign = "";
    var c;
    var newVal;
    var prec;

    if (value === 0) {
        return "0";
    }

    if (value < 0) {
        sign = "-";
    }

    value = Math.abs(value);

    if (value > 1) {
        for (c = prefixesOfBigNumbers.length - 1; c > -1; c--) {
            if (value >= prefixesOfBigNumbers[c].number) {
                newVal = value / prefixesOfBigNumbers[c].number;

                prec = Number(numberFormat.precision);

                if (prec < 1) {
                    prec = 1;
                }

                var newVal2 = AmCharts.roundTo(newVal, prec);

                var nf = {
                    precision: -1,
                    decimalSeparator: numberFormat.decimalSeparator,
                    thousandsSeparator: numberFormat.thousandsSeparator
                };

                var stringValue = AmCharts.formatNumber(newVal2, nf);

                if (strict) {
                    if (newVal != newVal2) {
                        continue;
                    }
                }

                str = sign + "" + stringValue + "" + prefixesOfBigNumbers[c].prefix;
                break;
            }
        }
    } else {
        for (c = 0; c < prefixesOfSmallNumbers.length; c++) {
            if (value <= prefixesOfSmallNumbers[c].number) {
                newVal = value / prefixesOfSmallNumbers[c].number;

                prec = Math.abs(Math.round(Math.log(newVal) * Math.LOG10E));
                newVal = AmCharts.roundTo(newVal, prec);

                str = sign + "" + newVal + "" + prefixesOfSmallNumbers[c].prefix;
                break;
            }
        }
    }
    return str;
};


AmCharts.remove = function(obj) {
    if (obj) {
        obj.remove();
    }
};



AmCharts.recommended = function() {
    var recommended = "js";
    var svg = document.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1");
    if (!svg) {
        if (swfobject) {
            if (swfobject.hasFlashPlayerVersion("8")) {
                recommended = "flash";
            }
        }
    }
    return recommended;
};

AmCharts.getEffect = function(val) {
    if (val == ">") {
        val = "easeOutSine";
    }
    if (val == "<") {
        val = "easeInSine";
    }
    if (val == "elastic") {
        val = "easeOutElastic";
    }
    return val;
};

AmCharts.getObjById = function(objects, id) {
    var _this = this;
    var currentObj;
    var i;
    for (i = 0; i < objects.length; i++) {
        var obj = objects[i];
        if (obj.id == id) {
            currentObj = obj;
        }
    }
    return currentObj;
};

AmCharts.applyTheme = function(object, theme, className) {

    if(!theme){
        theme = AmCharts.theme;
    }

    if (theme) {
        if (theme[className]) {
            AmCharts.extend(object, theme[className]);
        }
    }
};



AmCharts.isString = function(value) {
    if (typeof(value) == "string") {
        return true;
    } else {
        return false;
    }
};

AmCharts.extend = function(obj1, obj2, firstIsPriority) {
    var i;
    for (i in obj2) {
        if (firstIsPriority) {
            if (!obj1.hasOwnProperty(i)) {
                obj1[i] = obj2[i];
            }
        } else {
            obj1[i] = obj2[i];
        }

    }
    return obj1;
};


AmCharts.copyProperties = function(fromObject, toObject) {
    var i;
    for (i in fromObject) {
        if (fromObject.hasOwnProperty(i)) {
            if (i != "events" && fromObject[i] !== undefined && typeof(fromObject[i]) != "function" && i != "cname") {
                toObject[i] = fromObject[i];
            }
        }
    }
};

AmCharts.processObject = function(object, objectClass, theme) {
    if ((object instanceof objectClass) === false) {
        object = AmCharts.extend(new objectClass(theme), object);
    }
    return object;
};


AmCharts.fixNewLines = function(text) {
    //if (!AmCharts.isModern) {
        var from = "\\n";
        var to = "<br />";
        var rgx = new RegExp(from, "g");
        if (text) {
            text = text.replace(rgx, to);
        }
    //}
    return text;
};


AmCharts.fixBrakes = function(text) {
    if (!AmCharts.isModern) {
        text = AmCharts.fixNewLines(text);
    }
    else{
        var from = "<br>";
        var to = "\n";
        var rgx = new RegExp(from, "g");
        if (text) {
            text = text.replace(rgx, to);
        }
    }
    return text;
};


AmCharts.deleteObject = function(object, size) {
    if (!object) {
        return;
    }
    if (size === undefined || size === null) {
        size = 20;
    }
    if (size === 0) {
        return;
    }
    if (Object.prototype.toString.call(object) === '[object Array]') {
        for (var i = 0; i < object.length; i++) {
            AmCharts.deleteObject(object[i], size - 1);
            object[i] = null;
        }
    } else if (object && !object['tagName']) {  // added 3.3.6 to avoid destroying dom
    //}else{
        try {
            for (var prop in object) {
                if (!object[prop]) {
                    continue;
                }
                if (typeof object[prop] == "object") {
                    AmCharts.deleteObject(object[prop], size - 1);
                }
                if (typeof object[prop] == "function") {
                    continue;
                }
                object[prop] = null;
            }
        } catch (e) {}
    }
    object = null;
};



// borrowed from jquery
AmCharts.bounce = function(x, t, b, c, d) {
    if ((t /= d) < (1 / 2.75)) {
        return c * (7.5625 * t * t) + b;
    } else if (t < (2 / 2.75)) {
        return c * (7.5625 * (t -= (1.5 / 2.75)) * t + 0.75) + b;
    } else if (t < (2.5 / 2.75)) {
        return c * (7.5625 * (t -= (2.25 / 2.75)) * t + 0.9375) + b;
    } else {
        return c * (7.5625 * (t -= (2.625 / 2.75)) * t + 0.984375) + b;
    }
};

AmCharts.easeInSine = function(x, t, b, c, d) {
    return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;
};
AmCharts.easeOutSine = function(x, t, b, c, d) {
    return c * Math.sin(t / d * (Math.PI / 2)) + b;
};

AmCharts.easeOutElastic = function(x, t, b, c, d) {
    var s = 1.70158;
    var p = 0;
    var a = c;
    if (t === 0) {
        return b;
    }
    if ((t /= d) == 1) {
        return b + c;
    }
    if (!p) {
        p = d * 0.3;
    }
    if (a < Math.abs(c)) {
        a = c;
        s = p / 4;
    } else {
        s = p / (2 * Math.PI) * Math.asin(c / a);
    }
    return a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * (2 * Math.PI) / p) + c + b;
};

Ext.ClassManager.addNameAliasMappings({});